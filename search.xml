<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DataBase Interview II(Mysql)</title>
    <url>/2020/02/20/Database-Interview-II/</url>
    <content><![CDATA[<blockquote>
<p>人真正的强大，不是维护着自尊心的时候，而是抛开自尊心的时候——《请回答1988》</p>
</blockquote>
<a id="more"></a>

<h2 id="1-数据库的三范式是什么？"><a href="#1-数据库的三范式是什么？" class="headerlink" title="1. 数据库的三范式是什么？"></a>1. 数据库的三范式是什么？</h2><p>第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。</p>
<p>第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。</p>
<p>第三范式：任何非主属性不依赖于其它非主属性。</p>
<h2 id="2-一张自增表里面总共有17条数据，删除了最后2条数据，重启mysql数据库，又插入了一条数据，此时id是几？"><a href="#2-一张自增表里面总共有17条数据，删除了最后2条数据，重启mysql数据库，又插入了一条数据，此时id是几？" class="headerlink" title="2.一张自增表里面总共有17条数据，删除了最后2条数据，重启mysql数据库，又插入了一条数据，此时id是几？"></a>2.一张自增表里面总共有17条数据，删除了最后2条数据，重启mysql数据库，又插入了一条数据，此时id是几？</h2><p>• 表类型如果是 MyISAM ，那 id 就是 18。<br>• 表类型如果是 InnoDB，那 id 就是 15。</p>
<p>InnoDB 表只会把自增主键的最大 id 记录在内存中，所以重启之后会导致最大 id 丢失。</p>
<h2 id="3-如何获取当前数据库版本？"><a href="#3-如何获取当前数据库版本？" class="headerlink" title="3.如何获取当前数据库版本？"></a>3.如何获取当前数据库版本？</h2><p>使用 select version() 获取当前 MySQL 数据库版本。</p>
<h2 id="4-说一下ACID是什么？"><a href="#4-说一下ACID是什么？" class="headerlink" title="4.说一下ACID是什么？"></a>4.说一下ACID是什么？</h2><p>• Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。<br>• Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等<br>• Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</p>
<p>• Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失</p>
<h2 id="5-char和varchar的区别是什么？"><a href="#5-char和varchar的区别是什么？" class="headerlink" title="5.char和varchar的区别是什么？"></a>5.char和varchar的区别是什么？</h2><p>char(n) ：固定长度类型，比如订阅 char(10)，当你输入”abc”三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。</p>
<p>chat 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。</p>
<p>varchar(n) ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。</p>
<p>所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。</p>
<h2 id="6-float和double的区别是什么？"><a href="#6-float和double的区别是什么？" class="headerlink" title="6.float和double的区别是什么？"></a>6.float和double的区别是什么？</h2><p>• float 最多可以存储 8 位的十进制数，并在内存中占 4 字节。<br>• double 最可可以存储 16 位的十进制数，并在内存中占 8 字节。</p>
<h2 id="7-mysql的内连接、左连接、右连接有什么区别"><a href="#7-mysql的内连接、左连接、右连接有什么区别" class="headerlink" title="7.mysql的内连接、左连接、右连接有什么区别?"></a>7.mysql的内连接、左连接、右连接有什么区别?</h2><p>内连接关键字：inner join；左连接：left join；右连接：right join。</p>
<p>内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。</p>
<h2 id="8-mysql的索引是什么实现的？"><a href="#8-mysql的索引是什么实现的？" class="headerlink" title="8.mysql的索引是什么实现的？"></a>8.mysql的索引是什么实现的？</h2><p>索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。</p>
<p>具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。</p>
<h2 id="9-怎么验证mysql的索引是否满足需求？"><a href="#9-怎么验证mysql的索引是否满足需求？" class="headerlink" title="9.怎么验证mysql的索引是否满足需求？"></a>9.怎么验证mysql的索引是否满足需求？</h2><p>使用 explain 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。</p>
<p>explain 语法：explain select * from table where type=1。</p>
<h2 id="10-说一下数据库的事务隔离？"><a href="#10-说一下数据库的事务隔离？" class="headerlink" title="10.说一下数据库的事务隔离？"></a>10.说一下数据库的事务隔离？</h2><p>MySQL 的事务隔离是在 MySQL. ini 配置文件里添加的，在文件的最后添加：transaction-isolation = REPEATABLE-READ</p>
<p>可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。<br>• READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。<br>• READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。<br>• REPEATABLE-READ：可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。<br>• SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</p>
<p>脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</p>
<p>不可重复读 ：是指在一个事务内，多次读同一数据。</p>
<p>幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p>
<h2 id="11-说一下Mysql常用的引擎？"><a href="#11-说一下Mysql常用的引擎？" class="headerlink" title="11.说一下Mysql常用的引擎？"></a>11.说一下Mysql常用的引擎？</h2><p>InnoDB 引擎：InnoDB 引擎提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。</p>
<p>MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 select count(*) from table 指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。</p>
<p>MyIASM 引擎：MySQL 的默认引擎，但不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。</p>
<h2 id="12-说一下mysql的行锁和表锁？"><a href="#12-说一下mysql的行锁和表锁？" class="headerlink" title="12.说一下mysql的行锁和表锁？"></a>12.说一下mysql的行锁和表锁？</h2><p>MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。<br>• 表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。<br>• 行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。</p>
<h2 id="13-说一下乐观锁和悲观锁？"><a href="#13-说一下乐观锁和悲观锁？" class="headerlink" title="13.说一下乐观锁和悲观锁？"></a>13.说一下乐观锁和悲观锁？</h2><p>• 乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。<br>• 悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。</p>
<p>数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。 </p>
<h2 id="14-mysql问题排查都有哪些手段？"><a href="#14-mysql问题排查都有哪些手段？" class="headerlink" title="14.mysql问题排查都有哪些手段？"></a>14.mysql问题排查都有哪些手段？</h2><p>• 使用 show processlist 命令查看当前所有连接信息。<br>• 使用 explain 命令查询 SQL 语句执行计划。<br>• 开启慢查询日志，查看慢查询的 SQL。</p>
<h2 id="15-如何做mysql的性能优化？"><a href="#15-如何做mysql的性能优化？" class="headerlink" title="15.如何做mysql的性能优化？"></a>15.如何做mysql的性能优化？</h2><p>• 为搜索字段创建索引。<br>• 避免使用 select *，列出需要查询的字段。<br>• 垂直分割分表。<br>选择正确的存储引擎。</p>
]]></content>
      <categories>
        <category>Study Note</category>
      </categories>
      <tags>
        <tag>DataBase</tag>
        <tag>Interview</tag>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>DataBase Interview I</title>
    <url>/2020/02/19/DataBase-Interview/</url>
    <content><![CDATA[<blockquote>
<p>才能一旦让懒惰支配，它就一无可为。——克雷洛夫</p>
</blockquote>
<a id="more"></a>

<h2 id="数据库架构设计"><a href="#数据库架构设计" class="headerlink" title="数据库架构设计"></a>数据库架构设计</h2><p>如果提问：如何设计一个关系型数据库？实际上是考察你对数据库模块化的划分能力，当然也包括对数据库的概念的理解程度。</p>
<p>要开发数据库需要以下模块：</p>
<p><img src="https://s2.ax1x.com/2020/02/19/3Ax1HO.png" alt="3Ax1HO.png"></p>
<ul>
<li><p>存储管理模块可以控制IO次数，因为读取次数会非常花时间，在实际中，一次读取多行的效率远比多次读取(每次读取一两行)要省时间的多。</p>
</li>
<li><p>非常常用的一种方法，就是引入缓存机制，把取出来的数据块存放在缓存里，下次需要的时候直接从内存返回，而不用发生IO。管理缓存的方法很多，可以使用比如LRU等。注意，我们的缓存不宜过大，而且算法中需要有淘汰机制。</p>
</li>
</ul>
<p>总的来说，要回答如何设计一个关系型数据库(RDBMS：Relational Database Management System),首先要将其划分成两大部分，一个是存储部分，该部分类似一个文件系统，将数据持久化到存储设备当中。另一个是程序实例模块来对存储进行管理。而在程序实例模块中，需要包含下面八个模块：</p>
<p>①. 将数据的逻辑关系转换成物理存储关系的存储管理模块；</p>
<p>②. 优化执行效率的缓存机制模块</p>
<p>③. 将SQL语句进行解析的SQL解析模块</p>
<p>④. 记录操作的日志管理模块</p>
<p>⑤. 进行多用户权限管理的权限划分模块</p>
<p>⑥. 灾难恢复的容灾模块</p>
<p>⑦. <strong>优化查询效率的索引管理模块</strong> (重点)</p>
<p>⑧. <strong>使数据库支持并发操作的锁模块</strong> (重点)</p>
<p>实际上，数据库开发设计的模块结构和我们自己设计和开发的软件系统很相似，这个架构是很经典的，对程序的开发和设计也是很有借鉴意义的。</p>
<h2 id="索引相关问题"><a href="#索引相关问题" class="headerlink" title="索引相关问题"></a>索引相关问题</h2><h3 id="为什么要使用索引？"><a href="#为什么要使用索引？" class="headerlink" title="为什么要使用索引？"></a>为什么要使用索引？</h3><p>索引(Index)是可以帮助MYSQL高效获取数据的数据结构。如果数据量很小，那么哪怕是全表扫描，也可能比加了索引之后更快。但是如果数据量很大，那么全表扫描将是噩梦。</p>
<p>实际上，可以理解索引的灵感来自于”字典”，通过类似”偏旁部首”之类的”索引”可以更快速地找到要查的词。</p>
<p>具体作用描述：</p>
<ol>
<li>索引能极大地减少存储引擎需要扫描的数据量</li>
<li>索引可以把随机IO变成顺序IO</li>
<li>索引可以帮助我们在进行分组、排序等操作时，避免使用临时表</li>
</ol>
<h3 id="什么样的信息能成为索引？"><a href="#什么样的信息能成为索引？" class="headerlink" title="什么样的信息能成为索引？"></a>什么样的信息能成为索引？</h3><ul>
<li>主键、唯一键及普通键等，只要能让数据具备一定区分性的字段，都可以成为索引。</li>
</ul>
<h3 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h3><p>在选择建并且生成索引之后，可以选择不同的数据结构进行索引的查找。一般常用的是二分查找树进行二分查找、建立B-树结构查找、建立B+树查找(MySQL选择的结构)、建立Hash结构查找。下面简单介绍每种结构的细节。</p>
<p>回答：<font color=#FF0000>通常来说，索引的数据结构是B+树，比较小众的也有哈希结构、BitMap(位图)等</font></p>
<h4 id="二叉查找树结构进行索引查找"><a href="#二叉查找树结构进行索引查找" class="headerlink" title="二叉查找树结构进行索引查找"></a>二叉查找树结构进行索引查找</h4><p>大体的结构：</p>
<p><img src="https://s2.ax1x.com/2020/02/19/3VOG60.png" alt="3VOG60.png"></p>
<ul>
<li>二叉查找树符合左小右大的规则，查找的时候使用二分查找</li>
<li>检索深度每增加1，就会增加1次IO。但是需要注意的是整个树是通过很多数据块组合而成的，当许多数据块组合在一起的时候，会造成二叉树的深度很大，从而基本上没法避免多次的IO，从而造成很悲剧的后果：使用了索引，速度甚至可能比不用更慢，因为IO次数太多了。</li>
</ul>
<h4 id="B-树结构进行索引查找"><a href="#B-树结构进行索引查找" class="headerlink" title="B- 树结构进行索引查找"></a>B- 树结构进行索引查找</h4><p>B-树又称作”多路平衡查找树”</p>
<p><img src="https://s2.ax1x.com/2020/02/19/3VXkEF.png" alt="3VXkEF.png"></p>
<p>定义：</p>
<ul>
<li>根节点至少包括两个孩子</li>
<li>树中每个结点最多含有m个孩子(m&gt;=2)</li>
<li>除根节点和叶节点外，其他每个节点至少有ceil(m/2)个孩子(ceil为取上限，举例，1.2和1.5，都是取2)</li>
<li>所有叶子节点都位于同一层(即叶子节点高度都相同)</li>
</ul>
<h4 id="B-树结构进行索引查找-1"><a href="#B-树结构进行索引查找-1" class="headerlink" title="B+树结构进行索引查找"></a>B+树结构进行索引查找</h4><p><img src="https://s2.ax1x.com/2020/02/19/3Vvr1s.png" alt="3Vvr1s.png"></p>
<p>B+树实际上是B树的变体，其定义和B树不同的地方为：</p>
<ul>
<li>非叶子节点的子树指针与关键字个数相同</li>
<li>非叶子节点的子树指针P[i]，指向关键字值[K[i],K[i+1])<font color=#FFF0000>(左闭右开，即可以大于等于K[i]，但必须大于K[i+1]  )</font>的子树</li>
<li>非叶子节点仅用来索引，数据都保存在叶子节点中。<font color=#FFF0000>所有的数据实际都存储在叶子节点上，所以每一次遍历都必须遍历到叶子节点上。</font>这也使得B+树的层级可以更少，树可以更矮。</li>
<li>所有叶子节点均有一个链指针指向下一个叶子节点。<font color=#FFF0000>搜索的实际是上图中粉色的块的部分。</font>这个链指针主要服务于<strong>范围统计</strong>，定位到了某个叶指针之后，可以快速横向地去做统计。比如要统计索引&gt;10的，找到了第二个Q之后，直接统计后面所有的Q内容即可。</li>
</ul>
<p>结论：B+树相比B树更适合用来做存储索引</p>
<ul>
<li>B+树的磁盘读写代价更低。B+树内部只存储索引(或者说叶子节点的指针)，B树需要不断在父节点和叶子节点之间来回移动，所以B+树的高度能降低。</li>
<li>B+树查询效率更加稳定。因为所有实质内容都存储在根节点上，所以几乎所有数据的查询的时间都是稳定的：O(n)</li>
<li>B+树更有利于对数据库的扫描。B+树只需要遍历叶子节点就可以实现全部关键字信息的扫描。比如之前提到的，数据库中频繁使用的范围查询，使用B+树查询能够大大增加效率。</li>
</ul>
<h4 id="Hash结构进行索引查找"><a href="#Hash结构进行索引查找" class="headerlink" title="Hash结构进行索引查找"></a>Hash结构进行索引查找</h4><p>和哈希表的原理类似，通过一个哈希函数，将不同的key通过某种哈希映射得到value，然后存储在不同的链表节点上。如图：</p>
<p><img src="https://s2.ax1x.com/2020/02/20/3ZCI3D.png" alt="3ZCI3D.png"></p>
<p>哈希索引在理论上性能优于B+树。</p>
<p>但是哈希表相比B+树有一些缺点，却是更需要重视的：</p>
<ul>
<li>仅仅能满足”=”,”IN”，不能使用范围查询。因为哈希运算后得到的值之间的大小关系是根本不能保证和哈希运算前一样的，所以不能进行范围比较，只能进行具体的值的大小的比较。</li>
<li>无法被用来避免数据的排序操作</li>
<li>不能利用部分索引键查询</li>
<li>不能避免表扫描</li>
<li>遇到大量Hash值相等的情况后性能并不一定就会比B树索引高</li>
</ul>
<h4 id="BitMap索引"><a href="#BitMap索引" class="headerlink" title="BitMap索引"></a>BitMap索引</h4><p>需要注意，目前比较少的主流数据库支持位图索引，比较出名的是Oracl。位图索引不是主流索引。</p>
<p><img src="https://s2.ax1x.com/2020/02/20/3ZP7GT.png" alt="3ZP7GT.png"></p>
<p>这个索引可以算是一个”神器”。当表中的某个字段只有几种可能值的时候，比如性别，此时如果要实现性别统计，使用位图索引可以说是最佳选择。</p>
<p>位图索引比较类似B+树。</p>
<ul>
<li>锁的力度大，不适合高并发的联机数据处理系统(OLTP系统)，适合并发较少，且统计较多的OLAP系统</li>
</ul>
<h3 id="密集索引和稀疏索引的区别"><a href="#密集索引和稀疏索引的区别" class="headerlink" title="密集索引和稀疏索引的区别"></a>密集索引和稀疏索引的区别</h3><ul>
<li>密集索引文件中的每个搜索码值都对应一个索引值</li>
<li>稀疏索引文件只为索引码的某些值建立索引项</li>
</ul>
<p>密集索引和稀疏索引如下图所示：</p>
<p><img src="https://s2.ax1x.com/2020/02/20/3ZY1eA.png" alt="3ZY1eA.png"></p>
<p>一个表只能创建一个密集索引。</p>
<p>针对Mysql进行分析，其主要有两种存储引擎：MyISAM和InnoDB：</p>
<ul>
<li>MyISAM(数据和索引是分开的，文件后缀为.MYI、.MYD,前者存储索引，后者存储数据)：主键索引、唯一建索引和普通索引，全部都是稀疏索引。</li>
<li>InnoDB(数据和索引是合在一起的，文件后缀为.idb)则有且仅有一个密集索引。</li>
</ul>
<p>对于InnoDB的索引的额外知识：</p>
<ul>
<li>若一个主键被定义，该主键则作为密集索引</li>
<li>若没有主键被定义，该表的第一个唯一非空索引则作为密集索引</li>
<li>若没有主键，也没有合适的唯一索引，innodb内部会生成一个隐藏主键(是一个6字节的列，该列的值会随着数据的插入而自增)(密集索引)</li>
<li>非主键索引存储相关键位和其对应的主键值，包含两次查找(一次查找次级索引自身，一次查找主键)</li>
</ul>
<p><img src="https://s2.ax1x.com/2020/02/20/3ZagE9.png" alt="3ZagE9.png"></p>
<h3 id="索引额外的问题，以mysql为例"><a href="#索引额外的问题，以mysql为例" class="headerlink" title="索引额外的问题，以mysql为例"></a>索引额外的问题，以mysql为例</h3><h4 id="如何定位并优化慢查询Sql"><a href="#如何定位并优化慢查询Sql" class="headerlink" title="如何定位并优化慢查询Sql"></a>如何定位并优化慢查询Sql</h4><p>这个问题主要考察有没有做过sql优化，需要具体场景具体分析，这里给出大致思路</p>
<ul>
<li>根据慢日志定位慢查询sql</li>
<li>使用explain等工具分析sql</li>
<li>修改sql或尽量让sql走索引</li>
</ul>
<p>下面具体分析：</p>
<ul>
<li>根据慢日志定位慢查询sql</li>
</ul>
<p>什么是慢日志？——用来记录一些执行比较慢的sql</p>
<p><code>show variables like &#39;%quer%&#39;;//查看相关变量</code></p>
<p>查询结果：</p>
<p><img src="https://s2.ax1x.com/2020/02/20/3ZXX0f.png" alt="3ZXX0f.png"></p>
<p>其中需要重点关注三个变量：</p>
<p><code>show_query_log</code>(慢日志是否打开),</p>
<p><code>slow_query_log_file</code>(日志写入的文件路径)，</p>
<p><code>long_query_time</code>(多少秒以上的sql语句会被当做慢语句记录到文件中,一般设置为1秒)</p>
<p>一般来说可以用set设置慢查询开关和阈值时间(路径一般不迫切更改)</p>
<blockquote>
<p>set global slow_query_log = on;</p>
<p>set global long_query_time = 1;//必须重连才能生效</p>
</blockquote>
<p>但是如果想要永久生效，最好是去配置文件里面配好，而不是用set的方式。</p>
<p>查看系统慢查询的数量的语句：<code>show status like &#39;%slow_queries%&#39;</code>，能够把运行下来执行慢的语句数量统计出来。</p>
<p>通过查看慢日志的具体值，可以在分析之后进行调优。</p>
<ul>
<li>使用explain等工具分析sql</li>
</ul>
<p>在分析查询性能的时候explain关键字非常管用，一般放在select语句前面，用于描述mysql如何执行查询操作。以及mysql返回的结果和需要查询的行数。</p>
<p><img src="https://s2.ax1x.com/2020/02/20/3er9iQ.png" alt="3er9iQ.png"></p>
<p>重点介绍看两个字段：type和extra</p>
<ol>
<li>type：如果出现了index或all，表示语句进行了全表扫描，需要优化</li>
<li>extra：类型很多，其中using filesort/Using temporary出现的话，会对性能产生较大影响，必须优化：</li>
</ol>
<p><img src="https://s2.ax1x.com/2020/02/20/3erzOx.png" alt="3erzOx.png"></p>
<ul>
<li>修改sql或者尽量让sql走索引</li>
</ul>
<p>当我们进行查询的时候，如果一开始用的属性是没有索引的，可以更改成有索引的对象，可以减少查询时间。</p>
<p>但是有时候我们就是不能用带索引的属性，那么只能在新的需要查询的属性中加上索引了。</p>
<p>Mysql的索引优化器本质上也是一个软件，在不同的查询条件下可能就算你用了主键，查询效果也不够好。这个时候可以利用关键字<code>force index(primary)</code>进行对比，综合判断哪个索引的值最适合做此次的查询。</p>
<p>举一个调优的最简单的例子：如果我们是用户表，其中有用户账号account和用户名name，其中account有索引，则如果我们用name查询用了10s，用account查询用了6秒，那么实际我们将此次mysql查询的性能优化了40%</p>
<h4 id="联合索引的最左匹配原则的成因"><a href="#联合索引的最左匹配原则的成因" class="headerlink" title="联合索引的最左匹配原则的成因"></a>联合索引的最左匹配原则的成因</h4><p>什么是联合索引？——由多列组成的索引</p>
<p>假设将数据库某张表中的A列和B列设置成联合索引，查询的时候在where语句中调用(where A=** and B=**)的时候会走A和B这个组合索引；而且如果单独用A查询，也会走AB联合索引。<font color=#FF0000>但是如果直接select B，则会走”ALL”，即不走索引，全表扫描。</font></p>
<ul>
<li>最左匹配原则本身很重要。简单理解，是Mysql会从左一直向右匹配直到遇到范围查询(&gt;,&lt;,between,like)就停止匹配。比如a=3 and b=4 and c&gt;5 and d=6,如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到。其中a,b,d的顺序可以任意调整，比如(b,a,d,c),(a,d,b,c)，结果都是一样的。注意这里不是没有用到索引，而是最多只用到了(a)(a,b),(a,b,c)索引，没有能够用到(a,b,c,d)索引</li>
<li>=和in可以乱序的。比如a = 1 and b = 2 and c = 3建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。</li>
</ul>
<p>对于(a,b,c,d)这个例子，mysql创建复合索引的规则是首先会对复合索引的最左边的，也就是第一个a字段的数据进行排序，在第一个字段的排序基础上，然后再对后面第二个的b字段进行排序，如果此时c是范围查询的话，则没法获取到有序的d，因此是不行的。</p>
<h4 id="索引是建立得越多越好么？"><a href="#索引是建立得越多越好么？" class="headerlink" title="索引是建立得越多越好么？"></a>索引是建立得越多越好么？</h4><p>当然不是：</p>
<ul>
<li>数据量小的表不需要建立索引，增加额外的索引开销(比如看一两页的宣传手册，谁会需要索引呢？)</li>
<li>数据变更需要维护索引，因此更多的索引意味着更多的维护成本</li>
<li>更多的索引以为这也需要更多的空间(一本100页的书，目录不能是50页呀)</li>
</ul>
<h2 id="锁相关问题"><a href="#锁相关问题" class="headerlink" title="锁相关问题"></a>锁相关问题</h2><h3 id="MyISAM与InnoDB关于锁方面的区别是什么"><a href="#MyISAM与InnoDB关于锁方面的区别是什么" class="headerlink" title="MyISAM与InnoDB关于锁方面的区别是什么"></a>MyISAM与InnoDB关于锁方面的区别是什么</h3><ul>
<li><p>MyISAM默认用的是表级锁，不支持行级锁</p>
</li>
<li><p>InnoDB默认用的是行级锁，但是也支持表级锁</p>
</li>
</ul>
<p>分别来说：</p>
<h4 id="MyISAM默认用的是表级锁，不支持行级锁"><a href="#MyISAM默认用的是表级锁，不支持行级锁" class="headerlink" title="MyISAM默认用的是表级锁，不支持行级锁"></a>MyISAM默认用的是表级锁，不支持行级锁</h4><p>当使用MyISAM作为Mysql引擎时，对一个表进行操作时，会锁住整张表，其他session不能操作</p>
<p>读锁（共享锁）不释放，无法增加写锁</p>
<p>读锁（共享锁）不释放，可以增加读锁</p>
<p>写锁（排他锁）不释放，无法增加读锁</p>
<p>写锁 (排它锁) 不释放，无法增加写锁</p>
<p>给表加上读锁写锁或者读锁的写法：</p>
<blockquote>
<p>lock tables *** read | write;<br>unlock tables;</p>
</blockquote>
<h4 id="InnoDB默认用的是行级锁，但是也支持表级锁"><a href="#InnoDB默认用的是行级锁，但是也支持表级锁" class="headerlink" title="InnoDB默认用的是行级锁，但是也支持表级锁"></a>InnoDB默认用的是行级锁，但是也支持表级锁</h4><p>InnoDB使用的是二段锁，也就是加锁和解锁分成两个步骤进行，就像军训走正步一样，一个动作全部加锁，一个动作全部解锁。</p>
<p>InnoDB的行级锁会把某张表中的某一行锁住，这样如果你锁住了第3行，那么操作第4行是不会受影响的。</p>
<p>需要注意，InnoDB在sql没有用到索引的时候，会自动走表级锁。但是如果sql用到了索引，就会转为使用行级锁。</p>
<h4 id="MyISAM和InnoDB各自适合的场景"><a href="#MyISAM和InnoDB各自适合的场景" class="headerlink" title="MyISAM和InnoDB各自适合的场景"></a>MyISAM和InnoDB各自适合的场景</h4><ul>
<li><p>MyISAM适合的场景：</p>
<ul>
<li>频繁执行全表count语句(InnoDB不保存表的具体行数，但MyISAM会使用一个变量保存整张表的行数，执行count的时候可以调用之前保存过的变量,)</li>
<li>对数据进行增删改的频率不高，查询非常频繁(增删改设计锁表操作)</li>
<li>没有事务</li>
</ul>
</li>
<li><p>InnoDB适合的场景：</p>
<ul>
<li>数据增删改查都频繁(每次只锁行)</li>
<li>可靠性要求高</li>
<li>需要支持事务</li>
</ul>
</li>
</ul>
<h4 id="数据库锁的分类"><a href="#数据库锁的分类" class="headerlink" title="数据库锁的分类"></a>数据库锁的分类</h4><ul>
<li>按锁的粒度划分，可分为<strong>表级锁、行级锁、页级锁</strong>。InnoDB默认支持行级锁，同时支持表级锁。MyISAM只支持表级锁。</li>
<li>按锁的级别划分，可分为共享锁、排它锁</li>
<li>按加锁方式划分，可分为自动锁(mysql自动加上的锁)、显式锁(用语句加上的锁)</li>
<li>按操作划分，可分为DML锁(对数据操作)、DDL锁(对表结构操作)</li>
<li>按使用方式划分，可分为乐观锁(基于数据版本)、悲观锁(利用数据库提供的功能，对外界修改保守态度)</li>
</ul>
<p>其中，乐观锁和悲观锁不仅在数据库中会使用，在程序中也经常用到。悲观锁实际上会拒绝所有外部的修改。对于并发，悲观锁实际上也是先取锁，后访问的保守策略。为数据处理的安全提供了保证。但是对于数据库，处理过多的锁可能会给数据库造成额外的开销，并且增加产生死锁的机会，所以对于事务要不要加锁需要谨慎。</p>
<p>乐观锁认为数据一般不会造成冲突，所以只会在数据提交更新的时候才会检测数据是否冲突。如果发现冲突，则返回用户错误的信息。<strong>悲观锁一般需要使用数据库提供的锁机制，但是乐观锁一般不用。</strong>乐观锁一般记录数据库版本。记录版本的方式一般也有两种，一个是使用<strong>版本号</strong>，另一个是使用<strong>时间戳</strong>。添加版本号，可以通过添加一个int类型的version变量实现。</p>
<h3 id="数据库事务的四大特性"><a href="#数据库事务的四大特性" class="headerlink" title="数据库事务的四大特性"></a>数据库事务的四大特性</h3><p><strong>ACID</strong></p>
<ul>
<li>Atomicity：<strong>原子性</strong>，要么都做，要么都不做。比如银行取钱，我这边还没取完，你就不能操作我的账户。比较相似的是，如果一个用户正在操作他的账户，而且他的账户里面的钱的金额很大，可能出现的情况就是他点确认了，但是数据要处理几秒，那么这段时间这个账户也是不能被操作的。</li>
<li>Consistency，<strong>一致性</strong>，一个事务要持续做完。这个事务一般情况下需要满足既定好的假设，满足各种条件约束。</li>
<li>Isolation，<strong>隔离性</strong>，事务之间是互相独立的。一个事务的执行不能影响其他事务。</li>
<li>Durability，<strong>持久性</strong>，事务需要是持久的，比如介质受损了，比如断电之后，数据也还能保存。</li>
</ul>
<h3 id="事务隔离级别以及各级别下的并发访问问题"><a href="#事务隔离级别以及各级别下的并发访问问题" class="headerlink" title="事务隔离级别以及各级别下的并发访问问题"></a>事务隔离级别以及各级别下的并发访问问题</h3><h3 id="InnoDB可重复读隔离级别下如何避免幻读"><a href="#InnoDB可重复读隔离级别下如何避免幻读" class="headerlink" title="InnoDB可重复读隔离级别下如何避免幻读"></a>InnoDB可重复读隔离级别下如何避免幻读</h3><h3 id="RC、RP级别下的InnoDB的非阻塞读如何实现"><a href="#RC、RP级别下的InnoDB的非阻塞读如何实现" class="headerlink" title="RC、RP级别下的InnoDB的非阻塞读如何实现"></a>RC、RP级别下的InnoDB的非阻塞读如何实现</h3>]]></content>
      <categories>
        <category>Study Note</category>
      </categories>
      <tags>
        <tag>DataBase</tag>
        <tag>Interview</tag>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Analysis of LeetCode High Frequency Problems IV</title>
    <url>/2020/02/12/Analysis-of-LeetCode-High-Frequency-Problems-IV/</url>
    <content><![CDATA[<p>详细讲解LeetCode考察较多的3道题目：336、340、407。</p>
<a id="more"></a>

<h2 id="336-Palindrome-Pairs-回文对-Hard"><a href="#336-Palindrome-Pairs-回文对-Hard" class="headerlink" title="336.Palindrome Pairs(回文对)(Hard)"></a><a href="https://leetcode-cn.com/problems/palindrome-pairs/" target="_blank" rel="noopener">336.Palindrome Pairs(回文对)(Hard)</a></h2><h2 id="340-longest-Substring-with-at-most-k-distinct-characters-至多包含K个不同字符的最长子串-Hard"><a href="#340-longest-Substring-with-at-most-k-distinct-characters-至多包含K个不同字符的最长子串-Hard" class="headerlink" title="340.longest Substring with at most k distinct characters(至多包含K个不同字符的最长子串)(Hard)"></a><a href="https://leetcode-cn.com/problems/longest-substring-with-at-most-k-distinct-characters/" target="_blank" rel="noopener">340.longest Substring with at most k distinct characters(至多包含K个不同字符的最长子串)(Hard)</a></h2><h2 id="407-Trapping-rain-water-ii-接雨水-II-Hard"><a href="#407-Trapping-rain-water-ii-接雨水-II-Hard" class="headerlink" title="407.Trapping rain water ii(接雨水 II)(Hard)"></a><a href="https://leetcode-cn.com/problems/trapping-rain-water-ii/" target="_blank" rel="noopener">407.Trapping rain water ii(接雨水 II)(Hard)</a></h2>]]></content>
      <categories>
        <category>Algorithms Note</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Analysis of LeetCode High Frequency Problems III</title>
    <url>/2020/02/12/Analysis-of-LeetCode-High-Frequency-Problems-III/</url>
    <content><![CDATA[<p>详细讲解LeetCode考察较多的3道题目：10、84、28。</p>
<a id="more"></a>

<h2 id="10-regular-expression-matching-正则表达式匹配-Hard"><a href="#10-regular-expression-matching-正则表达式匹配-Hard" class="headerlink" title="10.regular-expression-matching(正则表达式匹配)(Hard)"></a><a href="https://leetcode-cn.com/problems/regular-expression-matching/" target="_blank" rel="noopener">10.regular-expression-matching(正则表达式匹配)(Hard)</a></h2><h2 id="84-Largest-Rectangle-in-Histogram-柱状图中最大的矩形-Hard"><a href="#84-Largest-Rectangle-in-Histogram-柱状图中最大的矩形-Hard" class="headerlink" title="84.Largest Rectangle in Histogram(柱状图中最大的矩形)(Hard)"></a><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">84.Largest Rectangle in Histogram(柱状图中最大的矩形)(Hard)</a></h2><h2 id="28-implement-strstr-实现strStr-Easy"><a href="#28-implement-strstr-实现strStr-Easy" class="headerlink" title="28.implement-strstr(实现strStr())(Easy)"></a><a href="https://leetcode-cn.com/problems/implement-strstr/" target="_blank" rel="noopener">28.implement-strstr(实现strStr())(Easy)</a></h2>]]></content>
      <categories>
        <category>Algorithms Note</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Analysis of LeetCode High Frequency Problems II</title>
    <url>/2020/02/12/Analysis-of-LeetCode-High-Frequency-Problems-II/</url>
    <content><![CDATA[<p>详细讲解LeetCode考察较多的3道题目：56、435、269。</p>
<a id="more"></a>


<h2 id="56-Merge-Intervals-合并区间-Mid"><a href="#56-Merge-Intervals-合并区间-Mid" class="headerlink" title="56.Merge Intervals(合并区间)(Mid)"></a><a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">56.Merge Intervals(合并区间)(Mid)</a></h2><h2 id="435-Non-Overlapping-Intervals-无重叠区间-Mid"><a href="#435-Non-Overlapping-Intervals-无重叠区间-Mid" class="headerlink" title="435.Non Overlapping Intervals(无重叠区间)(Mid)"></a><a href="https://leetcode-cn.com/problems/non-overlapping-intervals" target="_blank" rel="noopener">435.Non Overlapping Intervals(无重叠区间)(Mid)</a></h2><h2 id="269-Alien-Dictionary-火星词典-Hard"><a href="#269-Alien-Dictionary-火星词典-Hard" class="headerlink" title="269.Alien Dictionary(火星词典)(Hard)"></a><a href="https://leetcode-cn.com/problems/alien-dictionary/" target="_blank" rel="noopener">269.Alien Dictionary(火星词典)(Hard)</a></h2>]]></content>
      <categories>
        <category>Algorithms Note</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Analysis of LeetCode High Frequency Problems I</title>
    <url>/2020/02/12/Analysis-of-LeetCode-High-Frequency-Problems-I/</url>
    <content><![CDATA[<p>详细讲解LeetCode考察较多的3道题目：03、04、23。</p>
<a id="more"></a>

<h2 id="3-Longest-Substring-Without-Repeating-Characters-无重复字符的最长子串-Mid"><a href="#3-Longest-Substring-Without-Repeating-Characters-无重复字符的最长子串-Mid" class="headerlink" title="3.Longest Substring Without Repeating Characters(无重复字符的最长子串)(Mid)"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3.Longest Substring Without Repeating Characters(无重复字符的最长子串)(Mid)</a></h2><p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">Input: <span class="string">"abcabcbb"</span></span><br><span class="line">Output: <span class="number">3</span> </span><br><span class="line">Explanation: The answer <span class="keyword">is</span> <span class="string">"abc"</span>, <span class="keyword">with</span> <span class="keyword">the</span> <span class="built_in">length</span> <span class="keyword">of</span> <span class="number">3.</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">Input: <span class="string">"bbbbb"</span></span><br><span class="line">Output: <span class="number">1</span></span><br><span class="line">Explanation: The answer <span class="keyword">is</span> <span class="string">"b"</span>, <span class="keyword">with</span> <span class="keyword">the</span> <span class="built_in">length</span> <span class="keyword">of</span> <span class="number">1.</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Input: <span class="string">"pwwkew"</span></span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is <span class="string">"wke"</span>, with the length of 3. </span><br><span class="line">            <span class="built_in"> Note </span>that the answer must be a substring, <span class="string">"pwke"</span> is a subsequence <span class="keyword">and</span> <span class="keyword">not</span> a substring.</span><br></pre></td></tr></table></figure>

<hr>
<p>解：<strong>解法一：暴力法</strong></p>
<p>找到所有子串，然后每一个子串都一个一个地去判断是否有重复的字符。</p>
<p>要分析这个方法的时间复杂度，首先我们需要弄清楚一些问题，假设字符串长度为n，那么它有多少个非空子串？</p>
<p>答案是 n*(n+1)/2 个。</p>
<p>怎么计算出来的？</p>
<ul>
<li>长度为1的子串，有n个</li>
<li>长度为2的子串，有n-1个</li>
<li>长度为3的子串，有n-2个</li>
</ul>
<p>…</p>
<ul>
<li>长度为k的子串，有n-k+1个</li>
<li>当k=n时，n-k+1=1，即长度为n的子串就是1个</li>
</ul>
<p>所有情况相加，可以得到：<br>n+(n-1)+(n-2)+(n-3)+…+2+1 = n(n+1)/2<br>算上空字符串，一共有：(n(n+1)/2) + 1</p>
<p>在这里可以进行对比，子串和子序列的区别。比如，对于长度为n的字符串，一共有多少子序列？</p>
<p>答案是2^n</p>
<p>怎么计算得到的？</p>
<ul>
<li><p>子序列不同于子串</p>
</li>
<li><p>子序列中的元素不需要相互挨着</p>
</li>
<li><p>长度为1的子序列有n个，即：C(1,n)</p>
</li>
<li><p>长度为2的子序列有C(2,n)个</p>
</li>
<li><p>长度为3的子序列有C(3,n)个</p>
</li>
</ul>
<p>…</p>
<ul>
<li>长度为k的子序列有C(k,n)个</li>
<li>所有子序列的个数(包括空序列)为：C(0,n) + C(1,n) + C(2,n) + C(3,n) + … + C(n,n) = 2^n</li>
</ul>
<p>这里有关统计字符串的子串和子序列的过程和方法，和结果，务必熟悉和记下来，对于分析各种问题能有帮助。</p>
<p>如果对所有的子串进行判断，从每个子串里寻找最长且没有重复字符的，复杂度为：O(n* (n+1)/2 * n) = O(n^3)</p>
<p>当然，这不是最好的办法。</p>
<p><strong>解法二：线性法</strong></p>
<ul>
<li>把每次遍历到的字符放入到一个哈希集合中，这样每次判断当前遍历过的内容中是否包含下一个要遍历的字符的时候，用哈希表的contains方法，时间复杂度为O(1),比不放到哈希表中的O(n)的速度能够得到提高。</li>
</ul>
<p>具体解法：</p>
<ul>
<li>定义一个哈希集合set</li>
<li>从给定字符串的头开始，每次检查当前字符是否在集合内。如果不在，说明该字符不会造成冲突和重复，将其加入到集合中，并统计当前集合长度，或许为最长子串</li>
</ul>
<p>如果出现了重复的子串，处理方法是定义两个指针，i为慢指针，j为快指针。</p>
<p>当 j 遇到一个重复出现的字符时，我们从慢指针开始一个一个地将 i 指针指向的字符从集合中删除，然后判断是否可以把新字符加入到集合而不会重复。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="keyword">String</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义一个哈希集合set,初始化结果max为0</span></span><br><span class="line">        Set&lt;Character&gt; <span class="built_in">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 利用快慢指针i(慢)和j(快)扫描一遍字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; j &lt; s.length(); j++) &#123;</span><br><span class="line">            <span class="comment">// 如果快指针指向的字符已经出现在哈希集合中,不断尝试将慢指针指向的字符从哈希集合中删除</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">set</span>.contains(s.charAt(j))) &#123;</span><br><span class="line">                <span class="built_in">set</span>.<span class="built_in">remove</span>(s.charAt(i));</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 当快指针的字符终于能加入到哈希集合的时候，更新结果max</span></span><br><span class="line">            <span class="built_in">set</span>.add(s.charAt(j));</span><br><span class="line">            <span class="built_in">max</span> = Math.<span class="built_in">max</span>(<span class="built_in">max</span>, <span class="built_in">set</span>.<span class="built_in">size</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历完毕后，返回结果max</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度分析：O(n)。使用了快慢指针策略，字符串最多被遍历两次。快指针会被添加到哈希表集合，慢指针遇到的字符会从哈希集合中删除。哈希集合操作时间为O(1)，因此整个算法复杂度为：n * O(1) + n*O(1) = O(n)</li>
<li>空间复杂度分析：O(n)。由于使用到哈希集合，最坏的情况下，即给定的字符串没有任何重复的字符，我们需要把每个字符都加入集合。</li>
</ul>
<p><strong>解法三：优化的线性法</strong></p>
<p>基于方法二的线性法。也就是，如果我们在遍历过程中遇到了set已经有的字符的时候，如何不让慢指针一步一步移动，而是直接移动到重复元素的后面呢？这样可以大大减少比较次数。</p>
<p>这样一来我们需要能够记录每个字符出现的下标位置，可以用哈希表记录，因为查找过程时间复杂度也是O(1)</p>
<p>而且此时，我们不能像之前一样去数哈希集合的元素作为max的结果。比如可能出现一种情况，就是当前快指针j遍历到的元素在之前已经出现过了，那么此时不能让i又跳回到前面去呀！所以i的值需要有max计算得到：i = Math.max(i, map.get(s.charAt(j) + 1));</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="keyword">String</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义一个哈希表map用来记录上次某字符出现的位置,初始化结果max为0</span></span><br><span class="line">        Map&lt;Character, Integer&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 利用快慢指针i(慢)和j(快)扫描一遍字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; j &lt; s.length(); j++) &#123;</span><br><span class="line">            <span class="comment">// 如果发现快指针所对应的字符已经出现过，慢指针就进行跳跃</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.containsKey(s.charAt(j))) &#123;</span><br><span class="line">                i = Math.<span class="built_in">max</span>(i, <span class="built_in">map</span>.<span class="built_in">get</span>(s.charAt(j)) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 把快指针所对应的字符添加到哈希表中，更新结果max</span></span><br><span class="line">            <span class="built_in">map</span>.<span class="built_in">put</span>(s.charAt(j), j);</span><br><span class="line">            <span class="built_in">max</span> = Math.<span class="built_in">max</span>(<span class="built_in">max</span>, j - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历完毕后，返回结果max</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-Median-of-Two-Sorted-Arrays-寻找两个有序数组的中位数-Hard"><a href="#4-Median-of-Two-Sorted-Arrays-寻找两个有序数组的中位数-Hard" class="headerlink" title="4.Median of Two Sorted Arrays(寻找两个有序数组的中位数)(Hard)"></a><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays" target="_blank" rel="noopener">4.Median of Two Sorted Arrays(寻找两个有序数组的中位数)(Hard)</a></h2><p>There are two sorted arrays <strong>nums1</strong> and <strong>nums2</strong> of size m and n respectively.</p>
<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
<p>You may assume <strong>nums1</strong> and <strong>nums2</strong> cannot be both empty.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">nums1 = [<span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">nums2 = [<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">The median <span class="keyword">is</span> <span class="number">2.0</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">nums1 = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">nums2 = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">The median <span class="keyword">is</span> (<span class="number">2</span> + <span class="number">3</span>)/<span class="number">2</span> = <span class="number">2.5</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：解法一：暴力法</p>
<ul>
<li>利用归并排序的思想将它们合并成一个长度为m+n的有序数组</li>
<li>合并的时间复杂度为 m+n，从中选取中位数，整体时间复杂度为O(m+n)，要大于题目要求的O(log(m+n))，不符合要求</li>
</ul>
<p>解法二：切分法，比较偏重数学</p>
<p>这种方法需要考虑m+n为奇数还是偶数。假设m+n=L，</p>
<ul>
<li>如果L为奇数，即两个数组元素总个数为奇数，则中位数为第：int(L/2)+1小的数。</li>
<li>如果L为偶数，则中位数为第 int(L/2) 小于int(L/2)+1小的数求和的平均值。</li>
</ul>
<p>所以我们的问题转变成了，在两个有序数组中寻找第k小的数，f(k)</p>
<ul>
<li>当L为奇数时，若令 k=L/2，则结果为f(k+1)</li>
<li>当L为偶数时，结果为：(f(k) + f(k+1))/2</li>
</ul>
<p>那么接下来的问题是，怎么从两个排好序的数组中找到第k小的数呢？</p>
<p>假设nums1[] = {a0, a1, a2, a3, a4}、nums2[] = {b0, b1, b2, b3}<br>举例，如果从nums1和nums2中分别取出k1和k2个元素：</p>
<p><img src="https://s2.ax1x.com/2020/02/17/3iuZt0.png" alt="3iuZt0.png"></p>
<ol>
<li>a2=b1，这种算是最舒服的情况了,此时a2或者b1就是我们要找的第k小的数。因为此时我们如果把a0, a1, a2, b0, b1按照大小顺序合并在一起，那么a2和b1肯定排在最后，a0, a1 和b0都排在前面，不需要考虑这三个的大小关系。</li>
<li>a2&lt;b1， 这种情况开始不舒服了，我们无法肯定a2和b1是第五小的数。但是这种情况下我们可以确定，第五小的数一定不会是a0, a1, a2中的一个，同时也不会是b2和b3中的一个。所以，整个的搜索范围可以缩小为：{a3, a4, b0, b1}</li>
<li>a2&gt;b1，我们同样无法肯定a2和b1是第五小的数。但是这种情况下我们可以确定，第五小的数不可能是b0, b1和a3, a4。所以这种情况下，整个搜索范围可以缩小为：{a0, a1, a2, b2, b3}</li>
</ol>
<p>代码：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public double find<span class="constructor">MedianSortedArrays(<span class="params">int</span>[] <span class="params">nums1</span>, <span class="params">int</span>[] <span class="params">nums2</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据两个字符串长度的总和判断如何调用递归函数以及返回结果</span></span><br><span class="line">        <span class="built_in">int</span> m = nums1.length, n = nums2.length;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> k = (m + n) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>((m+n) % <span class="number">2</span><span class="operator"> == </span><span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 当总长度为奇数时，返回正中间的数</span></span><br><span class="line">            return find<span class="constructor">Kth(<span class="params">nums1</span>, 0, <span class="params">m</span>-1, <span class="params">nums2</span>, 0, <span class="params">n</span>-1, <span class="params">k</span>+1)</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当总长度为偶数时，返回两个数的平均值</span></span><br><span class="line">            return (find<span class="constructor">Kth(<span class="params">nums1</span>, 0, <span class="params">m</span>-1, <span class="params">nums2</span>, 0, <span class="params">n</span>-1, <span class="params">k</span>)</span> + </span><br><span class="line">                    find<span class="constructor">Kth(<span class="params">nums1</span>, 0, <span class="params">m</span>-1, <span class="params">nums2</span>, 0, <span class="params">n</span>-1, <span class="params">k</span>+1)</span>)<span class="operator"> / </span><span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进入findKth,这个函数目的是寻找第k小的元素</span></span><br><span class="line">    public double find<span class="constructor">Kth(<span class="params">int</span>[] <span class="params">nums1</span>, <span class="params">int</span> <span class="params">start1</span>, <span class="params">int</span> <span class="params">end1</span>, <span class="params">int</span>[] <span class="params">nums2</span>, <span class="params">int</span> <span class="params">start2</span>, <span class="params">int</span> <span class="params">end2</span>, <span class="params">int</span> <span class="params">k</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> m = end1 - start1 + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> n = end2 - start2 + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果nums1数组的长度大于nums2数组的长度，将二者互换，加快程序结束的速度</span></span><br><span class="line">        <span class="keyword">if</span>(m &gt; n) &#123;</span><br><span class="line">            return find<span class="constructor">Kth(<span class="params">nums2</span>, <span class="params">start2</span>, <span class="params">end2</span>, <span class="params">nums1</span>, <span class="params">start1</span>, <span class="params">end1</span>, <span class="params">k</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当nums1数组长度为0的时候，直接返回nums2数组中第k小的数</span></span><br><span class="line">        <span class="keyword">if</span>(m<span class="operator"> == </span><span class="number">0</span>) &#123;</span><br><span class="line">            return nums2<span class="literal">[<span class="identifier">start2</span> + <span class="identifier">k</span> - <span class="number">1</span>]</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当k == 1时，返回两个数组中的最小值</span></span><br><span class="line">        <span class="keyword">if</span>(k<span class="operator"> == </span><span class="number">1</span>) &#123;</span><br><span class="line">            return <span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>min(nums1<span class="literal">[<span class="identifier">start1</span>]</span>, nums2<span class="literal">[<span class="identifier">start2</span>]</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 分别选两个数组的中间数</span></span><br><span class="line">        <span class="built_in">int</span> na = <span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>min(k/<span class="number">2</span>, m);</span><br><span class="line">        <span class="built_in">int</span> nb = k - na;</span><br><span class="line">        <span class="built_in">int</span> va = nums1<span class="literal">[<span class="identifier">start1</span> + <span class="identifier">na</span> -<span class="number">1</span>]</span>;</span><br><span class="line">        <span class="built_in">int</span> vb = nums2<span class="literal">[<span class="identifier">start2</span> + <span class="identifier">nb</span> -<span class="number">1</span>]</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 比较下两者的大小</span></span><br><span class="line">        <span class="comment">// 如果相等，表明中位数已经找到，返回该值即可</span></span><br><span class="line">        <span class="keyword">if</span>(va<span class="operator"> == </span>vb) &#123;</span><br><span class="line">            return va;</span><br><span class="line">            <span class="comment">// 如果不相等，进行剪枝处理</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(va &lt; vb) &#123;</span><br><span class="line">            return find<span class="constructor">Kth(<span class="params">nums1</span>, <span class="params">start1</span> + <span class="params">na</span>, <span class="params">end1</span>, <span class="params">nums2</span>,<span class="params">start2</span>,  <span class="params">start2</span> + <span class="params">nb</span> - 1, <span class="params">k</span> - <span class="params">na</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            return find<span class="constructor">Kth(<span class="params">nums1</span>, <span class="params">start1</span>, <span class="params">start1</span> + <span class="params">na</span> - 1, <span class="params">nums2</span>, <span class="params">start2</span> + <span class="params">nb</span>, <span class="params">end2</span>, <span class="params">k</span> - <span class="params">nb</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="23-Merge-k-Sorted-Lists-合并K个排序链表-Hard"><a href="#23-Merge-k-Sorted-Lists-合并K个排序链表-Hard" class="headerlink" title="23.Merge k Sorted Lists(合并K个排序链表)(Hard)"></a><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">23.Merge k Sorted Lists(合并K个排序链表)(Hard)</a></h2><p>Merge <em>k</em> sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>,</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>,</span><br><span class="line">  <span class="number">2</span>-&gt;<span class="number">6</span></span><br><span class="line">]</span><br><span class="line">Output: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span></span><br></pre></td></tr></table></figure>
<hr>
<p>解：<strong>解法一：暴力法</strong></p>
<ul>
<li>用一个数组保存所有链表中的数，之后进行排序，再从头到尾将数组遍历，生成一个排好序的链表</li>
<li>假设每个链表平均长度为n,整体时间复杂度为O(nk * log(nk))，偏大</li>
</ul>
<p><strong>解法二：最小堆</strong></p>
<ul>
<li>每次比较k个链表头，时间复杂度为O(k)</li>
<li>对k个链表头创建一个大小为k的最小堆<ul>
<li>创建一个大小为k的最小堆所需时间为O(k)</li>
<li>从堆中取最小的数，所需时间都是O(logk)</li>
<li>如果每个链表平均长度为n，则共有nk个元素，即用大小为k的最小堆过滤nk个元素</li>
<li>整体时间复杂度为O(nk*log(k))</li>
</ul>
</li>
</ul>
<p>我们一直维护这个大小为k的最小堆，直到遍历完所有链表的节点</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode mergeKLists(ListNode[] lists) &#123;</span><br><span class="line">        <span class="comment">// 如果输入为[]，边界条件</span></span><br><span class="line">        <span class="keyword">if</span>(lists.length == <span class="number">0</span> || lists == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 利用一个空的链表头方便我们插入节点</span></span><br><span class="line">        ListNode fakeHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>), p = fakeHead;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义一个最小堆来保存k个链表节点</span></span><br><span class="line">        <span class="keyword">int</span> k = lists.length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将k个链表的头放到最小堆中,因为要维护最小堆，所以重新定义比较器，降序排列。</span></span><br><span class="line">        <span class="comment">// 不手动定义比较器的话默认升序排列</span></span><br><span class="line">        PriorityQueue&lt;ListNode&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k, <span class="keyword">new</span> Comparator&lt;ListNode&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">int</span> compare(ListNode a, ListNode b) &#123;</span><br><span class="line">                <span class="keyword">return</span> a.val - b.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从最小堆中将当前最小节点取出，插入到结果链表中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(lists[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                heap.offer(lists[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果发现该节点后还有后序节点，将其加入到最小堆中</span></span><br><span class="line">        <span class="keyword">while</span>(!heap.isEmpty()) &#123;</span><br><span class="line">            ListNode node = heap.poll();</span><br><span class="line">            </span><br><span class="line">            p.<span class="keyword">next</span> = node;</span><br><span class="line">            p = p.<span class="keyword">next</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(node.<span class="keyword">next</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">                heap.offer(node.<span class="keyword">next</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 最后返回结果链表</span></span><br><span class="line">        <span class="keyword">return</span> fakeHead.<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解法三：分治法</strong></p>
<p>利用分治思想，非常类似归并排序操作。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主函数非常类似归并排序的过程</span></span><br><span class="line"><span class="keyword">public</span> ListNode mergeKLists(ListNode[] lists, int low, int high) &#123;</span><br><span class="line">    <span class="comment">// 如果输入为[]，边界条件</span></span><br><span class="line">    <span class="keyword">if</span>(lists.length == <span class="number">0</span> || lists == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(low == high) <span class="keyword">return</span> lists[low];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从中间切一刀</span></span><br><span class="line">    int middle = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归地处理坐标和右边的列表，最后合并起来</span></span><br><span class="line">    <span class="keyword">return</span> mergeTwoLists(</span><br><span class="line">        mergeKLists(lists, low, middle),</span><br><span class="line">        mergeKLists(lists, middle + <span class="number">1</span>, high)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ListNode mergeTwoLists(ListNode a, ListNode b) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span>) <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">null</span>) <span class="keyword">return</span> a;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(a.<span class="keyword">val</span> &lt;= b.<span class="keyword">val</span>) &#123;</span><br><span class="line">        a.next = mergeTwoLists(a.next, b);</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    b.next = mergeTwoLists(a, b.next);</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(nk * log(k))</li>
<li>空间复杂度：O(1)，可以直接在链表上进行操作</li>
</ul>
]]></content>
      <categories>
        <category>Algorithms Note</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Practice by Categories Others</title>
    <url>/2020/01/13/LeetCode-Practice-by-Categories-Others/</url>
    <content><![CDATA[<blockquote>
<p>时间像海绵里的水，只要你愿意挤，总还是有的。——鲁迅</p>
</blockquote>
<p>LeetCode其他题目其解决思路和具体代码。</p>
<a id="more"></a>

<h2 id="169-Majority-Element-多数元素-Easy"><a href="#169-Majority-Element-多数元素-Easy" class="headerlink" title="169. Majority Element(多数元素)(Easy)"></a><a href="https://leetcode-cn.com/problems/majority-element/description/" target="_blank" rel="noopener">169. Majority Element(多数元素)(Easy)</a></h2><p>Given an array of size n, find the majority element. The majority element is the element that appears more than <code>⌊ n/2 ⌋</code> times.</p>
<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">Output: <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">Output: <span class="number">2</span></span><br></pre></td></tr></table></figure>
<hr>
<p>解：题目名字是”多数元素”，实际上，就是众数。</p>
<p>思路一：如果你头脑足够灵活，数学感觉足够好，那么实际上抓住一个点就可以：题目问的多数元素，其实不算真正的众数。这里的多数元素出现的次数必须大于 <code>n/2</code> ，所以，如果一个数组中一定有众数，那么这个数组排好序之后，下标为 <code>nums.length/2</code> 的那个元素，就是众数。利用排序，排好序之后返回下标为 <code>nums.length/2</code>的元素，就是这道题需要的结果。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> majorityElement(<span class="built_in">int</span>[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为用到了系统自带的排序方法，所以这种方法的时间复杂度是O(logN)。</p>
<p>方法二：开两个变量，result为最后返回的结果，count用于统计，因为按照题目定义，众数出现次数一定大于 n/2 ，所以count只要回到了0，说明当前result不可能是最后的众数。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> majorityElement(<span class="built_in">int</span>[] nums) &#123;</span><br><span class="line">        <span class="built_in">int</span> result = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">0</span>) </span><br><span class="line">                result = num;</span><br><span class="line">            <span class="keyword">if</span>(result != num) </span><br><span class="line">                count --;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                count ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h2 id="146-LRU-Cache-LRU缓存机制-Mid"><a href="#146-LRU-Cache-LRU缓存机制-Mid" class="headerlink" title="146. LRU Cache(LRU缓存机制)(Mid)"></a><a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">146. LRU Cache(LRU缓存机制)(Mid)</a></h2><p>Design and implement a data structure for <strong>Least Recently Used (LRU)</strong> cache. It should support the following operations: <code>get</code> and <code>put</code>.</p>
<p><code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br><code>put(key, value)</code> - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</p>
<p>The cache is initialized with a <strong>positive</strong> capacity.</p>
<p><strong>Follow up:</strong></p>
<p>Could you do both operations in <strong>O(1)</strong> time complexity?</p>
<p><strong>Example:</strong></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">LRUCache <span class="keyword">cache</span> = new LRUCache( <span class="number">2</span> <span class="comment">/* capacity */</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">cache</span>.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">cache</span>.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">cache</span>.get(<span class="number">1</span>);       // <span class="keyword">returns</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">cache</span>.put(<span class="number">3</span>, <span class="number">3</span>);    // evicts key <span class="number">2</span></span><br><span class="line"><span class="keyword">cache</span>.get(<span class="number">2</span>);       // <span class="keyword">returns</span> <span class="number">-1</span> (<span class="keyword">not</span> <span class="built_in">found</span>)</span><br><span class="line"><span class="keyword">cache</span>.put(<span class="number">4</span>, <span class="number">4</span>);    // evicts key <span class="number">1</span></span><br><span class="line"><span class="keyword">cache</span>.get(<span class="number">1</span>);       // <span class="keyword">returns</span> <span class="number">-1</span> (<span class="keyword">not</span> <span class="built_in">found</span>)</span><br><span class="line"><span class="keyword">cache</span>.get(<span class="number">3</span>);       // <span class="keyword">returns</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">cache</span>.get(<span class="number">4</span>);       // <span class="keyword">returns</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：本质上，这个替换算法和现在的推荐系统有异曲同工之妙。</p>
<p>推荐算法就是根据之前元素被使用的频次和被使用的时间，来预测新来的元素为某一个老元素的概率是多少。</p>
<p>现代计算机中，替换算法越来越使用人工智能来做了，而不是简单基于逻辑式的公式。</p>
<p>LRU cache源自于用得非常多的缓存的思想。它有两个比较重要的策略：大小和替换策略。除了LRU(Least Recently Used)，还有一种可以和它相似的，只是替换策略不同的缓存机制：LFU(Least Frequently Used)，具体区别可以从名字中看出。</p>
<p>按照题目的要求，我们自己完成的LRU cache应当保证<strong>查询</strong>与<strong>修改</strong>的时间复杂度都为O(1)。</p>
<p>如果最朴素的，全部自己实现，那么就是哈希表加双向链表。这样就训练一下双向链表怎么写。</p>
<p>所有双向链表或者单向链表的题目，没有巧，就是多练，即可。</p>
<p>在现实工作中，其实不太可能去手写一个链表、map、set或者排序，都是有现成的库。</p>
<p>有些公司可能比较刻板，需要多练一些基本功。</p>
<p>官方题解中，给出了两种解法，<a href="https://leetcode-cn.com/problems/lru-cache/solution/lru-huan-cun-ji-zhi-by-leetcode/" target="_blank" rel="noopener">详情可以点击这里</a></p>
<p>方法一：使用<strong>有序字典</strong>这个数据结构，它综合了哈希表和链表。对于java，系统使用了LinkedHashMap这个类实现；对于Python，系统使用了OrderedDict实现字典序。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">LRUCache</span> <span class="symbol">extends</span> <span class="symbol">LinkedHashMap</span>&lt;<span class="symbol">Integer, <span class="symbol">Integer</span></span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> capacity;</span><br><span class="line">    <span class="keyword">public</span> LRUCache(<span class="built_in">int</span> capacity) &#123;</span><br><span class="line">        <span class="keyword">super</span>(capacity, <span class="number">0.75</span>F, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> <span class="keyword">get</span>(<span class="built_in">int</span> key) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getOrDefault(key, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> put(<span class="built_in">int</span> key, <span class="built_in">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">super</span>.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">bool</span>ean removeEldestEntry(Map.Entry&lt;Integer, Integer&gt; eldest) &#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; capacity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p><strong>拓展:</strong>linkedhashmap和hashmap有什么区别？<br>HashMap就只是一个哈希表，键值对对应，最多允许一条记录的键值为Null，而且HashMap不支持线程同步，即任一时刻如果多个线程同时写HashMap，可能导致数据的不一致性。如果需要同步，对于HashMap，可以用Collections的synchronizedMap方法使HashMap拥有同步的能力。</p>
<p>LinkedHashMap也是一个HashMap，<strong>但是它内部维持了一个双向链表</strong>，可以保持顺序。</p>
<p>总之，LinkedHashMap的内部实现原理，就是一个双向的LinkedList+HashMap,所以名字是：LinkedHashMap。</p>
]]></content>
      <categories>
        <category>Algorithms Note</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Practice by Categories String Algorithm</title>
    <url>/2020/01/13/LeetCode-Practice-by-Categories-String-Algorithm/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>LeetCode Practice by Categories Sort</title>
    <url>/2020/01/13/LeetCode-Practice-by-Categories-Sort/</url>
    <content><![CDATA[<blockquote>
<p>所谓爱一个人，不是宽裕了想要给予，而是恳切地必须给予。<br>所谓爱一个人，不是喜欢对方的体温，而是要跟对方的体温越来越接近。所谓爱一个人，是即便对方一直折磨你，你想要的一直讨厌对方，但怎么也讨厌不起来。所谓爱一个人，真的是一件难事。所谓爱，不是不讨厌，而是绝对不能讨厌的意思。<br>——《请回答1988》</p>
</blockquote>
<p>由浅入深介绍和分析各种排序算法，重点给出快排和归并排序的实现思路。</p>
<a id="more"></a>

<p>国内面试中经常会问到排序方面问题。如果开放性强的话，可能直接问你有关排序，可以畅所欲言。但是考察得更多的应该还是排序的的思路和代码，尤其是快排、归并。</p>
<p>首先，排序分为比较类排序和非比较类排序，如下图所示：</p>
<p><img src="https://s2.ax1x.com/2020/02/13/1O9RkF.png" alt="1O9RkF.png"></p>
<h2 id="如何理解比较类排序和非比较类排序？"><a href="#如何理解比较类排序和非比较类排序？" class="headerlink" title="如何理解比较类排序和非比较类排序？"></a><strong>如何理解比较类排序和非比较类排序？</strong></h2><ol>
<li>比较类排序： 通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn), 因此也称为非线性时间比较类排序。</li>
</ol>
<ul>
<li>在高级语言里，大家直接调用系统的排序函数的时候，你可以传入一个参数：comparator(java语言，其他语言可能叫做cmp之类的函数)。也就是说，它比较的对象不一定必须是实数或者int之类的类型，可以是任何结构体或者类的对象。你只需要给它传入一个可以比较两个object之间的前后关系的类型，都可以通过排序算法得到。</li>
</ul>
<p>像这种通过比较来决定元素间的相对次序，数学上已经证明，时间复杂度不会超过O(logn)，而我们经常用到的，都是这种比较类排序。</p>
<ol start="2">
<li>非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也成为线性时间非比较类排序。</li>
</ol>
<ul>
<li>一般对于整型元素来做的，也就是说可以用线性时间来完成。它可以突破基于比较排序的时间下界，以线性时间完成。</li>
</ul>
<p><strong>但是非比较类排序的缺点是</strong>：一般只能用于整型相关的数据类型。也就是说对于一些比如字符串的排序，或者对象之间的排序，非比较类排序是无能为力的。而且非比较类排序一般需要辅助的内存空间。</p>
<p>非比较类排序基本都是把结果放入到数组中，统计不同元素出现的次数来排序。</p>
<p>常用的排序算法的复杂度分析和稳定性，如下表：</p>
<p><img src="https://s2.ax1x.com/2020/02/14/1jSh4g.png" alt="1jSh4g.png"></p>
<p>从重要程度来说，更重要的是比较类排序，因为它是泛型的，也是工业编程中用得最多的。</p>
<hr>
<p><strong>初级排序</strong>：O(n^2)</p>
<ol>
<li>选择排序(Selection Sort)</li>
</ol>
<p>每次选择最小值，然后放到待排序数组的起始位置。</p>
<ol start="2">
<li>插入排序(Insertion Sort)</li>
</ol>
<p>从前到后逐步构建有序序列;对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<ol start="3">
<li>冒泡排序(Bubble Sort)</li>
</ol>
<p>嵌套循环，每次查看相邻的元素，如果逆序，则交换。</p>
<p>这三种初级排序没有太大差别，其实是异曲同工的原理。</p>
<p><font color=#FF0000>而面试中，考察技术能力的时候，他考察的一般也都是O(nlogn)的排序，所以准备过程中也应该尽量多花时间去看时间复杂度为O(nlogn)的排序算法。</font>主要是三个：堆排序、快速排序、归并排序。</p>
<hr>
<h2 id="高级排序-——-O-N-logN"><a href="#高级排序-——-O-N-logN" class="headerlink" title="高级排序 —— O(N*logN)"></a><strong>高级排序</strong> —— O(N*logN)</h2><h3 id="快速排序-Quick-Sort"><a href="#快速排序-Quick-Sort" class="headerlink" title="快速排序(Quick Sort)"></a><strong>快速排序(Quick Sort)</strong></h3><p>数组取标杆pivot，将小元素放到pivot左边，大元素放右边，然后依次对左边和右边的子数组继续快排；以达到整个序列有序。</p>
<p>快排用到了<strong>分治</strong>的思想，首先，如果想要把排序的时间复杂度从O(n^2)降到O(N logN)，那么分治毫无疑问是要考虑的问题。</p>
<p><font color=#FF0000>快排的方法：拿到一个pivot的位置，将所有小于pivot的元素移动到左边去，大于pivot的移动到右边去，且分别对左右侧再进行递归，调用快排。</font>可以通过主定理，证明整个递归下来的时间复杂度为O(N logN)。</p>
<p>快排的样例代码：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] <span class="built_in">array</span>, <span class="keyword">int</span> <span class="built_in">begin</span>, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">end</span> &lt;= <span class="built_in">begin</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> pivot = partition(<span class="built_in">array</span>, <span class="built_in">begin</span>, <span class="built_in">end</span>);</span><br><span class="line">    quickSort(<span class="built_in">array</span>, <span class="built_in">begin</span>, pivot - <span class="number">1</span>);</span><br><span class="line">    quickSort(<span class="built_in">array</span>, pivot + <span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> <span class="built_in">begin</span>, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// pivot: 标杆位置，counter: 小于a[pivot]的元素的个数</span></span><br><span class="line">    <span class="keyword">int</span> pivot = <span class="built_in">end</span>, counter = <span class="built_in">begin</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">begin</span>; i &lt; <span class="built_in">end</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; a[pivot]) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = a[counter]; a[counter] = a[i]; a[i] = temp;</span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> temp = a[pivot]; a[pivot] = a[counter]; a[counter] = temp;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>稍微复杂的过程是partition，它做的是，返回一个下标pivot，且能够保证pivot之前的元素都小于pivot，pivot之后的元素都大于pivot。(但是需要注意，每次partition只能保证pivot前面的是小于它的，后面是大于它的，前面和后面不能保证是有序的)</p>
<p>这段代码其实是非常考验基本功的。</p>
<p>实现过程中，我们可以申请一个新的数组，通过比较，把小的元素放到数组的左边，大的元素放到数组的右边。但是如果不能申请一个新的数组，那么这段代码是非常巧妙的。</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (int i = <span class="keyword">begin</span>; i &lt; <span class="keyword">end</span>; i++) <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    if (a[i] &lt; a[pivot]) &#123;</span></span><br><span class="line"><span class="comment">        int temp = a[counter]; a[counter] = a[i]; a[i] = temp;</span></span><br><span class="line"><span class="comment">        counter++;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一开始把pivot定义在传入的数组的最后的位置，然后根据情况改变pivot的位置。counter用于统计小于a[pivot]的元素的个数。这里的关键是，只要a[i] &lt; a[pivot]，说明a[counter]要和a[i]交换位置。</p>
<p>这里一开始我也没能理解，但是用纸笔模拟了一下之后，发现真的很巧妙。一开始counter和i都是begin，是从相同的地方开始的，然后counter用于指在最后一个小于a[pivot]的元素上，i的值来进行循环，如果碰到比末尾的pivot值大的值，就跳过（因为这个是要留给counter进行交换的,counter此时的作用是把大的元素和后面的i位置的，而且比a[pivot]小元素进行交换），i只要碰到了小于a[pivot]的，就让前面的counter和这个小于a[pivot]的元素交换，从而让大的元素移到后面去，然后把counter往后移，如果此时a[counter]的元素是大于a[pivot]的，那么此时counter所指的元素是为了进行下次交换的。保证counter前面的所有值都是小于a[pivot]的。</p>
<p>一直这样下去，直到begin和end都遍历完了，然后交换a[pivot]和a[counter]，由此一来，绝对可以保证a[piovot]成为一个分水岭，pivot成为一个标杆，a[pivot]左边所有的元素都会是小于a[pivot]的，右边都是大于a[pivot]的。</p>
<p>快排就是这样，大家写的时候，就是把这一段记好，多写几次，多写几次，记住关键的pivot和counter以及它们的作用。</p>
<h3 id="归并排序-Merge-Sort"><a href="#归并排序-Merge-Sort" class="headerlink" title="归并排序(Merge Sort)"></a><strong>归并排序(Merge Sort)</strong></h3><p>归并排序也用到了<strong>分治</strong>的思想。</p>
<p>归并具体流程：</p>
<ol>
<li>把待排序的数组从中间一分为二，注意这个分只是从中间直接”劈开”，不用做任何交换元素的操作。</li>
<li>对这两个子序列先分别调用归并排序，这样可以保证左边的子序列和右边的子序列在自己的片段区间中是有序的。</li>
<li>将两个排好序的子序列合并。</li>
</ol>
<p>归并和快排刚好相反，可以把归并排序看做是快排的逆向操作。为什么？</p>
<p>具体做法不同。归并：先把数组一分为二，在左边和右边都分别调用了排序方法排好序之后，再把左右排好序的两个子数组合并成一个。</p>
<p>快排：先用partition排好序从而找到pivot的位置，然后再用pivot进行大小的”分隔”，和归并排序是完全相反的操作。</p>
<p>然后看代码，首先是mergeSort的主函数部分：</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">public static void mergeSort(<span class="built_in">int</span>[] array, <span class="built_in">int</span> <span class="built_in">left</span>, <span class="built_in">int</span> <span class="built_in">right</span>) &#123;</span><br><span class="line">    <span class="built_in">if</span> (<span class="built_in">right</span> &lt;= <span class="built_in">left</span>) return;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">mid</span> = (<span class="built_in">left</span> + <span class="built_in">right</span>) &gt;&gt; <span class="number">1</span>; // (<span class="built_in">left</span> + <span class="built_in">right</span>) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    mergeSort(array, <span class="built_in">left</span>, <span class="built_in">mid</span>);</span><br><span class="line">    mergeSort(array, <span class="built_in">mid</span> + <span class="number">1</span>, <span class="built_in">right</span>);</span><br><span class="line">    merge(array, <span class="built_in">left</span>, <span class="built_in">mid</span>, <span class="built_in">right</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先直接从中间一分为二地”劈开”, 得到mid，然后递归，每次都切分一次。最后在每次递归的终止的地方将切分并且排好序的两部分合并。</p>
<p>然后对于merge的逻辑怎么写，之前写过的，把两个有序的链表怎么合并，那里已经知道用O(n)就可以解决。</p>
<p>在这里的情况是，给你一个数组，它的两半部分全部都是排好序的，你怎么把它合并起来？你也可以想象，给你两个数组，这两个数组都是排好序的，怎么把它合并起来。</p>
<p>这种程序题目，逻辑相对来说比较简单，但是对于基础编码功底要求很高。</p>
<p>经过挑选出来的合并的代码，应该是最精简，最漂亮的代码。</p>
<p>如果之前没写过这段代码，多多少少是要花一些功夫的。</p>
<p>应当把这种，<strong>把两个有序的数组合并在一起（或者在这里称之为归并）</strong>，的方法，当成一个代码的模板，记在脑子里。最好能够灵活运用。这是提高你最基础的内容的很重要的一个部分。</p>
<p>merge方法部分：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> static <span class="type">void</span> merge(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right) &#123;</span><br><span class="line">        <span class="type">int</span>[] <span class="keyword">temp</span> = <span class="built_in">new</span> <span class="type">int</span>[right - left + <span class="number">1</span>]; // 中间数组</span><br><span class="line">        <span class="type">int</span> i = left, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">temp</span>[k++] = arr[i] &lt;= arr[j] ? arr[i++] : arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid)   <span class="keyword">temp</span>[k++] = arr[i++];</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= right) <span class="keyword">temp</span>[k++] = arr[j++];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">0</span>; p &lt; <span class="keyword">temp</span>.length; p++) &#123;</span><br><span class="line">            arr[left + p] = <span class="keyword">temp</span>[p];</span><br><span class="line">        &#125;</span><br><span class="line">        // 也可以用 <span class="keyword">System</span>.arraycopy(a, start1, b, start2, length)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这段代码具体在做什么呢？</p>
<p>首先，从left到mid和从mid到right都已经有序了。把这两个子序列合并在一起。</p>
<p>你可以想象为，有两个数组，第一个数组从left到mid，第二个数组是从mid到right。这两个数组分别是有序的，怎样合并起来。</p>
<p>首先，要申请一段额外的内存空间（归并排序必须要申请一块额外的内存空间出来）</p>
<p><code>int[] temp = new int[right - left + 1]; // 中间数组</code></p>
<p>需要的大小也没什么好说的，很多申请数组的大小都是要有这么一个+1的内容。</p>
<p>接下来，定义了两个下标i和j, i就是left，j是mid+1，也就是，i表示第一个数组的起始位置，j表示第二个数组的起始位置。k指的是temp这个数组里面已经填入的元素的个数。</p>
<p>关于合并：<font color=#FF0000>在看了这段之后，一定要养成一个习惯：要合并两个有序的数组，它永远是这种三段式写法：</font></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">i</span> &lt;= mid &amp;&amp; <span class="built_in">j</span> &lt;= right) &#123;</span><br><span class="line">    temp[k++] = arr[<span class="built_in">i</span>] &lt;= arr[<span class="built_in">j</span>] ? arr[<span class="built_in">i</span>++] : arr[<span class="built_in">j</span>++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">i</span> &lt;= mid)   temp[k++] = arr[<span class="built_in">i</span>++];</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">j</span> &lt;= right) temp[k++] = arr[<span class="built_in">j</span>++];</span><br></pre></td></tr></table></figure>

<p>具体分析：</p>
<p>第一个while：保证i没有循环完且j也没有循环完（所以有i&lt;=mid和j&lt;=right），然后比较a[i]和a[j]中的较小者，把较小者拿出来放到temp[k]里面去。同时，用了a[i]，就让i++（因为要再去用下一个元素了），用了a[j]，就让j++（同理），然后放入到temp[k]之后，毫无疑问k也要k++。</p>
<p>上面的这一大段逻辑，就三行写完，很是巧妙：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">i</span> &lt;= mid &amp;&amp; <span class="built_in">j</span> &lt;= right) &#123;</span><br><span class="line">    temp[k++] = arr[<span class="built_in">i</span>] &lt;= arr[<span class="built_in">j</span>] ? arr[<span class="built_in">i</span>++] : arr[<span class="built_in">j</span>++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color=#FF0000>但是，强调，这句话不是奇技淫巧！对于编程写得比较多的人，这句话是经常用的！</font></p>
<p>所以要习惯于写这么一句话。这句话的逻辑是非常清晰的，而且简明扼要。它做得事情就是，比较a[i]和a[j]中的较小者，取出来之后，把较小者赋值给temp[k]，同时a[i]或者a[j]谁被用到，就让下标加一用于下次使用，然后k也要移动用于下一次使用。</p>
<p>这个循环写完之后，可以保证一点，就是i全部走完子数组，或者j全部走完了子数组。</p>
<p>接下来要做的，如果i没有走完，那么把i的剩余部分赋值到temp[k]里面去，或者j没有走完的话，把j剩余部分复制到temp[k]里面去。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">i</span> &lt;= mid)   temp[k++] = arr[<span class="built_in">i</span>++];</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">j</span> &lt;= right) temp[k++] = arr[<span class="built_in">j</span>++];</span><br></pre></td></tr></table></figure>

<p>在这两个while循环也写完之后，你可以发现，整个数组已经完成了归并，放到了temp[]里面了。</p>
<p>因为我们在merge这个函数里面是要对arr[]进行排序，所以我们要再把temp里面的所有元素再拷贝回array里面去。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> p = <span class="number">0</span>; p &lt; temp.length; p++) &#123;</span><br><span class="line">    arr[left + p] = temp[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 也可以用 System.arraycopy(a, start1, b, start2, length)</span></span><br></pre></td></tr></table></figure>

<p>对于归并排序的代码，希望大家多多练习，把这段代码写得更细腻。</p>
<p>以及，<font color=#FF0000>把这段很能体现编程内力的代码可以在白板上写出来，面试官肯定会刮目相看的。</font></p>
<hr>
<p><strong>小总结</strong></p>
<p>归并 和 快排 具有相似性，但步骤顺序相反。</p>
<ul>
<li>归并：线排序左右子数组，然后合并两个有序子数组。</li>
<li>快排：先调配出左右子数组，然后对左右子数组进行合并。</li>
</ul>
<p>快排先调配左右子数组，就是让左边的数组的所有元素都小于右边数组的所有元素（中间的元素为pivot，就是pivot左边的所有元素都小于pivot，右边的所有元素都大于pivot）。但是左、右的元素在这个时候仍然还是无序的，那么然后对于左、右子数组分别调用排序的函数进行分治。</p>
<p><font color=#FF0000>快排和归并排序都讲完了，这两个是高级排序的面试的重点，一定要细细品味，多过遍数。</font></p>
<ul>
<li><strong>堆排序(Merge Sort)</strong></li>
</ul>
<p>堆插入时间复杂度为O(logN)，取堆顶，最大/小值，时间复杂度为O(1)</p>
<p>堆排序的过程：</p>
<ol>
<li>对元素依次建立最小堆</li>
<li>依次取堆顶元素，并删除</li>
</ol>
<p>堆本身是一种很有意思的数据结构，使用数组存储一个树状结构，通过自身的规律，可以用简单的公式获取到当前某个节点的父节点或者左右孩子节点(注意起始坐标是0还是1，公式有区别)。</p>
<p>关键点就是，每次你在调整之前，儿子节点如果大于父亲节点，两者就交换，一直到当前节点小于其他祖宗节点。</p>
<p><strong>非比较类排序</strong></p>
<ul>
<li>计数排序(Counting Sort)</li>
</ul>
<p>计数排序要求输入的数据必须是有确定范围的整数。将输入的数据值转化为键存储在额外开辟的数组空间中；然后依次把计数大于1的填充回原数组。<font color=#FF0000>总之，你的元素必须是整数，而且元素值不能太大，否则浪费空间。</font></p>
<ul>
<li>桶排序(Bucket Sort)</li>
</ul>
<p>工作原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序(有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序)。</p>
<ul>
<li>基数排序(Radix Sort)</li>
</ul>
<p>按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。<font color=#FF0000>先按照个位进行排序，也就是放到0,1,2…9的位置，把低位先排好序。然后再排十位，再按照0-9的值排上去。然后百位，以此类推。这样一来，排序的数组只需要存储0-9的数字，这是比较巧妙的地方。但是基数排序也是有一个短板，就是只能存储整数，不能存储小数的值。<br></font></p>
]]></content>
      <categories>
        <category>Algorithms Note</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Practice by Categories Bitwise Operation</title>
    <url>/2020/01/13/LeetCode-Practice-by-Categories-Bitwise-Operation/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>LeetCode Practice by Categories Dynamic Programming</title>
    <url>/2020/01/13/LeetCode-Practice-by-Categories-Dynamic-Programming/</url>
    <content><![CDATA[<blockquote>
<p>每个人都是自己命运的主宰——斯蒂尔斯</p>
</blockquote>
<p>LeetCode大量动态规划相关题目，其解决思路和具体代码。</p>
<a id="more"></a>

<p>动态规划不是空中楼阁。</p>
<h2 id="70-Climbing-stairsl-爬楼梯-Easy"><a href="#70-Climbing-stairsl-爬楼梯-Easy" class="headerlink" title="70. Climbing-stairsl(爬楼梯)(Easy)"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. Climbing-stairsl(爬楼梯)(Easy)</a></h2><p>You are climbing a stair case. It takes n steps to reach to the top.</p>
<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>
<p>Note: Given <em>n</em> will be a positive integer.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">Output:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">Explanation:</span> <span class="string">There</span> <span class="string">are</span> <span class="string">two</span> <span class="string">ways</span> <span class="string">to</span> <span class="string">climb</span> <span class="string">to</span> <span class="string">the</span> <span class="string">top.</span></span><br><span class="line"><span class="number">1</span><span class="string">.</span> <span class="number">1</span> <span class="string">step</span> <span class="string">+</span> <span class="number">1</span> <span class="string">step</span></span><br><span class="line"><span class="number">2</span><span class="string">.</span> <span class="number">2</span> <span class="string">steps</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">Output:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">Explanation:</span> <span class="string">There</span> <span class="string">are</span> <span class="string">three</span> <span class="string">ways</span> <span class="string">to</span> <span class="string">climb</span> <span class="string">to</span> <span class="string">the</span> <span class="string">top.</span></span><br><span class="line"><span class="number">1</span><span class="string">.</span> <span class="number">1</span> <span class="string">step</span> <span class="string">+</span> <span class="number">1</span> <span class="string">step</span> <span class="string">+</span> <span class="number">1</span> <span class="string">step</span></span><br><span class="line"><span class="number">2</span><span class="string">.</span> <span class="number">1</span> <span class="string">step</span> <span class="string">+</span> <span class="number">2</span> <span class="string">steps</span></span><br><span class="line"><span class="number">3</span><span class="string">.</span> <span class="number">2</span> <span class="string">steps</span> <span class="string">+</span> <span class="number">1</span> <span class="string">step</span></span><br></pre></td></tr></table></figure>
<hr>
<p>解：爬楼梯很经典，变型也很多。首先结论是，单纯的这道题，通过数学归纳的思路(或者说递归的思路)，不难发现其实结果就是前两个元素为1,2的斐波那契数列。(斐波那契数列为509题，因为类似这里就不记录了，链接<a href="https://leetcode-cn.com/problems/fibonacci-number/" target="_blank" rel="noopener">点击这里</a>)</p>
<p>方法一：递归，可以画出递归树发现，因为每个层级都会在上一层的数量基础上多出2倍的节点，所以时间复杂度为O(2^n)，指数级别，不可以接受。而且实际测试中在N为44的时候会出现超时。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> climbStairs(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> climbHelper(<span class="number">0</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> climbHelper(<span class="built_in">int</span> curr, <span class="built_in">int</span> target) &#123;</span><br><span class="line">        <span class="comment">// terminator</span></span><br><span class="line">        <span class="comment">// 跨过了目标阶梯，不算入方法</span></span><br><span class="line">        <span class="keyword">if</span>(curr &gt; target) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 刚好攀登到某个位置</span></span><br><span class="line">        <span class="keyword">if</span>(curr == target) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> climbHelper(curr + <span class="number">1</span>, target) + climbHelper(curr + <span class="number">2</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>方法二：基于递归，加上备忘录，进行有记忆的递归，可以把之前计算过的结果保存下来，有很好的剪枝效果。因为有记录所有的过程，所以子问题的数量就是f(1),f(2)…，为O(n),而且每个子问题解决的时间为O(n)</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> climbStairs(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="comment">// 基于暴力递归，进行有记忆的递归，把每一步的结果存储在mem数组之中，每当有函数被再次调用，就直接从memo数组返回结果，减少计算次数</span></span><br><span class="line">        <span class="built_in">int</span>[] memo = new <span class="built_in">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> climbHelper(<span class="number">0</span>,n,memo);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> climbHelper(<span class="built_in">int</span> curr, <span class="built_in">int</span> target, <span class="built_in">int</span>[] memo) &#123;</span><br><span class="line">        <span class="comment">// terminator</span></span><br><span class="line">        <span class="comment">// 跨过了目标阶梯，不算入方法</span></span><br><span class="line">        <span class="keyword">if</span>(curr &gt; target) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 刚好攀登到某个位置</span></span><br><span class="line">        <span class="keyword">if</span>(curr == target) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果当前N阶梯数量已经计算过，直接从memo返回</span></span><br><span class="line">        <span class="keyword">if</span>(memo[curr] &gt; <span class="number">0</span>) <span class="keyword">return</span> memo[curr];</span><br><span class="line">        </span><br><span class="line">        memo[curr] =  climbHelper(curr + <span class="number">1</span>, target, memo) + climbHelper(curr + <span class="number">2</span>, target, memo);</span><br><span class="line">        <span class="keyword">return</span> memo[curr];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>方法三：常规动态规划，时间复杂度为O(n)，空间复杂度也为O(n)</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> climbStairs(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// dp[i]表示爬到第i阶共有的爬法</span></span><br><span class="line">        <span class="built_in">int</span>[] dp = new <span class="built_in">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>; dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法四：基于常规动态规划的优化。在空间复杂度上可以提升到O(1)。实际上在一开始的时间复杂度的基础上都可以进行空间的优化，比如O(n)可以优化到O(1),O(m*n)可以优化到O(n)。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> climbStairs(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> f1 = <span class="number">1</span>, f2 = <span class="number">2</span>, f3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            f3 = f1 + f2;</span><br><span class="line">            f1 = f2;</span><br><span class="line">            f2 = f3;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="322-Coin-Change-零钱兑换-Mid"><a href="#322-Coin-Change-零钱兑换-Mid" class="headerlink" title="322. Coin Change(零钱兑换)(Mid)"></a><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">322. Coin Change(零钱兑换)(Mid)</a></h2><p>You are given coins of different denominations and a total amount of money <em>amount</em>. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return <code>-1</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="string">coins</span> <span class="string">=</span> <span class="string">[1,</span> <span class="number">2</span><span class="string">,</span> <span class="number">5</span><span class="string">],</span> <span class="string">amount</span> <span class="string">=</span> <span class="number">11</span></span><br><span class="line"><span class="attr">Output:</span> <span class="number">3</span> </span><br><span class="line"><span class="attr">Explanation:</span> <span class="number">11</span> <span class="string">=</span> <span class="number">5</span> <span class="string">+</span> <span class="number">5</span> <span class="string">+</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="string">coins</span> <span class="string">=</span> <span class="string">[2],</span> <span class="string">amount</span> <span class="string">=</span> <span class="number">3</span></span><br><span class="line"><span class="attr">Output:</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>


<p><strong>Note:</strong></p>
<p>You may assume that you have an infinite number of each kind of coin.</p>
<hr>
<p>解：这道题其实和之前的爬楼梯问题是异曲同工之处，可以看成每次可以走coins数组里面的步伐，最后要到达amount的高度，有多少种走法。当然这里有点变化，就是比如112和121，在爬楼梯问题是不同方法，而在这里coin change则是相同的，一种方法。但是写DP方程的话差不多了。</p>
<p>方法一：暴力法，用递归的方式。</p>
<p><img src="https://s2.ax1x.com/2020/02/21/3uunUK.png" alt="3uunUK.png"></p>
<p>题目变成：在状态树中找到叶子节点为0的，并且层数最小的。<br>可以用树的广度优先遍历，直到碰到数值为0的节点，当前层数就是最小硬币数，就是我们的答案。</p>
<p>但是这个方法会存在指数级别的时间复杂度。</p>
<p>方法二：DP</p>
<p>a. subproblems</p>
<p>b. DP array：f(n) = min{f(n-k), for k in [1,2,5]} + 1, 遍历可以选择的面值的数组，直到n被减到0为止，然后取得到的硬币数的最小值。加一是因为一开始的n-k没有被算入，后面补上。</p>
<p>c. DP方程</p>
<p>代码：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> coinChange(<span class="built_in">int</span>[] coins, <span class="built_in">int</span> amount) &#123;</span><br><span class="line">        <span class="comment">// amount + 1 是无法到达的，以此判断最后是否不能到达amount</span></span><br><span class="line">        <span class="built_in">int</span> max = amount+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// dp数组的下标是当前金额，里面的值是需要的硬币的个数，初始化是不可达的max</span></span><br><span class="line">        <span class="built_in">int</span>[] dp = new <span class="built_in">int</span>[max];</span><br><span class="line">        <span class="comment">// 初始化dp,初始化考虑只有面值为1的硬币，需要max个</span></span><br><span class="line">        Arrays.fill(dp,max);</span><br><span class="line">        <span class="comment">// 当拿到的amount是0的时候，需要0个硬币，类似爬楼梯，初始化就在0级台阶</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 外层，遍历所有下标的元素，也就是当前凑到的面值数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">            <span class="comment">// 每次都从coins里面取元素出来，比如coins是[1,2,5]，每次在要凑下标</span></span><br><span class="line">            <span class="comment">// 值的时候，都会把1,2,5取出来进行值的拼凑</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; coins.length; j++) &#123;</span><br><span class="line">                <span class="comment">// 如果当前coins里面取出来的值比下标小，才能用。否则比如你下标是3，</span></span><br><span class="line">                <span class="comment">// 即当前要凑到3的值，但当前conis里面硬币值是10，那肯定不用这个</span></span><br><span class="line">                <span class="keyword">if</span>(coins[j] &lt;= i) &#123;</span><br><span class="line">                    <span class="comment">// 用DP方程进行递推</span></span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[i-coins[j]] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果最后一个没有被修改，则没办法组成这个金额。否则返回最后amount下标的值</span></span><br><span class="line">        <span class="keyword">return</span> dp[amount] == max ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态规划一般脱离递归，直接由循环迭代完成计算。</p>
<p>动态规划问题最难的就是写出状态转移方程。</p>
<p>时间复杂度：O(m*n)</p>
]]></content>
      <categories>
        <category>Algorithms Note</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Practice by Categories Search</title>
    <url>/2020/01/13/LeetCode-Practice-by-Categories-Search/</url>
    <content><![CDATA[<blockquote>
<p>轻财足以聚人，律己足以服人，量宽足以得人，身先足以率人。——陈继儒</p>
</blockquote>
<p>LeetCode搜索相关题目，其解决思路和具体代码。内容也包括二分查找。</p>
<a id="more"></a>

<p>在树的章节中已经包括了很多有关DFS和BFS的题目，比如，非常经典和重要的，树的层次遍历(102)和树的一些遍历。之前重复的在这里先不再写了。</p>
<h2 id="127-Word-Ladder-单词接龙-Mid"><a href="#127-Word-Ladder-单词接龙-Mid" class="headerlink" title="127. Word Ladder(单词接龙)(Mid)"></a><a href="https://leetcode-cn.com/problems/word-ladder/" target="_blank" rel="noopener">127. Word Ladder(单词接龙)(Mid)</a></h2><p>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary’s word list, find the length of shortest transformation sequence from <em>beginWord</em> to <em>endWord</em>, such that:</p>
<ol>
<li>Only one letter can be changed at a time.</li>
<li>Each transformed word must exist in the word list. Note that <em>beginWord</em> is not a <em>transformed</em> word.</li>
</ol>
<p><strong>Note:</strong></p>
<ul>
<li>Return 0 if there is no such transformation sequence.</li>
<li>All words have the same length.</li>
<li>All words contain only lowercase alphabetic characters.</li>
<li>You may assume no duplicates in the word list.</li>
<li>You may assume beginWord and endWord are non-empty and are not the same.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">beginWord = <span class="string">"hit"</span>,</span><br><span class="line">endWord = <span class="string">"cog"</span>,</span><br><span class="line">wordList = [<span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span>,<span class="string">"cog"</span>]</span><br><span class="line"></span><br><span class="line">Output: <span class="number">5</span></span><br><span class="line"></span><br><span class="line">Explanation: As one shortest transformation <span class="keyword">is</span> <span class="string">"hit"</span><span class="function"> -&gt;</span> <span class="string">"hot"</span><span class="function"> -&gt;</span> <span class="string">"dot"</span><span class="function"> -&gt;</span> <span class="string">"dog"</span><span class="function"> -&gt;</span> <span class="string">"cog"</span>,</span><br><span class="line"><span class="keyword">return</span> its length <span class="number">5.</span></span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">Input:</span></span><br><span class="line">beginWord = <span class="string">"hit"</span></span><br><span class="line">endWord = <span class="string">"cog"</span></span><br><span class="line">wordList = [<span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span>]</span><br><span class="line"></span><br><span class="line"><span class="section">Output: 0</span></span><br><span class="line"></span><br><span class="line"><span class="section">Explanation: The endWord "cog" is not in wordList, therefore no possible transformation.</span></span><br></pre></td></tr></table></figure>
<hr>
<p>解：<strong>这道题是面试中经常会出现的问题</strong>。一般思路，可以使用初级搜索，即单向BFS。但是这里着重介绍使用双向BFS的方法，从beginWord和endWord中更小的那个开始扩散。为什么这样扩散比单向扩散效率更高？</p>
<p>因为同时从beginWord和endWord开始，然后每次从更短的一段开始继续搜索，那么因为是更小的Set，所以辐射的内容会更少，如果需要剪枝或者回溯，代价也可以更小。</p>
<p>比如，打仗的时候一方总会派出侦察兵，这些侦察兵往往身上负重很轻，因为这样他们才可以移动迅速，累赘小。而如果他们被抓了，需要被放弃，那么少量的武器，也能成为更小的损失和代价。</p>
<p>实际上，双向BFS是属于<strong>高级搜索</strong>的范畴的。对于初级搜索(BFS和DFS)，一般来说优化的思路有两个：<strong>一是让搜索过程去掉重复以及尽早剪枝</strong>，<strong>二是</strong>让它在搜索方向上加强。</p>
<p>事实上，双向BFS在高级搜索中用得比较多，而且代码并不难。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(<span class="keyword">String</span> beginWord, <span class="keyword">String</span> endWord, List&lt;<span class="keyword">String</span>&gt; wordList)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!wordList.contains(endWord)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 用Set代替Queue进行BFS, 是为了更方便查询单词是否在wordList中</span></span><br><span class="line">        <span class="comment">// 如果不用哈希，直接的list查询时间复杂度为O(n),使用Set之后时间复杂度为O(1)</span></span><br><span class="line">        Set&lt;<span class="keyword">String</span>&gt; wordListSet = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// beginSet是从beginWord开始扩散的，endSet是从endWord开始扩散的</span></span><br><span class="line">        Set&lt;<span class="keyword">String</span>&gt; beginSet = <span class="keyword">new</span> HashSet&lt;&gt;(), endSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里和单向BFS中一开始往queue中加入元素的操作类似,加入初始元素</span></span><br><span class="line">        <span class="comment">// 可以看出，beginSet和endSet本质没有先后顺序,先扩散小的可以更快收敛</span></span><br><span class="line">        beginSet.add(beginWord);</span><br><span class="line">        endSet.add(endWord);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 转换次数，这是细节，由于beingWord != endWord, 所以至少一步</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// visited 表示这个BFS节点是否已经被访问过了</span></span><br><span class="line">        Set&lt;<span class="keyword">String</span>&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// BFS start here</span></span><br><span class="line">        <span class="keyword">while</span>( !beginSet.isEmpty() ) &#123;</span><br><span class="line">            <span class="comment">// 扩散的时候优先选择小的Set</span></span><br><span class="line">            <span class="comment">// 如果beginSet更小，就扩散它</span></span><br><span class="line">            <span class="comment">// 否则如果beginSet更大，交换这两个Set,还是小的Set开始扩散</span></span><br><span class="line">            <span class="comment">// 核心：控制当前循环从哪个方向进行bfs；让begin指向size更小的集合，这样不会一直从一个方向BFS</span></span><br><span class="line">            <span class="keyword">if</span>(beginSet.<span class="built_in">size</span>() &gt; endSet.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                Set&lt;<span class="keyword">String</span>&gt; <span class="built_in">set</span> = beginSet;</span><br><span class="line">                beginSet = endSet;</span><br><span class="line">                endSet = <span class="built_in">set</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// neighbor 这个set表示每一次要扩散的set的内容</span></span><br><span class="line">            Set&lt;<span class="keyword">String</span>&gt; neighbor = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            <span class="comment">// 模板中这里会开始控制次数的for循环，但这里的HashSet和模板的queue是一样的含义,只是更方便查找</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">String</span> <span class="keyword">word</span> : beginSet) &#123;</span><br><span class="line">                <span class="comment">// 对每一个单词，变化它的字符位</span></span><br><span class="line">                <span class="keyword">char</span>[] chs = <span class="keyword">word</span>.toCharArray();</span><br><span class="line">                <span class="comment">// 用字母表遍历当前chs的每一个字母</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">char</span> c = <span class="string">'a'</span>; c &lt;= <span class="string">'z'</span>; c++) &#123;</span><br><span class="line">                        <span class="comment">// 保存chs的当前位置的字母</span></span><br><span class="line">                        <span class="keyword">char</span> old = chs[i];</span><br><span class="line">                        <span class="comment">// 然后替换成当前遍历到的字母表的字母</span></span><br><span class="line">                        chs[i] = c;</span><br><span class="line">                        <span class="comment">// 转换回String，从而使用endSet中的contains方法</span></span><br><span class="line">                        <span class="comment">// 否则不能对char[]使用contains方法</span></span><br><span class="line">                        <span class="keyword">String</span> target = <span class="keyword">String</span>.valueOf(chs);</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 因为endSet是从endWord那边扩散过来的，如果我们替换过程中产生的target也在</span></span><br><span class="line">                        <span class="comment">// 这个Set里，说明从begin扩散过来的Set和从end扩散过来的set，在这里相交了</span></span><br><span class="line">                        <span class="comment">// 这个相交的word就是target</span></span><br><span class="line">                        <span class="keyword">if</span>(endSet.contains(target)) &#123;</span><br><span class="line">                            <span class="keyword">return</span> len + <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 如果当时没找到target，则继续扩散其他的target,且把target追加到下一次</span></span><br><span class="line">                        <span class="comment">// 要扩散的set里面去，这里的neighbor set就是后面要扩散的set</span></span><br><span class="line">                        <span class="keyword">if</span>(!visited.contains(target) &amp;&amp; wordListSet.contains(target)) &#123;</span><br><span class="line">                            neighbor.add(target);</span><br><span class="line">                            <span class="comment">// 标记target 为 visited, 表示访问过了</span></span><br><span class="line">                            visited.add(target);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 把单词本身还原</span></span><br><span class="line">                        chs[i] = old;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理完beign中的元素之后，让begin指向begin中的元素的邻居</span></span><br><span class="line">            beginSet = neighbor;</span><br><span class="line">            <span class="comment">// 路径长度++</span></span><br><span class="line">            len ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有转换的路径</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="126-单词接龙-II-Hard"><a href="#126-单词接龙-II-Hard" class="headerlink" title="126. (单词接龙 II)(Hard)"></a><a href="https://leetcode-cn.com/problems/word-ladder-ii/" target="_blank" rel="noopener">126. (单词接龙 II)(Hard)</a></h2><h2 id="433-Minimum-Genetic-Mutation-最小基因变化-Mid"><a href="#433-Minimum-Genetic-Mutation-最小基因变化-Mid" class="headerlink" title="433. Minimum Genetic Mutation(最小基因变化)(Mid)"></a><a href="https://leetcode-cn.com/problems/minimum-genetic-mutation/" target="_blank" rel="noopener">433. Minimum Genetic Mutation(最小基因变化)(Mid)</a></h2><p>A gene string can be represented by an 8-character long string, with choices from <code>&quot;A&quot;, &quot;C&quot;, &quot;G&quot;, &quot;T&quot;</code>.</p>
<p>Suppose we need to investigate about a mutation (mutation from “start” to “end”), where ONE mutation is defined as ONE single character changed in the gene string.</p>
<p>For example, <code>&quot;AACCGGTT&quot; -&gt; &quot;AACCGGTA&quot;</code> is 1 mutation.</p>
<p>Also, there is a given gene “bank”, which records all the valid gene mutations. A gene must be in the bank to make it a valid gene string.</p>
<p>Now, given 3 things - start, end, bank, your task is to determine what is the minimum number of mutations needed to mutate from “start” to “end”. If there is no such a mutation, return -1.</p>
<p><strong>Note:</strong></p>
<ol>
<li>Starting point is assumed to be valid, so it might not be included in the bank.</li>
<li>If multiple mutations are needed, all mutations during in the sequence must be valid.</li>
<li>You may assume start and end string is not the same.</li>
</ol>
<p><strong>Exmaple 1:</strong></p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">start:</span> <span class="string">"AACCGGTT"</span></span><br><span class="line"><span class="symbol">end:</span>   <span class="string">"AACCGGTA"</span></span><br><span class="line"><span class="symbol">bank:</span> [<span class="string">"AACCGGTA"</span>]</span><br><span class="line"></span><br><span class="line"><span class="symbol">return:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">start:</span> <span class="string">"AACCGGTT"</span></span><br><span class="line"><span class="symbol">end:</span>   <span class="string">"AAACGGTA"</span></span><br><span class="line"><span class="symbol">bank:</span> [<span class="string">"AACCGGTA"</span>, <span class="string">"AACCGCTA"</span>, <span class="string">"AAACGGTA"</span>]</span><br><span class="line"></span><br><span class="line"><span class="symbol">return:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">start:</span> <span class="string">"AAAAACCC"</span></span><br><span class="line"><span class="symbol">end:</span>   <span class="string">"AACCCCCC"</span></span><br><span class="line"><span class="symbol">bank:</span> [<span class="string">"AAAACCCC"</span>, <span class="string">"AAACCCCC"</span>, <span class="string">"AACCCCCC"</span>]</span><br><span class="line"></span><br><span class="line"><span class="symbol">return:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：这道题实际和单词接龙属于一种类型的题目，都是通过BFS解决状态图搜索问题。</p>
<h2 id="17-Letter-Combinations-of-a-Phone-Number-电话号码的字母组合-Mid"><a href="#17-Letter-Combinations-of-a-Phone-Number-电话号码的字母组合-Mid" class="headerlink" title="17. Letter Combinations of a Phone Number(电话号码的字母组合)(Mid)"></a><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">17. Letter Combinations of a Phone Number(电话号码的字母组合)(Mid)</a></h2><p>Given a string containing digits from <code>2-9</code> inclusive, return all possible letter combinations that the number could represent.</p>
<p>A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png" alt=""></p>
<p><strong>Example:</strong></p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Input:</span> <span class="string">"23"</span></span><br><span class="line"><span class="symbol">Output:</span> [<span class="string">"ad"</span>, <span class="string">"ae"</span>, <span class="string">"af"</span>, <span class="string">"bd"</span>, <span class="string">"be"</span>, <span class="string">"bf"</span>, <span class="string">"cd"</span>, <span class="string">"ce"</span>, <span class="string">"cf"</span>].</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong><br>Although the above answer is in lexicographical order(字典序), your answer could be in any order you want.</p>
<hr>
<p>解：这道题是比较经典的搜索问题。深搜和广搜都可以。</p>
<p>方法一：</p>
]]></content>
      <categories>
        <category>Algorithms Note</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Practice by Categories Tree+Recursion</title>
    <url>/2020/01/13/LeetCode-Practice-by-Categories-Tree/</url>
    <content><![CDATA[<blockquote>
<p>世界上最快乐的事，莫过于为理想而奋斗——苏格拉底</p>
</blockquote>
<p>LeetCode树、递归相关题目，其解决思路和具体代码。</p>
<a id="more"></a>

<p>首先可以使用递归来解决的问题，一般具有如下特点： 1. 该问题可以被分解成若干个重复的子问题； 2. 该问题与它分解出的子问题可以使用相同的算法来解决； 3. 有明确的终止条件。</p>
<p>树这种数据结构的特点和上述三个特点高度一致，一棵树的每个非叶子节点的子节点也都是一棵树，都是树自然可以使用相同的算法来处理，因为没有环所以天然具有终止条件。 另外一方面，树本身是一种非线性的数据结构，循环遍历不易。当然循环遍历也是可以做，树是一种特殊的图，我们完全可以使用图的广度优先遍历算法一层一层的循环遍历整棵树。 综上，我们一般还是选择递归的方式来解决树的问题。</p>
<p>因为树的操作的特性，很多题目可以用递归相关轻易解决，比如树的前中后序遍历。但是非递归的方式同样重要。</p>
<p>除了树，还有分治，回溯和递归相关题目。分治和回溯本质就是递归，递归和回溯是特殊的递归。</p>
<p>有关树的时间复杂度和空间复杂度分析，可以参考下面这张图：</p>
<p><img src="https://s2.ax1x.com/2020/01/19/1CsVMT.png" alt="1CsVMT.png"></p>
<p>可以发现，因为二叉树每层最多两个元素，按照层级扩散，所以与树相关的结构平均下来的时间复杂度大多是 <code>O(logN)</code> 级别的。</p>
<p>针对递归，一般人们的认识是递归的时间复杂度非常高。但是具体说来，递归算法的时间复杂度如何计算呢？——<strong>子问题个数乘以解决一个子问题需要的时间。</strong></p>
<h2 id="94-Binary-Tree-Inorder-Traversal-二叉树中序遍历-Mid"><a href="#94-Binary-Tree-Inorder-Traversal-二叉树中序遍历-Mid" class="headerlink" title="94. Binary Tree Inorder Traversal(二叉树中序遍历)(Mid)"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. Binary Tree Inorder Traversal(二叉树中序遍历)(Mid)</a></h2><p>Given a binary tree, return the inorder traversal of its nodes’ values.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="literal">null</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">   <span class="number">1</span></span><br><span class="line">    \</span><br><span class="line">     <span class="number">2</span></span><br><span class="line">    /</span><br><span class="line">   <span class="number">3</span></span><br><span class="line"></span><br><span class="line">Output: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>


<p><strong>Follow up:</strong> Recursive solution is trivial(简单), could you do it iteratively?</p>
<hr>
<p>解：方法一，递归，时间复杂度较高。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; inorder<span class="constructor">Traversal(TreeNode <span class="params">root</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root<span class="operator"> == </span>null) return <span class="keyword">new</span> ArrayList&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">        travel<span class="constructor">Helper(<span class="params">root</span>, <span class="params">result</span>)</span>;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void travel<span class="constructor">Helper(TreeNode <span class="params">root</span>, List&lt;Integer&gt; <span class="params">result</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root<span class="operator"> == </span>null) return ;</span><br><span class="line">        travel<span class="constructor">Helper(<span class="params">root</span>.<span class="params">left</span>, <span class="params">result</span>)</span>;</span><br><span class="line">        result.add(root.<span class="keyword">val</span>);</span><br><span class="line">        travel<span class="constructor">Helper(<span class="params">root</span>.<span class="params">right</span>, <span class="params">result</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，非递归，用一个栈解决。</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">class Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; result = <span class="literal">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">Stack</span>&lt;TreeNode&gt; <span class="built_in">stack</span> = <span class="literal">new</span> <span class="built_in">Stack</span>&lt;&gt;();</span><br><span class="line">        TreeNode root0 = root;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(root0 != <span class="built_in">null</span> || !<span class="built_in">stack</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span>(root0 != <span class="built_in">null</span>) &#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(root0);</span><br><span class="line">                root0 = root0.left;</span><br><span class="line">            &#125;</span><br><span class="line">                <span class="comment">// 此时符合 !stack.isEmpty() 条件</span></span><br><span class="line">                root0 = <span class="built_in">stack</span>.pop();</span><br><span class="line">                result.add(root0.val);</span><br><span class="line">                <span class="comment">// 某节点左子树遍历完了，遍历右子树，符合中序遍历顺序</span></span><br><span class="line">                root0 = root0.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注：</strong>额外定义了一个root0，避免操作之后整棵树找不到了的情况。面试过程中只是为了完成遍历，不定义root0问题也不大。</p>
<h2 id="144-Binary-Tree-Preorder-Traversal-二叉树的前序遍历-Mid"><a href="#144-Binary-Tree-Preorder-Traversal-二叉树的前序遍历-Mid" class="headerlink" title="144. Binary Tree Preorder Traversal (二叉树的前序遍历)(Mid)"></a><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">144. Binary Tree Preorder Traversal (二叉树的前序遍历)(Mid)</a></h2><p>Given a binary tree, return the preorder traversal of its nodes’ values.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="literal">null</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">   <span class="number">1</span></span><br><span class="line">    \</span><br><span class="line">     <span class="number">2</span></span><br><span class="line">    /</span><br><span class="line">   <span class="number">3</span></span><br><span class="line"></span><br><span class="line">Output: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p>
<hr>
<p>解：方法一，递归</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; preorder<span class="constructor">Traversal(TreeNode <span class="params">root</span>)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">if</span>(root<span class="operator"> == </span>null) return result;</span><br><span class="line">        pre<span class="constructor">Helper(<span class="params">root</span>, <span class="params">result</span>)</span>;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void pre<span class="constructor">Helper(TreeNode <span class="params">root</span>, List&lt;Integer&gt; <span class="params">result</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// terminator</span></span><br><span class="line">        <span class="keyword">if</span>(root<span class="operator"> == </span>null) return ;</span><br><span class="line">        result.add(root.<span class="keyword">val</span>);</span><br><span class="line">        pre<span class="constructor">Helper(<span class="params">root</span>.<span class="params">left</span>, <span class="params">result</span>)</span>;</span><br><span class="line">        pre<span class="constructor">Helper(<span class="params">root</span>.<span class="params">right</span>, <span class="params">result</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，非递归</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">class Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; preorderTraversal(TreeNode root) &#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; result = <span class="literal">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        TreeNode root0 = root;</span><br><span class="line">        <span class="built_in">Stack</span>&lt;TreeNode&gt; <span class="built_in">stack</span> = <span class="literal">new</span> <span class="built_in">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">stack</span>.isEmpty() || root0 != <span class="built_in">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span>(root0 != <span class="built_in">null</span>) &#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(root0);</span><br><span class="line">                result.add(root0.val);</span><br><span class="line">                root0 = root0.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root0 = <span class="built_in">stack</span>.pop();</span><br><span class="line">            root0 = root0.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注：</strong>额外定义了一个root0，避免操作之后整棵树找不到了的情况。面试过程中只是为了完成遍历，不定义root0问题也不大。</p>
<h2 id="145-Binary-Tree-Postorder-Traversal-二叉树的后序遍历-Hard"><a href="#145-Binary-Tree-Postorder-Traversal-二叉树的后序遍历-Hard" class="headerlink" title="145. Binary Tree Postorder Traversal (二叉树的后序遍历)(Hard)"></a><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">145. Binary Tree Postorder Traversal (二叉树的后序遍历)(Hard)</a></h2><p>Given a binary tree, return the postorder traversal of its nodes’ values.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="literal">null</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">   <span class="number">1</span></span><br><span class="line">    \</span><br><span class="line">     <span class="number">2</span></span><br><span class="line">    /</span><br><span class="line">   <span class="number">3</span></span><br><span class="line"></span><br><span class="line">Output: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p>
<hr>
<p>解：方法一，递归</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; postorder<span class="constructor">Traversal(TreeNode <span class="params">root</span>)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">if</span>(root<span class="operator"> == </span>null) return result;</span><br><span class="line">        post<span class="constructor">Helper(<span class="params">root</span>, <span class="params">result</span>)</span>;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void post<span class="constructor">Helper(TreeNode <span class="params">root</span>, List&lt;Integer&gt; <span class="params">result</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root<span class="operator"> == </span>null) return ;</span><br><span class="line">        post<span class="constructor">Helper(<span class="params">root</span>.<span class="params">left</span>, <span class="params">result</span>)</span>;</span><br><span class="line">        post<span class="constructor">Helper(<span class="params">root</span>.<span class="params">right</span>, <span class="params">result</span>)</span>;</span><br><span class="line">        result.add(root.<span class="keyword">val</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，利用通过LinkedList构造的List&lt;&gt;可以用addFirst()方法。因为后序遍历访问节点的顺序刚好和前序相反，所以在同样地方访问节点然后加入到结果集合的头部即可。此外这个方法因为完全模拟前序的相反流程，所以访问节点的顺序也是和遍历顺序相反，即先访问右子树，再左子树。</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">class Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; postorderTraversal(TreeNode root) &#123;</span><br><span class="line">        LinkedList&lt;<span class="built_in">Integer</span>&gt; result = <span class="literal">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="built_in">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">Stack</span>&lt;TreeNode&gt; <span class="built_in">stack</span> = <span class="literal">new</span> <span class="built_in">Stack</span>&lt;&gt;();</span><br><span class="line">        TreeNode root0 = root;</span><br><span class="line">        <span class="keyword">while</span>(root0 != <span class="built_in">null</span> || !<span class="built_in">stack</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span>(root0 != <span class="built_in">null</span>) &#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(root0);</span><br><span class="line">                result.addFirst(root0.val);</span><br><span class="line">                root0 = root0.right;</span><br><span class="line">            &#125;</span><br><span class="line">            root0 = <span class="built_in">stack</span>.pop();</span><br><span class="line">            root0 = root0.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注：</strong>额外定义了一个root0，避免操作之后整棵树找不到了的情况。面试过程中只是为了完成遍历，不定义root0问题也不大。</p>
<p>但是这个看起来很巧妙(确实也很巧妙，利用后序遍历和前序遍历相反的规律)的方法有Bug，即如果树存在比较复杂的拓扑依赖，这种方法会报出错(但是面试用这个方法应该问题不大)。</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">class Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; postorderTraversal(TreeNode root) &#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; result=<span class="literal">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="built_in">Stack</span>&lt;TreeNode&gt; <span class="built_in">stack</span>=<span class="literal">new</span> <span class="built_in">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="built_in">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">stack</span>.push(root);</span><br><span class="line">        TreeNode cur=root;</span><br><span class="line">        TreeNode pre=<span class="built_in">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">stack</span>.isEmpty())&#123;</span><br><span class="line">            cur=<span class="built_in">stack</span>.peek();</span><br><span class="line">            <span class="keyword">if</span>(cur.left==<span class="built_in">null</span>&amp;&amp;cur.right==<span class="built_in">null</span>||(pre!=<span class="built_in">null</span>&amp;&amp;(pre==cur.left||pre==cur.right)))&#123;</span><br><span class="line">                result.add(cur.val); <span class="comment">//deal with topological dependency</span></span><br><span class="line">                <span class="built_in">stack</span>.pop();</span><br><span class="line">                pre=cur;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.right!=<span class="built_in">null</span>)&#123;</span><br><span class="line">                    <span class="built_in">stack</span>.push(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur.left!=<span class="built_in">null</span>)&#123;</span><br><span class="line">                    <span class="built_in">stack</span>.push(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="102-Binary-tree-level-order-traversal-二叉树的层序遍历-Mid"><a href="#102-Binary-tree-level-order-traversal-二叉树的层序遍历-Mid" class="headerlink" title="102. Binary tree level order traversal(二叉树的层序遍历)(Mid)"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">102. Binary tree level order traversal(二叉树的层序遍历)(Mid)</a></h2><p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).</p>
<p>For example:<br><code>Given binary tree [3,9,20,null,null,15,7],</code></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>return its level order traversal as:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">20</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<hr>
<p>解：这道题，在整个硅谷的面试题中，出现次数也是能够排在前三的位置，非常重要。</p>
<p>方法一，递归，DFS。层序遍历用深搜其实有一点”反人类”，但是有助于理解和面试时候的表现。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Definition for </span>a<span class="markdown"> binary tree node.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>public class TreeNode &#123;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>int val;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>TreeNode left;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>TreeNode right;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>TreeNode(int x) &#123; val = x; &#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>&#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> */</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    public <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        levelHelper(result, root ,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public <span class="keyword">void</span> levelHelper(<span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;Integer&gt;&gt; result, TreeNode root, <span class="built_in">int</span> height) &#123;</span><br><span class="line">        <span class="comment">// terminator</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// process current logic</span></span><br><span class="line">        <span class="keyword">if</span>(height &gt;= result.size()) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> LinkedList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="keyword">get</span>(height).add(root.val);</span><br><span class="line">        levelHelper(result, root.left, height + <span class="number">1</span>);</span><br><span class="line">        levelHelper(result, root.right, height + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，使用队列，使用BFS遍历的模板。</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">class Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; result = <span class="literal">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">Queue</span>&lt;TreeNode&gt; <span class="built_in">queue</span> = <span class="literal">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="built_in">queue</span>.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">queue</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 循环里面要定义三个变量</span></span><br><span class="line">            </span><br><span class="line">			<span class="comment">// 每次循环队列长度都会变化，需要每次都更新</span></span><br><span class="line">            int levelLength = <span class="built_in">queue</span>.size();</span><br><span class="line">            <span class="comment">// 需要临时保存当前层的所有元素</span></span><br><span class="line">            <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; currLevel = <span class="literal">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            for(int i = <span class="number">0</span>; i &lt; levelLength; i++) &#123;</span><br><span class="line">                TreeNode currNode = <span class="built_in">queue</span>.poll();</span><br><span class="line">                currLevel.add(currNode.val);</span><br><span class="line">                <span class="keyword">if</span>(currNode.left != <span class="built_in">null</span>) <span class="built_in">queue</span>.add(currNode.left);</span><br><span class="line">                <span class="keyword">if</span>(currNode.right != <span class="built_in">null</span>) <span class="built_in">queue</span>.add(currNode.right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(currLevel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="103-Binary-Tree-Zigzag-Level-Order-Traversal-二叉树的锯齿形层序遍历-Mid"><a href="#103-Binary-Tree-Zigzag-Level-Order-Traversal-二叉树的锯齿形层序遍历-Mid" class="headerlink" title="103. Binary Tree Zigzag Level Order Traversal(二叉树的锯齿形层序遍历)(Mid)"></a><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">103. Binary Tree Zigzag Level Order Traversal(二叉树的锯齿形层序遍历)(Mid)</a></h2><p>Given a binary tree, return the <em>zigzag level order</em> traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p>
<p>For example:<br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>return its zigzag level order traversal as:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">20</span>,<span class="number">9</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<hr>
<p>解：上一道102已经解决了层次遍历的问题，可以基于上一题使用队列实现BFS的思想。但是这里需要判断锯齿(或者称为之字型)，用变量zigzag记录当前从右向左添加还是从左向右添加元素。zigzag为false，表示从左到右。zigzag为true，表示从右到左。初始的时候为从左到右，即zigzag初始值为false。</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">class Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; result = <span class="literal">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">Queue</span>&lt;TreeNode&gt; <span class="built_in">queue</span> = <span class="literal">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="built_in">queue</span>.add(root);</span><br><span class="line">        <span class="built_in">boolean</span> zigzag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">queue</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; currLevel = <span class="literal">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            int currLength = <span class="built_in">queue</span>.size();</span><br><span class="line">            for(int i = <span class="number">0</span>; i &lt; currLength; i++) &#123;</span><br><span class="line">                TreeNode currNode = <span class="built_in">queue</span>.poll();</span><br><span class="line">                <span class="keyword">if</span>(zigzag) &#123;</span><br><span class="line">                    currLevel.add(<span class="number">0</span>, currNode.val);</span><br><span class="line">                &#125; <span class="keyword">else</span> currLevel.add(currNode.val);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(currNode.left != <span class="built_in">null</span>) <span class="built_in">queue</span>.add(currNode.left);</span><br><span class="line">                <span class="keyword">if</span>(currNode.right != <span class="built_in">null</span>) <span class="built_in">queue</span>.add(currNode.right);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            result.add(currLevel);</span><br><span class="line">            zigzag = !zigzag;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>linkedList的add方法，两参数的重构方法中第一个参数为index：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">	<span class="built_in">add</span>(int index, E <span class="keyword">element</span>)</span><br><span class="line">Inserts <span class="keyword">the</span> specified <span class="keyword">element</span> <span class="keyword">at</span> <span class="keyword">the</span> specified position <span class="keyword">in</span> this list.</span><br></pre></td></tr></table></figure>

<h2 id="515-Find-Largest-Value-in-Each-Tree-Row-在每个树中找最大值-Mid"><a href="#515-Find-Largest-Value-in-Each-Tree-Row-在每个树中找最大值-Mid" class="headerlink" title="515. Find Largest Value in Each Tree Row(在每个树中找最大值)(Mid)"></a><a href="https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/#/description" target="_blank" rel="noopener">515. Find Largest Value in Each Tree Row(在每个树中找最大值)(Mid)</a></h2><p>You need to find the largest value in each row of a binary tree.</p>
<p><strong>Example :</strong></p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Input</span>: </span><br><span class="line"></span><br><span class="line">          1</span><br><span class="line">         / \</span><br><span class="line">        3   2</span><br><span class="line">       / \   \  </span><br><span class="line">      5   3   9 </span><br><span class="line"></span><br><span class="line"><span class="attribute">Output</span>: [1, 3, 9]</span><br></pre></td></tr></table></figure>

<hr>
<p>解：因为需要按照层次记录最大值，所以和层次遍历题目有类似之处。</p>
<p>方法一：DFS。深搜大多利用递归，写一个递归函数，直接利用计算机帮你维护的栈即可。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; largest<span class="constructor">Values(TreeNode <span class="params">root</span>)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">if</span>(root<span class="operator"> == </span>null) return result;</span><br><span class="line">        largest<span class="constructor">Helper(<span class="params">result</span>, <span class="params">root</span>, 0)</span>;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void largest<span class="constructor">Helper(List&lt;Integer&gt; <span class="params">result</span>, TreeNode <span class="params">root</span>, <span class="params">int</span> <span class="params">height</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root<span class="operator"> == </span>null) return ;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// expand list size</span></span><br><span class="line">        <span class="keyword">if</span>(height<span class="operator"> == </span>result.size<span class="literal">()</span>) &#123;</span><br><span class="line">            result.add(root.<span class="keyword">val</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.set(height, <span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>max(result.get(height), root.<span class="keyword">val</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        largest<span class="constructor">Helper(<span class="params">result</span>, <span class="params">root</span>.<span class="params">left</span>, <span class="params">height</span> + 1)</span>;</span><br><span class="line">        largest<span class="constructor">Helper(<span class="params">result</span>, <span class="params">root</span>.<span class="params">right</span>, <span class="params">height</span> + 1)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：BFS。和树部分102题层次遍历大体结构相同。</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">class Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; largestValues(TreeNode root) &#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; result = <span class="literal">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">Queue</span>&lt;TreeNode&gt; <span class="built_in">queue</span> = <span class="literal">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>.offer(root);</span><br><span class="line">        int <span class="keyword">max</span> = <span class="built_in">Integer</span>.MIN_VALUE;</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">queue</span>.isEmpty()) &#123;</span><br><span class="line">            int levelSize = <span class="built_in">queue</span>.size();</span><br><span class="line">            for(int i = <span class="number">0</span>; i &lt; levelSize; i++) &#123;</span><br><span class="line">                TreeNode currNode = <span class="built_in">queue</span>.poll();</span><br><span class="line">                <span class="keyword">max</span> = Math.<span class="keyword">max</span>(<span class="keyword">max</span>, currNode.val);</span><br><span class="line">                <span class="keyword">if</span>(currNode.left != <span class="built_in">null</span>) <span class="built_in">queue</span>.add(currNode.left);</span><br><span class="line">                <span class="keyword">if</span>(currNode.right != <span class="built_in">null</span>) <span class="built_in">queue</span>.add(currNode.right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(<span class="keyword">max</span>);</span><br><span class="line">            <span class="keyword">max</span> = <span class="built_in">Integer</span>.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="590-N-ary-Tree-Postorder-Traversal-N叉树的后序遍历-Easy"><a href="#590-N-ary-Tree-Postorder-Traversal-N叉树的后序遍历-Easy" class="headerlink" title="590. N-ary Tree Postorder Traversal (N叉树的后序遍历)(Easy)"></a><a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/" target="_blank" rel="noopener">590. N-ary Tree Postorder Traversal (N叉树的后序遍历)(Easy)</a></h2><p>Given an n-ary tree, return the postorder traversal of its nodes’ values.</p>
<p><em>Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).</em></p>
<p><strong>Follow up:</strong></p>
<p>Recursive solution is trivial, could you do it iteratively?</p>
<p><strong>Example 1:</strong><br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/narytreeexample.png" alt=""></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: root = [<span class="number">1</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">Output: [<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong><br><img src="https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png" alt=""></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: root = [<span class="number">1</span>,<span class="literal">null</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="literal">null</span>,<span class="number">8</span>,<span class="literal">null</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">11</span>,<span class="literal">null</span>,<span class="number">12</span>,<span class="literal">null</span>,<span class="number">13</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">14</span>]</span><br><span class="line">Output: [<span class="number">2</span>,<span class="number">6</span>,<span class="number">14</span>,<span class="number">11</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">12</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">13</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li>The height of the n-ary tree is less than or equal to 1000</li>
<li>The total number of nodes is between [0, 10^4]</li>
</ul>
<hr>
<p>解：利用LinkedList的addFirst()遍历树。。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">// Definition for a <span class="keyword">Node</span>.<span class="title"></span></span><br><span class="line"><span class="title">class</span> <span class="keyword">Node</span> <span class="title">&#123;</span></span><br><span class="line"><span class="title">    public</span> int val;</span><br><span class="line">    public List<span class="tag">&lt;Node&gt;</span> children;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">Node</span><span class="title">() &#123;&#125;</span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">    public</span> <span class="keyword">Node</span><span class="title">(int</span> _val) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">Node</span><span class="title">(int</span> _val, List<span class="tag">&lt;Node&gt;</span> _children) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        children = _children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List<span class="tag">&lt;Integer&gt;</span> postorder(<span class="keyword">Node</span> <span class="title">root</span>) &#123;</span><br><span class="line">        LinkedList<span class="tag">&lt;Integer&gt;</span> result = new LinkedList<span class="tag">&lt;&gt;</span>();</span><br><span class="line">        if(root == null) return result;</span><br><span class="line">        Stack<span class="tag">&lt;Node&gt;</span> stack = new Stack<span class="tag">&lt;&gt;</span>();</span><br><span class="line">        stack.add(root);</span><br><span class="line">        </span><br><span class="line">        while(!stack.empty()) &#123;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            result.addFirst(root.val);</span><br><span class="line">            for(<span class="keyword">Node</span> <span class="title">node</span> : root.children) &#123;</span><br><span class="line">                stack.add(<span class="keyword">node</span><span class="title">);</span></span><br><span class="line"><span class="title">            &#125;</span></span><br><span class="line"><span class="title">        &#125;</span></span><br><span class="line"><span class="title">        return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="589-N-ary-Tree-Preorder-Traversal-N叉树的前序遍历-Easy"><a href="#589-N-ary-Tree-Preorder-Traversal-N叉树的前序遍历-Easy" class="headerlink" title="589. N-ary Tree Preorder Traversal (N叉树的前序遍历)(Easy)"></a><a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/" target="_blank" rel="noopener">589. N-ary Tree Preorder Traversal (N叉树的前序遍历)(Easy)</a></h2><p>Given an n-ary tree, return the preorder traversal of its nodes’ values.</p>
<p><em>Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).</em></p>
<p><strong>Follow up:</strong><br>Recursive solution is trivial, could you do it iteratively?</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/narytreeexample.png" alt=""></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: root = [<span class="number">1</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">Output: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong><br><img src="https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png" alt=""></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: root = [<span class="number">1</span>,<span class="literal">null</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="literal">null</span>,<span class="number">8</span>,<span class="literal">null</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">11</span>,<span class="literal">null</span>,<span class="number">12</span>,<span class="literal">null</span>,<span class="number">13</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">14</span>]</span><br><span class="line">Output: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">14</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">13</span>,<span class="number">10</span>]</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li>The height of the n-ary tree is less than or equal to 1000</li>
<li>The total number of nodes is between [0, 10^4]</li>
</ul>
<hr>
<p>解：使用DFS非递归模板。把子树从后往前添加到栈里面，弹出的时候刚好相反，从前往后的顺序弹出。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">// Definition for a <span class="keyword">Node</span>.<span class="title"></span></span><br><span class="line"><span class="title">class</span> <span class="keyword">Node</span> <span class="title">&#123;</span></span><br><span class="line"><span class="title">    public</span> int val;</span><br><span class="line">    public List<span class="tag">&lt;Node&gt;</span> children;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">Node</span><span class="title">() &#123;&#125;</span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">    public</span> <span class="keyword">Node</span><span class="title">(int</span> _val) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">Node</span><span class="title">(int</span> _val, List<span class="tag">&lt;Node&gt;</span> _children) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        children = _children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List<span class="tag">&lt;Integer&gt;</span> preorder(<span class="keyword">Node</span> <span class="title">root</span>) &#123;</span><br><span class="line">        List<span class="tag">&lt;Integer&gt;</span> result = new LinkedList<span class="tag">&lt;&gt;</span>();</span><br><span class="line">        if(root == null) return result;</span><br><span class="line">        </span><br><span class="line">        Stack<span class="tag">&lt;Node&gt;</span> stack = new Stack<span class="tag">&lt;&gt;</span>();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        </span><br><span class="line">        while(!stack.empty()) &#123;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            result.add(root.val);</span><br><span class="line">            for(int i = root.children.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                stack.add(root.children.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="429-N-ary-Tree-Level-Order-Traversal-N叉树的层序遍历-Mid"><a href="#429-N-ary-Tree-Level-Order-Traversal-N叉树的层序遍历-Mid" class="headerlink" title="429. N-ary Tree Level Order Traversal(N叉树的层序遍历)(Mid)"></a><a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/" target="_blank" rel="noopener">429. N-ary Tree Level Order Traversal(N叉树的层序遍历)(Mid)</a></h2><p>Given an n-ary tree, return the level order traversal of its nodes’ values.</p>
<p><em>Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).</em></p>
<p><strong>Example 1:</strong><br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/narytreeexample.png" alt=""></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: root = [<span class="number">1</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">Output: [[<span class="number">1</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>]]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong><br><img src="https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png" alt=""></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: root = [<span class="number">1</span>,<span class="literal">null</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="literal">null</span>,<span class="number">8</span>,<span class="literal">null</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">11</span>,<span class="literal">null</span>,<span class="number">12</span>,<span class="literal">null</span>,<span class="number">13</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">14</span>]</span><br><span class="line">Output: [[<span class="number">1</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>],[<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>],[<span class="number">14</span>]]</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li>The height of the n-ary tree is less than or equal to 1000</li>
<li>The total number of nodes is between [0, 10^4]</li>
</ul>
<hr>
<p>解：和层序遍历思路相同，只是需要注意N叉树的遍历在内层要多一个循环去遍历所有节点的子节点。</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public List&lt;Node&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, List&lt;Node&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">class Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; levelOrder(Node root) &#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; result = <span class="literal">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">Queue</span>&lt;Node&gt; <span class="built_in">queue</span> = <span class="literal">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="built_in">queue</span>.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">queue</span>.isEmpty()) &#123;</span><br><span class="line">            int currLength = <span class="built_in">queue</span>.size();</span><br><span class="line">            <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; currLevel = <span class="literal">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            for(int i = <span class="number">0</span>; i &lt; currLength; i++) &#123;</span><br><span class="line">                Node currNode = <span class="built_in">queue</span>.poll();</span><br><span class="line">                currLevel.add(currNode.val);</span><br><span class="line">                for(Node node : currNode.children) &#123;</span><br><span class="line">                    <span class="built_in">queue</span>.add(node);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(currLevel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="70-Climbing-stairsl-爬楼梯-Easy"><a href="#70-Climbing-stairsl-爬楼梯-Easy" class="headerlink" title="70. Climbing-stairsl(爬楼梯)(Easy)"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. Climbing-stairsl(爬楼梯)(Easy)</a></h2><p>You are climbing a stair case. It takes n steps to reach to the top.</p>
<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>
<p>Note: Given <em>n</em> will be a positive integer.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">Output:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">Explanation:</span> <span class="string">There</span> <span class="string">are</span> <span class="string">two</span> <span class="string">ways</span> <span class="string">to</span> <span class="string">climb</span> <span class="string">to</span> <span class="string">the</span> <span class="string">top.</span></span><br><span class="line"><span class="number">1</span><span class="string">.</span> <span class="number">1</span> <span class="string">step</span> <span class="string">+</span> <span class="number">1</span> <span class="string">step</span></span><br><span class="line"><span class="number">2</span><span class="string">.</span> <span class="number">2</span> <span class="string">steps</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">Output:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">Explanation:</span> <span class="string">There</span> <span class="string">are</span> <span class="string">three</span> <span class="string">ways</span> <span class="string">to</span> <span class="string">climb</span> <span class="string">to</span> <span class="string">the</span> <span class="string">top.</span></span><br><span class="line"><span class="number">1</span><span class="string">.</span> <span class="number">1</span> <span class="string">step</span> <span class="string">+</span> <span class="number">1</span> <span class="string">step</span> <span class="string">+</span> <span class="number">1</span> <span class="string">step</span></span><br><span class="line"><span class="number">2</span><span class="string">.</span> <span class="number">1</span> <span class="string">step</span> <span class="string">+</span> <span class="number">2</span> <span class="string">steps</span></span><br><span class="line"><span class="number">3</span><span class="string">.</span> <span class="number">2</span> <span class="string">steps</span> <span class="string">+</span> <span class="number">1</span> <span class="string">step</span></span><br></pre></td></tr></table></figure>
<hr>
<p>解：爬楼梯很经典，变型也很多。首先结论是，单纯的这道题，通过数学归纳的思路(或者说递归的思路)，不难发现其实结果就是前两个元素为1,2的斐波那契数列。(斐波那契数列为509题，因为类似这里就不记录了，链接<a href="https://leetcode-cn.com/problems/fibonacci-number/" target="_blank" rel="noopener">点击这里</a>)</p>
<p>方法一：递归，可以画出递归树发现，因为每个层级都会在上一层的数量基础上多出2倍的节点，所以时间复杂度为O(2^n)，指数级别，不可以接受。而且实际测试中在N为44的时候会出现超时。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> climbStairs(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> climbHelper(<span class="number">0</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> climbHelper(<span class="built_in">int</span> curr, <span class="built_in">int</span> target) &#123;</span><br><span class="line">        <span class="comment">// terminator</span></span><br><span class="line">        <span class="comment">// 跨过了目标阶梯，不算入方法</span></span><br><span class="line">        <span class="keyword">if</span>(curr &gt; target) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 刚好攀登到某个位置</span></span><br><span class="line">        <span class="keyword">if</span>(curr == target) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> climbHelper(curr + <span class="number">1</span>, target) + climbHelper(curr + <span class="number">2</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>方法二：基于递归，加上备忘录，进行有记忆的递归，可以把之前计算过的结果保存下来，有很好的剪枝效果。因为有记录所有的过程，所以子问题的数量就是f(1),f(2)…，为O(n),而且每个子问题解决的时间为O(n)</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> climbStairs(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="comment">// 基于暴力递归，进行有记忆的递归，把每一步的结果存储在mem数组之中，每当有函数被再次调用，就直接从memo数组返回结果，减少计算次数</span></span><br><span class="line">        <span class="built_in">int</span>[] memo = new <span class="built_in">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> climbHelper(<span class="number">0</span>,n,memo);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> climbHelper(<span class="built_in">int</span> curr, <span class="built_in">int</span> target, <span class="built_in">int</span>[] memo) &#123;</span><br><span class="line">        <span class="comment">// terminator</span></span><br><span class="line">        <span class="comment">// 跨过了目标阶梯，不算入方法</span></span><br><span class="line">        <span class="keyword">if</span>(curr &gt; target) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 刚好攀登到某个位置</span></span><br><span class="line">        <span class="keyword">if</span>(curr == target) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果当前N阶梯数量已经计算过，直接从memo返回</span></span><br><span class="line">        <span class="keyword">if</span>(memo[curr] &gt; <span class="number">0</span>) <span class="keyword">return</span> memo[curr];</span><br><span class="line">        </span><br><span class="line">        memo[curr] =  climbHelper(curr + <span class="number">1</span>, target, memo) + climbHelper(curr + <span class="number">2</span>, target, memo);</span><br><span class="line">        <span class="keyword">return</span> memo[curr];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>方法三：常规动态规划，时间复杂度为O(n)，空间复杂度也为O(n)</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> climbStairs(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// dp[i]表示爬到第i阶共有的爬法</span></span><br><span class="line">        <span class="built_in">int</span>[] dp = new <span class="built_in">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>; dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法四：基于常规动态规划的优化。在空间复杂度上可以提升到O(1)。实际上在一开始的时间复杂度的基础上都可以进行空间的优化，比如O(n)可以优化到O(1),O(m*n)可以优化到O(n)。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> climbStairs(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> f1 = <span class="number">1</span>, f2 = <span class="number">2</span>, f3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            f3 = f1 + f2;</span><br><span class="line">            f1 = f2;</span><br><span class="line">            f2 = f3;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="22-Generate-Parentheses-括号生成-Mid"><a href="#22-Generate-Parentheses-括号生成-Mid" class="headerlink" title="22. Generate Parentheses (括号生成)(Mid)"></a><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">22. Generate Parentheses (括号生成)(Mid)</a></h2><p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p>
<p>For example, given <em>n = 3</em>, a solution set is:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="string">"((()))"</span>,</span><br><span class="line">  <span class="string">"(()())"</span>,</span><br><span class="line">  <span class="string">"(())()"</span>,</span><br><span class="line">  <span class="string">"()(())"</span>,</span><br><span class="line">  <span class="string">"()()()"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<hr>
<p>解：<strong>方法一</strong>，这道题是用递归+剪枝可以轻松解决的典型题目。</p>
<p>可以想象一共有2n个位置来填补括号。然后给上括号的填补条件即可得到符合要求的括号对。</p>
<p>什么条件呢？必须明确，n为几，就一定会有几个左括号和右括号。<strong>其中左括号加入的条件，是不超过n。而添加左括号的条件是没有的，也就是随时可以加。而右括号添加有条件，就是左括号个数要大于右括号个数才能添加。</strong></p>
<p>也就是说，左括号的条件时：left &lt; n; 右括号的条件是：left &gt; right &amp;&amp; right &lt; n。当然，因为Left&lt;n了，right&lt;left,所以右括号的条件中可以不用写right &lt; n了</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 经典的剪枝问题</span></span><br><span class="line">    <span class="comment">// 方法一，递归</span></span><br><span class="line">    public List&lt;String&gt; generate<span class="constructor">Parenthesis(<span class="params">int</span> <span class="params">n</span>)</span> &#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">        <span class="constructor">_generate( 0, 0, <span class="params">n</span>, <span class="string">""</span>,<span class="params">result</span>)</span>;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void <span class="constructor">_generate(<span class="params">int</span> <span class="params">left</span>, <span class="params">int</span> <span class="params">right</span>, <span class="params">int</span> <span class="params">n</span>, String <span class="params">s</span>, List&lt;String&gt; <span class="params">result</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// terminator</span></span><br><span class="line">        <span class="keyword">if</span> (left<span class="operator"> == </span>n<span class="operator"> &amp;&amp; </span>right<span class="operator"> == </span>n) &#123;</span><br><span class="line">            result.add(s);</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// drill down</span></span><br><span class="line">        <span class="comment">//运用剪枝思想，分别针对左括号和右括号的放置条件来剪枝</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 左括号只要数量小于n，随便放</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; n)</span><br><span class="line">            <span class="constructor">_generate(<span class="params">left</span>+1, <span class="params">right</span>, <span class="params">n</span>, <span class="params">s</span> + <span class="string">"("</span>, <span class="params">result</span>)</span>;</span><br><span class="line">        <span class="comment">// 右括号数量要比左括号少，而且少于n。但是因为本身就存在left &lt; n的条件，所以写left &lt; right 即可</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt; right)</span><br><span class="line">            <span class="constructor">_generate(<span class="params">left</span>, <span class="params">right</span> + 1, <span class="params">n</span>, <span class="params">s</span> + <span class="string">")"</span>, <span class="params">result</span>)</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度上，因为每个子问题处理的时间为O(1)，一共的子问题数量是O(2n)，也就是<strong>O(n)</strong></p>
<p><img src="https://s2.ax1x.com/2020/02/11/1Tttpt.png" alt="1Tttpt.png"></p>
<p><strong>方法二：</strong>动态规划。</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;<span class="keyword">String</span>&gt; generateParenthesis(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义dp为list方便调用</span></span><br><span class="line">        List&lt;List&lt;<span class="keyword">String</span>&gt;&gt; dp = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        dp.<span class="built_in">add</span>(Collections.singletonList(<span class="string">""</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// i表示i对括号</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            List&lt;<span class="keyword">String</span>&gt; curr = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="comment">//j表示在i循环的内部循环，每次可能的括号对数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">String</span> first : dp.<span class="built_in">get</span>(j)) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">String</span> <span class="built_in">second</span> : dp.<span class="built_in">get</span>(i-j<span class="number">-1</span>)) &#123;</span><br><span class="line">                        curr.<span class="built_in">add</span>(<span class="string">"("</span> + first + <span class="string">")"</span> + <span class="built_in">second</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp.<span class="built_in">add</span>(curr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.<span class="built_in">get</span>(dp.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="226-Invert-binary-tree-反转二叉树-Mid"><a href="#226-Invert-binary-tree-反转二叉树-Mid" class="headerlink" title="226. Invert-binary-tree(反转二叉树)(Mid)"></a><a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">226. Invert-binary-tree(反转二叉树)(Mid)</a></h2><p>Invert a binary tree.</p>
<p><strong>Example:</strong></p>
<p>Input:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">     <span class="number">4</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">2</span>     <span class="number">7</span></span><br><span class="line"> / \   / \</span><br><span class="line"><span class="number">1</span>   <span class="number">3</span> <span class="number">6</span>   <span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>Output:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">     <span class="number">4</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">7</span>     <span class="number">2</span></span><br><span class="line"> / \   / \</span><br><span class="line"><span class="number">9</span>   <span class="number">6</span> <span class="number">3</span>   <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>Trivia:<br>This problem was inspired by this original tweet by Max Howell:</p>
<blockquote>
<p>Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so f*** off.</p>
</blockquote>
<hr>
<p>解：方法一，DFS，用递归实现。</p>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * <span class="keyword">public</span> <span class="keyword">class</span> TreeNode &#123;</span><br><span class="line"> *     <span class="built_in">int</span> val;</span><br><span class="line"> *     TreeNode <span class="built_in">left</span>;</span><br><span class="line"> *     TreeNode <span class="built_in">right</span>;</span><br><span class="line"> *     TreeNode(<span class="built_in">int</span> x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) return <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        TreeNode <span class="built_in">left</span> = root.<span class="built_in">left</span>, <span class="built_in">right</span> = root.<span class="built_in">right</span>;</span><br><span class="line">        root.<span class="built_in">left</span> = invertTree(<span class="built_in">right</span>);</span><br><span class="line">        root.<span class="built_in">right</span> = invertTree(<span class="built_in">left</span>);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，非递归，BFS，用队列实现。本质上是针对层次进行翻转，故可以在层次遍历的基础上把每一层的两个子树交换即可。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree <span class="keyword">node</span>.<span class="title"></span></span><br><span class="line"><span class="title"> * public</span> class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">        if(root == null) return null;</span><br><span class="line">        </span><br><span class="line">        Queue<span class="tag">&lt;TreeNode&gt;</span> queue = new LinkedList<span class="tag">&lt;&gt;</span>();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        while(!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode <span class="keyword">node</span> <span class="title">= queue</span>.poll();</span><br><span class="line">            TreeNode tempNode = <span class="keyword">node</span>.<span class="title">left</span>;</span><br><span class="line">            <span class="keyword">node</span>.<span class="title">left</span> = <span class="keyword">node</span>.<span class="title">right</span>;</span><br><span class="line">            <span class="keyword">node</span>.<span class="title">right</span> = tempNode;</span><br><span class="line">            </span><br><span class="line">            if(<span class="keyword">node</span>.<span class="title">left</span> != null) queue.add(<span class="keyword">node</span>.<span class="title">left</span>);</span><br><span class="line">            if(<span class="keyword">node</span>.<span class="title">right</span> != null) queue.add(<span class="keyword">node</span>.<span class="title">right</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="98-Validate-Binary-Search-Tree-验证二叉搜索树-Mid"><a href="#98-Validate-Binary-Search-Tree-验证二叉搜索树-Mid" class="headerlink" title="98. Validate Binary Search Tree(验证二叉搜索树)(Mid)"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree" target="_blank" rel="noopener">98. Validate Binary Search Tree(验证二叉搜索树)(Mid)</a></h2><p>Given a binary tree, determine if it is a valid binary search tree (BST).</p>
<p>Assume a BST is defined as follows:</p>
<ul>
<li>The left subtree of a node contains only nodes with keys less than the node’s key.</li>
<li>The right subtree of a node contains only nodes with keys greater than the node’s key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">    <span class="number">2</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">1</span>   <span class="number">3</span></span><br><span class="line"></span><br><span class="line">Input: [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">Output: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">    <span class="number">5</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">1</span>   <span class="number">4</span></span><br><span class="line">     / \</span><br><span class="line">    <span class="number">3</span>   <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Input</span>: [<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">3</span>,<span class="number">6</span>]</span><br><span class="line">Output: <span class="keyword">false</span></span><br><span class="line">Explanation: The root nod<span class="string">e's value is 5 but its right child'</span>s <span class="keyword">value</span> <span class="keyword">is</span> <span class="number">4.</span></span><br></pre></td></tr></table></figure>
<hr>
<p>解：<strong>验证是否为二叉搜索树</strong>是一道经常考的题目，root0.val为当前遍历的节点，inorderVal为上一个节点</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Definition for </span>a<span class="markdown"> binary tree node.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>public class TreeNode &#123;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>int val;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>TreeNode left;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>TreeNode right;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>TreeNode(int x) &#123; val = x; &#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>&#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> */</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    public boolean isValidBST(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">double</span> inorderVal = -Double.MAX_VALUE;</span><br><span class="line">        TreeNode root0 = root;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() || root0 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span>(root0 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(root0);</span><br><span class="line">                root0 = root0.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root0 = stack.pop();</span><br><span class="line">            <span class="comment">// BST中序遍历一定是递增的，不是递增的序列就一定不是BST</span></span><br><span class="line">            <span class="keyword">if</span>(root0.val &lt;= inorderVal) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            inorderVal = root0.val;</span><br><span class="line">            root0 = root0.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>，在LeetCode平台上，输入的root为空，最终返回的也是true。</p>
<ul>
<li>时间复杂度 : O(N)。每个结点访问一次。</li>
<li>空间复杂度 : O(N)。我们跟进了整棵树。</li>
</ul>
<h2 id="104-Maximum-depth-of-binary-tree-二叉树的最大深度-Easy"><a href="#104-Maximum-depth-of-binary-tree-二叉树的最大深度-Easy" class="headerlink" title="104. Maximum-depth-of-binary-tree(二叉树的最大深度)(Easy)"></a><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree" target="_blank" rel="noopener">104. Maximum-depth-of-binary-tree(二叉树的最大深度)(Easy)</a></h2><p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<p><strong>Note:</strong>A leaf is a node with no children.</p>
<p><strong>Example:</strong><br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>return its depth = 3.</p>
<hr>
<p>解：方法一，递归</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Definition for </span>a<span class="markdown"> binary tree node.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>public class TreeNode &#123;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>int val;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>TreeNode left;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>TreeNode right;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>TreeNode(int x) &#123; val = x; &#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>&#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> */</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    public <span class="built_in">int</span> maxDepth(TreeNode root) &#123;</span><br><span class="line">        <span class="comment">//虽然是树的遍历，但是用DFS可以不需要写递归辅助函数</span></span><br><span class="line">        <span class="comment">//不需要记录任何节点的信息，这是这道题可以用简短代码解决的主要原因</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归退出条件，到叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> leftDepthMax = maxDepth(root.left);</span><br><span class="line">        <span class="built_in">int</span> rightDepthMax = maxDepth(root.right);</span><br><span class="line">        <span class="comment">// 计算出来的max是以某个节点为根节点的数的最大深度</span></span><br><span class="line">        <span class="comment">// max = java.lang.Math.max(leftMaxDepth，rightMaxDepth) + 1;</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(leftDepthMax, rightDepthMax) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写得漂亮一些，可以用一行解决：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public <span class="built_in">int</span> max<span class="constructor">Depth(TreeNode <span class="params">root</span>)</span> &#123;</span><br><span class="line">        return root<span class="operator"> == </span>null ? <span class="number">0</span> : <span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>max(max<span class="constructor">Depth(<span class="params">root</span>.<span class="params">left</span>)</span>,max<span class="constructor">Depth(<span class="params">root</span>.<span class="params">right</span>)</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度：我们每个结点只访问一次，因此时间复杂度为 O(N)，<br>其中 N 是结点的数量。</li>
<li>空间复杂度：在最糟糕的情况下，树是完全不平衡的，例如每个结点只剩下左子结点，递归将会被调用 N 次（树的高度），因此保持调用栈的存储将是 O(N)。但在最好的情况下（树是完全平衡的），树的高度将是 log(N)。因此，在这种情况下的空间复杂度将是 O(log(N))。</li>
</ul>
<p>方法二，迭代，用BFS层次遍历的方法，遍历完之后层数就是最大深度：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == null) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        Queue&lt;TreeNode&gt; <span class="built_in">queue</span> = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="built_in">queue</span>.add(root);</span><br><span class="line">        <span class="keyword">int</span> maxDepth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">queue</span>.isEmpty()) &#123;</span><br><span class="line">            maxDepth ++;</span><br><span class="line">            <span class="keyword">int</span> currLength = <span class="built_in">queue</span>.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; currLength; i++) &#123;</span><br><span class="line">                TreeNode node = <span class="built_in">queue</span>.poll();</span><br><span class="line">                <span class="keyword">if</span>(node.left != null) <span class="built_in">queue</span>.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != null) <span class="built_in">queue</span>.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxDepth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<p><strong>注：</strong>综合下来这道题用递归解法时间和空间复杂度都更优，因为平衡二叉树的情况下栈的调用次数只有log(n)。</p>
<h2 id="111-Minimum-depth-of-binary-tree-二叉树的最小深度-Mid"><a href="#111-Minimum-depth-of-binary-tree-二叉树的最小深度-Mid" class="headerlink" title="111. Minimum-depth-of-binary-tree(二叉树的最小深度)(Mid)"></a><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree" target="_blank" rel="noopener">111. Minimum-depth-of-binary-tree(二叉树的最小深度)(Mid)</a></h2><p>Given a binary tree, find its minimum depth.</p>
<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>
<p><strong>Note:</strong> A leaf is a node with no children.</p>
<p><strong>Example:</strong><br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>return its minimum depth = 2.</p>
<hr>
<p>解：递归是最直接的方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> int minDepth(<span class="type">TreeNode</span> root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == null) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        int <span class="keyword">left</span> = minDepth(root.<span class="keyword">left</span>);</span><br><span class="line">        int <span class="keyword">right</span> = minDepth(root.<span class="keyword">right</span>);</span><br><span class="line">        <span class="comment">//1.如果左孩子和右孩子有为空的情况，直接返回 left + right + 1</span></span><br><span class="line">        <span class="comment">//2.如果都不为空，返回较小深度+1</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">left</span> == <span class="number">0</span> || <span class="keyword">right</span> == <span class="number">0</span>) ? <span class="keyword">left</span> + <span class="keyword">right</span> + <span class="number">1</span>: <span class="type">Math</span>.<span class="built_in">min</span>(<span class="keyword">left</span>,<span class="keyword">right</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：我们访问每个节点一次，时间复杂度为 O(N) ，其中 N 是节点个数。</li>
<li>空间复杂度：最坏情况下，整棵树是非平衡的，例如每个节点都只有一个孩子，递归会调用 N （树的高度）次，因此栈的空间开销是 O(N) 。但在最好情况下，树是完全平衡的，高度只有 log(N)，因此在这种情况下空间复杂度只有 O(log(N)) 。</li>
</ul>
<h2 id="297-Serialize-and-deserialize-binary-tree-二叉树的序列化与反序列化-Hard"><a href="#297-Serialize-and-deserialize-binary-tree-二叉树的序列化与反序列化-Hard" class="headerlink" title="297. Serialize-and-deserialize-binary-tree(二叉树的序列化与反序列化)(Hard)"></a><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener">297. Serialize-and-deserialize-binary-tree(二叉树的序列化与反序列化)(Hard)</a></h2><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p>
<p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>
<p><strong>示例：</strong></p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">你可以将以下二叉树：</span><br><span class="line"></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">3</span></span><br><span class="line">     / \</span><br><span class="line">    <span class="number">4</span>   <span class="number">5</span></span><br><span class="line"></span><br><span class="line">序列化为 <span class="string">"[1,2,3,null,null,4,5]"</span></span><br></pre></td></tr></table></figure>
<p><strong>提示</strong>: 这与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p>
<p><strong>说明：</strong>不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。</p>
<hr>
<p>解：可以看出来，序列化和反序列化在实际中应用非常广泛也非常的重要。如果没有序列化，数据结构无法存储到文件和内存里面，通过网络的传输效率也会很低。</p>
<p>因为需要完成序列化和反序列化两个函数，所以需要两个思路：序列化的思想是利用dfs的先序遍历得到一个完整的序列，遇到了null直接存储null即可。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化的思想：利用dfs的preorder遍历得到一个完整的序列，遇到null的地方可以直接存储null，反序列化的时候可以根据标识操作</span></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serializeHelper(root, <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">String</span> <span class="title">serializeHelper</span><span class="params">(TreeNode root, <span class="keyword">String</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == null) &#123;</span><br><span class="line">            str += <span class="string">"null,"</span>;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// preorder add node</span></span><br><span class="line">        str += root.val + <span class="string">","</span>;</span><br><span class="line">        str = serializeHelper(root.left, str);</span><br><span class="line">        str = serializeHelper(root.right, str);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 反序列化的思想：利用list结构，每次返回list的首元素，作为上一个节点的左节点和右节点，然后依次删除掉list的首元素</span></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(<span class="keyword">String</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">String</span>[] data_ = data.split(<span class="string">","</span>);</span><br><span class="line">        List&lt;<span class="keyword">String</span>&gt; <span class="built_in">list</span> = <span class="keyword">new</span> LinkedList&lt;&gt;(Arrays.asList(data_));</span><br><span class="line">        <span class="keyword">return</span> desHelper(<span class="built_in">list</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">desHelper</span><span class="params">(List&lt;<span class="keyword">String</span>&gt; <span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">list</span>.<span class="built_in">get</span>(<span class="number">0</span>).equals(<span class="string">"null"</span>)) &#123;</span><br><span class="line">            <span class="built_in">list</span>.<span class="built_in">remove</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> null;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把String元素转换成int</span></span><br><span class="line">        <span class="keyword">int</span> val = Integer.valueOf(<span class="built_in">list</span>.<span class="built_in">get</span>(<span class="number">0</span>));</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        <span class="built_in">list</span>.<span class="built_in">remove</span>(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        root.left = desHelper(<span class="built_in">list</span>);</span><br><span class="line">        root.right = desHelper(<span class="built_in">list</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec = new Codec();</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：在序列化和反序列化函数中，我们只访问每个节点一次，因此时间复杂度为 O(n)，其中 n 是节点数，即树的大小。</li>
<li>空间复杂度：在序列化和反序列化函数中，我们将整棵树保留在开头或结尾，因此，空间复杂性为 O(n)。</li>
</ul>
<h2 id="236-Lowest-common-ancestor-of-a-binary-tree-二叉树的最近公共祖先-Mid"><a href="#236-Lowest-common-ancestor-of-a-binary-tree-二叉树的最近公共祖先-Mid" class="headerlink" title="236. Lowest-common-ancestor-of-a-binary-tree(二叉树的最近公共祖先)(Mid)"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">236. Lowest-common-ancestor-of-a-binary-tree(二叉树的最近公共祖先)(Mid)</a></h2><p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>
<p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”</p>
<p>Given the following binary tree:  root = [3,5,1,6,2,0,8,null,null,7,4]</p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt=""></p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: root = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">7</span>,<span class="number">4</span>], p = <span class="number">5</span>, q = <span class="number">1</span></span><br><span class="line">Output: <span class="number">3</span></span><br><span class="line">Explanation: The LCA of nodes <span class="number">5</span> <span class="keyword">and</span> <span class="number">1</span> <span class="keyword">is</span> <span class="number">3.</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: root = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">7</span>,<span class="number">4</span>], p = <span class="number">5</span>, q = <span class="number">4</span></span><br><span class="line">Output: <span class="number">5</span></span><br><span class="line">Explanation: The LCA of nodes <span class="number">5</span> <span class="keyword">and</span> <span class="number">4</span> <span class="keyword">is</span> <span class="number">5</span>, since a node can be a descendant of itself according to the LCA definition.</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ul>
<li>All of the nodes’ values will be unique.</li>
<li>p and q are different and both values will exist in the binary tree.</li>
</ul>
<hr>
<p>解：递归代码简单而且时间空间复杂度和迭代相同。</p>
<p>递归的base case:递归过程中如果root 是null,则返回null；如果递归到了子过程，比如(5, 5, 8)，则忽略其他内容返回传入的头结点(5)，同理如果到了(5, 8, 5)，同样忽略其他节点返回5。<br>这个逻辑可以用一行代码概括：</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span><span class="built_in">(root</span> == null ||<span class="built_in"> root</span> == p ||<span class="built_in"> root</span> == q) <span class="keyword">return</span><span class="built_in"> root</span>;</span><br></pre></td></tr></table></figure>
<p>之后进行递归调用，每次drill down 根节点的左孩子和右孩子。递归过程一般有四种：</p>
<ol>
<li>递归的时候总会传入整个结构的根节点。拿题目给的树为例，如果递归到了(2, 6, 0),即p和q都不为根节点的左子树和右子树节点，则返回null。(但是编写代码过程中貌似到不了这种情况，在递归过程中已经过滤掉了)。</li>
<li>传入的p和q中没有根节点右孩子节点，比如(3, 5, 4)，此时返回左子树靠上节点：5</li>
<li>传入的p和q中没有根节点左孩子节点，比如(3, 1, 0)， 此时返回右子树靠上节点：1</li>
<li>传入的p和q分别为根节点的左孩子节点和右孩子节点，比如(3, 6, 8)，返回根节点：3</li>
</ol>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Definition for </span>a<span class="markdown"> binary tree node.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>public class TreeNode &#123;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>int val;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>TreeNode left;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>TreeNode right;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>TreeNode(int x) &#123; val = x; &#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>&#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> */</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">        <span class="comment">// terminator</span></span><br><span class="line">        <span class="comment">// base cases</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || root == p || root == q)  <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">// 一路 drill down</span></span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="comment">// 第四种情况，左孩子和右孩子都有，则返回根节点</span></span><br><span class="line">        <span class="keyword">if</span>(left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>)   <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">// 概括第二和第三种情况</span></span><br><span class="line">        <span class="keyword">return</span> left != <span class="keyword">null</span> ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(N)，N 是二叉树中的节点数，最坏情况下，我们需要访问二叉树的所有节点。</li>
<li>空间复杂度：O(N)，这是因为递归堆栈使用的最大空间位 N,斜二叉树的高度可以是 N。</li>
</ul>
<h2 id="105-Construct-binary-tree-from-preorder-and-inorder-traversal-从前序与中序遍历序列构造二叉树-Mid"><a href="#105-Construct-binary-tree-from-preorder-and-inorder-traversal-从前序与中序遍历序列构造二叉树-Mid" class="headerlink" title="105. Construct-binary-tree-from-preorder-and-inorder-traversal(从前序与中序遍历序列构造二叉树)(Mid)"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal" target="_blank" rel="noopener">105. Construct-binary-tree-from-preorder-and-inorder-traversal(从前序与中序遍历序列构造二叉树)(Mid)</a></h2><p>Given preorder and inorder traversal of a tree, construct the binary tree.</p>
<p><strong>Note:</strong><br>You may assume that duplicates do not exist in the tree.</p>
<p>For example, given</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">preorder = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">inorder = [<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure>
<p>Return the following binary tree:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure>
<hr>
<p>解：这个题解过程在大学期间的数据结构课程应当有掌握。先序遍历的顺序总是根节点的顺序。我们可以根据先序遍历过程中遍历过的点逐渐判断哪些是根节点，然后中序遍历数组中在根节点左边的就是左子树，在右边的就是这个根节点的子树。</p>
<p>首先，preorder中的第一个元素一定是树的根，这个根又将inorder序列分成了左右两棵子树。现在我们只需要将先序遍历的数组中删除根元素，然后重复这个过程处理左右两棵子树。</p>
<p>解法一，直接使用上述原理，利用递归进行。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode buildTree(<span class="built_in">int</span>[] preorder, <span class="built_in">int</span>[] inorder) &#123;</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>, <span class="number">0</span>, inorder.length - <span class="number">1</span>, preorder, inorder);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 需要标记先序开始的地方和中序的序列.不需要preend是因为可以用preorder.length-1来标识</span></span><br><span class="line">    <span class="comment">// 每次递归的子问题需要用类似size的变量构造左子树和右子树</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode helper(<span class="built_in">int</span> preStart, <span class="built_in">int</span> inStart, <span class="built_in">int</span> inEnd, <span class="built_in">int</span>[] preorder, <span class="built_in">int</span>[] inorder) &#123;</span><br><span class="line">        <span class="comment">// 当前遍历的为null的条件</span></span><br><span class="line">        <span class="keyword">if</span> (preStart &gt; preorder.length - <span class="number">1</span> || inStart &gt; inEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// root 为当前遍历的根节点</span></span><br><span class="line">        TreeNode root = new TreeNode(preorder[preStart]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//知道了根节点之后可以推出左子树和右子树有哪些序列</span></span><br><span class="line">        <span class="comment">// 下面6行代码用于找到当前的根节点在中序遍历的什么位置</span></span><br><span class="line">        <span class="built_in">int</span> inIndex = <span class="number">0</span>; <span class="comment">// Index of current root in inorder</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = inStart; i &lt;= inEnd; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == root.val) &#123;</span><br><span class="line">                inIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归构造左子树。preStart+1是下一个左子树开始的节点。</span></span><br><span class="line">        <span class="comment">// 之前循环已经找到了当前root的位置并且用inIndex记录好了，所以左子树索引就是inIndex-1</span></span><br><span class="line">        root.left = helper(preStart + <span class="number">1</span>, inStart, inIndex - <span class="number">1</span>, preorder, inorder);</span><br><span class="line">        <span class="comment">// 递归构造右子树</span></span><br><span class="line">        root.right = helper(preStart + inIndex - inStart + <span class="number">1</span>, inIndex + <span class="number">1</span>, inEnd, preorder, inorder);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解法二，因为在递归过程中每次都要遍历中序遍历的数组去寻找，所以可以利用HashMap，把inorder[]，即中序遍历数组的每一个元素的值和下标存起来，这样可以直接用当前先序的值获取中序数组的下标位置了。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public TreeNode build<span class="constructor">Tree(<span class="params">int</span>[] <span class="params">preorder</span>, <span class="params">int</span>[] <span class="params">inorder</span>)</span> &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">        </span><br><span class="line">        for(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">            map.put(inorder<span class="literal">[<span class="identifier">i</span>]</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        TreeNode root = <span class="constructor">Helper(<span class="params">preorder</span>, 0, <span class="params">preorder</span>.<span class="params">length</span> - 1, <span class="params">inorder</span>, 0, <span class="params">inorder</span>.<span class="params">length</span> - 1, <span class="params">map</span>)</span>;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public TreeNode <span class="constructor">Helper(<span class="params">int</span>[] <span class="params">preorder</span>, <span class="params">int</span> <span class="params">preStart</span>, <span class="params">int</span> <span class="params">preEnd</span>, <span class="params">int</span>[] <span class="params">inorder</span>, <span class="params">int</span> <span class="params">inStart</span>, <span class="params">int</span> <span class="params">inEnd</span>, Map&lt;Integer, Integer&gt; <span class="params">map</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(preStart &gt; preEnd<span class="operator"> || </span>inStart &gt; inEnd) return null;</span><br><span class="line">        </span><br><span class="line">        TreeNode root = <span class="keyword">new</span> <span class="constructor">TreeNode(<span class="params">preorder</span>[<span class="params">preStart</span>])</span>;</span><br><span class="line">        <span class="built_in">int</span> inRoot = map.get(root.<span class="keyword">val</span>);</span><br><span class="line">        <span class="built_in">int</span> numsLeft = inRoot - inStart;</span><br><span class="line">        </span><br><span class="line">        root.left = <span class="constructor">Helper(<span class="params">preorder</span>, <span class="params">preStart</span> + 1, <span class="params">preStart</span> + <span class="params">numsLeft</span>, <span class="params">inorder</span>, <span class="params">inStart</span>, <span class="params">inRoot</span> - 1,<span class="params">map</span>)</span>;</span><br><span class="line">        root.right = <span class="constructor">Helper(<span class="params">preorder</span>, <span class="params">preStart</span> + <span class="params">numsLeft</span> + 1, <span class="params">preEnd</span>, <span class="params">inorder</span>, <span class="params">inRoot</span> + 1, <span class="params">inEnd</span>,<span class="params">map</span>)</span>;</span><br><span class="line">        </span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用HashMap可以大大提高效率，因为哈希表平均情况下查找效率为O(1)</p>
<ul>
<li>时间复杂度:O(n)，可用主定理计算得到</li>
<li>空间复杂度:O(n),存储整棵树的开销</li>
</ul>
<h2 id="50-Pow-x-n-Mid"><a href="#50-Pow-x-n-Mid" class="headerlink" title="50. Pow(x ,n)(Mid)"></a><a href="https://leetcode-cn.com/problems/powx-n/" target="_blank" rel="noopener">50. Pow(x ,n)(Mid)</a></h2><p>实现 <em>pow(x, n)</em> ，即计算 x 的 n 次幂函数。<br>Implement pow(x, n), which calculates x raised to the power n (x^n).</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="number">2.00000</span><span class="string">,</span> <span class="number">10</span></span><br><span class="line"><span class="attr">Output:</span> <span class="number">1024.00000</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="number">2.10000</span><span class="string">,</span> <span class="number">3</span></span><br><span class="line"><span class="attr">Output:</span> <span class="number">9.26100</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: <span class="number">2.00000</span>, <span class="number">-2</span></span><br><span class="line">Output: <span class="number">0.25000</span></span><br><span class="line">Explanation: <span class="number">2</span>^(<span class="number">-2</span>) = <span class="number">1</span>/(<span class="number">2</span>^<span class="number">2</span>) = <span class="number">1</span>/<span class="number">4</span> = <span class="number">0.25</span></span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ul>
<li>-100.0 &lt; x &lt; 100.0</li>
<li><em>n</em> is a 32 bit signed integer, within the range [−2^31, 2^(31 − 1)]</li>
</ul>
<hr>
<p>解：面试中碰到，首先需要和面试官确定一些事情(经常需要做的)：是否允许调用库函数？更重要的是，x和n的取值范围？x和n是否可以取0，正负值之类的。</p>
<p>其实我们在小学初中就学过某个数的几次方，就是把它乘几个自己，但是在高等数学中不是这么做的，在这里就进行一下计算。</p>
<p>方法一：暴力，求Pow就直接乘出来，时间复杂度为O(n)，提一嘴就行。</p>
<p>方法二，利用回溯和二分查找。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> myPow(<span class="built_in">double</span> x, <span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="comment">// 需要注意，如果输入的x大于1，同时n非常小，那么需要四舍五入输出0</span></span><br><span class="line">        <span class="comment">// 少了这一个判断，新增的一个用例无法通过：</span></span><br><span class="line">        <span class="comment">// 2.00000</span></span><br><span class="line">        <span class="comment">//-2147483648</span></span><br><span class="line">        <span class="keyword">if</span>(n == Integer.MIN_VALUE &amp;&amp; x &gt; <span class="number">1</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 递归出口</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 针对n为负数的处理</span></span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            n = -n;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (n % <span class="number">2</span> == <span class="number">0</span>) ? myPow(x * x, n / <span class="number">2</span>) : x * myPow(x * x, n / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<p><font color=#FF0000><strong>下面八道题为利用回溯解决的几个经典问题：求子集、排列问题、组合问题。此外还加上了分割回文串问题。虽然不是数字的list了，但是也是对List&lt;List<String>&gt;的操作以及回溯法的使用。</strong></font></p>
<p>参考LeetCode国际站回答： <a href="https://leetcode.com/problems/permutations/discuss/18239/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partioning)" target="_blank" rel="noopener">点击这里</a> 这些问题可以利用相同的一套解题模板，具体思路过程是：选择-&gt;拓展-&gt;剔除。</p>
<p>还有一点，这几道题最后返回的结果都是List&lt;List&lt;&gt;&gt;()类型的，即list里面装了list，如果不熟练，可能新手写起来都会存在困惑和错误。需要注意因为List不是基本数据类型，每次添加到result中时都需要new出来新的对象才可以，这也是对操作java中的list集合对象的熟练程度的考察。</p>
<p>此外，在过程中每次都是使用result.add(new ArrayList&lt;&gt;(curList))，是因为curList在回溯过程中每次都会被改变，我们需要记录当前curList的结果而不能让后面的curList的内容改变当前curList的结果。</p>
<h2 id="77-Combinations-组合-Mid"><a href="#77-Combinations-组合-Mid" class="headerlink" title="77. Combinations(组合)(Mid)"></a><a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/" target="_blank" rel="noopener">77. Combinations(组合)(Mid)</a></h2><p>Given two integers n and k, return all possible combinations of k numbers out of 1 … <em>n</em>.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: n = <span class="number">4</span>, k = <span class="number">2</span></span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">2</span>,<span class="number">4</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">4</span>],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>


<hr>
<p>解：这道题是很典型的用分治，回溯。这个题目递归最重要的两件事：递归终止条件和递归里面的for循环做的事情。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combine(<span class="built_in">int</span> n, <span class="built_in">int</span> k) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span><span class="operator"> || </span>k &lt;= <span class="number">0</span>) return results;</span><br><span class="line">        combine<span class="constructor">Helper(<span class="params">n</span>, <span class="params">k</span>, 1, <span class="params">results</span>, <span class="params">new</span> ArrayList&lt;Integer&gt;()</span>);</span><br><span class="line">        return results;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// st_num 为当前回合从哪个数开始取值。比如一开始从1到n所有的值都可以取</span></span><br><span class="line">    <span class="comment">// curSeq为当前List的状态</span></span><br><span class="line">    public void combine<span class="constructor">Helper(<span class="params">int</span> <span class="params">n</span>, <span class="params">int</span> <span class="params">k</span>, <span class="params">int</span> <span class="params">st_num</span>, List&lt;List&lt;Integer&gt;&gt; <span class="params">results</span>, List&lt;Integer&gt; <span class="params">curSeq</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// terminator ，k位都生成了,size满足条件之后把curSeq加入到results中</span></span><br><span class="line">        <span class="keyword">if</span>(k<span class="operator"> == </span><span class="number">0</span>) results.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt; (curSeq));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            for(<span class="built_in">int</span> i = st_num; i &lt;= n; i++) &#123;</span><br><span class="line">                curSeq.add(i);</span><br><span class="line">                <span class="comment">// 每次drill down循环次数为k-1</span></span><br><span class="line">                combine<span class="constructor">Helper(<span class="params">n</span>, <span class="params">k</span>-1, <span class="params">i</span> + 1, <span class="params">results</span>, <span class="params">curSeq</span>)</span>;</span><br><span class="line">                <span class="comment">// 和数组一样，list下标从0开始</span></span><br><span class="line">                curSeq.remove(curSeq.size<span class="literal">()</span>-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="39-Combination-Sum-组合总和-Mid"><a href="#39-Combination-Sum-组合总和-Mid" class="headerlink" title="39. Combination Sum(组合总和)(Mid)"></a><a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">39. Combination Sum(组合总和)(Mid)</a></h2><p>Given a <strong>set</strong> of candidate numbers (<code>candidates</code>) (<strong>without duplicates</strong>) and a target number (<code>target</code>), find all unique combinations in <code>candidates</code> where the candidate numbers sums to <code>target</code>.</p>
<p>The <strong>same</strong> repeated number may be chosen from <code>candidates</code> unlimited number of times.</p>
<p><strong>Note:</strong></p>
<ul>
<li>All numbers (including <code>target</code>) will be positive integers.</li>
<li>The solution set must not contain duplicate combinations.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: candidates = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>], target = <span class="number">7</span>,</span><br><span class="line">A solution <span class="keyword">set</span> <span class="keyword">is</span>:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">7</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: candidates = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>], target = <span class="number">8</span>,</span><br><span class="line">A solution <span class="keyword">set</span> <span class="keyword">is</span>:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<hr>
<p>解：需要注意的是只要和为target，candidates里面的元素每一个都可以被无限次选择。</p>
<p>看起来和上一道，77组合问题，有相似之处，但是解决起来复杂比较多，因为既需要考虑和是否为target，同时candidates里面的元素可以无限次数选择，加大了难度。</p>
<p>但是可以套用解决这几道回溯(写递归)问题的一系列问题的模板。</p>
<p>首先排序，用于剪枝。不排序也可以通过，但是先排序能够提升最后的空间和时间复杂度。</p>
<p>这样只要当前值比剩余的target大了，后面都是递增的，则可以break跳出了。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combination<span class="constructor">Sum(<span class="params">int</span>[] <span class="params">candidates</span>, <span class="params">int</span> <span class="params">target</span>)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">if</span>(target<span class="operator"> == </span><span class="number">0</span><span class="operator"> || </span>candidates<span class="operator"> == </span>null<span class="operator"> || </span>candidates.length<span class="operator"> == </span><span class="number">0</span>) return result;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span>sort(candidates);</span><br><span class="line">        <span class="constructor">Helper(<span class="params">result</span>, <span class="params">candidates</span>, <span class="params">target</span>, <span class="params">new</span> ArrayList&lt;&gt;()</span>, <span class="number">0</span>);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// start为当前使用的元素在candidates中的位置。因为可以重复使用，所以下一次传入的是i而不是i+1</span></span><br><span class="line">    public void <span class="constructor">Helper(List&lt;List&lt;Integer&gt;&gt; <span class="params">result</span>, <span class="params">int</span>[] <span class="params">candidates</span>, <span class="params">int</span> <span class="params">remain</span>, List&lt;Integer&gt; <span class="params">curList</span>, <span class="params">int</span> <span class="params">start</span>)</span> &#123;</span><br><span class="line">         <span class="keyword">if</span>(remain &lt; <span class="number">0</span>) return ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(remain<span class="operator"> == </span><span class="number">0</span>) result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(curList));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 从当前的 start 到数组的最后一个数来进行判断</span></span><br><span class="line">            for(<span class="built_in">int</span> i = start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">                curList.add(candidates<span class="literal">[<span class="identifier">i</span>]</span>);</span><br><span class="line">                <span class="constructor">Helper(<span class="params">result</span>, <span class="params">candidates</span>, <span class="params">remain</span> - <span class="params">candidates</span>[<span class="params">i</span>], <span class="params">curList</span>, <span class="params">i</span>)</span>; <span class="comment">// The start is not i+1 because we can reuse same element</span></span><br><span class="line">                curList.remove(curList.size<span class="literal">()</span> - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的for循环中的三行内容为回溯常用的写法，在curList中，先curList.add()加进去，再递归处理得到结果，再从curList中移除掉。</p>
<p>回溯的过程是怎样的呢？举个例子，如果candidates为<code>[1,2,3,4,5]</code>, target为7，一开始加入的结果是[1,2,3]，然后为[1,2,3,4]的时候，此时remain &lt; 0，所以return 回到curList为[1,2,3]的时候，此时需要执行curList.remove(curList.size() - 1)，即curList又变成[1,2]，然后再放入4, curList变成[1,2,4]，再往后执行，以此类推。</p>
<p>时间复杂度：组合问题，指数级的，O(2^n)。因为最终是从所有candidates的组合中选择出符合要求的，所有的情况是2^n的，所以整体时间复杂度就是O(2^n)。</p>
<h2 id="40-Combination-Sum-II-组合总和-II-Mid"><a href="#40-Combination-Sum-II-组合总和-II-Mid" class="headerlink" title="40. Combination Sum II (组合总和 II)(Mid)"></a><a href="https://leetcode-cn.com/problems/combination-sum-ii/" target="_blank" rel="noopener">40. Combination Sum II (组合总和 II)(Mid)</a></h2><p>Given a collection of candidate numbers (<code>candidates</code>) and a target number (<code>target</code>), find all unique combinations in <code>candidates</code> where the candidate numbers sums to <code>target</code>.</p>
<p>Each number in <code>candidates</code> may only be used <strong>once</strong> in the combination.</p>
<p><strong>Note:</strong></p>
<ul>
<li>All numbers (including <code>target</code>) will be positive integers.</li>
<li>The solution set must not contain duplicate combinations.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: candidates = [<span class="number">10</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">5</span>], target = <span class="number">8</span>,</span><br><span class="line">A solution <span class="keyword">set</span> <span class="keyword">is</span>:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>, <span class="number">7</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="number">6</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">1</span>, <span class="number">6</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: candidates = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>], target = <span class="number">5</span>,</span><br><span class="line">A solution <span class="keyword">set</span> <span class="keyword">is</span>:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">5</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<hr>
<p>解：39题的变题。和39相比的区别是，给的candidates数组可能包含重复元素、结果的list中不能有重复元素。</p>
<p>在去重思路上有一点变化。首先结果中不能重复使用candidates中的元素，所以在递归中start元素要变成i+1。此外，因为candidates中可以有重复元素，所以也要避免重复使用相同元素，在for循环中加一个判断。其他相同。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combination<span class="constructor">Sum2(<span class="params">int</span>[] <span class="params">candidates</span>, <span class="params">int</span> <span class="params">target</span>)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">if</span>(target<span class="operator"> == </span><span class="number">0</span><span class="operator"> || </span>candidates<span class="operator"> == </span>null<span class="operator"> || </span>candidates.length<span class="operator"> == </span><span class="number">0</span>) return result;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span>sort(candidates);</span><br><span class="line">        <span class="constructor">Helper(<span class="params">result</span>, <span class="params">candidates</span>, <span class="params">target</span>, <span class="params">new</span> ArrayList&lt;&gt;()</span>, <span class="number">0</span>);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void <span class="constructor">Helper(List&lt;List&lt;Integer&gt;&gt; <span class="params">result</span>, <span class="params">int</span>[] <span class="params">candidates</span>, <span class="params">int</span> <span class="params">remain</span>, List&lt;Integer&gt; <span class="params">curList</span>, <span class="params">int</span> <span class="params">start</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(remain &lt; <span class="number">0</span>) return ;</span><br><span class="line">        <span class="keyword">if</span>(remain<span class="operator"> == </span><span class="number">0</span>) result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(curList));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            for(<span class="built_in">int</span> i = start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">                <span class="comment">// 很重要的去掉重复解的步骤，这一行代码就可以实现</span></span><br><span class="line">                <span class="comment">// 逻辑写成i != start也可以</span></span><br><span class="line">                <span class="keyword">if</span>(i &gt; start<span class="operator"> &amp;&amp; </span>candidates<span class="literal">[<span class="identifier">i</span>]</span><span class="operator"> == </span>candidates<span class="literal">[<span class="identifier">i</span>-<span class="number">1</span>]</span>) continue; <span class="comment">// skip duplicates</span></span><br><span class="line">                curList.add(candidates<span class="literal">[<span class="identifier">i</span>]</span>);</span><br><span class="line">                <span class="constructor">Helper(<span class="params">result</span>, <span class="params">candidates</span>, <span class="params">remain</span> - <span class="params">candidates</span>[<span class="params">i</span>], <span class="params">curList</span>, <span class="params">i</span>+1)</span>;</span><br><span class="line">                curList.remove(curList.size<span class="literal">()</span> - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：指数级的，O(2^n)，推理方法和39题相同。</p>
<h2 id="46-Permutations-全排列-Mid"><a href="#46-Permutations-全排列-Mid" class="headerlink" title="46. Permutations(全排列)(Mid)"></a><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">46. Permutations(全排列)(Mid)</a></h2><p>Given a collection of distinct integers, return all possible permutations.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<hr>
<p>解：这是一个典型的用递归解决的问题</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="built_in">public</span> List&lt;List&lt;<span class="type">Integer</span>&gt;&gt; permute(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;<span class="type">Integer</span>&gt;&gt; result = <span class="built_in">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        permuteHelper(result, <span class="built_in">new</span> ArrayList&lt;<span class="type">Integer</span>&gt;(),  nums);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> permuteHelper(List&lt;List&lt;<span class="type">Integer</span>&gt;&gt; result, List&lt;<span class="type">Integer</span>&gt; curList, <span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(curList.size() == nums.length) &#123;</span><br><span class="line">            result.<span class="keyword">add</span>(<span class="built_in">new</span> ArrayList&lt;&gt;(curList));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(curList.contains(nums[i])) <span class="keyword">continue</span>; // element already <span class="keyword">exists</span>, skip</span><br><span class="line">                curList.<span class="keyword">add</span>(nums[i]);</span><br><span class="line">                permuteHelper(result,curList,nums);</span><br><span class="line">                curList.remove(curList.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以想象，每一位都是从nums[0]开始，递归完(nums[0],nums[1],nums[2])之后，从list中remove掉nums[2]，发现会掉入if(curList.contains(nums[i]))的条件，所以会紧接着remove掉nums[1]。再之后会尝试往curList中加入nums[2],因为此时nums[0]和nums[2]都已经在list中有了，所以会在continue之后加入nums[1]，再continue一次，然后以nums[0]作为第一个元素的list的答案就结束了，后面第一个元素变成nums[1]，再进行递归。</p>
<p>之前有一个不清楚的困扰，就是为什么result.add(curList)会返回空的list，必须result.add(new ArrayList&lt;&gt;(curList))才可以返回有值的结果。后来发现应该是单纯的add能加入的只能是基本数据类型，而要加入的curList是引用类型，需要new 以curList为内容的list才能加入。也可以理解为，在递归过程中curList总会变化，所以每次新加的是为了记录当前curList的内容的值，需要new才可以。</p>
<p>这道题是非常经典的一道题，这种递归的写法对于初学者可能会比较难思考的，建议多重复几遍，参考我上面这两段文字，更利于理解。</p>
<h2 id="47-Permutations-ii-全排列-II-Mid"><a href="#47-Permutations-ii-全排列-II-Mid" class="headerlink" title="47. Permutations-ii(全排列 II)(Mid)"></a><a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">47. Permutations-ii(全排列 II)(Mid)</a></h2><p>Given a collection of numbers that might contain duplicates, return all possible unique permutations.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<hr>
<p>解：47是46的变题。输入的nums可能存在重复的元素，实际上，重复的元素也是最重要的考量因素。</p>
<p>有了重复元素之后，整个逻辑和46就已经完全不同了。如果仍然使用46的contains去在循环过程中剔除掉，那么根本凑不足排列的元素数量。所以在往curList里面添加元素的过程中的逻辑需要改变。</p>
<p>在遍历每个元素的过程中，我们也要考虑去重，同一个元素不能被多次使用。而对于这道题，相等的元素也不能被多次使用。</p>
<p>具体到实现上，因为nums[]没说排好序了，所以为了方便根据前后元素进行判重，所以相比46题需要先排序。此外，因为nums[]中存在重复元素，需要判断当前元素是否使用的情况，所以要定义一个boolean数组:used。</p>
<p><font color=#FF0000><strong>为什么用一个boolean数组可以对去重复情况有效？</strong></font>因为经过推演可以发现这样一个规律：每次重复的结果出现的情况都是：<strong>重复的元素中，前面的不取，后面的取</strong>。其他情况比如前面和后面都取、前面取后面不取、前面后面都不取，这些都不会是重复的情况。读者可以自行举例推演验证。</p>
<p>为了方便记忆，实际上，used数组成为了循环内部判断的条件，不再需要使用curList.contains()方法。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; permute<span class="constructor">Unique(<span class="params">int</span>[] <span class="params">nums</span>)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length<span class="operator"> == </span><span class="number">0</span><span class="operator"> || </span>nums<span class="operator"> == </span>null) return result;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span>sort(nums);</span><br><span class="line">        permute<span class="constructor">UniqueHelper(<span class="params">result</span>, <span class="params">nums</span>, <span class="params">new</span> ArrayList&lt;&gt;()</span>, <span class="keyword">new</span> boolean<span class="literal">[<span class="identifier">nums</span>.<span class="identifier">length</span>]</span>);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// used 每一位都记录nums的某一个数字是否用过了   </span></span><br><span class="line">    public void permute<span class="constructor">UniqueHelper(List&lt;List&lt;Integer&gt;&gt; <span class="params">result</span>, <span class="params">int</span>[] <span class="params">nums</span>, List&lt;Integer&gt; <span class="params">curList</span>, <span class="params">boolean</span>[] <span class="params">used</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(curList.size<span class="literal">()</span><span class="operator"> == </span>nums.length) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(curList));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            for(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">                <span class="comment">// 相比46题，continue的条件有点复杂</span></span><br><span class="line">                <span class="comment">// 如果第i个已经被用过了，即used[i]为true，则直接跳过本轮</span></span><br><span class="line">                <span class="comment">// 如果当前第i个没有用过，那么同时满足三个条件，本轮也跳过。分别是：</span></span><br><span class="line">                <span class="comment">// 不是第一轮了，即i &gt; 0; nums[]中当前元素为重复; 当前元素的前一个元素目前没有被用，即</span></span><br><span class="line">                <span class="comment">// 正要把第i个之前有重复的元素推到最前面的时候</span></span><br><span class="line">                <span class="keyword">if</span>(used<span class="literal">[<span class="identifier">i</span>]</span><span class="operator"> || </span>i &gt; <span class="number">0</span><span class="operator"> &amp;&amp; </span>nums<span class="literal">[<span class="identifier">i</span>]</span><span class="operator"> == </span>nums<span class="literal">[<span class="identifier">i</span>-<span class="number">1</span>]</span><span class="operator"> &amp;&amp; </span>!used<span class="literal">[<span class="identifier">i</span>-<span class="number">1</span>]</span>) continue;</span><br><span class="line">                used<span class="literal">[<span class="identifier">i</span>]</span> = <span class="literal">true</span>;</span><br><span class="line">                curList.add(nums<span class="literal">[<span class="identifier">i</span>]</span>);</span><br><span class="line">                permute<span class="constructor">UniqueHelper(<span class="params">result</span>, <span class="params">nums</span>, <span class="params">curList</span>, <span class="params">used</span>)</span>;</span><br><span class="line">                used<span class="literal">[<span class="identifier">i</span>]</span> = <span class="literal">false</span>;</span><br><span class="line">                curList.remove(curList.size<span class="literal">()</span> - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="78-Subsets-子集-Mid"><a href="#78-Subsets-子集-Mid" class="headerlink" title="78. Subsets(子集)(Mid)"></a><a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">78. Subsets(子集)(Mid)</a></h2><p>Given a set of <strong>distinct</strong> integers, <em>nums</em>, return all possible subsets (the power set).</p>
<p><strong>Note</strong>: The solution set must not contain duplicate subsets.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>],</span><br><span class="line">  [<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<hr>
<p>解：方法一：给的nums都是不同的元素，都没有排序过，返回的list总会包含[]，这几点需要注意。</p>
<p>这也是非常典型的用回溯完成的题目。和之前几个需要考虑和为target的或者每个集合里面必须有所有数字的排列来说，其实终止条件比较简单。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; subsets(<span class="built_in">int</span><span class="literal">[]</span> nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length<span class="operator"> == </span><span class="number">0</span><span class="operator"> || </span>nums<span class="operator"> == </span>null) return result;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span>sort(nums);</span><br><span class="line">        <span class="constructor">Helper(<span class="params">result</span>, <span class="params">nums</span>, <span class="params">new</span> ArrayList&lt;&gt;()</span>, <span class="number">0</span>);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void <span class="constructor">Helper(List&lt;List&lt;Integer&gt;&gt; <span class="params">result</span>, <span class="params">int</span>[] <span class="params">nums</span>, List&lt;Integer&gt; <span class="params">curList</span>, <span class="params">int</span> <span class="params">start</span>)</span> &#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(curList));</span><br><span class="line">        for(<span class="built_in">int</span> i = start; i &lt; nums.length; i++) &#123;</span><br><span class="line">            curList.add(nums<span class="literal">[<span class="identifier">i</span>]</span>);</span><br><span class="line">            <span class="constructor">Helper(<span class="params">result</span>, <span class="params">nums</span>, <span class="params">curList</span>, <span class="params">i</span> + 1)</span>;</span><br><span class="line">            curList.remove(curList.size<span class="literal">()</span> - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：考虑每一位可以选某个元素或者不选，相当于填空。</p>
<h2 id="90-Subsets-II-子集II-Mid"><a href="#90-Subsets-II-子集II-Mid" class="headerlink" title="90. Subsets II(子集II)(Mid)"></a><a href="https://leetcode.com/problems/subsets-ii/" target="_blank" rel="noopener">90. Subsets II(子集II)(Mid)</a></h2><p>Given a collection of integers that might contain duplicates, <strong>nums</strong>, return all possible subsets (the power set).</p>
<p><strong>Note</strong>: The solution set must not contain duplicate subsets.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<hr>
<p>解：与78题相比，Input可以有重复元素。具体写法上主要是for里面需要增加循环终止的条件，因为相同的元素只能使用一次，再次使用产生的结果会是重复的。具体做法也和之前一样，排好序之后，当前循环变量(i)不为start之后(条件为i &gt; start或者i!=start都可以)，只要 <code>nums[i] == nums[i-1]</code>，就continue。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; subsets<span class="constructor">WithDup(<span class="params">int</span>[] <span class="params">nums</span>)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums<span class="operator"> == </span>null<span class="operator"> || </span>nums.length<span class="operator"> == </span><span class="number">0</span>) return result;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span>sort(nums);</span><br><span class="line">        <span class="constructor">Helper(<span class="params">result</span>, <span class="params">nums</span>, <span class="params">new</span> ArrayList&lt;&gt;()</span>, <span class="number">0</span>);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void <span class="constructor">Helper(List&lt;List&lt;Integer&gt;&gt; <span class="params">result</span>, <span class="params">int</span>[] <span class="params">nums</span>, List&lt;Integer&gt; <span class="params">curList</span>, <span class="params">int</span> <span class="params">start</span>)</span> &#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(curList));</span><br><span class="line">        for(<span class="built_in">int</span> i = start; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; start<span class="operator"> &amp;&amp; </span>nums<span class="literal">[<span class="identifier">i</span>]</span><span class="operator"> == </span>nums<span class="literal">[<span class="identifier">i</span>-<span class="number">1</span>]</span>) continue;</span><br><span class="line">            curList.add(nums<span class="literal">[<span class="identifier">i</span>]</span>);</span><br><span class="line">            <span class="constructor">Helper(<span class="params">result</span>, <span class="params">nums</span>, <span class="params">curList</span>, <span class="params">i</span> + 1)</span>;</span><br><span class="line">            curList.remove(curList.size<span class="literal">()</span> - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="131-Palindrome-Partitioning-分割回文串-Mid"><a href="#131-Palindrome-Partitioning-分割回文串-Mid" class="headerlink" title="131. Palindrome Partitioning(分割回文串)(Mid)"></a><a href="https://leetcode-cn.com/problems/palindrome-partitioning/" target="_blank" rel="noopener">131. Palindrome Partitioning(分割回文串)(Mid)</a></h2><p>Given a string s, partition s such that every substring of the partition is a palindrome.</p>
<p>Return all possible palindrome partitioning of s.</p>
<p><strong>Example:</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Input</span>: <span class="string">"aab"</span></span><br><span class="line"><span class="symbol">Output</span>:</span><br><span class="line">[</span><br><span class="line">  [<span class="string">"aa"</span>,<span class="string">"b"</span>],</span><br><span class="line">  [<span class="string">"a"</span>,<span class="string">"a"</span>,<span class="string">"b"</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<hr>
<p>解：判断是否为回文串的部分可以单独定义成一个函数。一头一尾两个指针扫描，必须相等才能是回文串。利用自增自减简化写法。只有符合要求才放入curList</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;<span class="keyword">String</span>&gt;&gt; partition(<span class="keyword">String</span> s) &#123;</span><br><span class="line">        List&lt;List&lt;<span class="keyword">String</span>&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        backtrack(result, <span class="keyword">new</span> ArrayList&lt;&gt;(), s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;<span class="keyword">String</span>&gt;&gt; result, List&lt;<span class="keyword">String</span>&gt; curList, <span class="keyword">String</span> s, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == s.length())</span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(curList));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; s.length(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(isPalindrome(s, start, i)) &#123;</span><br><span class="line">                    curList.add(s.substring(start, i+<span class="number">1</span>));</span><br><span class="line">                    backtrack(result, curList, s, i+<span class="number">1</span>);</span><br><span class="line">                    curList.<span class="built_in">remove</span>(curList.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">String</span> s, <span class="keyword">int</span> <span class="built_in">begin</span>, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">begin</span> &lt; <span class="built_in">end</span>)</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(<span class="built_in">begin</span>++) != s.charAt(<span class="built_in">end</span>--)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithms Note</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Practice by Categories Hash Table</title>
    <url>/2020/01/13/LeetCode-Practice-by-Categories-Hash-Table/</url>
    <content><![CDATA[<blockquote>
<p>合理安排时间，等于节约时间。——培根</p>
</blockquote>
<p>LeetCode哈希表、相关题目，其解决思路和具体代码。以及有关java语言哈希表的解析。</p>
<a id="more"></a>

<h2 id="242-Valid-Anagram-有效的字母异位词-Easy"><a href="#242-Valid-Anagram-有效的字母异位词-Easy" class="headerlink" title="242. Valid Anagram(有效的字母异位词)(Easy)"></a><a href="https://leetcode-cn.com/problems/valid-anagram/" target="_blank" rel="noopener">242. Valid Anagram(有效的字母异位词)(Easy)</a></h2><p>Given two strings s and t , write a function to determine if t is an anagram of s.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">Input:</span> s = <span class="string">"anagram"</span>, t = <span class="string">"nagaram"</span></span><br><span class="line"><span class="string">Output:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">Input:</span> s = <span class="string">"rat"</span>, t = <span class="string">"car"</span></span><br><span class="line"><span class="string">Output:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong><br>You may assume the string contains only lowercase alphabets.</p>
<p><strong>Follow up:</strong><br>What if the inputs contain unicode characters? How would you adapt your solution to such case?</p>
<hr>
<p>解：这道题可以直接把传入的两个字符串转换成字符数组，按照字典序排序后比较是否相等。这种方法不需要用到哈希表，但是类库自带的快排整体速度不如哈希表(这道题实际上使用到哈希表的思想，我们自己定义一个哈希映射)的查询速度快。</p>
<p>方法一：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public boolean is<span class="constructor">Anagram(String <span class="params">s</span>, String <span class="params">t</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length<span class="literal">()</span> != t.length<span class="literal">()</span>) return <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">char</span><span class="literal">[]</span> s1 = s.<span class="keyword">to</span><span class="constructor">CharArray()</span>;</span><br><span class="line">        <span class="built_in">char</span><span class="literal">[]</span> t1 = t.<span class="keyword">to</span><span class="constructor">CharArray()</span>;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span>sort(s1);</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span>sort(t1);</span><br><span class="line">        return <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span>equals(s1,t1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：使用哈希映射思想，定义一个我们自己的哈希表，遍历s和t，每次把s中遍历到的字母的ASICC码计算并且加起来，再减去t中对应的值。遍历一遍下来，如果有一个字母的对应的出现次数不为0，则整个传入数据不为字母异位词。此方法中new了一个大小为26的数组，其中每一个元素代表一个字母的出现次数，所以最后只要有一个不为0，输入就不为字母异位词。</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isAnagram(String s, String t) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() != t.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] <span class="keyword">count</span> = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">char</span>[] s1 = s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] t1 = t.toCharArray();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s1.length; i++) &#123;</span><br><span class="line">            <span class="keyword">count</span>[s1[i] - <span class="string">'a'</span>]++;</span><br><span class="line">            <span class="keyword">count</span>[t1[i] - <span class="string">'a'</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">count</span>[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>，如果不先将s和t 进行toCharArray转换，而直接用charAt()判断位置然后进行哈希映射，整体执行效率会很慢。上面的用时可以击败90%以上，但是下面这段代码一般只能击败60%，试验了多次。</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isAnagram(String s, String t) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() != t.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] <span class="keyword">count</span> = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s.length() ;i++) &#123;</span><br><span class="line">            <span class="keyword">count</span>[s.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">            <span class="keyword">count</span>[t.charAt(i) - <span class="string">'a'</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> counter : <span class="keyword">count</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(counter != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="49-Group-Anagram-字母异位词分组-Mid"><a href="#49-Group-Anagram-字母异位词分组-Mid" class="headerlink" title="49. Group Anagram(字母异位词分组)(Mid)"></a><a href="https://leetcode-cn.com/problems/group-anagrams/" target="_blank" rel="noopener">49. Group Anagram(字母异位词分组)(Mid)</a></h2><p>Given an array of strings, group anagrams together.</p>
<p><strong>Example:</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Input</span>: [<span class="string">"eat"</span>, <span class="string">"tea"</span>, <span class="string">"tan"</span>, <span class="string">"ate"</span>, <span class="string">"nat"</span>, <span class="string">"bat"</span>],</span><br><span class="line"><span class="symbol">Output</span>:</span><br><span class="line">[</span><br><span class="line">  [<span class="string">"ate"</span>,<span class="string">"eat"</span>,<span class="string">"tea"</span>],</span><br><span class="line">  [<span class="string">"nat"</span>,<span class="string">"tan"</span>],</span><br><span class="line">  [<span class="string">"bat"</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ul>
<li>All inputs will be in lowercase.</li>
<li>The order of your output does not matter.</li>
</ul>
<hr>
<p>解：使用排序解决判断是否为异位词的部分。</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;<span class="keyword">String</span>&gt;&gt; groupAnagrams(<span class="keyword">String</span>[] strs) &#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.length == <span class="number">0</span> || strs == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;List&lt;<span class="keyword">String</span>&gt;&gt;();</span><br><span class="line">        Map&lt;<span class="keyword">String</span>, List&lt;<span class="keyword">String</span>&gt;&gt; <span class="built_in">map</span> = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">String</span> s : strs) &#123;</span><br><span class="line">            <span class="built_in">char</span>[] ca = s.toCharArray();</span><br><span class="line">            Arrays.<span class="built_in">sort</span>(ca);</span><br><span class="line">            <span class="keyword">String</span> keyStr = <span class="keyword">String</span>.valueOf(ca);</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">map</span>.containsKey(keyStr)) <span class="built_in">map</span>.put(keyStr, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            <span class="built_in">map</span>.<span class="built_in">get</span>(keyStr).<span class="built_in">add</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;List&lt;<span class="keyword">String</span>&gt;&gt; (<span class="built_in">map</span>.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="1-Two-Sum-两数之和-Easy"><a href="#1-Two-Sum-两数之和-Easy" class="headerlink" title="1. Two Sum(两数之和)(Easy)"></a><a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">1. Two Sum(两数之和)(Easy)</a></h2><p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have <strong><em>exactly</em></strong> one solution, and you may not use the same element twice.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Given nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span>,</span><br><span class="line"></span><br><span class="line">Because nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span>,</span><br><span class="line"><span class="keyword">return</span> [<span class="number">0</span>, <span class="number">1</span>].</span><br></pre></td></tr></table></figure>

<hr>
<p>解：保持数组中的每个元素与其索引相互对应的最好方式是什么？当然是基于数组的哈希表。利用哈希表先把内容存储起来，这样一来查找的过程只需要O(1)了。</p>
<p>这个map中，key是nums元素的值，value是该元素的下标。因为要找到a+b = target,所以 a = target - b，所以查找 target-a 在不在数组里面即可。</p>
<p>注意</p>
<ol>
<li>这里是把元素当做key，该元素的位置当做value。</li>
<li>虽然看起来 <code>map.put(nums[i], i)</code> 这句放在循环体里的前面和后面都可以，但是其实是不能放在前面的，否则如果某个元素的值是target的二分之一，先把它添加进map之后再比较，会直接比较到它自己。换句话说，必须先比较，再put进map。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                result[<span class="number">0</span>] = i;</span><br><span class="line">                result[<span class="number">1</span>] = map.get(target - nums[i]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 注意这里put不能放在判断前面，必须先比较再放入。否则如果某个元素是target的一半，先添加再比较的话，会比较到它自己。</span></span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithms Note</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Practice by Categories(Stack, Queue)</title>
    <url>/2020/01/08/LeetCode-Practice-by-Categories-Stack-Queue/</url>
    <content><![CDATA[<blockquote>
<p>衡量一个人真正的品德，是看他在知道没有人看见的时候做些什么 —— 孟德斯鸠</p>
</blockquote>
<p>分析讨论栈、队列、优先队列、双端队列以及相关LeetCode题目。</p>
<a id="more"></a>

<p><font color=#FF0000>java中，队列Queue是一种特殊的线性表，实例化的时候用链表(new LinkedList&lt;&gt;())、栈Stack有单独的类，实例化的时候使用Stack(new Stack&lt;&gt;())。 队列因为用LinkedList实现,一般操作size()方法。而栈可以使用empty()或者isEmpty()判空(empty()和isEmpty()没有本质区别，一般可以通用)</p>
<p>事实上，普通的栈和队列在工作中基本不会使用，而用得比较多的是双端队列。比如本文中曾经在239题中使用了java库中的双端队列，并用Array实现：<code>Deque&lt;Integer&gt; dq = new ArrayDeque&lt;&gt;();</code><br></font> </p>
<h2 id="20-Valid-Parentheses-有效的括号-Easy"><a href="#20-Valid-Parentheses-有效的括号-Easy" class="headerlink" title="20.Valid Parentheses(有效的括号)(Easy)"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">20.Valid Parentheses(有效的括号)(Easy)</a></h2><p>Given a string containing just the characters <code>&#39;(&#39;, &#39;)&#39;, &#39;{&#39;, &#39;}&#39;, &#39;[&#39;</code> and<code>&#39;]&#39;</code>, determine if the input string is valid.</p>
<p>An input string is valid if:</p>
<ol>
<li>Open brackets must be closed by the same type of brackets.</li>
<li>Open brackets must be closed in the correct order.</li>
</ol>
<p>Note that an empty string is also considered valid.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">Input:</span> <span class="string">"()"</span></span><br><span class="line"><span class="string">Output:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">Input:</span> <span class="string">"()[]&#123;&#125;"</span></span><br><span class="line"><span class="string">Output:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">Input:</span> <span class="string">"(]"</span></span><br><span class="line"><span class="string">Output:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">Input:</span> <span class="string">"([)]"</span></span><br><span class="line"><span class="string">Output:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 5:</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">Input:</span> <span class="string">"&#123;[]&#125;"</span></span><br><span class="line"><span class="string">Output:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>


<hr>
<p>解：想要符合闭合的括号的标准，用一个栈保存和左括号对应的右括号。每次碰到左括号就入栈对应的右括号，碰到右括号就判断是否和当前栈顶元素相同。</p>
<p>注意有两个判空，一个是碰到右括号，如果此时栈为空，那么不能pop()(会报错)，如果此时栈为空则不为有效括号。另一个情况是所有括号都遍历完了，此时如果栈不为空，则不是有效括号。所以在遍历完s之后需要返回stack.isEmpty()。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">String</span> s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; <span class="built_in">stack</span> = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'('</span>) &#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(<span class="string">')'</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'['</span>) &#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(<span class="string">']'</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'&#123;'</span>) &#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(<span class="string">'&#125;'</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">stack</span>.isEmpty() || <span class="built_in">stack</span>.pop() != c) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="155-Min-Stack-最小栈-Easy"><a href="#155-Min-Stack-最小栈-Easy" class="headerlink" title="155.Min Stack(最小栈)(Easy)"></a><a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">155.Min Stack(最小栈)(Easy)</a></h2><p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p>
<ul>
<li>push(x) – Push element x onto stack.</li>
<li>pop() – Removes the element on top of the stack.</li>
<li>top() – Get the top element.</li>
<li>getMin() – Retrieve the minimum element in the stack.</li>
</ul>
<p><strong>Example:</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">MinStack minStack = new MinStack()<span class="comment">;</span></span><br><span class="line">minStack.push(-<span class="number">2</span>)<span class="comment">;</span></span><br><span class="line">minStack.push(<span class="number">0</span>)<span class="comment">;</span></span><br><span class="line">minStack.push(-<span class="number">3</span>)<span class="comment">;</span></span><br><span class="line">minStack.getMin()<span class="comment">;   --&gt; Returns -3.</span></span><br><span class="line">minStack.pop()<span class="comment">;</span></span><br><span class="line">minStack.top()<span class="comment">;      --&gt; Returns 0.</span></span><br><span class="line">minStack.getMin()<span class="comment">;   --&gt; Returns -2.</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：java语言本身已经定义好了一种传统作用的Stack，这道题有什么意义呢？事实上这道题就是要实现一个可以获得最小元素的栈。</p>
<p>换个角度看，要能够在常数时间内检索到最小元素的栈，是不是有点像优先队列？——其实不一样，它还是一个先入后出的栈。它只是能让你在常规时间中探索到最小元素，而不是取的时候每次都取最小元素。它的api本身和栈一模一样，只是多了一个功能，能够探测到最小元素。</p>
<p>给出两种方法，分别用两个栈和一个栈实现。</p>
<p>解法一：用两个栈实现，一个数据栈，一个辅助栈。这种写法注意了健壮性，考虑了栈为空的情况。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据栈和辅助栈同步,后面每个操作两个栈都进行相同操作</span></span><br><span class="line">    Stack&lt;Integer&gt; data;</span><br><span class="line">    Stack&lt;Integer&gt; helper;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化两个栈</span></span><br><span class="line">        data = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        helper = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        data.push(x);</span><br><span class="line">        <span class="keyword">if</span>(helper.isEmpty() || helper.<span class="built_in">peek</span>() &gt;= x) &#123;</span><br><span class="line">            helper.push(x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            helper.push(helper.<span class="built_in">peek</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!data.isEmpty()) &#123;</span><br><span class="line">            data.pop();</span><br><span class="line">            helper.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!data.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> data.<span class="built_in">peek</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"栈中元素为空，此操作非法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!helper.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> helper.<span class="built_in">peek</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"栈中元素为空，此操作非法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>解法二：用一个栈解决。解法一开辟了一个helper栈去保存最小值，实际上我们可以用一个变量,min,去保存这个最小值。<br>这里有两个问题：</p>
<ol>
<li>min保存了当前的最小值，如果min更新了，那么如何保存之前的最小值呢？——把之前的min在新元素之前入栈，也就是说来了新的更小的元素，旧的最小的元素需要再次入栈以求保存。</li>
<li>如果当前出栈的是最小值，我们在出栈当前元素之余，还需要再出栈一次，并且把这一次出栈的值赋给min。因为最小的元素入栈前会把之前最小的元素入栈，所以这样做就把旧的最小元素保存下来了。</li>
</ol>
<p>详细题解：<a href="https://leetcode-cn.com/problems/min-stack/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-38/" target="_blank" rel="noopener">点击这里</a></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">min</span> = Integer.MAX_VALUE;</span><br><span class="line">    Stack&lt;Integer&gt; <span class="built_in">stack</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span> = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// only push the old minimum value when the current</span></span><br><span class="line">        <span class="comment">// minimum value changes after pushing the new value x</span></span><br><span class="line">        <span class="keyword">if</span>(x &lt;= <span class="built_in">min</span>) &#123;</span><br><span class="line">            <span class="built_in">stack</span>.push(<span class="built_in">min</span>);</span><br><span class="line">            <span class="built_in">min</span> = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">stack</span>.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// if pop operation could result in the changing of the current minimum value,</span></span><br><span class="line">        <span class="comment">// pop twice and change the current minimum value to the last minimum value</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">stack</span>.pop() == <span class="built_in">min</span>) <span class="built_in">min</span> = <span class="built_in">stack</span>.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>.<span class="built_in">peek</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="641-Design-Circular-Deque-设计循环双端队列-Mid"><a href="#641-Design-Circular-Deque-设计循环双端队列-Mid" class="headerlink" title="641.Design Circular Deque(设计循环双端队列)(Mid)"></a><a href="https://leetcode-cn.com/problems/design-circular-deque/" target="_blank" rel="noopener">641.Design Circular Deque(设计循环双端队列)(Mid)</a></h2><p>Design your implementation of the circular double-ended queue (deque).</p>
<p>Your implementation should support following operations:</p>
<ul>
<li><code>MyCircularDeque(k)</code>: Constructor, set the size of the deque to be k.</li>
<li><code>insertFront()</code>: Adds an item at the front of Deque. Return true if the operation is successful.</li>
<li><code>insertLast()</code>: Adds an item at the rear of Deque. Return true if the operation is successful.</li>
<li><code>deleteFront()</code>: Deletes an item from the front of Deque. Return true if the operation is successful.</li>
<li><code>deleteLast()</code>: Deletes an item from the rear of Deque. Return true if the operation is successful.</li>
<li><code>getFront()</code>: Gets the front item from the Deque. If the deque is empty, return -1.</li>
<li><code>getRear()</code>: Gets the last item from Deque. If the deque is empty, return -1.</li>
<li><code>isEmpty()</code>: Checks whether Deque is empty or not. </li>
<li><code>isFull()</code>: Checks whether Deque is full or not.</li>
</ul>
<p><strong>Example:</strong></p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">MyCircularDeque circularDeque = new MycircularDeque(<span class="number">3</span>); <span class="regexp">//</span> set the size to be <span class="number">3</span></span><br><span class="line">circularDeque.insertLast(<span class="number">1</span>);			<span class="regexp">//</span> <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">circularDeque.insertLast(<span class="number">2</span>);			<span class="regexp">//</span> <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">circularDeque.insertFront(<span class="number">3</span>);			<span class="regexp">//</span> <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">circularDeque.insertFront(<span class="number">4</span>);			<span class="regexp">//</span> <span class="keyword">return</span> <span class="keyword">false</span>, the queue is full</span><br><span class="line">circularDeque.getRear();  			<span class="regexp">//</span> <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">circularDeque.isFull();				<span class="regexp">//</span> <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">circularDeque.deleteLast();			<span class="regexp">//</span> <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">circularDeque.insertFront(<span class="number">4</span>);			<span class="regexp">//</span> <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">circularDeque.getFront();			<span class="regexp">//</span> <span class="keyword">return</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ul>
<li>All values will be in the range of [0, 1000].</li>
<li>The number of operations will be in the range of [1, 1000].</li>
<li>Please do not use the built-in Deque library.</li>
</ul>
<hr>
<p>解：使用链表完成这个API的设计。</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> MyCircularDeque &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> DoubleListNode &#123;</span><br><span class="line">        DoubleListNode pre;</span><br><span class="line">        DoubleListNode <span class="keyword">next</span>;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">public</span> DoubleListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">size</span>;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    DoubleListNode head;</span><br><span class="line">    DoubleListNode tail;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Initialize your data structure here. Set the size of the deque to be k. */</span></span><br><span class="line">    <span class="keyword">public</span> MyCircularDeque(<span class="keyword">int</span> k) &#123;</span><br><span class="line">        head = <span class="keyword">new</span> DoubleListNode(-<span class="number">1</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> DoubleListNode(-<span class="number">1</span>);</span><br><span class="line">        head.pre = tail;</span><br><span class="line">        tail.<span class="keyword">next</span> = head;</span><br><span class="line">        <span class="keyword">this</span>.k = k;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">size</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Adds an item at the front of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> insertFront(<span class="keyword">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">size</span> == k) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        DoubleListNode node = <span class="keyword">new</span> DoubleListNode(value);</span><br><span class="line">        node.<span class="keyword">next</span> = head;</span><br><span class="line">        node.pre = head.pre;</span><br><span class="line">        head.pre.<span class="keyword">next</span> = node;</span><br><span class="line">        head.pre = node;</span><br><span class="line">        <span class="keyword">size</span>++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Adds an item at the rear of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> insertLast(<span class="keyword">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">size</span> == k) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        DoubleListNode node = <span class="keyword">new</span> DoubleListNode(value);</span><br><span class="line">        node.<span class="keyword">next</span> = tail.<span class="keyword">next</span>;</span><br><span class="line">        tail.<span class="keyword">next</span>.pre = node;</span><br><span class="line">        tail.<span class="keyword">next</span> = node;</span><br><span class="line">        node.pre = tail;</span><br><span class="line">        <span class="keyword">size</span>++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Deletes an item from the front of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> deleteFront() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">size</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        head.pre.pre.<span class="keyword">next</span> = head;</span><br><span class="line">        head.pre = head.pre.pre;</span><br><span class="line">        <span class="keyword">size</span>--;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Deletes an item from the rear of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> deleteLast() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">size</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        tail.<span class="keyword">next</span>.<span class="keyword">next</span>.pre = tail;</span><br><span class="line">        tail.<span class="keyword">next</span> = tail.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">        <span class="keyword">size</span>--;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front item from the deque. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> getFront() &#123;</span><br><span class="line">        <span class="keyword">return</span> head.pre.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the last item from the deque. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> getRear() &#123;</span><br><span class="line">        <span class="keyword">return</span> tail.<span class="keyword">next</span>.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Checks whether the circular deque is empty or not. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">size</span> == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Checks whether the circular deque is full or not. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isFull() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">size</span> == k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyCircularDeque object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyCircularDeque obj = new MyCircularDeque(k);</span></span><br><span class="line"><span class="comment"> * boolean param_1 = obj.insertFront(value);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.insertLast(value);</span></span><br><span class="line"><span class="comment"> * boolean param_3 = obj.deleteFront();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.deleteLast();</span></span><br><span class="line"><span class="comment"> * int param_5 = obj.getFront();</span></span><br><span class="line"><span class="comment"> * int param_6 = obj.getRear();</span></span><br><span class="line"><span class="comment"> * boolean param_7 = obj.isEmpty();</span></span><br><span class="line"><span class="comment"> * boolean param_8 = obj.isFull();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="225-Implement-Stack-using-Queues-用队列实现栈-Easy"><a href="#225-Implement-Stack-using-Queues-用队列实现栈-Easy" class="headerlink" title="225.Implement Stack using Queues(用队列实现栈)(Easy)"></a><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/" target="_blank" rel="noopener">225.Implement Stack using Queues(用队列实现栈)(Easy)</a></h2><p>Implement the following operations of a stack using queues.</p>
<ul>
<li>push(x) – Push element x onto stack.</li>
<li>pop() – Removes the element on top of the stack.</li>
<li>top() – Get the top element.</li>
<li>empty() – Return whether the stack is empty.</li>
</ul>
<p><strong>Example:</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MyStack <span class="built_in">stack</span> = <span class="keyword">new</span> MyStack();</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>.push(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">stack</span>.push(<span class="number">2</span>);  </span><br><span class="line"><span class="built_in">stack</span>.top();   <span class="comment">// returns 2</span></span><br><span class="line"><span class="built_in">stack</span>.pop();   <span class="comment">// returns 2</span></span><br><span class="line"><span class="built_in">stack</span>.empty(); <span class="comment">// returns false</span></span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ul>
<li>You must use only standard operations of a queue – which means only <code>push to back, peek/pop from front, size</code>, and <code>is empty</code> operations are valid.</li>
<li>Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.</li>
<li>You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).</li>
</ul>
<hr>
<p>解：想要用队列实现栈，常规想法可以使用两个队列，在每次出栈操作的时候，把元素临时保存到第二个队列中，在第一个队列还剩一个元素的时候把这个元素取出，从而实现类似栈的”后入先出”操作。</p>
<p>但是存在空间复杂度更优的方法，就是使用一个队列。具体操作方法是，每次入队都把整个队列循环弹出和新增元素，使得新添加的元素总在队列的前面，由此一来这个队列实际操作与栈无异。**关键步骤就是在于入队列时候的操作：<code>queue.add(queue.remove())</code>(remove()在队列为空的时候会抛出NoSuchElementException异常，poll()会返回null，其他没有区别)</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    Queue&lt;Integer&gt; <span class="built_in">queue</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="built_in">queue</span> = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>.add(x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">queue</span>.<span class="built_in">size</span>()<span class="number">-1</span>; i++)</span><br><span class="line">            <span class="built_in">queue</span>.add(<span class="built_in">queue</span>.<span class="built_in">remove</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">queue</span>.<span class="built_in">remove</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">queue</span>.<span class="built_in">peek</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">queue</span>.<span class="built_in">size</span>() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>


<h2 id="232-Implement-Queue-using-Stacks-用栈实现队列-Easy"><a href="#232-Implement-Queue-using-Stacks-用栈实现队列-Easy" class="headerlink" title="232.Implement Queue using Stacks(用栈实现队列)(Easy)"></a><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/" target="_blank" rel="noopener">232.Implement Queue using Stacks(用栈实现队列)(Easy)</a></h2><p>Implement the following operations of a queue using stacks.</p>
<ul>
<li>push(x) – Push element x to the back of queue.</li>
<li>pop() – Removes the element from in front of queue.</li>
<li>peek() – Get the front element.</li>
<li>empty() – Return whether the queue is empty.</li>
</ul>
<p><strong>Example:</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">MyQueue <span class="built_in">queue</span> = <span class="keyword">new</span> MyQueue();</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>.push(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">queue</span>.push(<span class="number">2</span>);  </span><br><span class="line"><span class="built_in">queue</span>.<span class="built_in">peek</span>();  <span class="comment">// returns 1</span></span><br><span class="line"><span class="built_in">queue</span>.pop();   <span class="comment">// returns 1</span></span><br><span class="line"><span class="built_in">queue</span>.empty(); <span class="comment">// returns false</span></span><br></pre></td></tr></table></figure>
<p><strong>Notes:</strong></p>
<ul>
<li>You must use only standard operations of a stack – which means only <code>push to top, peek/pop from top, size, and is empty</code> operations are valid.</li>
<li>Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.</li>
<li>You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).</li>
</ul>
<hr>
<p>解：和之前用队列实现栈类似，可以用两个栈实现一个队列。但是由于栈只有一个出入口，所以不能用一个栈实现队列(队列中出队再入队可以实现倒置，栈不行).</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要两个栈才能实现队列</span></span><br><span class="line">    Stack&lt;Integer&gt; input;</span><br><span class="line">    Stack&lt;Integer&gt; output;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        input = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        output = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        input.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">peek</span>();</span><br><span class="line">        <span class="keyword">return</span> output.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(output.empty())</span><br><span class="line">            <span class="keyword">while</span>( !input.empty() )</span><br><span class="line">                output.push(input.pop());</span><br><span class="line">        <span class="keyword">return</span> output.<span class="built_in">peek</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input.empty() &amp;&amp; output.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.peek();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>


<h2 id="239-Sliding-Window-Maximum-滑动窗口最大值-Hard"><a href="#239-Sliding-Window-Maximum-滑动窗口最大值-Hard" class="headerlink" title="239.Sliding Window Maximum(滑动窗口最大值)(Hard)"></a><a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">239.Sliding Window Maximum(滑动窗口最大值)(Hard)</a></h2><p>Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: nums = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">-1</span>,<span class="number">-3</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>], <span class="keyword">and</span> k = <span class="number">3</span></span><br><span class="line">Output: [<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>] </span><br><span class="line">Explanation: </span><br><span class="line"></span><br><span class="line">Window position                Max</span><br><span class="line">---------------               -----</span><br><span class="line">[<span class="number">1</span>  <span class="number">3</span>  <span class="number">-1</span>] <span class="number">-3</span>  <span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">3</span></span><br><span class="line"> <span class="number">1</span> [<span class="number">3</span>  <span class="number">-1</span>  <span class="number">-3</span>] <span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">3</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span> [<span class="number">-1</span>  <span class="number">-3</span>  <span class="number">5</span>] <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">5</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  <span class="number">-1</span> [<span class="number">-3</span>  <span class="number">5</span>  <span class="number">3</span>] <span class="number">6</span>  <span class="number">7</span>       <span class="number">5</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  <span class="number">-1</span>  <span class="number">-3</span> [<span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>] <span class="number">7</span>       <span class="number">6</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  <span class="number">-1</span>  <span class="number">-3</span>  <span class="number">5</span> [<span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>]      <span class="number">7</span></span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong><br>You may assume k is always valid, 1 ≤ k ≤ input array’s size for non-empty array.</p>
<p><strong>Follow up:</strong><br>Could you solve it in linear time?</p>
<hr>
<p>解：<strong>所有滑动窗口的题目，想到用队列解决。</strong></p>
<p>方法一：暴力求解。枚举窗口的起点位置，因为窗口长度是k,所以枚举起点是0，终点是 length-1 。写一个二重循环，最后时间复杂度是O(n*k)。</p>
<p>方法二：这里用到单调队列(实际就是所谓的双端队列)，可以达到线性的时间复杂度。</p>
<p><font color=#FF0000>双端队列可以操作队列里面的头元素和尾元素，一些API见下图：</font><br><img src="https://s2.ax1x.com/2020/01/11/lIIZSs.png" alt="JDK8 Deque API"></p>
<p>我们通过双端队列维护的一个”单调队列”，从左到右为递减。所以每次对比元素都是peekLast()，弹出元素也是pollLast()</p>
<p>我们用双向队列可以在O(N)时间内解决这题。当我们遇到新的数时，将新的数和双向队列的末尾比较，如果末尾比新数小，则把末尾扔掉，直到该队列的末尾比新数大或者队列为空的时候才住手。这样，我们可以保证队列里的元素是从头到尾降序的，由于队列里只有窗口内的数，所以他们其实就是窗口内第一大，第二大，第三大…的数。保持队列里只有窗口内数的方法和上个解法一样，也是每来一个新的把窗口最左边的扔掉，然后把新的加进去。然而由于我们在加新数的时候，已经把很多没用的数给扔了，这样队列头部的数并不一定是窗口最左边的数。这里的技巧是，我们队列中存的是那个数在原数组中的下标，这样我们既可以直到这个数的值，也可以知道该数是不是窗口最左边的数。这里为什么时间复杂度是O(N)呢？因为每个数只可能被操作最多两次，一次是加入队列的时候，一次是因为有别的更大数在后面，所以被扔掉，或者因为出了窗口而被扔掉。(引用<a href="https://segmentfault.com/a/1190000003903509" target="_blank" rel="noopener">这篇文章</a>)</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>[] maxSlidingWindow(<span class="built_in">int</span>[] nums, <span class="built_in">int</span> k) &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(nums.length == <span class="number">0</span> || k &lt;= <span class="number">0</span>) <span class="keyword">return</span> nums;</span><br><span class="line">		<span class="built_in">int</span> len = nums.length;</span><br><span class="line">		<span class="comment">// 可以自己举个例子，推得这个result大小应该为len-k+1</span></span><br><span class="line">		<span class="built_in">int</span>[] result = new <span class="built_in">int</span>[len - k + <span class="number">1</span>];</span><br><span class="line">		<span class="comment">// store index</span></span><br><span class="line">		<span class="comment">// 注意，dq用于保存数组下标</span></span><br><span class="line">		Deque&lt;Integer&gt; dq = new ArrayDeque&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">			<span class="comment">//这里不需要循环，用一个判断就可 </span></span><br><span class="line">			<span class="comment">//因为我们最多只能在一轮中弹出一个超出范围的元素。（一轮我们只接受一个元素，所以我们最多弹出一个元素）。</span></span><br><span class="line">			<span class="comment">// dq 用于保存数组下标，这也是一个技巧</span></span><br><span class="line">			<span class="keyword">if</span>( !dq.isEmpty() &amp;&amp; dq.peekFirst() == i-k) &#123;</span><br><span class="line">				<span class="comment">// 双端队列中 poll() 相当于 pollFirst(),皮一下</span></span><br><span class="line">				dq.poll();</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 新加入的元素必须比前面的小，否则前面比它小的元素都要出队</span></span><br><span class="line">			<span class="keyword">while</span>(!dq.isEmpty() &amp;&amp; nums[i] &gt;= nums[dq.peekLast()]) &#123;</span><br><span class="line">				dq.pollLast();</span><br><span class="line">			&#125;</span><br><span class="line">			dq.offer(i);</span><br><span class="line">			<span class="comment">// dq是有序的，队列头总是最大的元素，只要下标在范围内，直接peek()即可</span></span><br><span class="line">			<span class="keyword">if</span>(i-k+<span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">				result[i-k+<span class="number">1</span>] = nums[dq.peek()];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<h2 id="84-Largest-Rectangle-in-Histogram-柱状图中最大的矩形-Hard"><a href="#84-Largest-Rectangle-in-Histogram-柱状图中最大的矩形-Hard" class="headerlink" title="84.Largest Rectangle in Histogram(柱状图中最大的矩形)(Hard)"></a><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">84.Largest Rectangle in Histogram(柱状图中最大的矩形)(Hard)</a></h2><h2 id="42-Trapping-Rain-Water-接雨水-Hard"><a href="#42-Trapping-Rain-Water-接雨水-Hard" class="headerlink" title="42.Trapping Rain Water(接雨水)(Hard)"></a><a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">42.Trapping Rain Water(接雨水)(Hard)</a></h2>]]></content>
      <categories>
        <category>Algorithms Note</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Practice by Categories(Array,LinkedList,SkipList)</title>
    <url>/2019/12/28/LeetCode-Practice-by-Categories/</url>
    <content><![CDATA[<blockquote>
<p>天才是长期劳动的结果。 —— 牛顿</p>
</blockquote>
<p>包含大量LeetCode链表、数组相关题目及其解决思路和具体代码。</p>
<a id="more"></a>

<p>点击题目链接为中国站题目，页面附上英文题目。</p>
<p><font color=#FF0000><strong>我总觉得，高超精简的算法，其精彩程度不输好的影视剧！</strong></font></p>
<h1 id="数组、链表、跳表"><a href="#数组、链表、跳表" class="headerlink" title="数组、链表、跳表"></a>数组、链表、跳表</h1><h2 id="283-Move-zeros-移动零-Easy"><a href="#283-Move-zeros-移动零-Easy" class="headerlink" title="283.Move zeros(移动零)(Easy)"></a><a href="https://leetcode-cn.com/problems/move-zeroes/?utm_source=LCUS&utm_medium=ip_redirect_q_uns&utm_campaign=transfer2china" target="_blank" rel="noopener">283.Move zeros(移动零)(Easy)</a></h2><p>Given an array <code>nums</code> , write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.</p>
<p><strong>Examples:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">12</span>]</span><br><span class="line">Output: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ol>
<li>You must do this in-place without making a copy of the array.</li>
<li>Minimize the total number of operations.</li>
</ol>
<hr>
<p>解：这道题可以使用双指针思想很简洁代码解决。用i作为指针，只要之前元素不为0，就把它移动到j的位置上去，把i位置的元素赋值为0. 但是需要注意corner case, 如果传入的数据全都是非0，那么i和j始终相等，不能给任何元素赋值为0.</p>
<p>需要注意指针j什么时候递增，<strong>只要i指的位置不为零，j就要往后移动</strong>，j用来记录从左到右，下一个非0元素的位置.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                nums[j] = nums[i];</span><br><span class="line">                <span class="keyword">if</span>(i != j) &#123;</span><br><span class="line">                    nums[i] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)，一重循环</p>
<p>空间复杂度：O(1)，按照题目要求，不能使用额外数组空间</p>
<h2 id="11-Container-With-Most-Water-盛水最多的容器-Mid"><a href="#11-Container-With-Most-Water-盛水最多的容器-Mid" class="headerlink" title="11.Container With Most Water(盛水最多的容器)(Mid)"></a><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">11.Container With Most Water(盛水最多的容器)(Mid)</a></h2><p>Given n non-negative integers <em>a1, a2, …, an</em> , where each represents a point at coordinate <em>(i, ai)</em>. <em>n</em> vertical lines are drawn such that the two endpoints of line <em>i</em> is at <em>(i, ai)</em> and <em>(i, 0)</em>. Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>
<p><strong>Note</strong>: You may not slant the container and n is at least 2.</p>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg" alt=""></p>
<p>The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.</p>
<p><strong>Example</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">7</span>]</span><br><span class="line">Output: <span class="number">49</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：<strong>方法一</strong>，枚举。记录左边bar x, 右边 bar y，遍历每一个x和y的组合，计算(x-y)*height_diff，但是时间复杂度太高了，O(n^2)，显然不是最优解法。</p>
<p>但是这里可以回顾一下遍历数组的固定写法，形成机械记忆，一定要熟悉。</p>
<p>正常遍历一维数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.length; i++) &#123;</span><br></pre></td></tr></table></figure>

<p>遍历二维数组，实现 i 和 j 两个下标对数组的遍历，而且 i 和 j 不会重复</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; height.length; j++) &#123;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一段二维数组的遍历应当形成肌肉式记忆。 整个遍历过程中，j 总是比 i 大，最后j到了最后一个元素，i还在前面。当然，这种暴力的方式很慢，开销很大。</p>
<p><strong>方法二</strong>，从左边和右边开始往中间收敛（或者理解是左右往中间夹逼）。<strong>因为肯定是外面的棒子组成的面积更大。如果内部的棒子高度也不如外面，那么组成的面积肯定比外面小</strong>，这里可以看做是一个tricky的点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//循环初始条件巧妙，很简洁</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = height.length-<span class="number">1</span>; i &lt; j;) &#123;</span><br><span class="line">            <span class="comment">// 这句话真的很巧妙，也侧面利用了类似i++和++i的语法内容，把下标的挪动放在了比较选择更低的那一端，会更舒服</span></span><br><span class="line">            <span class="keyword">int</span> minHeight = (height[i] &lt; height[j]) ? height[i++] : height[j--];</span><br><span class="line">            <span class="comment">//这里加一是一因为经过上面选择最小内容之后的操作，两个点之间的宽度减小了1，这里加回来</span></span><br><span class="line">            <span class="keyword">int</span> area = (j-i+<span class="number">1</span>) * minHeight;</span><br><span class="line">            max = Math.max(area,max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>i 和 j 是左下标和右下标，哪个棒子更矮，就挪动哪个。</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<h2 id="1-Two-Sum-两数之和-Easy"><a href="#1-Two-Sum-两数之和-Easy" class="headerlink" title="1. Two Sum(两数之和)(Easy)"></a><a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">1. Two Sum(两数之和)(Easy)</a></h2><p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have <strong><em>exactly</em></strong> one solution, and you may not use the same element twice.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Given nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span>,</span><br><span class="line"></span><br><span class="line">Because nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span>,</span><br><span class="line"><span class="keyword">return</span> [<span class="number">0</span>, <span class="number">1</span>].</span><br></pre></td></tr></table></figure>

<hr>
<p>解：<font color=#FF0000>这里给出两个解法，第一个无脑双指针遍历，第二个基于哈希表，是正解。</font></p>
<p><strong>方法一</strong>，两重循环，枚举下标，如果下标对应的内容相加可以达成target，那么完成。但是这种方法时间复杂度较大，O(n^2)</p>
<p>直接可以利用之前讲过的双指针遍历的方法。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>[] twoSum(<span class="built_in">int</span>[] nums, <span class="built_in">int</span> target) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span>[] result = new <span class="built_in">int</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.length<span class="number">-1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = i+<span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    result[<span class="number">0</span>] = i;</span><br><span class="line">                    result[<span class="number">1</span>] = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码可以通过，但是性能怎么样？——某次LeetCode的统计结果是，击败8%用户。<font color=#FF0000>所以如果你面试只想到了这个方法，刷刷写完了，没后续了，还很得意，那对不起，你的面试肯定过不了。除非其他候选者连这个方法都没想到。</font></p>
<p><strong>方法二</strong>,保持数组中的每个元素与其索引相互对应的最好方式是什么？当然是基于数组的哈希表。利用哈希表先把内容存储起来，这样一来查找的过程只需要O(1)了。</p>
<p>这个map中，key是nums元素的值，value是该元素的下标。因为要找到a+b = target,所以 a = target - b，所以查找 target-a 在不在数组里面即可。</p>
<p>注意</p>
<ol>
<li>这里是把元素当做key，该元素的位置当做value。</li>
<li>虽然看起来 <code>map.put(nums[i], i)</code> 这句放在循环体里的前面和后面都可以，但是其实是不能放在前面的，否则如果某个元素的值是target的二分之一，先把它添加进map之后再比较，会直接比较到它自己。换句话说，必须先比较，再put进map。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                result[<span class="number">0</span>] = i;</span><br><span class="line">                result[<span class="number">1</span>] = map.get(target - nums[i]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 注意这里put不能放在判断前面，必须先比较再放入。否则如果某个元素是target的一半，先添加再比较的话，会比较到它自己。</span></span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="15-3Sum-三数之和-Mid"><a href="#15-3Sum-三数之和-Mid" class="headerlink" title="15. 3Sum(三数之和)(Mid)"></a><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">15. 3Sum(三数之和)(Mid)</a></h2><p>Given an array <code>nums</code> of <em>n</em> integers, are there elements <em>a, b, c</em> in <code>nums</code> such that <em>a + b + c</em> = 0? Find all unique triplets in the array which gives the sum of zero.</p>
<p><strong>Note:</strong><br>The solution set must not contain duplicate triplets.(答案不能包含重复三元组)</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Given <span class="built_in">array</span> nums = [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-4</span>],</span><br><span class="line"></span><br><span class="line">A solution <span class="keyword">set</span> <span class="keyword">is</span>:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">2</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<hr>
<p>解：这道三数之和其实是第一题两数之和的升级版本。</p>
<p>方法一：暴力求解，和第一题非常相似，但是时间复杂度为O(n^3)，非常高。</p>
<p>方法二，用类似第一题的哈希表，时间复杂度可以降到O(n^2)</p>
<p>方法三，用左右下标夹逼的方法。其实很难直接想到，比较tricky。</p>
<p>方法三的解法详解：<a href="https://leetcode-cn.com/problems/3sum/solution/hua-jie-suan-fa-15-san-shu-zhi-he-by-guanpengchn/" target="_blank" rel="noopener">点击这里</a></p>
<p>需要注意题目输入的nums中可能有重复的元素；最后返回的答案不能有重复的三元组。</p>
<p>步骤：</p>
<ol>
<li>排序（排好序之后非常利于判重）</li>
<li>循环，因为有3个指针，循环length-2即可</li>
<li>设置判断条件，初始化指针位置</li>
<li>遍历找符合条件的3个数，一路上都要注意判重</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);<span class="comment">// 默认有小到大排序，先排序</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">		<span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="comment">// 有三个指针，循环 nums.length-2 次就够了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len-<span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> || (i &gt; <span class="number">0</span> &amp;&amp; nums[i] != nums[i-<span class="number">1</span>])) &#123; <span class="comment">//第二个条件是去重</span></span><br><span class="line">                <span class="keyword">int</span> lo = i+<span class="number">1</span>, hi = len-<span class="number">1</span>, sum = <span class="number">0</span>-nums[i];</span><br><span class="line">                <span class="keyword">while</span>(lo &lt; hi) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[lo] + nums[hi] == sum) &#123;</span><br><span class="line">                        <span class="comment">// asList是Arrays的工具类，能把数组转化成List，但是注意只能转换包装类，不能转换基本数据类型</span></span><br><span class="line">                    <span class="comment">// 此外asList不支持add和remove方法。</span></span><br><span class="line">                    <span class="comment">// 把所有数组里的内容丢到asList的参数里面来直接把几个数变成list，看得出技巧熟练</span></span><br><span class="line">                        res.add(Arrays.asList(nums[i], nums[lo],nums[hi]));</span><br><span class="line">                        <span class="keyword">while</span>(lo &lt; hi &amp;&amp; nums[lo] == nums[lo+<span class="number">1</span>]) lo++;</span><br><span class="line">                        <span class="keyword">while</span>(lo &lt; hi &amp;&amp; nums[hi] == nums[hi-<span class="number">1</span>]) hi--;</span><br><span class="line">                        lo++;hi--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[lo] + nums[hi] &lt; sum) lo++; <span class="comment">// lo++ 把和变大</span></span><br><span class="line">                    <span class="keyword">else</span> hi--; <span class="comment">// hi-- 把和变小</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="206-Reverse-LinkedList-反转链表-Easy"><a href="#206-Reverse-LinkedList-反转链表-Easy" class="headerlink" title="206. Reverse LinkedList(反转链表)(Easy)"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">206. Reverse LinkedList(反转链表)(Easy)</a></h2><p>Reverse a singly linked list.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL</span><br><span class="line">Output: <span class="number">5</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br></pre></td></tr></table></figure>

<p><strong>Follow up:</strong></p>
<p>A linked list can be reversed either iteratively or recursively. Could you implement both?</p>
<hr>
<p>解：就按照题目，给出迭代(iteratively)和递归(recursively)两种方法的解法。</p>
<p><strong>方法一：迭代</strong></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode reverseList(ListNode head) &#123;</span><br><span class="line">        ListNode <span class="keyword">new</span><span class="type">Header</span> = <span class="literal">null</span>;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="literal">null</span>) &#123;</span><br><span class="line">            ListNode nextTemp = curr.next;</span><br><span class="line">            curr.next = <span class="keyword">new</span><span class="type">Header</span>;</span><br><span class="line">            <span class="keyword">new</span><span class="type">Header</span> = curr;</span><br><span class="line">            curr = nextTemp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span><span class="type">Header</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：递归</strong></p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode <span class="keyword">next</span>;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode reverseList(ListNode<span class="built_in"> head</span>) &#123;</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">if</span><span class="built_in">(head</span> == null ||<span class="built_in"> head</span>.<span class="keyword">next</span> == null) <span class="keyword">return</span><span class="built_in"> head</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode newHeader = reverseList<span class="built_in">(head</span>.<span class="keyword">next</span>);</span><br><span class="line">       <span class="built_in"> head</span>.<span class="keyword">next</span>.<span class="keyword">next</span> =<span class="built_in"> head</span>;</span><br><span class="line">       <span class="built_in"> head</span>.<span class="keyword">next</span> = null;</span><br><span class="line">        <span class="keyword">return</span> newHeader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对递归方法值得注意的是，因为newHeader没有被动过，所以在一开始递归结束的时候，就返回的是反转之后的链表的新的head，也就是这个newHeader，所以最后的结果就是每一层的递归返回的都是一开始递归返回的newHeader，问题就迎刃而解了。</p>
<h2 id="92-Reverse-LinkedList-II-反转链表II-Mid"><a href="#92-Reverse-LinkedList-II-反转链表II-Mid" class="headerlink" title="92. Reverse LinkedList II(反转链表II)(Mid)"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">92. Reverse LinkedList II(反转链表II)(Mid)</a></h2><p>Reverse a linked list from position <em>m</em> to <em>n</em>. Do it in one-pass.</p>
<p>Note: 1 ≤ <em>m ≤ n</em> ≤ length of list.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL, m = <span class="number">2</span>, n = <span class="number">4</span></span><br><span class="line">Output: <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span>-&gt;NULL</span><br></pre></td></tr></table></figure>

<hr>
<p>解：和数组不同，这里的反转下标从1开始。需要初始化一个dummy节点代表0号节点，然后开始遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create a dummy node to mark the head of this list</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>); </span><br><span class="line">        dummy.next = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// make a pointer pre as a marker for the node before reversing</span></span><br><span class="line">        ListNode pre = dummy; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m-<span class="number">1</span>; i++) pre = pre.next;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// a pointer to the beginning of a sub-list that will be reversed</span></span><br><span class="line">        ListNode start = pre.next; </span><br><span class="line">        <span class="comment">// a pointer to a node that will be reversed</span></span><br><span class="line">        ListNode then = start.next; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1 - 2 -3 - 4 - 5 ; m=2; n =4 ---&gt; pre = 1, start = 2, then = 3</span></span><br><span class="line">    <span class="comment">// dummy-&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n-m; i++) &#123;</span><br><span class="line">        start.next = then.next;</span><br><span class="line">        then.next = pre.next;</span><br><span class="line">        pre.next = then;</span><br><span class="line">        then = start.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// first reversing : dummy-&gt;1 - 3 - 2 - 4 - 5; pre = 1, start = 2, then = 4</span></span><br><span class="line">    <span class="comment">// second reversing: dummy-&gt;1 - 4 - 3 - 2 - 5; pre = 1, start = 2, then = 5 (finish)</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="141-Linked-List-Cycle-环形链表-Easy"><a href="#141-Linked-List-Cycle-环形链表-Easy" class="headerlink" title="141. Linked List Cycle(环形链表)(Easy)"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">141. Linked List Cycle(环形链表)(Easy)</a></h2><p>Given a linked list, determine if it has a cycle in it.</p>
<p>To represent a cycle in the given linked list, we use an integer <code>pos</code> which represents the position (0-indexed) in the linked list where tail connects to. If <code>pos</code> is <code>-1</code>, then there is no cycle in the linked list.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: head = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">-4</span>], pos = <span class="number">1</span></span><br><span class="line">Output: <span class="literal">true</span></span><br><span class="line">Explanation: There <span class="keyword">is</span> a cycle <span class="keyword">in</span> the linked list, </span><br><span class="line">where tail connects to the second node.</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt=""></p>
<p><strong>Example 2:</strong></p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">Input:<span class="built_in"> head</span> = [<span class="number">1</span>,<span class="number">2</span>], pos = <span class="number">0</span></span><br><span class="line">Output:<span class="built_in"> true</span></span><br><span class="line">Explanation: There <span class="literal">is</span> a cycle <span class="keyword">in</span> the linked list, <span class="keyword">where</span><span class="built_in"> tail</span> connects <span class="keyword">to</span> the first <span class="type">node</span>.</span><br></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" alt=""></p>
<p><strong>Example 3:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="string">head</span> <span class="string">=</span> <span class="string">[1],</span> <span class="string">pos</span> <span class="string">=</span> <span class="number">-1</span></span><br><span class="line"><span class="attr">Output:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">Explanation:</span> <span class="string">There</span> <span class="string">is</span> <span class="literal">no</span> <span class="string">cycle</span> <span class="string">in</span> <span class="string">the</span> <span class="string">linked</span> <span class="string">list.</span></span><br></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png" alt=""></p>
<p><strong>Follow up:</strong></p>
<p>Can you solve it using O(1) (i.e. constant) memory?</p>
<hr>
<p>解：题目中虽然说会用pos明显标出成环的链表情况，而且貌似人用眼睛可以非常直接地发现，pos只要不是-1就一定有环，但是传入的参数没有pos,不能直接使用它。</p>
<p>判断链表成环可以有思维上的巧妙性，主要是快慢指针的使用。</p>
<p>解法一，用哈希表，但是不符合进阶要求，时间复杂度和空间复杂度都是O(n)</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Definition for singly-linked list.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>class ListNode &#123;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>int val;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>ListNode next;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>ListNode(int x) &#123;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *         </span>val = x;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *         </span>next = null;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>&#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>&#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> */</span></span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    public boolean hasCycle(ListNode head) &#123;</span><br><span class="line">        <span class="built_in">Set</span>&lt;ListNode&gt; <span class="keyword">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">set</span>.contains(head)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">set</span>.add(head);</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，如果没有了解，很难想到的双指针法（其实之前很多题目已经用到了双指针，比如283题移动零、11题盛水容器、15题三数之和等。三数之和甚至用到了三指针。）</p>
<p>时间复杂度为O(n)，但是符合空间复杂度为O(1)的要求因为它是在原有的链表上进行操作。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Definition for singly-linked list.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>class ListNode &#123;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>int val;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>ListNode next;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>ListNode(int x) &#123;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *         </span>val = x;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *         </span>next = null;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>&#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>&#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> */</span></span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    public boolean hasCycle(ListNode head) &#123;</span><br><span class="line">        <span class="comment">// 一开始考虑边界条件，head或head.next可能为空，那么slow或fast就有一个</span></span><br><span class="line">        <span class="comment">// 会是空指针异常了。这个边界条件考虑得很重要</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head.next;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast) &#123;</span><br><span class="line">            <span class="comment">// 只要链表有环，fast和fast.next一定不会为null，会一直走下去</span></span><br><span class="line">            <span class="comment">// 不可能跳出false</span></span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="142-Linked-List-Cycle-II-环形链表II-Mid"><a href="#142-Linked-List-Cycle-II-环形链表II-Mid" class="headerlink" title="142. Linked List Cycle II(环形链表II)(Mid)"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">142. Linked List Cycle II(环形链表II)(Mid)</a></h2><p>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.</p>
<p>To represent a cycle in the given linked list, we use an integer <code>pos</code> which represents the position (0-indexed) in the linked list where tail connects to. If <code>pos</code> is <code>-1</code>, then there is no cycle in the linked list.</p>
<p><strong>Note</strong>: Do not modify the linked list.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">Input:<span class="built_in"> head</span> = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,-<span class="number">4</span>], pos = <span class="number">1</span></span><br><span class="line">Output:<span class="built_in"> tail</span> connects <span class="keyword">to</span> <span class="type">node</span> index <span class="number">1</span></span><br><span class="line">Explanation: There <span class="literal">is</span> a cycle <span class="keyword">in</span> the linked list, <span class="keyword">where</span><span class="built_in"> tail</span> connects <span class="keyword">to</span> the second <span class="type">node</span>.</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt=""></p>
<p><strong>Example 2:</strong></p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">Input:<span class="built_in"> head</span> = [<span class="number">1</span>,<span class="number">2</span>], pos = <span class="number">0</span></span><br><span class="line">Output:<span class="built_in"> tail</span> connects <span class="keyword">to</span> <span class="type">node</span> index <span class="number">0</span></span><br><span class="line">Explanation: There <span class="literal">is</span> a cycle <span class="keyword">in</span> the linked list, <span class="keyword">where</span><span class="built_in"> tail</span> connects <span class="keyword">to</span> the first <span class="type">node</span>.</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" alt=""></p>
<p><strong>Example 3:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="string">head</span> <span class="string">=</span> <span class="string">[1],</span> <span class="string">pos</span> <span class="string">=</span> <span class="number">-1</span></span><br><span class="line"><span class="attr">Output:</span> <span class="literal">no</span> <span class="string">cycle</span></span><br><span class="line"><span class="attr">Explanation:</span> <span class="string">There</span> <span class="string">is</span> <span class="literal">no</span> <span class="string">cycle</span> <span class="string">in</span> <span class="string">the</span> <span class="string">linked</span> <span class="string">list.</span></span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png" alt=""></p>
<p><strong>Follow-up:</strong><br>Can you solve it without using extra space?</p>
<hr>
<p>解：还是两个方法，快慢指针是环形链表相关的常用方法。</p>
<p>方法一，哈希表。虽然不符合进阶要求，但是可以解决。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        Set&lt;ListNode&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        ListNode node = head;</span><br><span class="line">        <span class="keyword">while</span>( node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(visited.contains(node)) &#123;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">            visited.add(node);</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这个方法在空间上开辟了新的空间给哈希表。</p>
<p>方法二，快慢指针，空间复杂度为O(1)</p>
<p>把判断是否有交点单独写成方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二，快慢指针，也叫 Floyd 算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">getIntersect</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// A fast pointer will either loop around a cycle and meet the slow</span></span><br><span class="line">        <span class="comment">// pointer or reach the `null` at the end of a non-cyclic list.</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// If there is a cycle, the fast/slow pointers will intersect at some</span></span><br><span class="line">        <span class="comment">// node. Otherwise, there is no cycle, so we cannot find an entrance to a cycle.</span></span><br><span class="line">        ListNode intersect = getIntersect(head);</span><br><span class="line">        <span class="keyword">if</span> (intersect == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// To find the entrance to the cycle, we have two pointers traverse at</span></span><br><span class="line">        <span class="comment">// the same speed -- one from the front of the list, and the other from</span></span><br><span class="line">        <span class="comment">// the point of intersection.</span></span><br><span class="line">        ListNode ptr1 = head;</span><br><span class="line">        ListNode ptr2 = intersect;</span><br><span class="line">        <span class="keyword">while</span> (ptr1 != ptr2) &#123;</span><br><span class="line">            ptr1 = ptr1.next;</span><br><span class="line">            ptr2 = ptr2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ptr1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="24-Swap-Nodes-in-Pairs-两两交换链表中的节点-Mid"><a href="#24-Swap-Nodes-in-Pairs-两两交换链表中的节点-Mid" class="headerlink" title="24. Swap Nodes in Pairs(两两交换链表中的节点)(Mid)"></a><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">24. Swap Nodes in Pairs(两两交换链表中的节点)(Mid)</a></h2><p>Given a linked list, swap every two adjacent nodes and return its head.</p>
<p>You may <strong>not</strong> modify the values in the list’s nodes, only nodes itself may be changed.</p>
<p><strong>Example:</strong><br><code>Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</code></p>
<hr>
<p>解：<br>方法一，递归，开销较大。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// terminator</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// process current logic</span></span><br><span class="line">        ListNode node = head.next;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// drill down</span></span><br><span class="line">        head.next = swapPairs(node.next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// reverse current state</span></span><br><span class="line">        node.next = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，非递归：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode pre = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode temp = pre;</span><br><span class="line">        pre.next = head;</span><br><span class="line">        <span class="keyword">while</span>(temp.next != <span class="keyword">null</span> &amp;&amp; temp.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode start = temp.next;</span><br><span class="line">            ListNode end = temp.next.next;</span><br><span class="line">            temp.next = end;</span><br><span class="line">            start.next = end.next;</span><br><span class="line">            end.next = start;</span><br><span class="line">            temp = start;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比于递归，非递归的写法实际对链表指针的操作更明显，需要注意在改变指针的过程中需要利用临时指针temp.next和temp.next.next分别定义start和end的位置。将start和end指向的节点反转之后将temp位置改变再重新定义start和end的位置从而重新操作。</p>
<p>具体过程可以如下图所示：</p>
<p><img src="https://s2.ax1x.com/2020/01/04/ldDjSA.jpg" alt="ldDjSA.jpg"></p>
<h2 id="25-Reverse-Nodes-in-k-Group-k个一组翻转链表-Hard"><a href="#25-Reverse-Nodes-in-k-Group-k个一组翻转链表-Hard" class="headerlink" title="25. Reverse Nodes in k-Group(k个一组翻转链表)(Hard)"></a><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">25. Reverse Nodes in k-Group(k个一组翻转链表)(Hard)</a></h2><p>Given a linked list, reverse the nodes of a linked list <em>k</em> at a time and return its modified list.</p>
<p><em>k</em> is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of <em>k</em> then left-out nodes in the end should remain as it is.</p>
<p><strong>Example:</strong></p>
<p>Given this linked list:  <code>1-&gt;2-&gt;3-&gt;4-&gt;5</code></p>
<p>For k = 2, you should return: <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code></p>
<p>For k = 3, you should return: <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code></p>
<p><strong>Note:</strong></p>
<ul>
<li><p>Only constant extra memory is allowed.</p>
</li>
<li><p>You may not alter the values in the list’s nodes, only nodes itself may be changed.</p>
</li>
</ul>
<hr>
<p>解：提供递归和非递归两种解法。</p>
<p>方法一，递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span> &amp;&amp; count != k) &#123; <span class="comment">// To find the k+1 node</span></span><br><span class="line">            curr = curr.next;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(count == k) &#123;</span><br><span class="line">            curr = reverseKGroup(curr, k); <span class="comment">// reverse list with k+1 node as head</span></span><br><span class="line">            <span class="comment">// head - head-pointer to direct part</span></span><br><span class="line">            <span class="comment">// curr - head-pointer to reversed part</span></span><br><span class="line">            <span class="keyword">while</span>(count-- &gt; <span class="number">0</span>) &#123; <span class="comment">// reverse the k-group</span></span><br><span class="line">                ListNode tmp = head.next; <span class="comment">//tmp - next head in direct part</span></span><br><span class="line">                head.next = curr; <span class="comment">// preappending "direct" head to the reversed list</span></span><br><span class="line">                curr = head; <span class="comment">//move head of reversed part to a new node</span></span><br><span class="line">                head = tmp; <span class="comment">// move ""direct" head to the next node in direct part</span></span><br><span class="line">            &#125;</span><br><span class="line">            head = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归写法在找到k组节点之后的反转操作和单纯的链表翻转的节点指针的改变操作相同，即把第206题翻转链表非递归写法提取了出来。</p>
<p>方法二，非递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        </span><br><span class="line">        ListNode pre = dummy;</span><br><span class="line">        ListNode end = dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(end.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k &amp;&amp; end != <span class="keyword">null</span>; i++) &#123;</span><br><span class="line">                end = end.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(end == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode start = pre.next;</span><br><span class="line">            ListNode next = end.next;</span><br><span class="line">            end.next = <span class="keyword">null</span>;</span><br><span class="line">            pre.next = reverse(start);</span><br><span class="line">            start.next = next;</span><br><span class="line">            pre = start;</span><br><span class="line">            end = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode next = curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细题解：<br><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/solution/tu-jie-kge-yi-zu-fan-zhuan-lian-biao-by-user7208t/" target="_blank" rel="noopener">点击这里</a></p>
<h2 id="26-Remove-Duplicates-from-Sorted-Array-删除排序数组中的重复项-Easy"><a href="#26-Remove-Duplicates-from-Sorted-Array-删除排序数组中的重复项-Easy" class="headerlink" title="26. Remove Duplicates from Sorted Array(删除排序数组中的重复项)(Easy)"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">26. Remove Duplicates from Sorted Array(删除排序数组中的重复项)(Easy)</a></h2><p>Given a sorted array <em>nums</em>, remove the duplicates in-place(原地操作) such that each element appear only <em>once</em> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array in-place</strong> with O(1) extra memory.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">Given nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line"></span><br><span class="line">Your <span class="keyword">function</span> <span class="title">should</span> <span class="keyword">return</span> <span class="type">length</span> = <span class="number">2</span>, <span class="keyword">with</span> the first two elements <span class="keyword">of</span> nums being <span class="number">1</span> <span class="keyword">and</span> <span class="number">2</span> respectively.</span><br><span class="line"></span><br><span class="line">It doesn<span class="symbol">'t</span> matter what you leave beyond the returned length.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">Given nums = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line"></span><br><span class="line">Your function should return length = <span class="number">5</span>, with the first five elements of nums being modified to <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, and <span class="number">4</span> respectively.</span><br><span class="line"></span><br><span class="line">It doesn't matter what values are set beyond the returned length.</span><br></pre></td></tr></table></figure>

<p><strong>Clarfication:</strong><br>Confused why the returned value is an integer but your answer is an array?</p>
<p>Note that the input array is passed in by <strong>reference</strong>, which means modification to the input array will be known to the caller as well.</p>
<p>Internally you can think of this:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// nums is passed in by reference. (i.e., without making a copy)</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">len</span> = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// any modification to nums in your function would be known by the caller.</span></span><br><span class="line"><span class="comment">// using the length returned by your function, it prints the first len elements.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">len</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">print</span>(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>解：</p>
<p>方法一，快慢指针：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 删除重复项之后的数组下标为after_numsLength</span></span><br><span class="line">        <span class="keyword">int</span> after_numslength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// i在前，after_numslength在后，nums[after_numslength]为去重之后的数组</span></span><br><span class="line">            <span class="keyword">if</span>(nums[after_numslength] != nums[i]) &#123;</span><br><span class="line">                after_numslength++;</span><br><span class="line">                nums[after_numslength] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回长度，为下标最大值+1</span></span><br><span class="line">        <span class="keyword">return</span> after_numslength+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，i表示删除元素后数组元素的个数，注意因为i是元素个数，所以判断元素是否重复的时候比较的是”n != nums[i-1]”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> || nums[i-<span class="number">1</span>] != n) &#123;</span><br><span class="line">                nums[i++] = n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="189-Rotate-Array-旋转数组-Easy"><a href="#189-Rotate-Array-旋转数组-Easy" class="headerlink" title="189. Rotate Array(旋转数组)(Easy)"></a><a href="https://leetcode-cn.com/problems/rotate-array/" target="_blank" rel="noopener">189. Rotate Array(旋转数组)(Easy)</a></h2><p>Given an array, rotate the array to the right by <em>k</em> steps, where <em>k</em> is non-negative.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>] <span class="keyword">and</span> k = <span class="number">3</span></span><br><span class="line">Output: [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">Explanation:</span><br><span class="line">rotate <span class="number">1</span> steps to the right: [<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">rotate <span class="number">2</span> steps to the right: [<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">rotate <span class="number">3</span> steps to the right: [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">-1</span>,<span class="number">-100</span>,<span class="number">3</span>,<span class="number">99</span>] <span class="keyword">and</span> k = <span class="number">2</span></span><br><span class="line">Output: [<span class="number">3</span>,<span class="number">99</span>,<span class="number">-1</span>,<span class="number">-100</span>]</span><br><span class="line">Explanation: </span><br><span class="line">rotate <span class="number">1</span> steps to the right: [<span class="number">99</span>,<span class="number">-1</span>,<span class="number">-100</span>,<span class="number">3</span>]</span><br><span class="line">rotate <span class="number">2</span> steps to the right: [<span class="number">3</span>,<span class="number">99</span>,<span class="number">-1</span>,<span class="number">-100</span>]</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ul>
<li><p>Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.</p>
</li>
<li><p>Could you do it in-place with O(1) extra space?</p>
</li>
</ul>
<hr>
<p>解：给出三种解法。</p>
<p>方法一，双重循环，比较暴力。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> rotate(<span class="built_in">int</span>[] nums, <span class="built_in">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// 按照轮次来做，每一轮操作一个数字</span></span><br><span class="line">        <span class="built_in">int</span> len = nums.length;</span><br><span class="line">        <span class="comment">// 如果k太大，甚至比nums还大，那么移动过程会经过了一轮。这里k表示最后要位移的位数</span></span><br><span class="line">        k %= len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="comment">//temp 保存最后一个元素的值</span></span><br><span class="line">            <span class="built_in">int</span> temp = nums[len - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = len<span class="number">-1</span>; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">                nums[j] = nums[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            nums[<span class="number">0</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(kn)</p>
<p>空间复杂度：O(1)</p>
<p>方法二</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> rotate(<span class="built_in">int</span>[] nums, <span class="built_in">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">int</span> nums_length = nums.length;</span><br><span class="line">        k %= nums_length;</span><br><span class="line">        <span class="comment">// 第一次交换完毕后，前 k 位数字位置正确，后 n-k 位数字中最后 k 位数字顺序错误，继续交换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> start = <span class="number">0</span>; start &lt; nums.length &amp;&amp; k != <span class="number">0</span>; nums_length -= k, start += k, k %= nums_length) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">                swap(nums, start + i, nums.length - k + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> <span class="built_in">void</span> swap(<span class="built_in">int</span> [] nums, <span class="built_in">int</span> i, <span class="built_in">int</span> j)&#123;</span><br><span class="line">            <span class="built_in">int</span> temp = nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度:O(n)<br>空间复杂度：O(1)</p>
<p>方法三，翻转，最巧妙。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> rotate(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span> len = nums.length;</span><br><span class="line">        // 如果k太大，甚至比nums还大，那么移动过程会经过一轮，在这里k表示最后要位移的位数。</span><br><span class="line">        k %= len;</span><br><span class="line">        reverse(nums,<span class="number">0</span>,len<span class="number">-1</span>);</span><br><span class="line">        reverse(nums,<span class="number">0</span>,k<span class="number">-1</span>);</span><br><span class="line">        reverse(nums,k,len<span class="number">-1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private <span class="type">void</span> reverse(<span class="type">int</span>[] nums, <span class="type">int</span> <span class="keyword">start</span>, <span class="type">int</span> <span class="keyword">end</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">start</span> &lt; <span class="keyword">end</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="keyword">temp</span> = nums[<span class="keyword">start</span>];</span><br><span class="line">            nums[<span class="keyword">start</span>++] = nums[<span class="keyword">end</span>];</span><br><span class="line">            nums[<span class="keyword">end</span><span class="comment">--] = temp;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>arr = [1,2,3,4,5] –右移两位–&gt; [4,5,1,2,3]<br>假设 n = arr.length，k = 右移位数，可得：  </p>
<pre><code>[1,2,3,4,5] --翻转索引为[0,n-1]之间的元素--&gt; [5,4,3,2,1] 
            --翻转索引为[0,k-1]之间的元素--&gt; [4,5,3,2,1] 
            --翻转索引为[k,n-1]之间的元素--&gt; [4,5,1,2,3]</code></pre><p>注意上面这个区间貌似左和右都是闭合的</p>
<p>旋转数组其实就是把数组分成了两部分，解题关键就是在保证原有顺序的情况下<br>把后面一部分移到前面去。数组整体翻转满足了第二个要素，但是打乱了数组的<br>原有顺序，所以此时再次对两部分进行翻转，让他们恢复到原有顺序（翻转之后<br>再翻转，就恢复成原有顺序了）。没有什么太复杂的思想，但是这种很巧妙的思想或许是神来之笔。</p>
<h2 id="21-Merge-Two-Sorted-Lists-合并两个有序链表-Easy"><a href="#21-Merge-Two-Sorted-Lists-合并两个有序链表-Easy" class="headerlink" title="21. Merge Two Sorted Lists(合并两个有序链表)(Easy)"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">21. Merge Two Sorted Lists(合并两个有序链表)(Easy)</a></h2><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>, <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span></span><br><span class="line">Output: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：<br>方法一，非递归，操作指针。</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        <span class="comment">// 创建合并后链表的虚拟头结点</span></span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode curr = dummyHead;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 若链表不为空，开始合并,实际操作是插入节点</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt; l2.val) &#123;</span><br><span class="line">                curr.<span class="keyword">next</span> = l1;</span><br><span class="line">                l1 = l1.<span class="keyword">next</span>;</span><br><span class="line">                curr = curr.<span class="keyword">next</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr.<span class="keyword">next</span> = l2;</span><br><span class="line">                l2 = l2.<span class="keyword">next</span>;</span><br><span class="line">                curr = curr.<span class="keyword">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 若l1或者l2有一个为空，则直接返回另一条链表</span></span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            curr.<span class="keyword">next</span> = l2;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curr.<span class="keyword">next</span> = l1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummyHead.<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，递归</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        <span class="comment">// 使用recursion，代码虽然简洁，但是可能导致Stack OverFlow</span></span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="literal">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">if</span>(l1.<span class="keyword">val</span> &lt; l2.<span class="keyword">val</span>) &#123;</span><br><span class="line">            l1.next = mergeTwoLists(l1.next,l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            l2.next = mergeTwoLists(l1,l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="88-Merge-Sorted-Array-合并两个有序数组-Easy"><a href="#88-Merge-Sorted-Array-合并两个有序数组-Easy" class="headerlink" title="88. Merge Sorted Array(合并两个有序数组)(Easy)"></a><a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">88. Merge Sorted Array(合并两个有序数组)(Easy)</a></h2><p>Given two sorted integer arrays <em>nums1</em> and <em>nums2</em>, merge <em>nums2</em> into <em>nums1</em> as one sorted array.</p>
<p><strong>Note:</strong></p>
<ul>
<li><p>The number of elements initialized in <em>nums1</em> and <em>nums2</em> are m and n respectively.</p>
</li>
<li><p>You may assume that <em>nums1</em> has enough space (size that is greater or equal to <em>m + n</em>) to hold additional elements from <em>nums2</em>.</p>
</li>
</ul>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], m = <span class="number">3</span></span><br><span class="line">nums2 = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>],       n = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">Output: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure>

<hr>
<p>解：<br>方法一，调用自带函数，但是面试中肯定不允许使用，可以提一嘴</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 方法一，使用java的arraycopy进行nums1和nums2的合并，合并之后再排序即可</span></span><br><span class="line">        System.arraycopy(nums2,<span class="number">0</span>,nums1,m,n);</span><br><span class="line">        <span class="comment">// 使用工具类Arrays的排序方法</span></span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，使用从后往前的指针，一共三个指针，分别在在nums1元素的最后位置、nums1长度的最后位置和nums2的最后位置。每次进行比较，直到nums1或nums2被遍历完为止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 更加酷，不需要开辟额外空间，直接在nums1的末尾开始，用三个指针从后往前</span></span><br><span class="line">        <span class="comment">// two pointers for nums1 and nums2</span></span><br><span class="line">        <span class="keyword">int</span> p1 = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> p2 = n - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// set pointer for nums1</span></span><br><span class="line">        <span class="keyword">int</span> p = m + n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// while there are still elements to compare</span></span><br><span class="line">        <span class="keyword">while</span>((p1 &gt;= <span class="number">0</span>) &amp;&amp; (p2 &gt;= <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">// compare two elements from nums1 and nums2 and add the largest</span></span><br><span class="line">            <span class="comment">// one in nums1</span></span><br><span class="line">            nums1[p--] = (nums1[p1] &lt; nums2[p2]) ? nums2[p2--] : nums1[p1--];</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="comment">// add missing elements from nums2</span></span><br><span class="line">            <span class="comment">// 如果先触发了p1 &lt; 0的条件，nums2不再能copy了，需要手动arraycopy过去</span></span><br><span class="line">            System.arraycopy(nums2, <span class="number">0</span>, nums1, <span class="number">0</span>, p2 + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="66-Plus-One-加一-Easy"><a href="#66-Plus-One-加一-Easy" class="headerlink" title="66. Plus One(加一)(Easy)"></a><a href="https://leetcode-cn.com/problems/plus-one/" target="_blank" rel="noopener">66. Plus One(加一)(Easy)</a></h2><p>Given a <strong>non-empty</strong> array of digits representing a non-negative integer, plus one to the integer.</p>
<p>The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.</p>
<p>You may assume the integer does not contain any leading zero, except the number 0 itself.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">Output: [1,2,4]</span><br><span class="line">Explanation: The<span class="built_in"> array </span>represents the integer 123.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">Output: [<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">Explanation: The <span class="built_in">array</span> represents the <span class="built_in">int</span>eger <span class="number">4321.</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>[] plusOne(<span class="built_in">int</span>[] digits) &#123;</span><br><span class="line">        <span class="built_in">int</span> len = digits.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            digits[i]++;</span><br><span class="line">            digits[i] %= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(digits[i] != <span class="number">0</span>) <span class="keyword">return</span> digits;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若digits起初所有元素都为9，则需要新开辟一位</span></span><br><span class="line">        digits = new <span class="built_in">int</span>[len + <span class="number">1</span>];</span><br><span class="line">        digits[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="83-Remove-Duplicates-from-Sorted-List-删除排序链表中的重复元素-Easy"><a href="#83-Remove-Duplicates-from-Sorted-List-删除排序链表中的重复元素-Easy" class="headerlink" title="83. Remove Duplicates from Sorted List(删除排序链表中的重复元素)(Easy)"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">83. Remove Duplicates from Sorted List(删除排序链表中的重复元素)(Easy)</a></h2><p>Given a sorted linked list, delete all duplicates such that each element appear only once.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span></span><br><span class="line">Output: <span class="number">1</span>-&gt;<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">3</span></span><br><span class="line">Output: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：比较简单，只是考察操作链表节点指针的能力。因为传入的链表已经排序，我们只需要比较当前节点和它之后节点的值是否相等即可，如果相等，让当前节点指针跳过下一个节点，指向下一个节点的next即可。</p>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> singly-linked list.</span><br><span class="line"> * <span class="keyword">public</span> <span class="keyword">class</span> ListNode &#123;</span><br><span class="line"> *     <span class="built_in">int</span> val;</span><br><span class="line"> *     ListNode <span class="keyword">next</span>;</span><br><span class="line"> *     ListNode(<span class="built_in">int</span> x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode deleteDuplicates(ListNode head) &#123;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="literal">null</span> &amp;&amp; curr.<span class="keyword">next</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(curr.val == curr.<span class="keyword">next</span>.val) &#123;</span><br><span class="line">                curr.<span class="keyword">next</span> = curr.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr = curr.<span class="keyword">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h2 id="82-Remove-Duplicates-from-Sorted-List-II-删除排序链表中的重复元素-II-Mid"><a href="#82-Remove-Duplicates-from-Sorted-List-II-删除排序链表中的重复元素-II-Mid" class="headerlink" title="82. Remove Duplicates from Sorted List II(删除排序链表中的重复元素 II)(Mid)"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/submissions/" target="_blank" rel="noopener">82. Remove Duplicates from Sorted List II(删除排序链表中的重复元素 II)(Mid)</a></h2><p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span></span><br><span class="line">Output: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span></span><br><span class="line">Output: <span class="number">2</span>-&gt;<span class="number">3</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：</p>
<p>方法一，非递归。</p>
<p>重复的元素直接彻底跳过而不是去重，难度上升变成中等。方法中定义虚拟节点FakeNode(用于处理开头节点就是重复节点的情况，最后一定要返回FakeNode.next)、pre节点(用于直接跳过重复的所有元素)、cur(判断当前节点是否为重复元素的节点)</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode deleteDuplicates(ListNode head) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> ) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode FakeNode = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        FakeNode.<span class="keyword">next</span> = head;</span><br><span class="line">        ListNode pre = FakeNode;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span> ) &#123;</span><br><span class="line">            <span class="comment">// cur 标记是否当前节点为重复节点，用pre进行过滤，链起来一个新链表</span></span><br><span class="line">            <span class="comment">// cur为重复元素的最后一个结点</span></span><br><span class="line">            <span class="comment">// 不能把cur.next != null 放入大循环条件，否则可能报空指针</span></span><br><span class="line">            <span class="keyword">while</span>(cur.<span class="keyword">next</span> != <span class="keyword">null</span> &amp;&amp; cur.val == cur.<span class="keyword">next</span>.val) &#123;</span><br><span class="line">                cur = cur.<span class="keyword">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若pre的下一个节点就是cur，说明cur当前元素不是重复的，不需要跳过</span></span><br><span class="line">            <span class="comment">// 反之，根据题意需要跳过cur指向的找到的重复的最后一个结点</span></span><br><span class="line">            <span class="keyword">if</span>(pre.<span class="keyword">next</span> == cur) &#123;</span><br><span class="line">                pre = pre.<span class="keyword">next</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre.<span class="keyword">next</span> = cur.<span class="keyword">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 相比83题简单地去重，这里需要判断cur重复之后还要删除重复元素，使用pre指针</span></span><br><span class="line">            <span class="comment">// 所以不是简单地在判断元素重复之后直接进入下一元素，而是经过一个循环和一个判断之后才可以</span></span><br><span class="line">            cur = cur.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> FakeNode.<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，递归。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> ) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(head.next != <span class="keyword">null</span> &amp;&amp; head.val == head.next.val) &#123;</span><br><span class="line">            <span class="keyword">while</span>(head.next != <span class="keyword">null</span> &amp;&amp; head.val == head.next.val) &#123;</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> deleteDuplicates(head.next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head.next = deleteDuplicates(head.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="203-Remove-Linked-List-Elements-移除链表元素-Easy"><a href="#203-Remove-Linked-List-Elements-移除链表元素-Easy" class="headerlink" title="203. Remove Linked List Elements(移除链表元素)(Easy)"></a><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/" target="_blank" rel="noopener">203. Remove Linked List Elements(移除链表元素)(Easy)</a></h2><p>Remove all elements from a linked list of integers that have value <strong><em>val</em></strong>.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input:  <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">6</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span>, val = <span class="number">6</span></span><br><span class="line">Output: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：<br>方法一，递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode next = removeElements(head.next, val);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(head.val == val) <span class="keyword">return</span> next;</span><br><span class="line">        </span><br><span class="line">        head.next = next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，非递归，迭代，定义虚拟节点</p>
<p>需要注意，如果第一个元素的值是val,无法返回头结点。所以自然想到需要dummyuNode(或者叫做FakeNode)。当遇到含有val的值的时候，比如2-&gt;6-&gt;3，val是6，此时需要赋值：2.next=2.next.next，和83题的操作同样很类似。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode fakeNode = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        fakeNode.next = head;</span><br><span class="line">        ListNode curr = fakeNode;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span> &amp;&amp; curr.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(curr.next.val == val) &#123;</span><br><span class="line">                curr.next = curr.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fakeNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法三，非递归，不使用虚拟节点，单纯删除节点，只是头结点值为val的时候需要单独考虑。(删除节点操作很简单,很类似83题，只是83题是和 x.next 去比较val是否相同，而这道题比较当前节点的 val 是否和传入的val相同)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span> &amp;&amp; head.val == val) &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果没有这个判断，curr.next在corner edge情况下很可能会报空指针</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span> &amp;&amp; curr.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(curr.next.val == val) &#123;</span><br><span class="line">                curr.next = curr.next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr = curr.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="237-Delete-Node-in-a-Linked-List-删除链表中的节点-Easy"><a href="#237-Delete-Node-in-a-Linked-List-删除链表中的节点-Easy" class="headerlink" title="237. Delete Node in a Linked List(删除链表中的节点)(Easy)"></a><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/" target="_blank" rel="noopener">237. Delete Node in a Linked List(删除链表中的节点)(Easy)</a></h2><p>Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.</p>
<p>Given linked list – head = [4,5,1,9], which looks like following:</p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/28/237_example.png" alt=""></p>
<p><strong>Example 1:</strong></p>
<p>Input: head = [4,5,1,9], node = 5<br>Output: [4,1,9]<br>Explanation: You are given the second node with value 5, the linked list should become 4 -&gt; 1 -&gt; 9 after calling your function.</p>
<p><strong>Example 2:</strong></p>
<p>Input: head = [4,5,1,9], node = 1<br>Output: [4,5,9]<br>Explanation: You are given the third node with value 1, the linked list should become 4 -&gt; 5 -&gt; 9 after calling your function.</p>
<p><strong>Note:</strong></p>
<ul>
<li>The linked list will have at least two elements.</li>
<li>All of the nodes’ values will be unique.</li>
<li>The given node will not be the tail and it will always be a valid node of the linked list.</li>
<li>Do not return anything from your function.</li>
</ul>
<hr>
<p>解：<br>注意，这道题只是考如何删除某个指定的节点，考的就是在无法知道这个节点前面指针的时候该如何操作。感觉和脑筋急转弯差不多。</p>
<p>因为我们不能操作这个节点前面的节点的next指针，所以要删除当前这个节点，就只能把下一个节点的值赋给当前这个节点，然后让当前节点跳过下一个节点。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public void deleteNode(ListNode <span class="keyword">node</span><span class="title">) &#123;</span></span><br><span class="line"><span class="title">        node</span>.val = <span class="keyword">node</span>.<span class="title">next</span>.val;</span><br><span class="line">        <span class="keyword">node</span>.<span class="title">next</span> = <span class="keyword">node</span>.<span class="title">next</span>.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Algorithms Note</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Object oriented(OOP)</title>
    <url>/2019/12/25/Object-oriented-OOP/</url>
    <content><![CDATA[<p><img src="https://s2.ax1x.com/2019/12/30/lKcqcd.md.jpg" alt=""></p>
<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>Design Pattern</title>
    <url>/2019/12/25/Design-Pattern/</url>
    <content><![CDATA[<blockquote>
<p>看待事物都可以按照这个顺序：发现问题、分析问题、理顺逻辑、寻求证据、解决问题</p>
</blockquote>
<p>设计模式相关内容介绍，尤其着重Java的单例模拟，看完必有收获。</p>
<a id="more"></a>

<h1 id="如何用java写一个单例模式？"><a href="#如何用java写一个单例模式？" class="headerlink" title="如何用java写一个单例模式？"></a>如何用java写一个单例模式？</h1><p>只能生成一个实例的类是实现了Singleton(单例)模式的类。由于设计模式在面向对象编程中起到了举足轻重的作用，所以在面试中很多公司都会问。而在常用的设计模式中，Singleton是唯一一个能够用短短几十行代码完整实现的设计模式，<font color=#FF0000>所以写一个Singleton是一个很常见的面试题</font>。</p>
<p>单例模式虽然看起来简单，但是如果往深了挖，又可以考察出候选者对于并发、类加载、序列化等知识点的掌握。</p>
<h2 id="什么是单例模式？"><a href="#什么是单例模式？" class="headerlink" title="什么是单例模式？"></a>什么是单例模式？</h2><p>如上面所说，只能生成一个实例的类是实现了Singleton(单例模式)的类，也就是一个单例模式的类只有一个实例，并且提供一个全局可以访问的入口(比如getInstance()方法)。比如《火影忍者》中漩涡鸣人特别喜欢用的影分身之术，实际上，每一个影分身都只对应着一个真身。</p>
<p>为什么要有只有一个实例的这种类？我们为什么需要它？</p>
<p><strong>理由一：</strong>为了节省内存、节省计算。很多情况下，我们只需要一个实例，如果出现了更多实例，反而是浪费。</p>
<p>举例：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">ExpensiveResource</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ExpensiveResource() &#123;</span><br><span class="line">        field1 = <span class="comment">// 查询数据库</span></span><br><span class="line">        field2 = <span class="comment">// 对查到的数据做大量计算</span></span><br><span class="line">        field3 = <span class="comment">// 加密、压缩等耗时操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类在构造的时候，需要查询数据库，对查到的数据做大量的计算，然后还要进行加密、压缩等非常耗时的操作。所以在第一次构造这个类的时候，我们就要花费很多时间来初始化这个对象。</p>
<p>假设数据库在一段时间不变，那么我们其实只需要使用这一个实例完成任务即可。如果每次都重新生成新的实例，浪费资源，十分没有必要。</p>
<p><strong>理由二：</strong>为了保证结果的正确。比如我们需要一个全局计数器用来统计人数。如果有多个实例，反而会造成混乱。</p>
<p><strong>理由三：</strong>方便管理。很多工具类，我们只需要一个实例，通过一个统一的入口，获取这个单例。太多实例不但没有帮助，只会让人眼花缭乱。</p>
<h2 id="单例模式使用场景？"><a href="#单例模式使用场景？" class="headerlink" title="单例模式使用场景？"></a>单例模式使用场景？</h2><ol>
<li><p><strong>无状态的工具类：日志工具、字符串工具等</strong>。——日志工具，不论在哪里使用，我们只需要它帮我们记录日志信息，除此功能之外并不需要在它的实例对象上存储任何状态，所以我们只需要一个实例对象就可以了。</p>
</li>
<li><p><strong>全局信息类：全局计数、环境变量</strong>。——比如我们要记录某个网站的访问次数，而且不希望有的访问记录被记录在对象A上，而有的被记录在对象B上。此时我们就可以让这个类为单例，在需要计数的时候拿出来用就可以了。</p>
</li>
</ol>
<p><font color=#FF0000>单例模式常见写法，这里列举五种：饿汉式、懒汉式、双重检查式、静态内部类式、枚举式</font></p>
<h2 id="单例模式的实现"><a href="#单例模式的实现" class="headerlink" title="单例模式的实现"></a>单例模式的实现</h2><p>下面按照写法的难易程度逐层递进：<br>相对简单的<strong>饿汉式：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 饿汉式写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类的第一行，用static修饰实例，并且把构造函数用private修饰。</p>
<p><strong>饿汉式优点：</strong>这种写法比较简单，在类装载的时候就完成了实例化，避免了线程同步的问题。</p>
<p><strong>饿汉式缺点：</strong>类装载的时候就完成了实例化，没有达到懒加载的效果，这点是最大缺陷。所以如果自始至终都没使用过这个实例，就可能会造成内存的浪费。</p>
<p>饿汉式写法的变种：<strong>静态代码块</strong>形式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 饿汉式另一种写法，静态代码块</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法和最开始的饿汉式的方式类似，只是把类实例化的过程放在了静态代码块中。同样，在类装载的过程中会执行静态代码块中的代码，完成实例的初始化，所以静态代码块的优缺点和饿汉式是一样的。<em>静态代码块写法就是饿汉式的写法。</em></p>
<p>接下来看第二种<strong>懒汉式</strong>。</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线程不安全的懒汉式写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是需要注意，上面这个懒汉式写法只能用于单线程。因为如果一个线程进入了 <code>if(singleton == null)</code> 判断语句块，还没来得及往下执行，另一个线程也通过了这个判断语句，此时会多次创建实例。所以这里需要注意，在多线程环境下，不能用上面这种懒汉式写法，它是错误的。</p>
<p>当然，懒汉式写法可以进行升级，让其成为线程安全的懒汉式写法。升级之后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线程安全的懒汉式写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加上了synchronized关键字，为了解决刚才的线程安全问题。<strong>缺点是效率太低了</strong>，每个线程在想获得类的实例的时候，执行getInstance的时候都要进行同步，虽然保证了多个线程不能同时访问，但是这在大多数情况下是没有必要的。</p>
<p>为了解决这个问题，衍生出了<strong>双重检查模式</strong>。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双重检查模式写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点在getInstance方法，我们进行了两次 <code>if(singleton == null)</code> 的判断，这样可以保证线程安全了。可以想象，在第一次初始化了singleton对象之后，再次调用代码块的时候，第一个if判断就可以让执行跳过整个代码块，返回之前已经初始化过的singleton,避免破坏单例。</p>
<p>这种写法的优势是，不仅保证了线程安全，而且延迟加载，效率也更高。</p>
<p>这里会有一个面试经常会问到的问题：”为什么要有两个if判断呢？去掉第二个if，可以么？(或者说，为什么要double-check?去掉第二个check行不行呢？)”</p>
<p>结论是，不行。为什么不行？我们来考虑这样的情景：</p>
<p>有两个线程同时调用getInstance()方法，由于singleton是空的，所以两个线程都可以通过第一重if判断。然后由于锁机制的存在，会有一个线程进入到第二个判断语句，而另一个线程会在外等候。过了一小段时间，第一个线程完成了对singleton的创建操作，它会退出synchronized的保护区域。此时第二个线程会进入到运行区域。此时如果没有第二个if判断，那么第二个线程也会创建一个实例，这就破坏了单例，这肯定是不行的。</p>
<p>当然，第一个check也是不能去掉的。如果去掉了第一个check,那么所有线程都会串行执行，效率低下。所以，<strong>两个check都是需要保留的</strong>。</p>
<p>此外，在双重检查模式中，我们给singleton加了 <code>volatile</code> 关键字。为什么要增加volatile呢？</p>
<p>原因在于， <code>singleton = new Singleton();</code> 这句话不是一个原子操作。事实上，在JVM中，这句话至少做了<strong>3件事</strong>：</p>
<ol>
<li>给singleton分配内存空间</li>
<li>调用Singleton的构造函数等来初始化singleton</li>
<li>将singleton对象指向分配的内存空间(执行完这步，singleton就不是Null了)</li>
</ol>
<p>但是这里需要注意1、2、3步骤的顺序。因为存在着重排序的优化。也就是说，<strong>第二步和第三步这两者的顺序是不能保证的</strong>。</p>
<p>最终的执行顺序可能是1-2-3，也可能是1-3-2。如果是1-3-2，那么如果第一个线程正在创建的时候，另一个线程也进来了，那么在进行第一重判断的时候会直接跳过整个代码块，直接返回singleton对象。而此时因为singleton还没有被初始化，所以会有空指针报错。哪怕最后线程1最后的初始化了，但是只是姗姗来迟，程序已经报错了。</p>
<p>用图解详细分析一下：<br><img src="https://s2.ax1x.com/2020/01/10/lfTzJs.png" alt="lfTzJs.png"></p>
<p>总结用volatile的原因：<strong>它可以防止上面重排序的发生，可以避免拿到未完成初始化的对象。</strong></p>
<p>下面来看静态内部类的写法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态内部类写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span> &#123;</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法和饿汉式所采用的机制类似，都才用了类装载的机制：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以此保证我们初始化实例时只有一个线程，而且是JVM帮助我们保证了线程安全性。</p>
<p>但是，饿汉式有一个特点，就是只要Singleton这个类被加载了，就会实例化单例对象。而静态内部类方式在Singleton类被装载的时候，并不会立刻实例化，而是在需要实例的时候，也就是调用getInstance()方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SingletonInstance.singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>的时候，才会去完成对singleton实例的实例化。</p>
<p><strong>静态内部类写法优点：</strong></p>
<ol>
<li>代码简洁，和双重检查的单例模式对比，静态内部类的单例实现代码更加简洁，清晰明了。</li>
<li>延迟初始化，调用getInstance()才会初始化Singleton对象。</li>
<li>线程安全。JVM在执行类的初始化阶段，会获得一个可以同步多个线程对同一个类的初始化锁。</li>
</ol>
<p>在介绍枚举写法之前，做一个小总结：</p>
<p><strong>静态内部类的写法与双重检查模式的优点是一样的，都避免了线程不安全的问题，并且延迟加载，效率高。</strong></p>
<p>可以看出，静态内部类和双重检查都是不错的写法。但是这两种方法都有一个缺陷：<strong>不能防止被反序列化。</strong></p>
<p>最后，枚举类的写法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 枚举类写法实现单例模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whatereverMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举类是在JDK1.5之后新增的方法。它不仅可以避免多线程同步的问题，而且还能防止反序列化和反射(这两种方法可以创建新的对象)破坏单例模式。</p>
<p>上面讲了五种方式，但是可以说，实现单例模式最好的方式，是利用枚举。这个观点其实是Josh Bloch的。他曾经在Effective Java中写道：”使用枚举实现单例的方法，虽然还没有被广泛采用，但是单元素的枚举类型应成为了实现Singleton的最佳方法。”</p>
<p>他如此推崇枚举，主要还是因为枚举写法的优点：</p>
<ol>
<li>代码简洁。枚举的写法不需要我们去考虑懒加载或者线程安全等问题。同时，代码短小精悍，比其他任何写法都更加简洁。</li>
<li>线程安全有保障。通过反编译枚举类，我们可以发现枚举种的各个枚举项，都是通过static代码块来定义和初始化的。他们会在类被加载的时候完成初始化。而java类的加载由JVM保证线程安全。所以，创建一个Enum类型的枚举是线程安全的。</li>
<li>最重要的优点：<strong>防止破坏单例</strong>。java专门对枚举的序列化做了单独的规定。在<strong>序列化</strong>的时候，仅仅会将枚举对象的name属性输出到结果中。而在反序列化时，会通过 <code>java.lang.Enum</code> 的valueOf方法来根据名字查找对象，而不会新建一个新的对象。这就防止了反序列化导致的单例破坏问题的出现。而针对<strong>反射</strong>，枚举类同样有防御措施。反射在通过newInstance创建对象时，会检查这个类是否是枚举类。如果是，会抛出： <code>IllegalArgumentException(&quot;Cannot reflecatively create enum objects&quot;)</code> 这个异常，反射创建对象会失败。可以说，java针对枚举做的工作是非常全面的，枚举，是java亲生的。</li>
</ol>
<p>可以看出，枚举这种方式可以防止反序列化和反射破坏单例，在这一点上与其他方式相比，优势巨大。安全问题不容小觑，一旦通过反序列化或者反射生成了多个实例，那么单例模式就彻底没用了。</p>
<p>总结：<br><img src="https://s2.ax1x.com/2020/01/10/lhCFII.png" alt="lhCFII.png"></p>
<p>需要注意，如果使用了线程不安全的写法，在并发的情况下可能产生多个实例，那么不仅会影响性能，更可能造成数据错误等严重的后果。</p>
<p>回答面试问题过程中，可以先从饿汉式、懒汉式说起，一步一步地分析每一种的优缺点，并且对写法进行演进。重点需要关注，<strong>双重检查模式为什么需要两次检查？为什么要是用volatile关键字？</strong>最后再说枚举类写法的优点和其背后的原理。</p>
<p>此外，在工作中，如果遇到了<strong>全局信息类、无状态工具类</strong>等场景，推荐使用枚举的写法实现单例模式。</p>
]]></content>
      <categories>
        <category>Study Note</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
        <tag>Foundation</tag>
      </tags>
  </entry>
</search>
