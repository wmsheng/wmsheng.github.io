<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LeetCode-Practice-by-Categories-Others</title>
    <url>/2020/01/13/LeetCode-Practice-by-Categories-Others/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>LeetCode-Practice-by-Categories-String-Algorithm</title>
    <url>/2020/01/13/LeetCode-Practice-by-Categories-String-Algorithm/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>LeetCode-Practice-by-Categories-Sort</title>
    <url>/2020/01/13/LeetCode-Practice-by-Categories-Sort/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>LeetCode-Practice-by-Categories-Bitwise-Operation</title>
    <url>/2020/01/13/LeetCode-Practice-by-Categories-Bitwise-Operation/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>LeetCode-Practice-by-Categories-Dynamic-Programming</title>
    <url>/2020/01/13/LeetCode-Practice-by-Categories-Dynamic-Programming/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>LeetCode-Practice-by-Categories-Search</title>
    <url>/2020/01/13/LeetCode-Practice-by-Categories-Search/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>LeetCode-Practice-by-Categories-Tree</title>
    <url>/2020/01/13/LeetCode-Practice-by-Categories-Tree/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>LeetCode-Practice-by-Categories-Hash-Table</title>
    <url>/2020/01/13/LeetCode-Practice-by-Categories-Hash-Table/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>LeetCode Practice by Categories(Stack, Queue)</title>
    <url>/2020/01/08/LeetCode-Practice-by-Categories-Stack-Queue/</url>
    <content><![CDATA[<blockquote>
<p>衡量一个人真正的品德，是看他在知道没有人发觉的时候做些什么 —— 孟德斯鸠</p>
</blockquote>
<p>分析讨论栈、队列、优先队列、双端队列以及相关LeetCode题目。</p>
<a id="more"></a>

<p><font color=#FF0000>java中，队列Queue是一种特殊的线性表，实例化的时候用链表(new LinkedList&lt;&gt;())、栈Stack有单独的类，实例化的时候使用Stack(new Stack&lt;&gt;())。 队列因为用LinkedList实现,一般操作size()方法。而栈可以使用empty()或者isEmpty()判空(empty()和isEmpty()没有本质区别，一般可以通用)</p>
<p>事实上，普通的栈和队列在工作中基本不会使用，而用得比较多的是双端队列。比如本文中曾经在239题中使用了java库中的双端队列，并用Array实现：<code>Deque&lt;Integer&gt; dq = new ArrayDeque&lt;&gt;();</code><br></font> </p>
<h2 id="20-Valid-Parentheses-有效的括号-Easy"><a href="#20-Valid-Parentheses-有效的括号-Easy" class="headerlink" title="20.Valid Parentheses(有效的括号)(Easy)"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">20.Valid Parentheses(有效的括号)(Easy)</a></h2><p>Given a string containing just the characters <code>&#39;(&#39;, &#39;)&#39;, &#39;{&#39;, &#39;}&#39;, &#39;[&#39;</code> and<code>&#39;]&#39;</code>, determine if the input string is valid.</p>
<p>An input string is valid if:</p>
<ol>
<li>Open brackets must be closed by the same type of brackets.</li>
<li>Open brackets must be closed in the correct order.</li>
</ol>
<p>Note that an empty string is also considered valid.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">Input:</span> <span class="string">"()"</span></span><br><span class="line"><span class="string">Output:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">Input:</span> <span class="string">"()[]&#123;&#125;"</span></span><br><span class="line"><span class="string">Output:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">Input:</span> <span class="string">"(]"</span></span><br><span class="line"><span class="string">Output:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">Input:</span> <span class="string">"([)]"</span></span><br><span class="line"><span class="string">Output:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 5:</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">Input:</span> <span class="string">"&#123;[]&#125;"</span></span><br><span class="line"><span class="string">Output:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>


<hr>
<p>解：想要符合闭合的括号的标准，用一个栈保存和左括号对应的右括号。每次碰到左括号就入栈对应的右括号，碰到右括号就判断是否和当前栈顶元素相同。</p>
<p>注意有两个判空，一个是碰到右括号，如果此时栈为空，那么不能pop()(会报错)，如果此时栈为空则不为有效括号。另一个情况是所有括号都遍历完了，此时如果栈不为空，则不是有效括号。所以在遍历完s之后需要返回stack.isEmpty()。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">String</span> s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; <span class="built_in">stack</span> = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'('</span>) &#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(<span class="string">')'</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'['</span>) &#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(<span class="string">']'</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'&#123;'</span>) &#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(<span class="string">'&#125;'</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">stack</span>.isEmpty() || <span class="built_in">stack</span>.pop() != c) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="155-Min-Stack-最小栈-Easy"><a href="#155-Min-Stack-最小栈-Easy" class="headerlink" title="155.Min Stack(最小栈)(Easy)"></a><a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">155.Min Stack(最小栈)(Easy)</a></h2><p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p>
<ul>
<li>push(x) – Push element x onto stack.</li>
<li>pop() – Removes the element on top of the stack.</li>
<li>top() – Get the top element.</li>
<li>getMin() – Retrieve the minimum element in the stack.</li>
</ul>
<p><strong>Example:</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">MinStack minStack = new MinStack()<span class="comment">;</span></span><br><span class="line">minStack.push(-<span class="number">2</span>)<span class="comment">;</span></span><br><span class="line">minStack.push(<span class="number">0</span>)<span class="comment">;</span></span><br><span class="line">minStack.push(-<span class="number">3</span>)<span class="comment">;</span></span><br><span class="line">minStack.getMin()<span class="comment">;   --&gt; Returns -3.</span></span><br><span class="line">minStack.pop()<span class="comment">;</span></span><br><span class="line">minStack.top()<span class="comment">;      --&gt; Returns 0.</span></span><br><span class="line">minStack.getMin()<span class="comment">;   --&gt; Returns -2.</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：java语言本身已经定义好了一种传统作用的Stack，这道题有什么意义呢？事实上这道题就是要实现一个可以获得最小元素的栈。</p>
<p>换个角度看，要能够在常数时间内检索到最小元素的栈，是不是有点像优先队列？——其实不一样，它还是一个先入后出的栈。它只是能让你在常规时间中探索到最小元素，而不是取的时候每次都取最小元素。它的api本身和栈一模一样，只是多了一个功能，能够探测到最小元素。</p>
<p>给出两种方法，分别用两个栈和一个栈实现。</p>
<p>解法一：用两个栈实现，一个数据栈，一个辅助栈。这种写法注意了健壮性，考虑了栈为空的情况。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据栈和辅助栈同步,后面每个操作两个栈都进行相同操作</span></span><br><span class="line">    Stack&lt;Integer&gt; data;</span><br><span class="line">    Stack&lt;Integer&gt; helper;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化两个栈</span></span><br><span class="line">        data = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        helper = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        data.push(x);</span><br><span class="line">        <span class="keyword">if</span>(helper.isEmpty() || helper.<span class="built_in">peek</span>() &gt;= x) &#123;</span><br><span class="line">            helper.push(x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            helper.push(helper.<span class="built_in">peek</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!data.isEmpty()) &#123;</span><br><span class="line">            data.pop();</span><br><span class="line">            helper.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!data.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> data.<span class="built_in">peek</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"栈中元素为空，此操作非法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!helper.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> helper.<span class="built_in">peek</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"栈中元素为空，此操作非法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>解法二：用一个栈解决。解法一开辟了一个helper栈去保存最小值，实际上我们可以用一个变量,min,去保存这个最小值。<br>这里有两个问题：</p>
<ol>
<li>min保存了当前的最小值，如果min更新了，那么如何保存之前的最小值呢？——把之前的min在新元素之前入栈，也就是说来了新的更小的元素，旧的最小的元素需要再次入栈以求保存。</li>
<li>如果当前出栈的是最小值，我们在出栈当前元素之余，还需要再出栈一次，并且把这一次出栈的值赋给min。因为最小的元素入栈前会把之前最小的元素入栈，所以这样做就把旧的最小元素保存下来了。</li>
</ol>
<p>详细题解：<a href="https://leetcode-cn.com/problems/min-stack/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-38/" target="_blank" rel="noopener">点击这里</a></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">min</span> = Integer.MAX_VALUE;</span><br><span class="line">    Stack&lt;Integer&gt; <span class="built_in">stack</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span> = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// only push the old minimum value when the current</span></span><br><span class="line">        <span class="comment">// minimum value changes after pushing the new value x</span></span><br><span class="line">        <span class="keyword">if</span>(x &lt;= <span class="built_in">min</span>) &#123;</span><br><span class="line">            <span class="built_in">stack</span>.push(<span class="built_in">min</span>);</span><br><span class="line">            <span class="built_in">min</span> = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">stack</span>.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// if pop operation could result in the changing of the current minimum value,</span></span><br><span class="line">        <span class="comment">// pop twice and change the current minimum value to the last minimum value</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">stack</span>.pop() == <span class="built_in">min</span>) <span class="built_in">min</span> = <span class="built_in">stack</span>.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>.<span class="built_in">peek</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="641-Design-Circular-Deque-设计循环双端队列-Mid"><a href="#641-Design-Circular-Deque-设计循环双端队列-Mid" class="headerlink" title="641.Design Circular Deque(设计循环双端队列)(Mid)"></a><a href="https://leetcode-cn.com/problems/design-circular-deque/" target="_blank" rel="noopener">641.Design Circular Deque(设计循环双端队列)(Mid)</a></h2><p>Design your implementation of the circular double-ended queue (deque).</p>
<p>Your implementation should support following operations:</p>
<ul>
<li><code>MyCircularDeque(k)</code>: Constructor, set the size of the deque to be k.</li>
<li><code>insertFront()</code>: Adds an item at the front of Deque. Return true if the operation is successful.</li>
<li><code>insertLast()</code>: Adds an item at the rear of Deque. Return true if the operation is successful.</li>
<li><code>deleteFront()</code>: Deletes an item from the front of Deque. Return true if the operation is successful.</li>
<li><code>deleteLast()</code>: Deletes an item from the rear of Deque. Return true if the operation is successful.</li>
<li><code>getFront()</code>: Gets the front item from the Deque. If the deque is empty, return -1.</li>
<li><code>getRear()</code>: Gets the last item from Deque. If the deque is empty, return -1.</li>
<li><code>isEmpty()</code>: Checks whether Deque is empty or not. </li>
<li><code>isFull()</code>: Checks whether Deque is full or not.</li>
</ul>
<p><strong>Example:</strong></p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">MyCircularDeque circularDeque = new MycircularDeque(<span class="number">3</span>); <span class="regexp">//</span> set the size to be <span class="number">3</span></span><br><span class="line">circularDeque.insertLast(<span class="number">1</span>);			<span class="regexp">//</span> <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">circularDeque.insertLast(<span class="number">2</span>);			<span class="regexp">//</span> <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">circularDeque.insertFront(<span class="number">3</span>);			<span class="regexp">//</span> <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">circularDeque.insertFront(<span class="number">4</span>);			<span class="regexp">//</span> <span class="keyword">return</span> <span class="keyword">false</span>, the queue is full</span><br><span class="line">circularDeque.getRear();  			<span class="regexp">//</span> <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">circularDeque.isFull();				<span class="regexp">//</span> <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">circularDeque.deleteLast();			<span class="regexp">//</span> <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">circularDeque.insertFront(<span class="number">4</span>);			<span class="regexp">//</span> <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">circularDeque.getFront();			<span class="regexp">//</span> <span class="keyword">return</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ul>
<li>All values will be in the range of [0, 1000].</li>
<li>The number of operations will be in the range of [1, 1000].</li>
<li>Please do not use the built-in Deque library.</li>
</ul>
<hr>
<p>解：使用链表完成这个API的设计。</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> MyCircularDeque &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> DoubleListNode &#123;</span><br><span class="line">        DoubleListNode pre;</span><br><span class="line">        DoubleListNode <span class="keyword">next</span>;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">public</span> DoubleListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">size</span>;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    DoubleListNode head;</span><br><span class="line">    DoubleListNode tail;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Initialize your data structure here. Set the size of the deque to be k. */</span></span><br><span class="line">    <span class="keyword">public</span> MyCircularDeque(<span class="keyword">int</span> k) &#123;</span><br><span class="line">        head = <span class="keyword">new</span> DoubleListNode(-<span class="number">1</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> DoubleListNode(-<span class="number">1</span>);</span><br><span class="line">        head.pre = tail;</span><br><span class="line">        tail.<span class="keyword">next</span> = head;</span><br><span class="line">        <span class="keyword">this</span>.k = k;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">size</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Adds an item at the front of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> insertFront(<span class="keyword">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">size</span> == k) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        DoubleListNode node = <span class="keyword">new</span> DoubleListNode(value);</span><br><span class="line">        node.<span class="keyword">next</span> = head;</span><br><span class="line">        node.pre = head.pre;</span><br><span class="line">        head.pre.<span class="keyword">next</span> = node;</span><br><span class="line">        head.pre = node;</span><br><span class="line">        <span class="keyword">size</span>++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Adds an item at the rear of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> insertLast(<span class="keyword">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">size</span> == k) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        DoubleListNode node = <span class="keyword">new</span> DoubleListNode(value);</span><br><span class="line">        node.<span class="keyword">next</span> = tail.<span class="keyword">next</span>;</span><br><span class="line">        tail.<span class="keyword">next</span>.pre = node;</span><br><span class="line">        tail.<span class="keyword">next</span> = node;</span><br><span class="line">        node.pre = tail;</span><br><span class="line">        <span class="keyword">size</span>++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Deletes an item from the front of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> deleteFront() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">size</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        head.pre.pre.<span class="keyword">next</span> = head;</span><br><span class="line">        head.pre = head.pre.pre;</span><br><span class="line">        <span class="keyword">size</span>--;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Deletes an item from the rear of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> deleteLast() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">size</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        tail.<span class="keyword">next</span>.<span class="keyword">next</span>.pre = tail;</span><br><span class="line">        tail.<span class="keyword">next</span> = tail.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">        <span class="keyword">size</span>--;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front item from the deque. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> getFront() &#123;</span><br><span class="line">        <span class="keyword">return</span> head.pre.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the last item from the deque. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> getRear() &#123;</span><br><span class="line">        <span class="keyword">return</span> tail.<span class="keyword">next</span>.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Checks whether the circular deque is empty or not. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">size</span> == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Checks whether the circular deque is full or not. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isFull() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">size</span> == k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyCircularDeque object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyCircularDeque obj = new MyCircularDeque(k);</span></span><br><span class="line"><span class="comment"> * boolean param_1 = obj.insertFront(value);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.insertLast(value);</span></span><br><span class="line"><span class="comment"> * boolean param_3 = obj.deleteFront();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.deleteLast();</span></span><br><span class="line"><span class="comment"> * int param_5 = obj.getFront();</span></span><br><span class="line"><span class="comment"> * int param_6 = obj.getRear();</span></span><br><span class="line"><span class="comment"> * boolean param_7 = obj.isEmpty();</span></span><br><span class="line"><span class="comment"> * boolean param_8 = obj.isFull();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="225-Implement-Stack-using-Queues-用队列实现栈-Easy"><a href="#225-Implement-Stack-using-Queues-用队列实现栈-Easy" class="headerlink" title="225.Implement Stack using Queues(用队列实现栈)(Easy)"></a><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/" target="_blank" rel="noopener">225.Implement Stack using Queues(用队列实现栈)(Easy)</a></h2><p>Implement the following operations of a stack using queues.</p>
<ul>
<li>push(x) – Push element x onto stack.</li>
<li>pop() – Removes the element on top of the stack.</li>
<li>top() – Get the top element.</li>
<li>empty() – Return whether the stack is empty.</li>
</ul>
<p><strong>Example:</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MyStack <span class="built_in">stack</span> = <span class="keyword">new</span> MyStack();</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>.push(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">stack</span>.push(<span class="number">2</span>);  </span><br><span class="line"><span class="built_in">stack</span>.top();   <span class="comment">// returns 2</span></span><br><span class="line"><span class="built_in">stack</span>.pop();   <span class="comment">// returns 2</span></span><br><span class="line"><span class="built_in">stack</span>.empty(); <span class="comment">// returns false</span></span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ul>
<li>You must use only standard operations of a queue – which means only <code>push to back, peek/pop from front, size</code>, and <code>is empty</code> operations are valid.</li>
<li>Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.</li>
<li>You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).</li>
</ul>
<hr>
<p>解：想要用队列实现栈，常规想法可以使用两个队列，在每次出栈操作的时候，把元素临时保存到第二个队列中，在第一个队列还剩一个元素的时候把这个元素取出，从而实现类似栈的”后入先出”操作。</p>
<p>但是存在空间复杂度更优的方法，就是使用一个队列。具体操作方法是，每次入队都把整个队列循环弹出和新增元素，使得新添加的元素总在队列的前面，由此一来这个队列实际操作与栈无异。**关键步骤就是在于入队列时候的操作：<code>queue.add(queue.remove())</code>(remove()在队列为空的时候会抛出NoSuchElementException异常，poll()会返回null，其他没有区别)</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    Queue&lt;Integer&gt; <span class="built_in">queue</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="built_in">queue</span> = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>.add(x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">queue</span>.<span class="built_in">size</span>()<span class="number">-1</span>; i++)</span><br><span class="line">            <span class="built_in">queue</span>.add(<span class="built_in">queue</span>.<span class="built_in">remove</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">queue</span>.<span class="built_in">remove</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">queue</span>.<span class="built_in">peek</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">queue</span>.<span class="built_in">size</span>() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>


<h2 id="232-Implement-Queue-using-Stacks-用栈实现队列-Easy"><a href="#232-Implement-Queue-using-Stacks-用栈实现队列-Easy" class="headerlink" title="232.Implement Queue using Stacks(用栈实现队列)(Easy)"></a><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/" target="_blank" rel="noopener">232.Implement Queue using Stacks(用栈实现队列)(Easy)</a></h2><p>Implement the following operations of a queue using stacks.</p>
<ul>
<li>push(x) – Push element x to the back of queue.</li>
<li>pop() – Removes the element from in front of queue.</li>
<li>peek() – Get the front element.</li>
<li>empty() – Return whether the queue is empty.</li>
</ul>
<p><strong>Example:</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">MyQueue <span class="built_in">queue</span> = <span class="keyword">new</span> MyQueue();</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>.push(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">queue</span>.push(<span class="number">2</span>);  </span><br><span class="line"><span class="built_in">queue</span>.<span class="built_in">peek</span>();  <span class="comment">// returns 1</span></span><br><span class="line"><span class="built_in">queue</span>.pop();   <span class="comment">// returns 1</span></span><br><span class="line"><span class="built_in">queue</span>.empty(); <span class="comment">// returns false</span></span><br></pre></td></tr></table></figure>
<p><strong>Notes:</strong></p>
<ul>
<li>You must use only standard operations of a stack – which means only <code>push to top, peek/pop from top, size, and is empty</code> operations are valid.</li>
<li>Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.</li>
<li>You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).</li>
</ul>
<hr>
<p>解：和之前用队列实现栈类似，可以用两个栈实现一个队列。但是由于栈只有一个出入口，所以不能用一个栈实现队列(队列中出队再入队可以实现倒置，栈不行).</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要两个栈才能实现队列</span></span><br><span class="line">    Stack&lt;Integer&gt; input;</span><br><span class="line">    Stack&lt;Integer&gt; output;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        input = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        output = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        input.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">peek</span>();</span><br><span class="line">        <span class="keyword">return</span> output.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(output.empty())</span><br><span class="line">            <span class="keyword">while</span>( !input.empty() )</span><br><span class="line">                output.push(input.pop());</span><br><span class="line">        <span class="keyword">return</span> output.<span class="built_in">peek</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input.empty() &amp;&amp; output.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.peek();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>


<h2 id="239-Sliding-Window-Maximum-滑动窗口最大值-Hard"><a href="#239-Sliding-Window-Maximum-滑动窗口最大值-Hard" class="headerlink" title="239.Sliding Window Maximum(滑动窗口最大值)(Hard)"></a><a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">239.Sliding Window Maximum(滑动窗口最大值)(Hard)</a></h2><p>Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: nums = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">-1</span>,<span class="number">-3</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>], <span class="keyword">and</span> k = <span class="number">3</span></span><br><span class="line">Output: [<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>] </span><br><span class="line">Explanation: </span><br><span class="line"></span><br><span class="line">Window position                Max</span><br><span class="line">---------------               -----</span><br><span class="line">[<span class="number">1</span>  <span class="number">3</span>  <span class="number">-1</span>] <span class="number">-3</span>  <span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">3</span></span><br><span class="line"> <span class="number">1</span> [<span class="number">3</span>  <span class="number">-1</span>  <span class="number">-3</span>] <span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">3</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span> [<span class="number">-1</span>  <span class="number">-3</span>  <span class="number">5</span>] <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">5</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  <span class="number">-1</span> [<span class="number">-3</span>  <span class="number">5</span>  <span class="number">3</span>] <span class="number">6</span>  <span class="number">7</span>       <span class="number">5</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  <span class="number">-1</span>  <span class="number">-3</span> [<span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>] <span class="number">7</span>       <span class="number">6</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  <span class="number">-1</span>  <span class="number">-3</span>  <span class="number">5</span> [<span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>]      <span class="number">7</span></span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong><br>You may assume k is always valid, 1 ≤ k ≤ input array’s size for non-empty array.</p>
<p><strong>Follow up:</strong><br>Could you solve it in linear time?</p>
<hr>
<p>解：<strong>所有滑动窗口的题目，想到用队列解决。</strong></p>
<p>方法一：暴力求解。枚举窗口的起点位置，因为窗口长度是k,所以枚举起点是0，终点是 length-1 。写一个二重循环，最后时间复杂度是O(n*k)。</p>
<p>方法二：这里用到单调队列(实际就是所谓的双端队列)，可以达到线性的时间复杂度。</p>
<p><font color=#FF0000>双端队列可以操作队列里面的头元素和尾元素，一些API见下图：</font><br><img src="https://s2.ax1x.com/2020/01/11/lIIZSs.png" alt="JDK8 Deque API"></p>
<p>我们通过双端队列维护的一个”单调队列”，从左到右为递减。所以每次对比元素都是peekLast()，弹出元素也是pollLast()</p>
<p>我们用双向队列可以在O(N)时间内解决这题。当我们遇到新的数时，将新的数和双向队列的末尾比较，如果末尾比新数小，则把末尾扔掉，直到该队列的末尾比新数大或者队列为空的时候才住手。这样，我们可以保证队列里的元素是从头到尾降序的，由于队列里只有窗口内的数，所以他们其实就是窗口内第一大，第二大，第三大…的数。保持队列里只有窗口内数的方法和上个解法一样，也是每来一个新的把窗口最左边的扔掉，然后把新的加进去。然而由于我们在加新数的时候，已经把很多没用的数给扔了，这样队列头部的数并不一定是窗口最左边的数。这里的技巧是，我们队列中存的是那个数在原数组中的下标，这样我们既可以直到这个数的值，也可以知道该数是不是窗口最左边的数。这里为什么时间复杂度是O(N)呢？因为每个数只可能被操作最多两次，一次是加入队列的时候，一次是因为有别的更大数在后面，所以被扔掉，或者因为出了窗口而被扔掉。(引用<a href="https://segmentfault.com/a/1190000003903509" target="_blank" rel="noopener">这篇文章</a>)</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>[] maxSlidingWindow(<span class="built_in">int</span>[] nums, <span class="built_in">int</span> k) &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(nums.length == <span class="number">0</span> || k &lt;= <span class="number">0</span>) <span class="keyword">return</span> nums;</span><br><span class="line">		<span class="built_in">int</span> len = nums.length;</span><br><span class="line">		<span class="comment">// 可以自己举个例子，推得这个result大小应该为len-k+1</span></span><br><span class="line">		<span class="built_in">int</span>[] result = new <span class="built_in">int</span>[len - k + <span class="number">1</span>];</span><br><span class="line">		<span class="comment">// store index</span></span><br><span class="line">		<span class="comment">// 注意，dq用于保存数组下标</span></span><br><span class="line">		Deque&lt;Integer&gt; dq = new ArrayDeque&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">			<span class="comment">//这里不需要循环，用一个判断就可 </span></span><br><span class="line">			<span class="comment">//因为我们最多只能在一轮中弹出一个超出范围的元素。（一轮我们只接受一个元素，所以我们最多弹出一个元素）。</span></span><br><span class="line">			<span class="comment">// dq 用于保存数组下标，这也是一个技巧</span></span><br><span class="line">			<span class="keyword">if</span>( !dq.isEmpty() &amp;&amp; dq.peekFirst() == i-k) &#123;</span><br><span class="line">				<span class="comment">// 双端队列中 poll() 相当于 pollFirst(),皮一下</span></span><br><span class="line">				dq.poll();</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 新加入的元素必须比前面的小，否则前面比它小的元素都要出队</span></span><br><span class="line">			<span class="keyword">while</span>(!dq.isEmpty() &amp;&amp; nums[i] &gt;= nums[dq.peekLast()]) &#123;</span><br><span class="line">				dq.pollLast();</span><br><span class="line">			&#125;</span><br><span class="line">			dq.offer(i);</span><br><span class="line">			<span class="comment">// dq是有序的，队列头总是最大的元素，只要下标在范围内，直接peek()即可</span></span><br><span class="line">			<span class="keyword">if</span>(i-k+<span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">				result[i-k+<span class="number">1</span>] = nums[dq.peek()];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<h2 id="84-Largest-Rectangle-in-Histogram-柱状图中最大的矩形-Hard"><a href="#84-Largest-Rectangle-in-Histogram-柱状图中最大的矩形-Hard" class="headerlink" title="84.Largest Rectangle in Histogram(柱状图中最大的矩形)(Hard)"></a><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">84.Largest Rectangle in Histogram(柱状图中最大的矩形)(Hard)</a></h2><h2 id="42-Trapping-Rain-Water-接雨水-Hard"><a href="#42-Trapping-Rain-Water-接雨水-Hard" class="headerlink" title="42.Trapping Rain Water(接雨水)(Hard)"></a><a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">42.Trapping Rain Water(接雨水)(Hard)</a></h2>]]></content>
      <categories>
        <category>Algorithms Note</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Practice by Categories(Array,LinkedList,SkipList)</title>
    <url>/2019/12/28/LeetCode-Practice-by-Categories/</url>
    <content><![CDATA[<blockquote>
<p>天才是长期劳动的结果。 —— 牛顿</p>
</blockquote>
<p>包含大量LeetCode链表、数组相关题目及其解决思路和具体代码。</p>
<a id="more"></a>

<p>点击题目链接为中国站题目，页面附上英文题目。</p>
<p><font color=#FF0000><strong>我总觉得，高超精简的算法，其精彩程度不输好的影视剧！</strong></font></p>
<h1 id="数组、链表、跳表"><a href="#数组、链表、跳表" class="headerlink" title="数组、链表、跳表"></a>数组、链表、跳表</h1><h2 id="283-Move-zeros-移动零-Easy"><a href="#283-Move-zeros-移动零-Easy" class="headerlink" title="283.Move zeros(移动零)(Easy)"></a><a href="https://leetcode-cn.com/problems/move-zeroes/?utm_source=LCUS&utm_medium=ip_redirect_q_uns&utm_campaign=transfer2china" target="_blank" rel="noopener">283.Move zeros(移动零)(Easy)</a></h2><p>Given an array <code>nums</code> , write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.</p>
<p><strong>Examples:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">12</span>]</span><br><span class="line">Output: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ol>
<li>You must do this in-place without making a copy of the array.</li>
<li>Minimize the total number of operations.</li>
</ol>
<hr>
<p>解：这道题可以使用双指针思想很简洁代码解决。用i作为指针，只要之前元素不为0，就把它移动到j的位置上去，把i位置的元素赋值为0. 但是需要注意corner case, 如果传入的数据全都是非0，那么i和j始终相等，不能给任何元素赋值为0.</p>
<p>需要注意指针j什么时候递增，<strong>只要i指的位置不为零，j就要往后移动</strong>，j用来记录从左到右，下一个非0元素的位置.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                nums[j] = nums[i];</span><br><span class="line">                <span class="keyword">if</span>(i != j) &#123;</span><br><span class="line">                    nums[i] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)，一重循环</p>
<p>空间复杂度：O(1)，按照题目要求，不能使用额外数组空间</p>
<h2 id="11-Container-With-Most-Water-盛水最多的容器-Mid"><a href="#11-Container-With-Most-Water-盛水最多的容器-Mid" class="headerlink" title="11.Container With Most Water(盛水最多的容器)(Mid)"></a><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">11.Container With Most Water(盛水最多的容器)(Mid)</a></h2><p>Given n non-negative integers <em>a1, a2, …, an</em> , where each represents a point at coordinate <em>(i, ai)</em>. <em>n</em> vertical lines are drawn such that the two endpoints of line <em>i</em> is at <em>(i, ai)</em> and <em>(i, 0)</em>. Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>
<p><strong>Note</strong>: You may not slant the container and n is at least 2.</p>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg" alt=""></p>
<p>The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.</p>
<p><strong>Example</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">7</span>]</span><br><span class="line">Output: <span class="number">49</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：<strong>方法一</strong>，枚举。记录左边bar x, 右边 bar y，遍历每一个x和y的组合，计算(x-y)*height_diff，但是时间复杂度太高了，O(n^2)，显然不是最优解法。</p>
<p>但是这里可以回顾一下遍历数组的固定写法，形成机械记忆，一定要熟悉。</p>
<p>正常遍历一维数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.length; i++) &#123;</span><br></pre></td></tr></table></figure>

<p>遍历二维数组，实现 i 和 j 两个下标对数组的遍历，而且 i 和 j 不会重复</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; height.length; j++) &#123;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一段二维数组的遍历应当形成肌肉式记忆。 整个遍历过程中，j 总是比 i 大，最后j到了最后一个元素，i还在前面。当然，这种暴力的方式很慢，开销很大。</p>
<p><strong>方法二</strong>，从左边和右边开始往中间收敛（或者理解是左右往中间夹逼）。<strong>因为肯定是外面的棒子组成的面积更大。如果内部的棒子高度也不如外面，那么组成的面积肯定比外面小</strong>，这里可以看做是一个tricky的点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//循环初始条件巧妙，很简洁</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = height.length-<span class="number">1</span>; i &lt; j;) &#123;</span><br><span class="line">            <span class="comment">// 这句话真的很巧妙，也侧面利用了类似i++和++i的语法内容，把下标的挪动放在了比较选择更低的那一端，会更舒服</span></span><br><span class="line">            <span class="keyword">int</span> minHeight = (height[i] &lt; height[j]) ? height[i++] : height[j--];</span><br><span class="line">            <span class="comment">//这里加一是一因为经过上面选择最小内容之后的操作，两个点之间的宽度减小了1，这里加回来</span></span><br><span class="line">            <span class="keyword">int</span> area = (j-i+<span class="number">1</span>) * minHeight;</span><br><span class="line">            max = Math.max(area,max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>i 和 j 是左下标和右下标，哪个棒子更矮，就挪动哪个。</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<h2 id="1-Two-Sum-两数之和-Easy"><a href="#1-Two-Sum-两数之和-Easy" class="headerlink" title="1. Two Sum(两数之和)(Easy)"></a><a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">1. Two Sum(两数之和)(Easy)</a></h2><p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have <strong><em>exactly</em></strong> one solution, and you may not use the same element twice.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Given nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span>,</span><br><span class="line"></span><br><span class="line">Because nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span>,</span><br><span class="line"><span class="keyword">return</span> [<span class="number">0</span>, <span class="number">1</span>].</span><br></pre></td></tr></table></figure>

<hr>
<p>解：<font color=#FF0000>这里给出两个解法，第一个无脑双指针遍历，第二个基于哈希表，是正解。</font></p>
<p><strong>方法一</strong>，两重循环，枚举下标，如果下标对应的内容相加可以达成target，那么完成。但是这种方法时间复杂度较大，O(n^2)</p>
<p>直接可以利用之前讲过的双指针遍历的方法。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>[] twoSum(<span class="built_in">int</span>[] nums, <span class="built_in">int</span> target) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span>[] result = new <span class="built_in">int</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.length<span class="number">-1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = i+<span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    result[<span class="number">0</span>] = i;</span><br><span class="line">                    result[<span class="number">1</span>] = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码可以通过，但是性能怎么样？——某次LeetCode的统计结果是，击败8%用户。<font color=#FF0000>所以如果你面试只想到了这个方法，刷刷写完了，没后续了，还很得意，那对不起，你的面试肯定过不了。除非其他候选者连这个方法都没想到。</font></p>
<p><strong>方法二</strong>,保持数组中的每个元素与其索引相互对应的最好方式是什么？当然是基于数组的哈希表。利用哈希表先把内容存储起来，这样一来查找的过程只需要O(1)了。</p>
<p>这个map中，key是nums元素的值，value是该元素的下标。因为要找到a+b = target,所以 a = target - b，所以查找 target-a 在不在数组里面即可。</p>
<p>注意</p>
<ol>
<li>这里是把元素当做key，该元素的位置当做value。</li>
<li>虽然看起来 <code>map.put(nums[i], i)</code> 这句放在循环体里的前面和后面都可以，但是其实是不能放在前面的，否则如果某个元素的值是target的二分之一，先把它添加进map之后再比较，会直接比较到它自己。换句话说，必须先比较，再put进map。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                result[<span class="number">0</span>] = i;</span><br><span class="line">                result[<span class="number">1</span>] = map.get(target - nums[i]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 注意这里put不能放在判断前面，必须先比较再放入。否则如果某个元素是target的一半，先添加再比较的话，会比较到它自己。</span></span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="15-3Sum-三数之和-Mid"><a href="#15-3Sum-三数之和-Mid" class="headerlink" title="15. 3Sum(三数之和)(Mid)"></a><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">15. 3Sum(三数之和)(Mid)</a></h2><p>Given an array <code>nums</code> of <em>n</em> integers, are there elements <em>a, b, c</em> in <code>nums</code> such that <em>a + b + c</em> = 0? Find all unique triplets in the array which gives the sum of zero.</p>
<p><strong>Note:</strong><br>The solution set must not contain duplicate triplets.(答案不能包含重复三元组)</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Given <span class="built_in">array</span> nums = [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-4</span>],</span><br><span class="line"></span><br><span class="line">A solution <span class="keyword">set</span> <span class="keyword">is</span>:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">2</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<hr>
<p>解：这道三数之和其实是第一题两数之和的升级版本。</p>
<p>方法一：暴力求解，和第一题非常相似，但是时间复杂度为O(n^3)，非常高。</p>
<p>方法二，用类似第一题的哈希表，时间复杂度可以降到O(n^2)</p>
<p>方法三，用左右下标夹逼的方法。其实很难直接想到，比较tricky。</p>
<p>方法三的解法详解：<a href="https://leetcode-cn.com/problems/3sum/solution/hua-jie-suan-fa-15-san-shu-zhi-he-by-guanpengchn/" target="_blank" rel="noopener">点击这里</a></p>
<p>需要注意题目输入的nums中可能有重复的元素；最后返回的答案不能有重复的三元组。</p>
<p>步骤：</p>
<ol>
<li>排序（排好序之后非常利于判重）</li>
<li>循环，因为有3个指针，循环length-2即可</li>
<li>设置判断条件，初始化指针位置</li>
<li>遍历找符合条件的3个数，一路上都要注意判重</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);<span class="comment">// 默认有小到大排序，先排序</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">		<span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="comment">// 有三个指针，循环 nums.length-2 次就够了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len-<span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> || (i &gt; <span class="number">0</span> &amp;&amp; nums[i] != nums[i-<span class="number">1</span>])) &#123; <span class="comment">//第二个条件是去重</span></span><br><span class="line">                <span class="keyword">int</span> lo = i+<span class="number">1</span>, hi = len-<span class="number">1</span>, sum = <span class="number">0</span>-nums[i];</span><br><span class="line">                <span class="keyword">while</span>(lo &lt; hi) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[lo] + nums[hi] == sum) &#123;</span><br><span class="line">                        <span class="comment">// asList是Arrays的工具类，能把数组转化成List，但是注意只能转换包装类，不能转换基本数据类型</span></span><br><span class="line">                    <span class="comment">// 此外asList不支持add和remove方法。</span></span><br><span class="line">                    <span class="comment">// 把所有数组里的内容丢到asList的参数里面来直接把几个数变成list，看得出技巧熟练</span></span><br><span class="line">                        res.add(Arrays.asList(nums[i], nums[lo],nums[hi]));</span><br><span class="line">                        <span class="keyword">while</span>(lo &lt; hi &amp;&amp; nums[lo] == nums[lo+<span class="number">1</span>]) lo++;</span><br><span class="line">                        <span class="keyword">while</span>(lo &lt; hi &amp;&amp; nums[hi] == nums[hi-<span class="number">1</span>]) hi--;</span><br><span class="line">                        lo++;hi--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[lo] + nums[hi] &lt; sum) lo++; <span class="comment">// lo++ 把和变大</span></span><br><span class="line">                    <span class="keyword">else</span> hi--; <span class="comment">// hi-- 把和变小</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="206-Reverse-LinkedList-反转链表-Easy"><a href="#206-Reverse-LinkedList-反转链表-Easy" class="headerlink" title="206. Reverse LinkedList(反转链表)(Easy)"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">206. Reverse LinkedList(反转链表)(Easy)</a></h2><p>Reverse a singly linked list.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL</span><br><span class="line">Output: <span class="number">5</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br></pre></td></tr></table></figure>

<p><strong>Follow up:</strong></p>
<p>A linked list can be reversed either iteratively or recursively. Could you implement both?</p>
<hr>
<p>解：就按照题目，给出迭代(iteratively)和递归(recursively)两种方法的解法。</p>
<p><strong>方法一：迭代</strong></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode reverseList(ListNode head) &#123;</span><br><span class="line">        ListNode <span class="keyword">new</span><span class="type">Header</span> = <span class="literal">null</span>;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="literal">null</span>) &#123;</span><br><span class="line">            ListNode nextTemp = curr.next;</span><br><span class="line">            curr.next = <span class="keyword">new</span><span class="type">Header</span>;</span><br><span class="line">            <span class="keyword">new</span><span class="type">Header</span> = curr;</span><br><span class="line">            curr = nextTemp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span><span class="type">Header</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：递归</strong></p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode <span class="keyword">next</span>;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode reverseList(ListNode<span class="built_in"> head</span>) &#123;</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">if</span><span class="built_in">(head</span> == null ||<span class="built_in"> head</span>.<span class="keyword">next</span> == null) <span class="keyword">return</span><span class="built_in"> head</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode newHeader = reverseList<span class="built_in">(head</span>.<span class="keyword">next</span>);</span><br><span class="line">       <span class="built_in"> head</span>.<span class="keyword">next</span>.<span class="keyword">next</span> =<span class="built_in"> head</span>;</span><br><span class="line">       <span class="built_in"> head</span>.<span class="keyword">next</span> = null;</span><br><span class="line">        <span class="keyword">return</span> newHeader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对递归方法值得注意的是，因为newHeader没有被动过，所以在一开始递归结束的时候，就返回的是反转之后的链表的新的head，也就是这个newHeader，所以最后的结果就是每一层的递归返回的都是一开始递归返回的newHeader，问题就迎刃而解了。</p>
<h2 id="92-Reverse-LinkedList-II-反转链表II-Mid"><a href="#92-Reverse-LinkedList-II-反转链表II-Mid" class="headerlink" title="92. Reverse LinkedList II(反转链表II)(Mid)"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">92. Reverse LinkedList II(反转链表II)(Mid)</a></h2><p>Reverse a linked list from position <em>m</em> to <em>n</em>. Do it in one-pass.</p>
<p>Note: 1 ≤ <em>m ≤ n</em> ≤ length of list.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL, m = <span class="number">2</span>, n = <span class="number">4</span></span><br><span class="line">Output: <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span>-&gt;NULL</span><br></pre></td></tr></table></figure>

<hr>
<p>解：和数组不同，这里的反转下标从1开始。需要初始化一个dummy节点代表0号节点，然后开始遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create a dummy node to mark the head of this list</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>); </span><br><span class="line">        dummy.next = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// make a pointer pre as a marker for the node before reversing</span></span><br><span class="line">        ListNode pre = dummy; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m-<span class="number">1</span>; i++) pre = pre.next;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// a pointer to the beginning of a sub-list that will be reversed</span></span><br><span class="line">        ListNode start = pre.next; </span><br><span class="line">        <span class="comment">// a pointer to a node that will be reversed</span></span><br><span class="line">        ListNode then = start.next; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1 - 2 -3 - 4 - 5 ; m=2; n =4 ---&gt; pre = 1, start = 2, then = 3</span></span><br><span class="line">    <span class="comment">// dummy-&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n-m; i++) &#123;</span><br><span class="line">        start.next = then.next;</span><br><span class="line">        then.next = pre.next;</span><br><span class="line">        pre.next = then;</span><br><span class="line">        then = start.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// first reversing : dummy-&gt;1 - 3 - 2 - 4 - 5; pre = 1, start = 2, then = 4</span></span><br><span class="line">    <span class="comment">// second reversing: dummy-&gt;1 - 4 - 3 - 2 - 5; pre = 1, start = 2, then = 5 (finish)</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="141-Linked-List-Cycle-环形链表-Easy"><a href="#141-Linked-List-Cycle-环形链表-Easy" class="headerlink" title="141. Linked List Cycle(环形链表)(Easy)"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">141. Linked List Cycle(环形链表)(Easy)</a></h2><p>Given a linked list, determine if it has a cycle in it.</p>
<p>To represent a cycle in the given linked list, we use an integer <code>pos</code> which represents the position (0-indexed) in the linked list where tail connects to. If <code>pos</code> is <code>-1</code>, then there is no cycle in the linked list.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: head = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">-4</span>], pos = <span class="number">1</span></span><br><span class="line">Output: <span class="literal">true</span></span><br><span class="line">Explanation: There <span class="keyword">is</span> a cycle <span class="keyword">in</span> the linked list, </span><br><span class="line">where tail connects to the second node.</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt=""></p>
<p><strong>Example 2:</strong></p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">Input:<span class="built_in"> head</span> = [<span class="number">1</span>,<span class="number">2</span>], pos = <span class="number">0</span></span><br><span class="line">Output:<span class="built_in"> true</span></span><br><span class="line">Explanation: There <span class="literal">is</span> a cycle <span class="keyword">in</span> the linked list, <span class="keyword">where</span><span class="built_in"> tail</span> connects <span class="keyword">to</span> the first <span class="type">node</span>.</span><br></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" alt=""></p>
<p><strong>Example 3:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="string">head</span> <span class="string">=</span> <span class="string">[1],</span> <span class="string">pos</span> <span class="string">=</span> <span class="number">-1</span></span><br><span class="line"><span class="attr">Output:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">Explanation:</span> <span class="string">There</span> <span class="string">is</span> <span class="literal">no</span> <span class="string">cycle</span> <span class="string">in</span> <span class="string">the</span> <span class="string">linked</span> <span class="string">list.</span></span><br></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png" alt=""></p>
<p><strong>Follow up:</strong></p>
<p>Can you solve it using O(1) (i.e. constant) memory?</p>
<hr>
<p>解：题目中虽然说会用pos明显标出成环的链表情况，而且貌似人用眼睛可以非常直接地发现，pos只要不是-1就一定有环，但是传入的参数没有pos,不能直接使用它。</p>
<p>判断链表成环可以有思维上的巧妙性，主要是快慢指针的使用。</p>
<p>解法一，用哈希表，但是不符合进阶要求，时间复杂度和空间复杂度都是O(n)</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Definition for singly-linked list.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>class ListNode &#123;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>int val;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>ListNode next;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>ListNode(int x) &#123;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *         </span>val = x;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *         </span>next = null;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>&#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>&#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> */</span></span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    public boolean hasCycle(ListNode head) &#123;</span><br><span class="line">        <span class="built_in">Set</span>&lt;ListNode&gt; <span class="keyword">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">set</span>.contains(head)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">set</span>.add(head);</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，如果没有了解，很难想到的双指针法（其实之前很多题目已经用到了双指针，比如283题移动零、11题盛水容器、15题三数之和等。三数之和甚至用到了三指针。）</p>
<p>时间复杂度为O(n)，但是符合空间复杂度为O(1)的要求因为它是在原有的链表上进行操作。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Definition for singly-linked list.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>class ListNode &#123;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>int val;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>ListNode next;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>ListNode(int x) &#123;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *         </span>val = x;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *         </span>next = null;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>&#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>&#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> */</span></span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    public boolean hasCycle(ListNode head) &#123;</span><br><span class="line">        <span class="comment">// 一开始考虑边界条件，head或head.next可能为空，那么slow或fast就有一个</span></span><br><span class="line">        <span class="comment">// 会是空指针异常了。这个边界条件考虑得很重要</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head.next;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast) &#123;</span><br><span class="line">            <span class="comment">// 只要链表有环，fast和fast.next一定不会为null，会一直走下去</span></span><br><span class="line">            <span class="comment">// 不可能跳出false</span></span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="142-Linked-List-Cycle-II-环形链表II-Mid"><a href="#142-Linked-List-Cycle-II-环形链表II-Mid" class="headerlink" title="142. Linked List Cycle II(环形链表II)(Mid)"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">142. Linked List Cycle II(环形链表II)(Mid)</a></h2><p>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.</p>
<p>To represent a cycle in the given linked list, we use an integer <code>pos</code> which represents the position (0-indexed) in the linked list where tail connects to. If <code>pos</code> is <code>-1</code>, then there is no cycle in the linked list.</p>
<p><strong>Note</strong>: Do not modify the linked list.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">Input:<span class="built_in"> head</span> = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,-<span class="number">4</span>], pos = <span class="number">1</span></span><br><span class="line">Output:<span class="built_in"> tail</span> connects <span class="keyword">to</span> <span class="type">node</span> index <span class="number">1</span></span><br><span class="line">Explanation: There <span class="literal">is</span> a cycle <span class="keyword">in</span> the linked list, <span class="keyword">where</span><span class="built_in"> tail</span> connects <span class="keyword">to</span> the second <span class="type">node</span>.</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt=""></p>
<p><strong>Example 2:</strong></p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">Input:<span class="built_in"> head</span> = [<span class="number">1</span>,<span class="number">2</span>], pos = <span class="number">0</span></span><br><span class="line">Output:<span class="built_in"> tail</span> connects <span class="keyword">to</span> <span class="type">node</span> index <span class="number">0</span></span><br><span class="line">Explanation: There <span class="literal">is</span> a cycle <span class="keyword">in</span> the linked list, <span class="keyword">where</span><span class="built_in"> tail</span> connects <span class="keyword">to</span> the first <span class="type">node</span>.</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" alt=""></p>
<p><strong>Example 3:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="string">head</span> <span class="string">=</span> <span class="string">[1],</span> <span class="string">pos</span> <span class="string">=</span> <span class="number">-1</span></span><br><span class="line"><span class="attr">Output:</span> <span class="literal">no</span> <span class="string">cycle</span></span><br><span class="line"><span class="attr">Explanation:</span> <span class="string">There</span> <span class="string">is</span> <span class="literal">no</span> <span class="string">cycle</span> <span class="string">in</span> <span class="string">the</span> <span class="string">linked</span> <span class="string">list.</span></span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png" alt=""></p>
<p><strong>Follow-up:</strong><br>Can you solve it without using extra space?</p>
<hr>
<p>解：还是两个方法，快慢指针是环形链表相关的常用方法。</p>
<p>方法一，哈希表。虽然不符合进阶要求，但是可以解决。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        Set&lt;ListNode&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        ListNode node = head;</span><br><span class="line">        <span class="keyword">while</span>( node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(visited.contains(node)) &#123;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">            visited.add(node);</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这个方法在空间上开辟了新的空间给哈希表。</p>
<p>方法二，快慢指针，空间复杂度为O(1)</p>
<p>把判断是否有交点单独写成方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二，快慢指针，也叫 Floyd 算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">getIntersect</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// A fast pointer will either loop around a cycle and meet the slow</span></span><br><span class="line">        <span class="comment">// pointer or reach the `null` at the end of a non-cyclic list.</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// If there is a cycle, the fast/slow pointers will intersect at some</span></span><br><span class="line">        <span class="comment">// node. Otherwise, there is no cycle, so we cannot find an entrance to a cycle.</span></span><br><span class="line">        ListNode intersect = getIntersect(head);</span><br><span class="line">        <span class="keyword">if</span> (intersect == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// To find the entrance to the cycle, we have two pointers traverse at</span></span><br><span class="line">        <span class="comment">// the same speed -- one from the front of the list, and the other from</span></span><br><span class="line">        <span class="comment">// the point of intersection.</span></span><br><span class="line">        ListNode ptr1 = head;</span><br><span class="line">        ListNode ptr2 = intersect;</span><br><span class="line">        <span class="keyword">while</span> (ptr1 != ptr2) &#123;</span><br><span class="line">            ptr1 = ptr1.next;</span><br><span class="line">            ptr2 = ptr2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ptr1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="24-Swap-Nodes-in-Pairs-两两交换链表中的节点-Mid"><a href="#24-Swap-Nodes-in-Pairs-两两交换链表中的节点-Mid" class="headerlink" title="24. Swap Nodes in Pairs(两两交换链表中的节点)(Mid)"></a><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">24. Swap Nodes in Pairs(两两交换链表中的节点)(Mid)</a></h2><p>Given a linked list, swap every two adjacent nodes and return its head.</p>
<p>You may <strong>not</strong> modify the values in the list’s nodes, only nodes itself may be changed.</p>
<p><strong>Example:</strong><br><code>Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</code></p>
<hr>
<p>解：<br>方法一，递归，开销较大。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// terminator</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// process current logic</span></span><br><span class="line">        ListNode node = head.next;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// drill down</span></span><br><span class="line">        head.next = swapPairs(node.next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// reverse current state</span></span><br><span class="line">        node.next = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，非递归：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode pre = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode temp = pre;</span><br><span class="line">        pre.next = head;</span><br><span class="line">        <span class="keyword">while</span>(temp.next != <span class="keyword">null</span> &amp;&amp; temp.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode start = temp.next;</span><br><span class="line">            ListNode end = temp.next.next;</span><br><span class="line">            temp.next = end;</span><br><span class="line">            start.next = end.next;</span><br><span class="line">            end.next = start;</span><br><span class="line">            temp = start;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比于递归，非递归的写法实际对链表指针的操作更明显，需要注意在改变指针的过程中需要利用临时指针temp.next和temp.next.next分别定义start和end的位置。将start和end指向的节点反转之后将temp位置改变再重新定义start和end的位置从而重新操作。</p>
<p>具体过程可以如下图所示：</p>
<p><img src="https://s2.ax1x.com/2020/01/04/ldDjSA.jpg" alt="ldDjSA.jpg"></p>
<h2 id="25-Reverse-Nodes-in-k-Group-k个一组翻转链表-Hard"><a href="#25-Reverse-Nodes-in-k-Group-k个一组翻转链表-Hard" class="headerlink" title="25. Reverse Nodes in k-Group(k个一组翻转链表)(Hard)"></a><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">25. Reverse Nodes in k-Group(k个一组翻转链表)(Hard)</a></h2><p>Given a linked list, reverse the nodes of a linked list <em>k</em> at a time and return its modified list.</p>
<p><em>k</em> is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of <em>k</em> then left-out nodes in the end should remain as it is.</p>
<p><strong>Example:</strong></p>
<p>Given this linked list:  <code>1-&gt;2-&gt;3-&gt;4-&gt;5</code></p>
<p>For k = 2, you should return: <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code></p>
<p>For k = 3, you should return: <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code></p>
<p><strong>Note:</strong></p>
<ul>
<li><p>Only constant extra memory is allowed.</p>
</li>
<li><p>You may not alter the values in the list’s nodes, only nodes itself may be changed.</p>
</li>
</ul>
<hr>
<p>解：提供递归和非递归两种解法。</p>
<p>方法一，递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span> &amp;&amp; count != k) &#123; <span class="comment">// To find the k+1 node</span></span><br><span class="line">            curr = curr.next;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(count == k) &#123;</span><br><span class="line">            curr = reverseKGroup(curr, k); <span class="comment">// reverse list with k+1 node as head</span></span><br><span class="line">            <span class="comment">// head - head-pointer to direct part</span></span><br><span class="line">            <span class="comment">// curr - head-pointer to reversed part</span></span><br><span class="line">            <span class="keyword">while</span>(count-- &gt; <span class="number">0</span>) &#123; <span class="comment">// reverse the k-group</span></span><br><span class="line">                ListNode tmp = head.next; <span class="comment">//tmp - next head in direct part</span></span><br><span class="line">                head.next = curr; <span class="comment">// preappending "direct" head to the reversed list</span></span><br><span class="line">                curr = head; <span class="comment">//move head of reversed part to a new node</span></span><br><span class="line">                head = tmp; <span class="comment">// move ""direct" head to the next node in direct part</span></span><br><span class="line">            &#125;</span><br><span class="line">            head = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归写法在找到k组节点之后的反转操作和单纯的链表翻转的节点指针的改变操作相同，即把第206题翻转链表非递归写法提取了出来。</p>
<p>方法二，非递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        </span><br><span class="line">        ListNode pre = dummy;</span><br><span class="line">        ListNode end = dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(end.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k &amp;&amp; end != <span class="keyword">null</span>; i++) &#123;</span><br><span class="line">                end = end.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(end == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode start = pre.next;</span><br><span class="line">            ListNode next = end.next;</span><br><span class="line">            end.next = <span class="keyword">null</span>;</span><br><span class="line">            pre.next = reverse(start);</span><br><span class="line">            start.next = next;</span><br><span class="line">            pre = start;</span><br><span class="line">            end = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode newHeader = <span class="keyword">null</span>;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode nextTemp = curr.next;</span><br><span class="line">            curr.next = newHeader;</span><br><span class="line">            newHeader = curr;</span><br><span class="line">            curr = nextTemp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHeader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细题解：<br><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/solution/tu-jie-kge-yi-zu-fan-zhuan-lian-biao-by-user7208t/" target="_blank" rel="noopener">点击这里</a></p>
<h2 id="25-Remove-Duplicates-from-Sorted-Array-删除排序数组中的重复项-Easy"><a href="#25-Remove-Duplicates-from-Sorted-Array-删除排序数组中的重复项-Easy" class="headerlink" title="25. Remove Duplicates from Sorted Array(删除排序数组中的重复项)(Easy)"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">25. Remove Duplicates from Sorted Array(删除排序数组中的重复项)(Easy)</a></h2><p>Given a sorted array <em>nums</em>, remove the duplicates in-place(原地操作) such that each element appear only <em>once</em> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array in-place</strong> with O(1) extra memory.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">Given nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line"></span><br><span class="line">Your <span class="keyword">function</span> <span class="title">should</span> <span class="keyword">return</span> <span class="type">length</span> = <span class="number">2</span>, <span class="keyword">with</span> the first two elements <span class="keyword">of</span> nums being <span class="number">1</span> <span class="keyword">and</span> <span class="number">2</span> respectively.</span><br><span class="line"></span><br><span class="line">It doesn<span class="symbol">'t</span> matter what you leave beyond the returned length.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">Given nums = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line"></span><br><span class="line">Your function should return length = <span class="number">5</span>, with the first five elements of nums being modified to <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, and <span class="number">4</span> respectively.</span><br><span class="line"></span><br><span class="line">It doesn't matter what values are set beyond the returned length.</span><br></pre></td></tr></table></figure>

<p><strong>Clarfication:</strong><br>Confused why the returned value is an integer but your answer is an array?</p>
<p>Note that the input array is passed in by <strong>reference</strong>, which means modification to the input array will be known to the caller as well.</p>
<p>Internally you can think of this:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// nums is passed in by reference. (i.e., without making a copy)</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">len</span> = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// any modification to nums in your function would be known by the caller.</span></span><br><span class="line"><span class="comment">// using the length returned by your function, it prints the first len elements.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">len</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">print</span>(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>解：</p>
<p>方法一，快慢指针：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 删除重复项之后的数组下标为after_numsLength</span></span><br><span class="line">        <span class="keyword">int</span> after_numslength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// i在前，after_numslength在后，nums[after_numslength]为去重之后的数组</span></span><br><span class="line">            <span class="keyword">if</span>(nums[after_numslength] != nums[i]) &#123;</span><br><span class="line">                after_numslength++;</span><br><span class="line">                nums[after_numslength] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回长度，为下标最大值+1</span></span><br><span class="line">        <span class="keyword">return</span> after_numslength+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，i表示删除元素后数组元素的个数，注意因为i是元素个数，所以判断元素是否重复的时候比较的是”n != nums[i-1]”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> || nums[i-<span class="number">1</span>] != n) &#123;</span><br><span class="line">                nums[i++] = n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="189-Rotate-Array-旋转数组-Easy"><a href="#189-Rotate-Array-旋转数组-Easy" class="headerlink" title="189. Rotate Array(旋转数组)(Easy)"></a><a href="https://leetcode-cn.com/problems/rotate-array/" target="_blank" rel="noopener">189. Rotate Array(旋转数组)(Easy)</a></h2><p>Given an array, rotate the array to the right by <em>k</em> steps, where <em>k</em> is non-negative.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>] <span class="keyword">and</span> k = <span class="number">3</span></span><br><span class="line">Output: [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">Explanation:</span><br><span class="line">rotate <span class="number">1</span> steps to the right: [<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">rotate <span class="number">2</span> steps to the right: [<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">rotate <span class="number">3</span> steps to the right: [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">-1</span>,<span class="number">-100</span>,<span class="number">3</span>,<span class="number">99</span>] <span class="keyword">and</span> k = <span class="number">2</span></span><br><span class="line">Output: [<span class="number">3</span>,<span class="number">99</span>,<span class="number">-1</span>,<span class="number">-100</span>]</span><br><span class="line">Explanation: </span><br><span class="line">rotate <span class="number">1</span> steps to the right: [<span class="number">99</span>,<span class="number">-1</span>,<span class="number">-100</span>,<span class="number">3</span>]</span><br><span class="line">rotate <span class="number">2</span> steps to the right: [<span class="number">3</span>,<span class="number">99</span>,<span class="number">-1</span>,<span class="number">-100</span>]</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ul>
<li><p>Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.</p>
</li>
<li><p>Could you do it in-place with O(1) extra space?</p>
</li>
</ul>
<hr>
<p>解：给出三种解法。</p>
<p>方法一，双重循环，比较暴力。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> rotate(<span class="built_in">int</span>[] nums, <span class="built_in">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// 按照轮次来做，每一轮操作一个数字</span></span><br><span class="line">        <span class="built_in">int</span> len = nums.length;</span><br><span class="line">        <span class="comment">// 如果k太大，甚至比nums还大，那么移动过程会经过了一轮。这里k表示最后要位移的位数</span></span><br><span class="line">        k %= len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="comment">//temp 保存最后一个元素的值</span></span><br><span class="line">            <span class="built_in">int</span> temp = nums[len - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = len<span class="number">-1</span>; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">                nums[j] = nums[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            nums[<span class="number">0</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(kn)</p>
<p>空间复杂度：O(1)</p>
<p>方法二</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> rotate(<span class="built_in">int</span>[] nums, <span class="built_in">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">int</span> nums_length = nums.length;</span><br><span class="line">        k %= nums_length;</span><br><span class="line">        <span class="comment">// 第一次交换完毕后，前 k 位数字位置正确，后 n-k 位数字中最后 k 位数字顺序错误，继续交换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> start = <span class="number">0</span>; start &lt; nums.length &amp;&amp; k != <span class="number">0</span>; nums_length -= k, start += k, k %= nums_length) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">                swap(nums, start + i, nums.length - k + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> <span class="built_in">void</span> swap(<span class="built_in">int</span> [] nums, <span class="built_in">int</span> i, <span class="built_in">int</span> j)&#123;</span><br><span class="line">            <span class="built_in">int</span> temp = nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度:O(n)<br>空间复杂度：O(1)</p>
<p>方法三，翻转，最巧妙。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> rotate(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span> len = nums.length;</span><br><span class="line">        // 如果k太大，甚至比nums还大，那么移动过程会经过一轮，在这里k表示最后要位移的位数。</span><br><span class="line">        k %= len;</span><br><span class="line">        reverse(nums,<span class="number">0</span>,len<span class="number">-1</span>);</span><br><span class="line">        reverse(nums,<span class="number">0</span>,k<span class="number">-1</span>);</span><br><span class="line">        reverse(nums,k,len<span class="number">-1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private <span class="type">void</span> reverse(<span class="type">int</span>[] nums, <span class="type">int</span> <span class="keyword">start</span>, <span class="type">int</span> <span class="keyword">end</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">start</span> &lt; <span class="keyword">end</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="keyword">temp</span> = nums[<span class="keyword">start</span>];</span><br><span class="line">            nums[<span class="keyword">start</span>++] = nums[<span class="keyword">end</span>];</span><br><span class="line">            nums[<span class="keyword">end</span><span class="comment">--] = temp;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>arr = [1,2,3,4,5] –右移两位–&gt; [4,5,1,2,3]<br>假设 n = arr.length，k = 右移位数，可得：  </p>
<pre><code>[1,2,3,4,5] --翻转索引为[0,n-1]之间的元素--&gt; [5,4,3,2,1] 
            --翻转索引为[0,k-1]之间的元素--&gt; [4,5,3,2,1] 
            --翻转索引为[k,n-1]之间的元素--&gt; [4,5,1,2,3]</code></pre><p>注意上面这个区间貌似左和右都是闭合的</p>
<p>旋转数组其实就是把数组分成了两部分，解题关键就是在保证原有顺序的情况下<br>把后面一部分移到前面去。数组整体翻转满足了第二个要素，但是打乱了数组的<br>原有顺序，所以此时再次对两部分进行翻转，让他们恢复到原有顺序（翻转之后<br>再翻转，就恢复成原有顺序了）。没有什么太复杂的思想，但是这种很巧妙的思想或许是神来之笔。</p>
<h2 id="21-Merge-Two-Sorted-Lists-合并两个有序链表-Easy"><a href="#21-Merge-Two-Sorted-Lists-合并两个有序链表-Easy" class="headerlink" title="21. Merge Two Sorted Lists(合并两个有序链表)(Easy)"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">21. Merge Two Sorted Lists(合并两个有序链表)(Easy)</a></h2><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>, <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span></span><br><span class="line">Output: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：<br>方法一，非递归，操作指针。</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        <span class="comment">// 创建合并后链表的虚拟头结点</span></span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode curr = dummyHead;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 若链表不为空，开始合并,实际操作是插入节点</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt; l2.val) &#123;</span><br><span class="line">                curr.<span class="keyword">next</span> = l1;</span><br><span class="line">                l1 = l1.<span class="keyword">next</span>;</span><br><span class="line">                curr = curr.<span class="keyword">next</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr.<span class="keyword">next</span> = l2;</span><br><span class="line">                l2 = l2.<span class="keyword">next</span>;</span><br><span class="line">                curr = curr.<span class="keyword">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 若l1或者l2有一个为空，则直接返回另一条链表</span></span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            curr.<span class="keyword">next</span> = l2;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curr.<span class="keyword">next</span> = l1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummyHead.<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，递归</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        <span class="comment">// 使用recursion，代码虽然简洁，但是可能导致Stack OverFlow</span></span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="literal">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">if</span>(l1.<span class="keyword">val</span> &lt; l2.<span class="keyword">val</span>) &#123;</span><br><span class="line">            l1.next = mergeTwoLists(l1.next,l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            l2.next = mergeTwoLists(l1,l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="88-Merge-Sorted-Array-合并两个有序数组-Easy"><a href="#88-Merge-Sorted-Array-合并两个有序数组-Easy" class="headerlink" title="88. Merge Sorted Array(合并两个有序数组)(Easy)"></a><a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">88. Merge Sorted Array(合并两个有序数组)(Easy)</a></h2><p>Given two sorted integer arrays <em>nums1</em> and <em>nums2</em>, merge <em>nums2</em> into <em>nums1</em> as one sorted array.</p>
<p><strong>Note:</strong></p>
<ul>
<li><p>The number of elements initialized in <em>nums1</em> and <em>nums2</em> are m and n respectively.</p>
</li>
<li><p>You may assume that <em>nums1</em> has enough space (size that is greater or equal to <em>m + n</em>) to hold additional elements from <em>nums2</em>.</p>
</li>
</ul>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], m = <span class="number">3</span></span><br><span class="line">nums2 = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>],       n = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">Output: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure>

<hr>
<p>解：<br>方法一，调用自带函数，但是面试中肯定不允许使用，可以提一嘴</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 方法一，使用java的arraycopy进行nums1和nums2的合并，合并之后再排序即可</span></span><br><span class="line">        System.arraycopy(nums2,<span class="number">0</span>,nums1,m,n);</span><br><span class="line">        <span class="comment">// 使用工具类Arrays的排序方法</span></span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，使用从后往前的指针，一共三个指针，分别在在nums1元素的最后位置、nums1长度的最后位置和nums2的最后位置。每次进行比较，直到nums1或nums2被遍历完为止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 更加酷，不需要开辟额外空间，直接在nums1的末尾开始，用三个指针从后往前</span></span><br><span class="line">        <span class="comment">// two pointers for nums1 and nums2</span></span><br><span class="line">        <span class="keyword">int</span> p1 = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> p2 = n - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// set pointer for nums1</span></span><br><span class="line">        <span class="keyword">int</span> p = m + n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// while there are still elements to compare</span></span><br><span class="line">        <span class="keyword">while</span>((p1 &gt;= <span class="number">0</span>) &amp;&amp; (p2 &gt;= <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">// compare two elements from nums1 and nums2 and add the largest</span></span><br><span class="line">            <span class="comment">// one in nums1</span></span><br><span class="line">            nums1[p--] = (nums1[p1] &lt; nums2[p2]) ? nums2[p2--] : nums1[p1--];</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="comment">// add missing elements from nums2</span></span><br><span class="line">            <span class="comment">// 如果先触发了p1 &lt; 0的条件，nums2不再能copy了，需要手动arraycopy过去</span></span><br><span class="line">            System.arraycopy(nums2, <span class="number">0</span>, nums1, <span class="number">0</span>, p2 + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="66-Plus-One-加一-Easy"><a href="#66-Plus-One-加一-Easy" class="headerlink" title="66. Plus One(加一)(Easy)"></a><a href="https://leetcode-cn.com/problems/plus-one/" target="_blank" rel="noopener">66. Plus One(加一)(Easy)</a></h2><p>Given a <strong>non-empty</strong> array of digits representing a non-negative integer, plus one to the integer.</p>
<p>The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.</p>
<p>You may assume the integer does not contain any leading zero, except the number 0 itself.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">Output: [1,2,4]</span><br><span class="line">Explanation: The<span class="built_in"> array </span>represents the integer 123.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">Output: [<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">Explanation: The <span class="built_in">array</span> represents the <span class="built_in">int</span>eger <span class="number">4321.</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>[] plusOne(<span class="built_in">int</span>[] digits) &#123;</span><br><span class="line">        <span class="built_in">int</span> len = digits.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            digits[i]++;</span><br><span class="line">            digits[i] %= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(digits[i] != <span class="number">0</span>) <span class="keyword">return</span> digits;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若digits起初所有元素都为9，则需要新开辟一位</span></span><br><span class="line">        digits = new <span class="built_in">int</span>[len + <span class="number">1</span>];</span><br><span class="line">        digits[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="83-Remove-Duplicates-from-Sorted-List-删除排序链表中的重复元素-Easy"><a href="#83-Remove-Duplicates-from-Sorted-List-删除排序链表中的重复元素-Easy" class="headerlink" title="83. Remove Duplicates from Sorted List(删除排序链表中的重复元素)(Easy)"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">83. Remove Duplicates from Sorted List(删除排序链表中的重复元素)(Easy)</a></h2><p>Given a sorted linked list, delete all duplicates such that each element appear only once.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span></span><br><span class="line">Output: <span class="number">1</span>-&gt;<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">3</span></span><br><span class="line">Output: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：比较简单，只是考察操作链表节点指针的能力。因为传入的链表已经排序，我们只需要比较当前节点和它之后节点的值是否相等即可，如果相等，让当前节点指针跳过下一个节点，指向下一个节点的next即可。</p>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> singly-linked list.</span><br><span class="line"> * <span class="keyword">public</span> <span class="keyword">class</span> ListNode &#123;</span><br><span class="line"> *     <span class="built_in">int</span> val;</span><br><span class="line"> *     ListNode <span class="keyword">next</span>;</span><br><span class="line"> *     ListNode(<span class="built_in">int</span> x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode deleteDuplicates(ListNode head) &#123;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="literal">null</span> &amp;&amp; curr.<span class="keyword">next</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(curr.val == curr.<span class="keyword">next</span>.val) &#123;</span><br><span class="line">                curr.<span class="keyword">next</span> = curr.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr = curr.<span class="keyword">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h2 id="82-Remove-Duplicates-from-Sorted-List-II-删除排序链表中的重复元素-II-Mid"><a href="#82-Remove-Duplicates-from-Sorted-List-II-删除排序链表中的重复元素-II-Mid" class="headerlink" title="82. Remove Duplicates from Sorted List II(删除排序链表中的重复元素 II)(Mid)"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/submissions/" target="_blank" rel="noopener">82. Remove Duplicates from Sorted List II(删除排序链表中的重复元素 II)(Mid)</a></h2><p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span></span><br><span class="line">Output: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span></span><br><span class="line">Output: <span class="number">2</span>-&gt;<span class="number">3</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：</p>
<p>方法一，非递归。</p>
<p>重复的元素直接彻底跳过而不是去重，难度上升变成中等。方法中定义虚拟节点FakeNode(用于处理开头节点就是重复节点的情况，最后一定要返回FakeNode.next)、pre节点(用于直接跳过重复的所有元素)、cur(判断当前节点是否为重复元素的节点)</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode deleteDuplicates(ListNode head) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> ) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode FakeNode = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        FakeNode.<span class="keyword">next</span> = head;</span><br><span class="line">        ListNode pre = FakeNode;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span> ) &#123;</span><br><span class="line">            <span class="comment">// cur 标记是否当前节点为重复节点，用pre进行过滤，链起来一个新链表</span></span><br><span class="line">            <span class="comment">// cur为重复元素的最后一个结点</span></span><br><span class="line">            <span class="comment">// 不能把cur.next != null 放入大循环条件，否则可能报空指针</span></span><br><span class="line">            <span class="keyword">while</span>(cur.<span class="keyword">next</span> != <span class="keyword">null</span> &amp;&amp; cur.val == cur.<span class="keyword">next</span>.val) &#123;</span><br><span class="line">                cur = cur.<span class="keyword">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若pre的下一个节点就是cur，说明cur当前元素不是重复的，不需要跳过</span></span><br><span class="line">            <span class="comment">// 反之，根据题意需要跳过cur指向的找到的重复的最后一个结点</span></span><br><span class="line">            <span class="keyword">if</span>(pre.<span class="keyword">next</span> == cur) &#123;</span><br><span class="line">                pre = pre.<span class="keyword">next</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre.<span class="keyword">next</span> = cur.<span class="keyword">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 相比83题简单地去重，这里需要判断cur重复之后还要删除重复元素，使用pre指针</span></span><br><span class="line">            <span class="comment">// 所以不是简单地在判断元素重复之后直接进入下一元素，而是经过一个循环和一个判断之后才可以</span></span><br><span class="line">            cur = cur.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> FakeNode.<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，递归。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> ) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(head.next != <span class="keyword">null</span> &amp;&amp; head.val == head.next.val) &#123;</span><br><span class="line">            <span class="keyword">while</span>(head.next != <span class="keyword">null</span> &amp;&amp; head.val == head.next.val) &#123;</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> deleteDuplicates(head.next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head.next = deleteDuplicates(head.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="203-Remove-Linked-List-Elements-移除链表元素-Easy"><a href="#203-Remove-Linked-List-Elements-移除链表元素-Easy" class="headerlink" title="203. Remove Linked List Elements(移除链表元素)(Easy)"></a><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/" target="_blank" rel="noopener">203. Remove Linked List Elements(移除链表元素)(Easy)</a></h2><p>Remove all elements from a linked list of integers that have value <strong><em>val</em></strong>.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input:  <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">6</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span>, val = <span class="number">6</span></span><br><span class="line">Output: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：<br>方法一，递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode next = removeElements(head.next, val);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(head.val == val) <span class="keyword">return</span> next;</span><br><span class="line">        </span><br><span class="line">        head.next = next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，非递归，迭代，定义虚拟节点</p>
<p>需要注意，如果第一个元素的值是val,无法返回头结点。所以自然想到需要dummyuNode(或者叫做FakeNode)。当遇到含有val的值的时候，比如2-&gt;6-&gt;3，val是6，此时需要赋值：2.next=2.next.next，和83题的操作同样很类似。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode fakeNode = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        fakeNode.next = head;</span><br><span class="line">        ListNode curr = fakeNode;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span> &amp;&amp; curr.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(curr.next.val == val) &#123;</span><br><span class="line">                curr.next = curr.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fakeNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法三，非递归，不使用虚拟节点，单纯删除节点，只是头结点值为val的时候需要单独考虑。(删除节点操作很简单,很类似83题，只是83题是和 x.next 去比较val是否相同，而这道题比较当前节点的 val 是否和传入的val相同)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span> &amp;&amp; head.val == val) &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果没有这个判断，curr.next在corner edge情况下很可能会报空指针</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span> &amp;&amp; curr.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(curr.next.val == val) &#123;</span><br><span class="line">                curr.next = curr.next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr = curr.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="237-Delete-Node-in-a-Linked-List-删除链表中的节点-Easy"><a href="#237-Delete-Node-in-a-Linked-List-删除链表中的节点-Easy" class="headerlink" title="237. Delete Node in a Linked List(删除链表中的节点)(Easy)"></a><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/" target="_blank" rel="noopener">237. Delete Node in a Linked List(删除链表中的节点)(Easy)</a></h2><p>Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.</p>
<p>Given linked list – head = [4,5,1,9], which looks like following:</p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/28/237_example.png" alt=""></p>
<p><strong>Example 1:</strong></p>
<p>Input: head = [4,5,1,9], node = 5<br>Output: [4,1,9]<br>Explanation: You are given the second node with value 5, the linked list should become 4 -&gt; 1 -&gt; 9 after calling your function.</p>
<p><strong>Example 2:</strong></p>
<p>Input: head = [4,5,1,9], node = 1<br>Output: [4,5,9]<br>Explanation: You are given the third node with value 1, the linked list should become 4 -&gt; 5 -&gt; 9 after calling your function.</p>
<p><strong>Note:</strong></p>
<ul>
<li>The linked list will have at least two elements.</li>
<li>All of the nodes’ values will be unique.</li>
<li>The given node will not be the tail and it will always be a valid node of the linked list.</li>
<li>Do not return anything from your function.</li>
</ul>
<hr>
<p>解：<br>注意，这道题只是考如何删除某个指定的节点，考的就是在无法知道这个节点前面指针的时候该如何操作。感觉和脑筋急转弯差不多。</p>
<p>因为我们不能操作这个节点前面的节点的next指针，所以要删除当前这个节点，就只能把下一个节点的值赋给当前这个节点，然后让当前节点跳过下一个节点。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public void deleteNode(ListNode <span class="keyword">node</span><span class="title">) &#123;</span></span><br><span class="line"><span class="title">        node</span>.val = <span class="keyword">node</span>.<span class="title">next</span>.val;</span><br><span class="line">        <span class="keyword">node</span>.<span class="title">next</span> = <span class="keyword">node</span>.<span class="title">next</span>.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Algorithms Note</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Object-oriented(OOP)</title>
    <url>/2019/12/25/Object-oriented-OOP/</url>
    <content><![CDATA[<p><img src="https://s2.ax1x.com/2019/12/30/lKcqcd.md.jpg" alt=""></p>
<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>Design Pattern</title>
    <url>/2019/12/25/Design-Pattern/</url>
    <content><![CDATA[<blockquote>
<p>看待事物都可以按照这个顺序：发现问题、分析问题、理顺逻辑、寻求证据、解决问题</p>
</blockquote>
<p>设计模式相关内容介绍，尤其着重Java的单例模拟，看完必有收获。</p>
<a id="more"></a>

<h1 id="如何用java写一个单例模式？"><a href="#如何用java写一个单例模式？" class="headerlink" title="如何用java写一个单例模式？"></a>如何用java写一个单例模式？</h1><p>单例模式虽然看起来简单，但是如果往深了挖，又可以考察出候选者对于并发、类加载、序列化等知识点的掌握。</p>
<h2 id="什么是单例模式？"><a href="#什么是单例模式？" class="headerlink" title="什么是单例模式？"></a>什么是单例模式？</h2><p>一个类只有一个实例，并且提供一个全局可以访问的入口(比如getInstance()方法)。比如《火影忍者》中漩涡鸣人特别喜欢用的影分身之术，实际上，每一个影分身都只对应着一个真身。</p>
<p>为什么要有只有一个实例的这种类？我们为什么需要它？</p>
<p><strong>理由一：</strong>为了节省内存、节省计算。很多情况下，我们只需要一个实例，如果出现了更多实例，反而是浪费。</p>
<p>举例：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">ExpensiveResource</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ExpensiveResource() &#123;</span><br><span class="line">        field1 = <span class="comment">// 查询数据库</span></span><br><span class="line">        field2 = <span class="comment">// 对查到的数据做大量计算</span></span><br><span class="line">        field3 = <span class="comment">// 加密、压缩等耗时操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类在构造的时候，需要查询数据库，对查到的数据做大量的计算，然后还要进行加密、压缩等非常耗时的操作。所以在第一次构造这个类的时候，我们就要花费很多时间来初始化这个对象。</p>
<p>假设数据库在一段时间不变，那么我们其实只需要使用这一个实例完成任务即可。如果每次都重新生成新的实例，浪费资源，十分没有必要。</p>
<p><strong>理由二：</strong>为了保证结果的正确。比如我们需要一个全局计数器用来统计人数。如果有多个实例，反而会造成混乱。</p>
<p><strong>理由三：</strong>方便管理。很多工具类，我们只需要一个实例，通过一个统一的入口，获取这个单例。太多实例不但没有帮助，只会让人眼花缭乱。</p>
<h2 id="单例模式使用场景？"><a href="#单例模式使用场景？" class="headerlink" title="单例模式使用场景？"></a>单例模式使用场景？</h2><ol>
<li><p><strong>无状态的工具类：日志工具、字符串工具等</strong>。——日志工具，不论在哪里使用，我们只需要它帮我们记录日志信息，除此功能之外并不需要在它的实例对象上存储任何状态，所以我们只需要一个实例对象就可以了。</p>
</li>
<li><p><strong>全局信息类：全局计数、环境变量</strong>。——比如我们要记录某个网站的访问次数，而且不希望有的访问记录被记录在对象A上，而有的被记录在对象B上。此时我们就可以让这个类为单例，在需要计数的时候拿出来用就可以了。</p>
</li>
</ol>
<p><font color=#FF0000>单例模式常见写法，这里列举五种：饿汉式、懒汉式、双重检查式、静态内部类式、枚举式</font></p>
<h2 id="单例模式的实现"><a href="#单例模式的实现" class="headerlink" title="单例模式的实现"></a>单例模式的实现</h2><p>下面按照写法的难易程度逐层递进：<br>相对简单的<strong>饿汉式：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 饿汉式写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类的第一行，用static修饰实例，并且把构造函数用private修饰。</p>
<p><strong>饿汉式优点：</strong>这种写法比较简单，在类装载的时候就完成了实例化，避免了线程同步的问题。</p>
<p><strong>饿汉式缺点：</strong>类装载的时候就完成了实例化，没有达到懒加载的效果，这点是最大缺陷。所以如果自始至终都没使用过这个实例，就可能会造成内存的浪费。</p>
<p>饿汉式写法的变种：<strong>静态代码块</strong>形式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 饿汉式另一种写法，静态代码块</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法和最开始的饿汉式的方式类似，只是把类实例化的过程放在了静态代码块中。同样，在类装载的过程中会执行静态代码块中的代码，完成实例的初始化，所以静态代码块的优缺点和饿汉式是一样的。<em>静态代码块写法就是饿汉式的写法。</em></p>
<p>接下来看第二种<strong>懒汉式</strong>。</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线程不安全的懒汉式写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是需要注意，上面这个懒汉式写法只能用于多线程。因为如果一个线程进入了 <code>if(singleton == null)</code> 判断语句块，还没来得及往下执行，另一个线程也通过了这个判断语句，此时会多次创建实例。所以这里需要注意，在多线程环境下，不能用上面这种懒汉式写法，它是错误的。</p>
<p>当然，懒汉式写法可以进行升级，让其成为线程安全的懒汉式写法。升级之后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线程安全的懒汉式写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加上了synchronized关键字，为了解决刚才的线程安全问题。<strong>缺点是效率太低了</strong>，每个线程在想获得类的实例的时候，执行getInstance的时候都要进行同步，虽然保证了多个线程不能同时访问，但是这在大多数情况下是没有必要的。</p>
<p>为了解决这个问题，衍生出了<strong>双重检查模式</strong>。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双重检查模式写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点在getInstance方法，我们进行了两次 <code>if(singleton == null)</code> 的判断，这样可以保证线程安全了。可以想象，在第一次初始化了singleton对象之后，再次调用代码块的时候，第一个if判断就可以让执行跳过整个代码块，返回之前已经初始化过的singleton,避免破坏单例。</p>
<p>这种写法的优势是，不仅保证了线程安全，而且延迟加载，效率也更高。</p>
<p>这里会有一个面试经常会问到的问题：”为什么要有两个if判断呢？去掉第二个if，可以么？(或者说，为什么要double-check?去掉第二个check行不行呢？)”</p>
<p>结论是，不行。为什么不行？我们来考虑这样的情景：</p>
<p>有两个线程同时调用getInstance()方法，由于singleton是空的，所以两个线程都可以通过第一重if判断。然后由于锁机制的存在，会有一个线程进入到第二个判断语句，而另一个线程会在外等候。过了一小段时间，第一个线程完成了对singleton的创建操作，它会退出synchronized的保护区域。此时第二个线程会进入到运行区域。此时如果没有第二个if判断，那么第二个线程也会创建一个实例，这就破坏了单例，这肯定是不行的。</p>
<p>当然，第一个check也是不能去掉的。如果去掉了第一个check,那么所有线程都会串行执行，效率低下。所以，<strong>两个check都是需要保留的</strong>。</p>
<p>此外，在双重检查模式中，我们给singleton加了 <code>volatile</code> 关键字。为什么要增加volatile呢？</p>
<p>原因在于， <code>singleton = new Singleton();</code> 这句话不是一个原子操作。事实上，在JVM中，这句话至少做了<strong>3件事</strong>：</p>
<ol>
<li>给singleton分配内存空间</li>
<li>调用Singleton的构造函数等来初始化singleton</li>
<li>将singleton对象指向分配的内存空间(执行完这步，singleton就不是Null了)</li>
</ol>
<p>但是这里需要注意1、2、3步骤的顺序。因为存在着重排序的优化。也就是说，<strong>第二步和第三步这两者的顺序是不能保证的</strong>。</p>
<p>最终的执行顺序可能是1-2-3，也可能是1-3-2。如果是1-3-2，那么如果第一个线程正在创建的时候，另一个线程也进来了，那么在进行第一重判断的时候会直接跳过整个代码块，直接返回singleton对象。而此时因为singleton还没有被初始化，所以会有空指针报错。哪怕最后线程1最后的初始化了，但是只是姗姗来迟，程序已经报错了。</p>
<p>用图解详细分析一下：<br><img src="https://s2.ax1x.com/2020/01/10/lfTzJs.png" alt="lfTzJs.png"></p>
<p>总结用volatile的原因：<strong>它可以防止上面重排序的发生，可以避免拿到未完成初始化的对象。</strong></p>
<p>下面来看静态内部类的写法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态内部类写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span> &#123;</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法和饿汉式所采用的机制类似，都才用了类装载的机制：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以此保证我们初始化实例时只有一个线程，而且是JVM帮助我们保证了线程安全性。</p>
<p>但是，饿汉式有一个特点，就是只要Singleton这个类被加载了，就会实例化单例对象。而静态内部类方式在Singleton类被装载的时候，并不会立刻实例化，而是在需要实例的时候，也就是调用getInstance()方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SingletonInstance.singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>的时候，才会去完成对singleton实例的实例化。</p>
<p><strong>静态内部类写法优点：</strong></p>
<ol>
<li>代码简洁，和双重检查的单例模式对比，静态内部类的单例实现代码更加简洁，清晰明了。</li>
<li>延迟初始化，调用getInstance()才会初始化Singleton对象。</li>
<li>线程安全。JVM在执行类的初始化阶段，会获得一个可以同步多个线程对同一个类的初始化锁。</li>
</ol>
<p>在介绍枚举写法之前，做一个小总结：</p>
<p><strong>静态内部类的写法与双重检查模式的优点是一样的，都避免了线程不安全的问题，并且延迟加载，效率高。</strong></p>
<p>可以看出，静态内部类和双重检查都是不错的写法。但是这两种方法都有一个缺陷：<strong>不能防止被反序列化。</strong></p>
<p>最后，枚举类的写法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 枚举类写法实现单例模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whatereverMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举类是在JDK1.5之后新增的方法。它不仅可以避免多线程同步的问题，而且还能防止反序列化和反射(这两种方法可以创建新的对象)破坏单例模式。</p>
<p>上面讲了五种方式，但是可以说，实现单例模式最好的方式，是利用枚举。这个观点其实是Josh Bloch的。他曾经在Effective Java中写道：”使用枚举实现单例的方法，虽然还没有被广泛采用，但是单元素的枚举类型应成为了实现Singleton的最佳方法。”</p>
<p>他如此推崇枚举，主要还是因为枚举写法的优点：</p>
<ol>
<li>代码简洁。枚举的写法不需要我们去考虑懒加载或者线程安全等问题。同时，代码短小精悍，比其他任何写法都更加简洁。</li>
<li>线程安全有保障。通过反编译枚举类，我们可以发现枚举种的各个枚举项，都是通过static代码块来定义和初始化的。他们会在类被加载的时候完成初始化。而java类的加载由JVM保证线程安全。所以，创建一个Enum类型的枚举是线程安全的。</li>
<li>最重要的优点：<strong>防止破坏单例</strong>。java专门对枚举的序列化做了单独的规定。在<strong>序列化</strong>的时候，仅仅会将枚举对象的name属性输出到结果中。而在反序列化时，会通过 <code>java.lang.Enum</code> 的valueOf方法来根据名字查找对象，而不会新建一个新的对象。这就防止了反序列化导致的单例破坏问题的出现。而针对<strong>反射</strong>，枚举类同样有防御措施。反射在通过newInstance创建对象时，会检查这个类是否是枚举类。如果是，会抛出： <code>IllegalArgumentException(&quot;Cannot reflecatively create enum objects&quot;)</code> 这个异常，反射创建对象会失败。可以说，java针对枚举做的工作是非常全面的，枚举，是java亲生的。</li>
</ol>
<p>可以看出，枚举这种方式可以防止反序列化和反射破坏单例，在这一点上与其他方式相比，优势巨大。安全问题不容小觑，一旦通过反序列化或者反射生成了多个实例，那么单例模式就彻底没用了。</p>
<p>总结：<br><img src="https://s2.ax1x.com/2020/01/10/lhCFII.png" alt="lhCFII.png"></p>
<p>需要注意，如果使用了线程不安全的写法，在并发的情况下可能产生多个实例，那么不仅会影响性能，更可能造成数据错误等严重的后果。</p>
<p>回答面试问题过程中，可以先从饿汉式、懒汉式说起，一步一步地分析每一种的优缺点，并且对写法进行演进。重点需要关注，<strong>双重检查模式为什么需要两次检查？为什么要是用volatile关键字？</strong>最后再说枚举类写法的优点和其背后的原理。</p>
<p>此外，在工作中，如果遇到了<strong>全局信息类、无状态工具类</strong>等场景，推荐使用枚举的写法实现单例模式。</p>
]]></content>
      <categories>
        <category>Study Note</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
        <tag>Foundation</tag>
      </tags>
  </entry>
</search>
