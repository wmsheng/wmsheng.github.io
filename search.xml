<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LeetCode Practice by Categories(Array,LinkedList,SkipList)</title>
    <url>/2019/12/28/LeetCode-Practice-by-Categories/</url>
    <content><![CDATA[<blockquote>
<p>Genius is the result of long-term labor —— Isaac Newton</p>
</blockquote>
<p>Analyse and record questions’ answers by classification</p>
<a id="more"></a>

<p>点击题目链接为中国站题目，页面附上英文题目。</p>
<h1 id="数组、链表、跳表"><a href="#数组、链表、跳表" class="headerlink" title="数组、链表、跳表"></a>数组、链表、跳表</h1><h2 id="283-Move-zeros-移动零-Easy"><a href="#283-Move-zeros-移动零-Easy" class="headerlink" title="283.Move zeros(移动零)(Easy)"></a><a href="https://leetcode-cn.com/problems/move-zeroes/?utm_source=LCUS&utm_medium=ip_redirect_q_uns&utm_campaign=transfer2china" target="_blank" rel="noopener">283.Move zeros(移动零)(Easy)</a></h2><p>Given an array <code>nums</code> , write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.</p>
<p><strong>Examples:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">12</span>]</span><br><span class="line">Output: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ol>
<li>You must do this in-place without making a copy of the array.</li>
<li>Minimize the total number of operations.</li>
</ol>
<hr>
<p>解：这道题可以使用双指针思想很简洁代码解决。用i作为指针，只要之前元素不为0，就把它移动到j的位置上去，把i位置的元素赋值为0. 但是需要注意corner case, 如果传入的数据全都是非0，那么i和j始终相等，不能给任何元素赋值为0.</p>
<p>需要注意指针j什么时候递增，<strong>只要i指的位置不为零，j就要往后移动</strong>，j用来记录从左到右，下一个非0元素的位置.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                nums[j] = nums[i];</span><br><span class="line">                <span class="keyword">if</span>(i != j) &#123;</span><br><span class="line">                    nums[i] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)，一重循环</p>
<p>空间复杂度：O(1)，按照题目要求，不能使用额外数组空间</p>
<h2 id="11-Container-With-Most-Water-盛水最多的容器-Mid"><a href="#11-Container-With-Most-Water-盛水最多的容器-Mid" class="headerlink" title="11.Container With Most Water(盛水最多的容器)(Mid)"></a><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">11.Container With Most Water(盛水最多的容器)(Mid)</a></h2><p>Given n non-negative integers <em>a1, a2, …, an</em> , where each represents a point at coordinate <em>(i, ai)</em>. <em>n</em> vertical lines are drawn such that the two endpoints of line <em>i</em> is at <em>(i, ai)</em> and <em>(i, 0)</em>. Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>
<p><strong>Note</strong>: You may not slant the container and n is at least 2.</p>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg" alt=""></p>
<p>The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.</p>
<p><strong>Example</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">7</span>]</span><br><span class="line">Output: <span class="number">49</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：<strong>方法一</strong>，枚举。记录左边bar x, 右边 bar y，遍历每一个x和y的组合，计算(x-y)*height_diff，但是时间复杂度太高了，O(n^2)，显然不是最优解法。</p>
<p>但是这里可以回顾一下遍历数组的固定写法，形成机械记忆，一定要熟悉。</p>
<p>正常遍历一维数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.length; i++) &#123;</span><br></pre></td></tr></table></figure>

<p>遍历二维数组，实现 i 和 j 两个下标对数组的遍历，而且 i 和 j 不会重复</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; height.length; j++) &#123;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一段二维数组的遍历应当形成肌肉式记忆。 整个遍历过程中，j 总是比 i 大，最后j到了最后一个元素，i还在前面。当然，这种暴力的方式很慢，开销很大。</p>
<p><strong>方法二</strong>，从左边和右边开始往中间收敛（或者理解是左右往中间夹逼）。<strong>因为肯定是外面的棒子组成的面积更大。如果内部的棒子高度也不如外面，那么组成的面积肯定比外面小</strong>，这里可以看做是一个tricky的点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//循环初始条件巧妙，很简洁</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = height.length-<span class="number">1</span>; i &lt; j;) &#123;</span><br><span class="line">            <span class="comment">// 这句话真的很巧妙，也侧面利用了类似i++和++i的语法内容，把下标的挪动放在了比较选择更低的那一端，会更舒服</span></span><br><span class="line">            <span class="keyword">int</span> minHeight = (height[i] &lt; height[j]) ? height[i++] : height[j--];</span><br><span class="line">            <span class="comment">//这里加一是一因为经过上面选择最小内容之后的操作，两个点之间的宽度减小了1，这里加回来</span></span><br><span class="line">            <span class="keyword">int</span> area = (j-i+<span class="number">1</span>) * minHeight;</span><br><span class="line">            max = Math.max(area,max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>i 和 j 是左下标和右下标，哪个棒子更矮，就挪动哪个。</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<h2 id="1-Two-Sum-两数之和-Easy"><a href="#1-Two-Sum-两数之和-Easy" class="headerlink" title="1 Two Sum.(两数之和)(Easy)"></a><a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">1 Two Sum.(两数之和)(Easy)</a></h2><p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have <strong><em>exactly</em></strong> one solution, and you may not use the same element twice.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Given nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span>,</span><br><span class="line"></span><br><span class="line">Because nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span>,</span><br><span class="line"><span class="keyword">return</span> [<span class="number">0</span>, <span class="number">1</span>].</span><br></pre></td></tr></table></figure>

<hr>
<p>解：<font color=#FF0000>这里给出两个解法，第一个无脑双指针遍历，第二个基于哈希表，是正解。</font></p>
<p><strong>方法一</strong>，两重循环，枚举下标，如果下标对应的内容相加可以达成target，那么完成。但是这种方法时间复杂度较大，O(n^2)</p>
<p>直接可以利用之前讲过的双指针遍历的方法。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>[] twoSum(<span class="built_in">int</span>[] nums, <span class="built_in">int</span> target) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span>[] result = new <span class="built_in">int</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.length<span class="number">-1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = i+<span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    result[<span class="number">0</span>] = i;</span><br><span class="line">                    result[<span class="number">1</span>] = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码可以通过，但是性能怎么样？——某次LeetCode的统计结果是，击败8%用户。<font color=#FF0000>所以如果你面试只想到了这个方法，刷刷写完了，没后续了，还很得意，那对不起，你的面试肯定过不了。除非其他候选者连这个方法都没想到。</font></p>
<p><strong>方法二</strong>,保持数组中的每个元素与其索引相互对应的最好方式是什么？当然是基于数组的哈希表。利用哈希表先把内容存储起来，这样一来查找的过程只需要O(1)了。</p>
<p>这个map中，key是nums元素的值，value是该元素的下标。因为要找到a+b = target,所以 a = target - b，所以查找 target-a 在不在数组里面即可。</p>
<p>注意</p>
<ol>
<li>这里是把元素当做key，该元素的位置当做value。</li>
<li>虽然看起来 <code>map.put(nums[i], i)</code> 这句放在循环体里的前面和后面都可以，但是其实是不能放在前面的，否则如果某个元素的值是target的二分之一，先把它添加进map之后再比较，会直接比较到它自己。换句话说，必须先比较，再put进map。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                result[<span class="number">0</span>] = i;</span><br><span class="line">                result[<span class="number">1</span>] = map.get(target - nums[i]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 注意这里put不能放在判断前面，必须先比较再放入。否则如果某个元素是target的一半，先添加再比较的话，会比较到它自己。</span></span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="15-3Sum-三数之和-Mid"><a href="#15-3Sum-三数之和-Mid" class="headerlink" title="15 3Sum.(三数之和)(Mid)"></a><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">15 3Sum.(三数之和)(Mid)</a></h2><p>Given an array <code>nums</code> of <em>n</em> integers, are there elements <em>a, b, c</em> in <code>nums</code> such that <em>a + b + c</em> = 0? Find all unique triplets in the array which gives the sum of zero.</p>
<p><strong>Note:</strong><br>The solution set must not contain duplicate triplets.(答案不能包含重复三元组)</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Given <span class="built_in">array</span> nums = [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-4</span>],</span><br><span class="line"></span><br><span class="line">A solution <span class="keyword">set</span> <span class="keyword">is</span>:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">2</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>解：这道三数之和其实是第一题两数之和的升级版本。</p>
<p>方法一：暴力求解，和第一题非常相似，但是时间复杂度为O(n^3)，非常高。</p>
<p>方法二，用类似第一题的哈希表，但是时间复杂度只能降到O(n^2)</p>
<p>方法三，用左右下标夹逼的方法。其实很难直接想到，比较tricky。</p>
<p>详细介绍方法三的解法。</p>
]]></content>
      <categories>
        <category>Algorithms Note</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Object-oriented(OOP)</title>
    <url>/2019/12/25/Object-oriented-OOP/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Design Pattern</title>
    <url>/2019/12/25/Design-Pattern/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Study Note</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
        <tag>Foundation</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/12/20/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
