<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Message Queue(MQ) I</title>
    <url>/2020/05/29/Message-Queue-I/</url>
    <content><![CDATA[<blockquote>
<p>在乎的是，自己以及他所在乎的人，能不能够秉持着自己的心意与信念，在人生中大部分时间里都能自在、快乐</p>
</blockquote>
<a id="more"></a>

<ul>
<li>消息队列都有什么优点和缺点？</li>
<li>kafka、activemq、rabbitmq、rocketmq都有什么区别？</li>
<li>如何保证消息队列的高可用？</li>
<li>如何保证消息不被重复消费？如何保证消费的时候是幂等的？</li>
<li>如何保证消息的可靠性传输？要是消息丢失了怎么办？</li>
<li>如何保证消息的顺序性？</li>
<li>如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？</li>
<li>如果让你写一个消息队列，该如何进行架构设计？说一下你的思路</li>
</ul>
<p>如果你把这些常见问题都掌握了，<strong>哪怕是面试官没问到你这么深入，他问你一个消息队列问题，你就自己给他说出自己的一整套见解，那么恭喜你，就是plus加分项了</strong>。</p>
<h1 id="如何进行消息队列技术选型？"><a href="#如何进行消息队列技术选型？" class="headerlink" title="如何进行消息队列技术选型？"></a>如何进行消息队列技术选型？</h1><p>面试中大量的候选人，说自己项目里用了redis、mq，但是其实他并不知道自己为什么要用这个东西。其实说白了，就是为了用而用，或者是别人设计的架构，他从头到尾没思考过。</p>
<p>没有对自己的架构问过为什么的人，一定是平时没有思考的人，面试官对这类候选人印象通常很不好。因为进了团队担心你就木头木脑的干呆活儿，不会自己思考。</p>
<p>此外，任何技术都有优点和缺点，开发者需要清楚。</p>
<h2 id="为什么使用消息队列？"><a href="#为什么使用消息队列？" class="headerlink" title="为什么使用消息队列？"></a>为什么使用消息队列？</h2><p>其实就是问你消息队列都有哪些使用场景，然后你项目里具体是什么场景，说说你在这个场景里用消息队列是什么。</p>
<p>面试官问你这个问题，期望的一个回答是说，你们公司有个什么业务场景，这个业务场景有个什么技术挑战，如果不用MQ可能会很麻烦，但是你现在用了MQ之后带给了你很多的好处。</p>
<p>先说一下消息队列的常见使用场景吧，其实场景有很多，但是比较核心的有3个：<font color=#FF0000>解耦、异步、削峰</font></p>
<p><strong>解耦</strong>：现场画个图来说明一下，A系统发送个数据到BCD三个系统，接口调用发送，那如果E系统也要这个数据呢？那如果C系统现在不需要了呢？现在A系统又要发送第二种数据了呢？A系统负责人濒临崩溃中。。。再来点更加崩溃的事儿，A系统要时时刻刻考虑BCDE四个系统如果挂了咋办？我要不要重发？我要不要把消息存起来？头发都白了啊。。。</p>
<p><img src="https://i.loli.net/2020/05/30/f3Wj8wUEbxuCFOl.png" alt="不用MQ的解耦情况.png"></p>
<p>面试技巧：你需要去考虑一下你负责的系统中是否有类似的场景，就是一个系统或者一个模块，调用了多个系统或者模块，互相之间的调用很复杂，维护起来很麻烦。但是其实这个调用是不需要直接同步调用接口的，如果用MQ给他异步化解耦，也是可以的，你就需要去考虑在你的项目里，是不是可以运用这个MQ去进行系统的解耦。在简历中体现出来这块东西，用MQ作解耦。</p>
<p><img src="https://i.loli.net/2020/05/30/rqavTemu7319NOK.png" alt="使用MQ之后解耦的场景.png"></p>
<p><strong>异步</strong>：现场画个图来说明一下，A系统接收一个请求，需要在自己本地写库，还需要在BCD三个系统写库，自己本地写库要3ms，BCD三个系统分别写库要300ms、450ms、200ms。最终请求总延时是3 + 300 + 450 + 200 = 953ms，接近1s，用户感觉搞个什么东西，慢死了。</p>
<p><img src="https://i.loli.net/2020/05/30/bkvoFsOhptYSIPC.png" alt="不用MQ的高延迟请求场景.png"></p>
<p>使用MQ队列之后，不用强制拥塞在系统A或者单独的MQ中，可以让多条消息并行发送。异步MQ可以大大加快系统对用户请求的反馈。</p>
<p><img src="https://i.loli.net/2020/05/30/rpKNZaTcmIsnVAe.png" alt="使用MQ进行异步化之后的接口性能优化.png"></p>
<p>总之，碰到一个系统要调用多个系统这样的场景，可以使用多个MQ，把整个调用关系变成异步，不需要让系统同步去做，而是异步操作。</p>
<p><strong>异步可以大幅度提高高延时接口的性能</strong>。</p>
<p><strong>削峰</strong>：每天0点到11点，A系统风平浪静，每秒并发请求数量就100个。结果每次一到11点~1点，每秒并发请求数量突然会暴增到1万条。但是系统最大的处理能力就只能是每秒钟处理1000个请求啊。。。尴尬了，系统会死。。。</p>
<p><img src="https://i.loli.net/2020/05/30/95cQAafiX3TqnVU.png" alt="没有用MQ的时候高峰期系统被打死的情况.png"></p>
<p>在使用了MQ之后，让用户的请求打到MQ上，让MQ每秒能拉取的请求数量不超过MySQL能承载的请求数量，这样即可让数据库不会被请求打死。</p>
<p>尽管这样做，会让消息在MQ中产生积压，但是只会让系统慢一些，不会让数据库挂掉。高峰期一过，每秒的请求数量小了很多，系统即可把积压的消息都处理掉。</p>
<p><img src="https://i.loli.net/2020/05/30/ztnQUMH12jig6wa.png" alt="使用了MQ削峰之后.png"></p>
<p><strong>总的来说，为什么用MQ</strong>？</p>
<p>实际回答可以从两个角度来说：</p>
<ol>
<li>提高系统性能(包含了异步和削峰)</li>
<li>降低系统耦合性。</li>
</ol>
<p>使用消息队列主要有两点好处：1.通过异步处理提高系统性能（削峰、减少响应所需时间）;2.降低系统耦 合性。如果在面试的时候你被面试官问到这个问题的话，一般情况是你在你的简历上涉及到消息队列这方面的内容， 这个时候推荐你结合你自己的项目来回答。</p>
<h3 id="1-提升系统性能"><a href="#1-提升系统性能" class="headerlink" title="1.提升系统性能"></a>1.提升系统性能</h3><p><img src="https://i.loli.net/2020/05/31/CSE3K7BJUIje6Th.png" alt="使用与不使用消息队列服务器.png"></p>
<p>如上图，<strong>在不使用消息队列服务器的时候，用户的请求数据直接写入数据库，在高并发的情况下数据库压力剧增，使得响应速度变慢。但是在使用消息队列之后，用户的请求数据发送给消息队列之后立即 返回，再由消息队列 的消费者进程从消息队列中获取数据，异步写入数据库。由于消息队列服务器处理速度快于数据库（消息队列也比数 据库有更好的伸缩性），因此响应速度得到大幅改善</strong>。</p>
<p>消息队列具有很好的削峰作用的功能——即<strong>通过异步处理，将短时间高并发产生的事 务消息存储在消息队列中，从而削平高峰期的并发事务</strong>。 举例：在电子商务一些秒杀、促销活动中，合理使用消息 队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。如下图所示： </p>
<p><img src="https://i.loli.net/2020/05/31/5xAl4C7dy1gnqKX.png" alt="使用消息队列削峰.png"></p>
<p>因为<strong>用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中 可能失败</strong>。因此使用消息队列进行异步处理之后，需要<strong>适当修改业务流程进行配合</strong>，比如<strong>用户在提交订单之后，订单 数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚 至出库后，再通过电子邮件或短信通知用户订单成功</strong>，以免交易纠纷。这就类似我们平时手机订火车票和电影票。 </p>
<h3 id="2-降低系统耦合性"><a href="#2-降低系统耦合性" class="headerlink" title="2.降低系统耦合性"></a>2.降低系统耦合性</h3><p>我们知道如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展 性无疑更好一些。</p>
<p>我们常见的事件驱动架构类似生产者消费者模式，在大型网站中通常用利用消息队列实现事件驱动结构。如下 图所示：</p>
<p><img src="https://i.loli.net/2020/05/31/8X6RVHdcpPlbnys.png" alt="消息队列生产者消费者模式.png"></p>
<p><strong>消息队列使利用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅 消息</strong>。 从上图可以看到，<strong>消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合</strong>，消息发送者将消息发送 至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该 消息从何而来。<strong>对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计</strong>。</p>
<p>消息接受者对消息进行过滤、处理、包装后，构造成一个新的消息类型，将消息继续发送出去，等待其他消息接 受者订阅该消息。因此基于事件（消息对象）驱动的业务架构可以是一系列流程。</p>
<p><strong>另外为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上， 等消息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务 器集群中的其他服务器发布消息</strong>。</p>
<p><strong>备注</strong>： 不要认为消息队列只能利用发布-订阅模式工作，只不过在解耦这个特定业务环境下是使用发布-订阅模式的。 <strong>除了发布-订阅模式，还有点对点订阅模式（一个消息只有一个消费者），我们比较常用的是发布-订阅模式</strong>。 另外， 这两种消息模型是 JMS 提供的，AMQP 协议还提供了 5 种消息模型。 </p>
<h2 id="消息队列有什么优点和缺点？"><a href="#消息队列有什么优点和缺点？" class="headerlink" title="消息队列有什么优点和缺点？"></a>消息队列有什么优点和缺点？</h2><p>优点上面已经说了，就是在特殊场景下有其对应的好处，解耦、提升系统性能(异步、削峰)</p>
<p>缺点呢？显而易见</p>
<p><img src="https://i.loli.net/2020/05/30/FgXMleY8jpTmExH.png" alt="MQ的问题和缺点.png"></p>
<ul>
<li><p><strong>系统可用性降低</strong>：MQ挂掉了，整个系统就都挂掉了。系统引入的外部依赖越多，越容易挂掉，本来你就是A系统调用BCD三个系统的接口就好了，人ABCD四个系统好好的，没啥问题，你偏加个MQ进来，<font color=#FF0000>万一MQ挂了咋整？</font>MQ挂了，整套系统崩溃了，你不就完了么。</p>
</li>
<li><p><strong>系统复杂性提高</strong>：系统会变得更复杂。硬生生加个MQ进来，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺 序性等等问题。</p>
</li>
<li><p><strong>一致性问题</strong>：了消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万 一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了！多个系统之间数据可能不一致。A系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是BCD三个系统那里，BD两个系统写库成功了，结果C系统写库失败了，咋整？你这数据就不一致了。</p>
</li>
</ul>
<p>所以消息队列实际是一种非常复杂的架构，你引入它有很多好处，但是也得针对它带来的坏处做各种额外的技术方案和架构来规避掉，最好之后，你会发现，妈呀，系统复杂度提升了一个数量级，也许是复杂了10倍。但是关键时刻，用，还是得用的。。。</p>
<h2 id="kafka、activemq、rabbitmq、rocketmq都有什么区别以及适合哪些场景？"><a href="#kafka、activemq、rabbitmq、rocketmq都有什么区别以及适合哪些场景？" class="headerlink" title="kafka、activemq、rabbitmq、rocketmq都有什么区别以及适合哪些场景？"></a>kafka、activemq、rabbitmq、rocketmq都有什么区别以及适合哪些场景？</h2><table>
<thead>
<tr>
<th align="left">特性</th>
<th>ActiveMQ</th>
<th>RabbitMQ</th>
<th>RocketMQ</th>
<th>Kafka</th>
</tr>
</thead>
<tbody><tr>
<td align="left">单机吞吐量</td>
<td>万级，吞吐量比RocketMQ和Kafka要低了一个数量级</td>
<td>万级，吞吐量比RocketMQ和Kafka要低了一个数量级</td>
<td>10万级，RocketMQ也是可以支撑高吞吐的一种MQ</td>
<td>10万级别，这是kafka最大的优点，就是吞吐量高。     一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td>
</tr>
<tr>
<td align="left">topic数量对吞吐量的影响</td>
<td></td>
<td></td>
<td>topic可以达到几百，几千个的级别，吞吐量会有较小幅度的下降。这是RocketMQ的一大优势，在同等机器下，可以支撑大量的topic</td>
<td>topic从几十个到几百个的时候，吞吐量会大幅度下降。所以在同等机器下，kafka尽量保证topic数量不要过多。如果要支撑大规模的topic，需要增加更多的机器资源</td>
</tr>
<tr>
<td align="left">时效性</td>
<td>ms级</td>
<td>微秒级，这是rabbitmq的一大特点，延迟是最低的</td>
<td>ms级</td>
<td>延迟在ms级以内</td>
</tr>
<tr>
<td align="left">可用性</td>
<td>高，基于主从架构实现高可用性</td>
<td>高，基于主从架构实现高可用性</td>
<td>非常高，分布式架构</td>
<td>非常高，kafka是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td>
</tr>
<tr>
<td align="left">消息可靠性</td>
<td>有较低的概率丢失数据</td>
<td></td>
<td>经过参数优化配置，可以做到0丢失</td>
<td>经过参数优化配置，消息可以做到0丢失</td>
</tr>
<tr>
<td align="left">功能支持</td>
<td>MQ领域的功能极其完备</td>
<td>基于erlang开发，所以并发能力很强，性能极其好，延时很低</td>
<td>MQ功能较为完善，还是分布式的，扩展性好</td>
<td>功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准</td>
</tr>
<tr>
<td align="left">优劣势总结</td>
<td>非常成熟，功能强大，在业内大量的公司以及项目中都有应用。偶尔会有较低概率丢失消息。而且现在社区以及国内应用都越来越少，官方社区现在对ActiveMQ 5.x维护越来越少，几个月才发布一个版本。而且确实主要是基于解耦和异步来用的，较少在大规模吞吐的场景中使用</td>
<td>erlang语言开发，性能极其好，延时很低；吞吐量到万级，MQ功能比较完备；而且开源提供的管理界面非常棒，用起来很好用；社区相对比较活跃，几乎每个月都发布几个版本分；在国内一些互联网公司近几年用rabbitmq也比较多一些；但是问题也是显而易见的，RabbitMQ确实吞吐量会低一些，这是因为他做的实现机制比较重。而且erlang开发，国内有几个公司有实力做erlang源码级别的研究和定制？如果说你没这个实力的话，确实偶尔会有一些问题，你很难去看懂源码，你公司对这个东西的掌控很弱，基本职能依赖于开源社区的快速维护和修复bug。而且rabbitmq集群动态扩展会很麻烦，不过这个我觉得还好。其实主要是erlang语言本身带来的问题。很难读源码，很难定制和掌控。</td>
<td>接口简单易用，而且毕竟在阿里大规模应用过，有阿里品牌保障；     日处理消息上百亿之多，可以做到大规模吞吐，性能也非常好，分布式扩展也很方便，社区维护还可以，可靠性和可用性都是ok的，还可以支撑大规模的topic数量，支持复杂MQ业务场景 ；    而且一个很大的优势在于，阿里出品都是java系的，我们可以自己阅读源码，定制自己公司的MQ，可以掌控；     社区活跃度相对较为一般，不过也还可以，文档相对来说简单一些，然后接口这块不是按照标准JMS规范走的有些系统要迁移需要修改大量代码 ；    还有就是阿里出台的技术，你得做好这个技术万一被抛弃，社区黄掉的风险，那如果你们公司有技术实力我觉得用RocketMQ挺好的</td>
<td>kafka的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展；     同时kafka最好是支撑较少的topic数量即可，保证其超高吞吐量；     而且kafka唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略；     这个特性天然适合大数据实时计算以及日志收集</td>
</tr>
</tbody></table>
<p>上面这张表比较细，整合之后可以得到：</p>
<table>
<thead>
<tr>
<th>对比方向</th>
<th>概要</th>
</tr>
</thead>
<tbody><tr>
<td>吞吐量</td>
<td>万级的 ActiveMQ 和 RabbitMQ 的吞吐量（ActiveMQ 的性能差）要比 十万级甚至是百万级的 RocketMQ 和 Kafka 低一个数量级。</td>
</tr>
<tr>
<td>可用性</td>
<td>都可以实现高可用。ActiveMQ 和 RabbitMQ 都是基于主从架构实现高可用性。RocketMQ 基于分布式 架构。 kafka 也是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td>
</tr>
<tr>
<td>时效性</td>
<td>RabbitMQ 基于erlang开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。其他三个都是 ms 级。</td>
</tr>
<tr>
<td>功能支持</td>
<td>除了 Kafka，其他三个功能都较为完备。 Kafka 功能较为简单，主要支持简单的MQ功能，在大数据领域 的实时计算以及日志采集被大规模使用，是事实上的标准</td>
</tr>
<tr>
<td>消息丢失</td>
<td>ActiveMQ 和 RabbitMQ 丢失的可能性非常低， RocketMQ 和 Kafka 理论上不会丢失。</td>
</tr>
</tbody></table>
<p>综上所述，各种对比之后：</p>
<ul>
<li>ActiveMQ 的社区算是比较成熟，但是较目前来说，ActiveMQ 的性能比较差，而且版本迭代很慢，不推荐使用。</li>
<li>RabbitMQ 在吞吐量方面虽然稍逊于 Kafka 和 RocketMQ ，但是由于它基于 erlang 开发，所以并发能力很强， 性能极其好，延时很低，达到微秒级。但是也因为 RabbitMQ 基于 erlang 开发，所以国内很少有公司有实力做 erlang源码级别的研究和定制。如果业务场景对并发量要求不是太高（十万级、百万级），那这四种消息队列 中，RabbitMQ 一定是你的首选。如果是大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准的， 绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。 </li>
<li>RocketMQ 阿里出品，Java 系开源项目，源代码我们可以直接阅读，然后可以定制自己公司的MQ，并且 RocketMQ 有阿里巴巴的实际业务场景的实战考验。RocketMQ 社区活跃度相对较为一般，不过也还可以，文 档相对来说简单一些，然后接口这块不是按照标准 JMS 规范走的有些系统要迁移需要修改大量代码。还有就是 阿里出台的技术，你得做好这个技术万一被抛弃，社区黄掉的风险，那如果你们公司有技术实力我觉得用 RocketMQ 挺好的 。</li>
<li>kafka 的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms 级的延迟，极高的可用 性以及可靠性，而且分布式可以任意扩展。同时 kafka 好是支撑较少的 topic 数量即可，保证其超高吞吐量。 kafka 唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及 日志采集中，这点轻微影响可以忽略这个特性天然适合大数据实时计算以及日志收集。</li>
</ul>
<h1 id="JMS和AMQP"><a href="#JMS和AMQP" class="headerlink" title="JMS和AMQP"></a>JMS和AMQP</h1><h2 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h2><h3 id="JMS简介"><a href="#JMS简介" class="headerlink" title="JMS简介"></a>JMS简介</h3><p>JMS（JAVA Message Service,java消息服务）是java的消息服务，JMS的客户端之间可以通过JMS服务进行异步的 消息传输。<strong>JMS（JAVA Message Service,Java消息服务）API是一个消息服务的标准或者说是规范</strong>，允许应用程序组件基于JavaEE平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。</p>
<p><strong>ActiveMQ 就是基于 JMS 规范实现的</strong>。</p>
<h3 id="JMS两种消息模型-P2P、Pub-Sub"><a href="#JMS两种消息模型-P2P、Pub-Sub" class="headerlink" title="JMS两种消息模型(P2P、Pub/Sub)"></a>JMS两种消息模型(P2P、Pub/Sub)</h3><ol>
<li>点到点(P2P)模型</li>
</ol>
<p><img src="https://i.loli.net/2020/06/01/um8O2VKRzoMBqUD.png" alt="JMS_P2P.png"></p>
<p>使用<strong>队列(Queue)</strong>作为消息通信载体；满足<strong>生产者消费者模式</strong>，一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时。比如：我们生产者发送100条消息的话，两个消费者来消费一般情况下两个消费者会按 照消息发送的顺序各自消费一半（也就是你一个我一个的消费。）</p>
<ol start="2">
<li>发布/订阅(Pub/Sub)模型</li>
</ol>
<p><img src="https://i.loli.net/2020/06/01/5718qnoVC6WfXxb.png" alt="JMS_Pub.png"></p>
<p>发布订阅模型(Pub/Sub)使用<strong>主题(Topic)</strong>作为消息通信载体，类似于<strong>广播模式</strong>；发布者发布一条消息，该消息通过主题传递给所有的订阅者，<strong>在一 条消息广播之后才订阅的用户则是收不到该条消息的</strong>。</p>
<h3 id="JMS五种不同的消息正文格式"><a href="#JMS五种不同的消息正文格式" class="headerlink" title="JMS五种不同的消息正文格式"></a>JMS五种不同的消息正文格式</h3><p>JMS定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一些不同形式的数据，提供现 有消息格式的一些级别的兼容性。</p>
<ul>
<li>StreamMessage – Java原始值的数据流</li>
<li>MapMessage–一套名称-值对 </li>
<li>TextMessage–一个字符串对象</li>
<li>ObjectMessage–一个序列化的 Java对象</li>
<li>BytesMessage–一个字节的数据流  </li>
</ul>
<h2 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h2><p>AMQP，即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准 <strong>高级消息队列协议</strong>（<strong>二进制</strong>应用层协议），是应用层协议的一个开放标准,为面向消息的中间件设计，兼容 JMS。基于此协议的客户端与消 息中间件可传递消息，并不受客户端/中间件同产品，不同的开发语言等条件的限制。</p>
<p><strong>RabbitMQ 就是基于 AMQP 协议实现的</strong>。</p>
<h2 id="JMS-vs-AMQP"><a href="#JMS-vs-AMQP" class="headerlink" title="JMS vs AMQP"></a>JMS vs AMQP</h2><table>
<thead>
<tr>
<th>对比方向</th>
<th>JMS</th>
<th>AMQP</th>
</tr>
</thead>
<tbody><tr>
<td>定义</td>
<td>Java API</td>
<td>协议</td>
</tr>
<tr>
<td>跨语言</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>跨平台</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>支持消息模型</td>
<td>提供两种消息模 型：①Peer-2Peer;②Pub/sub</td>
<td>提供了五种消息模型：①direct exchange；②fanout exchange；③topic change；④headers exchange；⑤system exchange。本质来讲，后四种和JMS的 pub/sub模型没有太大差别，仅是在路由机制上做了更详细的划分</td>
</tr>
<tr>
<td>支持消息类型</td>
<td>支持多种消息类型，上面讲到了五种</td>
<td>byte[] (二进制)</td>
</tr>
</tbody></table>
<p><strong>总结</strong>：</p>
<ul>
<li>AMQP 为消息定义了线路层（wire-level protocol）的协议，而JMS所定义的是API规范。在 Java 体系中，多个 client均可以通过JMS进行交互，不需要应用修改代码，但是其对跨平台的支持较差。而AMQP天然具有跨平 台、跨语言特性。 </li>
<li>JMS 支持TextMessage、MapMessage 等复杂的消息类型；而 AMQP 仅支持 byte[] 消息类型（复杂的类型可 序列化后发送）。</li>
<li>由于Exchange 提供的路由算法，AMQP可以提供多样化的路由方式来传递消息到消息队列，而 JMS 仅支持 队 列 和 主题/订阅 方式两种。 </li>
</ul>
<h1 id="引入消息队列之后如何保证其高可用性？"><a href="#引入消息队列之后如何保证其高可用性？" class="headerlink" title="引入消息队列之后如何保证其高可用性？"></a>引入消息队列之后如何保证其高可用性？</h1><p>这个问题这么问是很好的，因为不能问你kafka的高可用性怎么保证啊？ActiveMQ的高可用性怎么保证啊？一个面试官要是这么问就显得很没水平，人家可能用的就是RabbitMQ，没用过Kafka，你上来问人家kafka干什么？这不是摆明了刁难人么。</p>
<p>所以有水平的面试官，问的是MQ的高可用性怎么保证？这样就是你用过哪个MQ，你就说说你对那个MQ的高可用性的理解。</p>
<p>先说说自己了解哪些MQ，然后分别讲不同MQ之间的区别、特点。</p>
<p>（1）RabbitMQ的高可用性</p>
<p>RabbitMQ是比较有代表性的，因为是基于主从做高可用性的，我们就以他为例子讲解第一种MQ的高可用性怎么实现。</p>
<p>rabbitmq有三种模式：单机模式，普通集群模式，镜像集群模式</p>
<p>1）单机模式</p>
<p>就是demo级别的，一般就是你本地启动了玩玩儿的，没人生产用单机模式</p>
<p>2）普通集群模式</p>
<p><img src="https://i.loli.net/2020/05/31/QHNWItZ9CYiSOul.png" alt="RabitMQ普通集群模式.png"></p>
<p>意思就是在多台机器上启动多个rabbitmq实例，每个机器启动一个。但是你创建的queue，只会放在一个rabbtimq实例上，但是每个实例都同步queue的元数据。完了你消费的时候，实际上如果连接到了另外一个实例，那么那个实例会从queue所在实例上拉取数据过来。</p>
<p>这种方式确实很麻烦，也不怎么好，没做到所谓的分布式，就是个普通集群。因为这导致你要么消费者每次随机连接一个实例然后拉取数据，要么固定连接那个queue所在实例消费数据，前者有数据拉取的开销，后者导致单实例性能瓶颈。</p>
<p>而且如果那个放queue的实例宕机了，会导致接下来其他实例就无法从那个实例拉取，如果你开启了消息持久化，让rabbitmq落地存储消息的话，消息不一定会丢，得等这个实例恢复了，然后才可以继续从这个queue拉取数据。</p>
<p>所以这个事儿就比较尴尬了，这就没有什么所谓的高可用性可言了，这方案主要是提高吞吐量的，就是说让集群中多个节点来服务某个queue的读写操作。</p>
<p>3）镜像集群模式</p>
<p><img src="https://i.loli.net/2020/05/31/ZSHRrg8bWEw6JCf.png" alt="RabbotMQ镜像集群模式.png"></p>
<p>这种模式，才是所谓的rabbitmq的<strong>高可用模式</strong>，跟普通集群模式不一样的是，你创建的queue，无论元数据还是queue里的消息都会存在于多个实例上，然后每次你写消息到queue的时候，都会自动把消息到多个实例的queue里进行消息同步。</p>
<p>这样的话，好处在于，你任何一个机器宕机了，没事儿，别的机器都可以用。坏处在于，第一，这个性能开销也太大了吧，消息同步所有机器，导致网络带宽压力和消耗很重！第二，这么玩儿，就没有扩展性可言了，如果某个queue负载很重，你加机器，新增的机器也包含了这个queue的所有数据，并没有办法线性扩展你的queue</p>
<p>那么怎么开启这个镜像集群模式呢？我这里简单说一下，避免面试人家问你你不知道，其实很简单，rabbitmq有很好的管理控制台，就是在后台新增一个策略，这个策略是镜像集群模式的策略，指定的时候可以要求数据同步到所有节点的，也可以要求就同步到指定数量的节点，然后你再次创建queue的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。</p>
<p>（2）kafka的高可用性</p>
<p><img src="https://i.loli.net/2020/05/31/zXsqIo6BML2RWxQ.png" alt="卡夫卡高可用架构.png"></p>
<p>kafka一个最基本的架构认识：多个broker组成，每个broker是一个节点；你创建一个topic，这个topic可以划分为多个partition，每个partition可以存在于不同的broker上，每个partition就放一部分数据。 </p>
<p>这就是天然的分布式消息队列，就是说一个topic的数据，是分散放在多个机器上的，每个机器就放一部分数据。</p>
<p>实际上rabbitmq之类的，并不是分布式消息队列，他就是传统的消息队列，只不过提供了一些集群、HA的机制而已，因为无论怎么玩儿，rabbitmq一个queue的数据都是放在一个节点里的，镜像集群下，也是每个节点都放这个queue的完整数据。</p>
<p>kafka 0.8以前，是没有HA机制的，就是任何一个broker宕机了，那个broker上的partition就废了，没法写也没法读，没有什么高可用性可言。</p>
<p>kafka 0.8以后，提供了HA机制，就是replica副本机制。每个partition的数据都会同步到吉他机器上，形成自己的多个replica副本。然后所有replica会选举一个leader出来，那么生产和消费都跟这个leader打交道，然后其他replica就是follower。写的时候，leader会负责把数据同步到所有follower上去，读的时候就直接读leader上数据即可。只能读写leader？很简单，要是你可以随意读写每个follower，那么就要care数据一致性的问题，系统复杂度太高，很容易出问题。kafka会均匀的将一个partition的所有replica分布在不同的机器上，这样才可以提高容错性。</p>
<p>这么搞，就有所谓的高可用性了，因为如果某个broker宕机了，没事儿，那个broker上面的partition在其他机器上都有副本的，如果这上面有某个partition的leader，那么此时会重新选举一个新的leader出来，大家继续读写那个新的leader即可。这就有所谓的高可用性了。</p>
<p>写数据的时候，生产者就写leader，然后leader将数据落地写本地磁盘，接着其他follower自己主动从leader来pull数据。一旦所有follower同步好数据了，就会发送ack给leader，leader收到所有follower的ack之后，就会返回写成功的消息给生产者。（当然，这只是其中一种模式，还可以适当调整这个行为）</p>
<p>消费的时候，只会从leader去读，但是只有一个消息已经被所有follower都同步成功返回ack的时候，这个消息才会被消费者读到。</p>
<p>实际上这块机制，讲深了，是可以非常之深入的，但是我还是回到我们这个课程的主题和定位，聚焦面试，至少你听到这里大致明白了kafka是如何保证高可用机制的了，对吧？不至于一无所知，现场还能给面试官画画图。要遇上面试官确实是kafka高手，深挖了问，那你只能说不好意思，太深入的你没研究过。</p>
<p>但是大家一定要明白，这个事情是要权衡的，你现在是要快速突击常见面试题体系，而不是要深入学习kafka，要深入学习kafka，你是没那么多时间的。你只能确保，你之前也许压根儿不知道这块，但是现在你知道了，面试被问到，你大概可以说一说。然后很多其他的候选人，也许还不如你，没看过这个，被问到了压根儿答不出来，相比之下，你还能说点出来，大概就是这个意思了。</p>
<h1 id="为什么在消息队列里消费了重复的数据？-保证数据幂等性"><a href="#为什么在消息队列里消费了重复的数据？-保证数据幂等性" class="headerlink" title="为什么在消息队列里消费了重复的数据？(保证数据幂等性)"></a>为什么在消息队列里消费了重复的数据？(保证数据幂等性)</h1><p>想要保证数据不被重复消费，实际上就是要<font color=#FF0000>保证数据的幂等性</font>。</p>
<p>既然是消费消息，那肯定要考虑考虑会不会重复消费？能不能避免重复消费？或者重复消费了也别造成系统异常可以吗？这个是MQ领域的基本问题，其实本质上还是问你使用消息队列如何保证幂等性。这也是关系到消息队列的系统设计问题。</p>
<p>首先，讲一下消息队列会有哪些重复消费的问题。</p>
<p>比如rabbitmq、rocketmq、kafka，都有可能会出现消费重复消费的问题，正常。因为这问题通常不是mq自己保证的，是给你保证的。然后我们挑一个kafka来举个例子。</p>
<p>kafka实际上有个<strong>offset</strong>的概念，就是每个消息写进去，都有一个offset，代表他的序号，然后consumer消费了数据之后，每隔一段时间，会把自己消费过的消息的offset提交一下，代表我已经消费过了，下次我要是重启啥的，系统就让我继续从上次消费到的offset来继续消费。</p>
<p><img src="https://i.loli.net/2020/06/02/6uZ2BkRa8j13nUh.png" alt="Kafka消费端可能出现的重复消费问题.png"></p>
<p>但是凡事总有意外，比如我们之前生产经常遇到的，就是你有时候重启系统，看你怎么重启了，如果碰到点着急的，直接kill进程了，再重启。这会导致consumer有些消息处理了，但是没来得及提交offset，尴尬了。重启之后，少数消息会再次消费一次。</p>
<p>举个例子，假设你有个系统，消费一条往数据库里插入一条，要是你一个消息重复两次，你不就插入了两条，这数据不就错了？但是你要是消费到第二次的时候，自己判断一下已经消费过了，直接扔了，不就保留了一条数据？</p>
<p>一条数据重复出现两或多次，数据库里就只有一条数据，这就保证了系统的<strong>幂等性</strong>。</p>
<p>怎么保证消息队列消费的幂等性呢？</p>
<p>其实还是得结合业务来思考，我这里给几个思路：</p>
<p>（1）比如你拿个数据要写库，你先根据主键查一下，如果这数据都有了，你就别插入了，update一下</p>
<p>（2）比如你是写redis，那没问题了，反正每次都是set，<strong>天然幂等性</strong></p>
<p>（3）比如你不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面加一个全局唯一的id，类似订单id之类的东西，然后你这里消费到了之后，先根据这个id去比如redis里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个id写redis。如果消费过了，那你就别处理了，保证别重复处理相同的消息即可。</p>
<p>还有比如基于数据库的唯一键来保证重复数据不会重复插入多条，我们之前线上系统就有这个问题，就是拿到数据的时候，每次重启可能会有重复，因为kafka消费者还没来得及提交offset，重复数据拿到了以后我们插入的时候，因为有唯一键约束了，所以重复数据只会插入报错，不会导致数据库中出现脏数据。</p>
<p>如何保证MQ的消费是幂等性的，需要结合具体的业务来看。</p>
<h1 id="我发到消息队列里面的数据怎么不见了？-消息可靠性传输-必问"><a href="#我发到消息队列里面的数据怎么不见了？-消息可靠性传输-必问" class="headerlink" title="我发到消息队列里面的数据怎么不见了？(消息可靠性传输)(必问)"></a>我发到消息队列里面的数据怎么不见了？(消息可靠性传输)(必问)</h1><p>用mq有个基本原则，就是数据不能多一条，也不能少一条，不能多，就是刚才说的重复消费和幂等性问题。不能少，就是说这数据别搞丢了。</p>
<p>实际使用的时候，比如广告系统，每点击一次算一次钱，因为操作很耗时，所以广告系统整体的架构里面，实际上是将计费做成异步化的，然后中间就是加了一个MQ。为了确保MQ传递过程中绝对不会把计费消息给弄丢，要花很多的精力。比如，用户点击一次扣费1块钱。但是如果在用户点击的时候搞的消息丢了，我们公司就会不断的少挣几块钱，积少成多，这个就对公司是一个很大的损失。</p>
<p>mq丢失数据一般分为两种：</p>
<ol>
<li>传输的时候弄丢了</li>
<li>消费的时候弄丢了</li>
</ol>
<p>咱们从rabbitmq和kafka分别来分析一下：</p>
<h2 id="rabbitMQ数据传输丢失"><a href="#rabbitMQ数据传输丢失" class="headerlink" title="rabbitMQ数据传输丢失"></a>rabbitMQ数据传输丢失</h2><p>rabbitmq这种mq，一般来说都是承载公司的核心业务的，数据是绝对不能弄丢的</p>
<p>1）生产者弄丢了数据</p>
<p>生产者将数据发送到rabbitmq的时候，可能数据就在半路给搞丢了，因为网络啥的问题，都有可能。</p>
<p>此时可以选择用rabbitmq提供的事务功能，就是生产者发送数据之前开启rabbitmq事务（channel.txSelect），然后发送消息，如果消息没有成功被rabbitmq接收到，那么生产者会收到异常报错，此时就可以回滚事务（channel.txRollback），然后重试发送消息；如果收到了消息，那么可以提交事务（channel.txCommit）。但是问题是，rabbitmq事务机制一搞，基本上吞吐量会下来，因为太耗性能。</p>
<p>所以一般来说，如果你要确保说写rabbitmq的消息别丢，可以开启confirm模式，在生产者那里设置开启confirm模式之后，你每次写的消息都会分配一个唯一的id，然后如果写入了rabbitmq中，rabbitmq会给你回传一个ack消息，告诉你说这个消息ok了。如果rabbitmq没能处理这个消息，会回调你一个nack接口，告诉你这个消息接收失败，你可以重试。而且你可以结合这个机制自己在内存里维护每个消息id的状态，如果超过一定时间还没接收到这个消息的回调，那么你可以重发。</p>
<p>事务机制和cnofirm机制最大的不同在于，事务机制是同步的，你提交一个事务之后会阻塞在那儿，但是confirm机制是异步的，你发送个消息之后就可以发送下一个消息，然后那个消息rabbitmq接收了之后会异步回调你一个接口通知你这个消息接收到了。</p>
<p>所以一般在生产者这块避免数据丢失，都是用confirm机制的。</p>
<p>2）rabbitmq弄丢了数据</p>
<p>就是rabbitmq自己弄丢了数据，这个你必须开启rabbitmq的持久化，就是消息写入之后会持久化到磁盘，哪怕是rabbitmq自己挂了，恢复之后会自动读取之前存储的数据，一般数据不会丢。除非极其罕见的是，rabbitmq还没持久化，自己就挂了，可能导致少量数据会丢失的，但是这个概率较小</p>
<p>设置持久化有两个步骤，第一个是创建queue的时候将其设置为持久化的，这样就可以保证rabbitmq持久化queue的元数据，但是不会持久化queue里的数据；第二个是发送消息的时候将消息的deliveryMode设置为2，就是将消息设置为持久化的，此时rabbitmq就会将消息持久化到磁盘上去。必须要同时设置这两个持久化才行，rabbitmq哪怕是挂了，再次重启，也会从磁盘上重启恢复queue，恢复这个queue里的数据。</p>
<p>而且持久化可以跟生产者那边的confirm机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者ack了，所以哪怕是在持久化到磁盘之前，rabbitmq挂了，数据丢了，生产者收不到ack，你也是可以自己重发的。</p>
<p>哪怕是你给rabbitmq开启了持久化机制，也有一种可能，就是这个消息写到了rabbitmq中，但是还没来得及持久化到磁盘上，结果不巧，此时rabbitmq挂了，就会导致内存里的一点点数据会丢失。</p>
<p>3）消费端弄丢了数据</p>
<p>rabbitmq如果丢失了数据，主要是因为你消费的时候，刚消费到，还没处理，结果进程挂了，比如重启了，那么就尴尬了，rabbitmq认为你都消费了，这数据就丢了。</p>
<p>这个时候得用rabbitmq提供的ack机制，简单来说，就是你关闭rabbitmq自动ack，可以通过一个api来调用就行，然后每次你自己代码里确保处理完的时候，再程序里ack一把。这样的话，如果你还没处理完，不就没有ack？那rabbitmq就认为你还没处理完，这个时候rabbitmq会把这个消费分配给别的consumer去处理，消息是不会丢的。</p>
<p><img src="https://i.loli.net/2020/06/03/D8EcjHisbXkl4ue.png" alt="RabbitMQ可能存在数据丢失的问题.png"></p>
<h2 id="Kafka传输数据丢失"><a href="#Kafka传输数据丢失" class="headerlink" title="Kafka传输数据丢失"></a>Kafka传输数据丢失</h2><p>1）消费端弄丢了数据</p>
<p>唯一可能导致消费者弄丢数据的情况，就是说，你那个消费到了这个消息，然后消费者那边自动提交了offset，让kafka以为你已经消费好了这个消息，其实你刚准备处理这个消息，你还没处理，你自己就挂了，此时这条消息就丢咯。</p>
<p>这不是一样么，大家都知道kafka会自动提交offset，那么只要关闭自动提交offset，在处理完之后自己手动提交offset，就可以保证数据不会丢。但是此时确实还是会重复消费，比如你刚处理完，还没提交offset，结果自己挂了，此时肯定会重复消费一次，自己保证幂等性就好了。</p>
<p>生产环境碰到的一个问题，就是说我们的kafka消费者消费到了数据之后是写到一个内存的queue里先缓冲一下，结果有的时候，你刚把消息写入内存queue，然后消费者会自动提交offset。</p>
<p>然后此时我们重启了系统，就会导致内存queue里还没来得及处理的数据就丢失了</p>
<p>2）kafka弄丢了数据</p>
<p>这块比较常见的一个场景，就是kafka某个broker宕机，然后重新选举partiton的leader时。大家想想，要是此时其他的follower刚好还有些数据没有同步，结果此时leader挂了，然后选举某个follower成leader之后，他不就少了一些数据？这就丢了一些数据啊。</p>
<p>生产环境也遇到过，我们也是，之前kafka的leader机器宕机了，将follower切换为leader之后，就会发现说这个数据就丢了</p>
<p>所以此时一般是要求起码设置如下4个参数：</p>
<p>给这个topic设置replication.factor参数：这个值必须大于1，要求每个partition必须有至少2个副本</p>
<p>在kafka服务端设置min.insync.replicas参数：这个值必须大于1，这个是要求一个leader至少感知到有至少一个follower还跟自己保持联系，没掉队，这样才能确保leader挂了还有一个follower吧</p>
<p>在producer端设置acks=all：这个是要求每条数据，必须是写入所有replica之后，才能认为是写成功了</p>
<p>在producer端设置retries=MAX（很大很大很大的一个值，无限次重试的意思）：这个是要求一旦写入失败，就无限重试，卡在这里了</p>
<p>我们生产环境就是按照上述要求配置的，这样配置之后，至少在kafka broker端就可以保证在leader所在broker发生故障，进行leader切换时，数据不会丢失</p>
<p>3）生产者会不会弄丢数据</p>
<p>如果按照上述的思路设置了ack=all，一定不会丢，要求是，你的leader接收到消息，所有的follower都同步到了消息之后，才认为本次写成功了。如果没满足这个条件，生产者会自动不断的重试，重试无限次。</p>
<p><img src="https://i.loli.net/2020/06/03/kyev9XnQbDtoFAC.png" alt="Kafka可能存在数据丢失的问题.png"></p>
<h1 id="怎么保证从消息队列里拿到的数据按顺序执行？"><a href="#怎么保证从消息队列里拿到的数据按顺序执行？" class="headerlink" title="怎么保证从消息队列里拿到的数据按顺序执行？"></a>怎么保证从消息队列里拿到的数据按顺序执行？</h1><h1 id="出现生产事故怎么办？"><a href="#出现生产事故怎么办？" class="headerlink" title="出现生产事故怎么办？"></a>出现生产事故怎么办？</h1><p>完了！生产事故！几百万消息在消息队列里积压了几个小时！</p>
<h1 id="如何设计消息队列中间件的架构？"><a href="#如何设计消息队列中间件的架构？" class="headerlink" title="如何设计消息队列中间件的架构？"></a>如何设计消息队列中间件的架构？</h1><h1 id="总结消息队列相关面试技巧"><a href="#总结消息队列相关面试技巧" class="headerlink" title="总结消息队列相关面试技巧"></a>总结消息队列相关面试技巧</h1>]]></content>
      <categories>
        <category>Interview Note</category>
      </categories>
      <tags>
        <tag>Interview</tag>
        <tag>Study</tag>
        <tag>Message Queue</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot Seckill Project</title>
    <url>/2020/05/05/Seckill-Project/</url>
    <content><![CDATA[<blockquote>
<p>天才是长期劳动的结果。 —— 牛顿</p>
</blockquote>
<p>从0到1构建电商基础秒杀项目，并且在其基础上打造亿级流量企业级项目</p>
<a id="more"></a>

<h1 id="应用SpringBoot完成基础项目搭建"><a href="#应用SpringBoot完成基础项目搭建" class="headerlink" title="应用SpringBoot完成基础项目搭建"></a>应用SpringBoot完成基础项目搭建</h1><p>项目的性能优化和秒杀，对能力要求实际上是非常大的。</p>
<p>实际上，最简单的电商只需要三个页面：商品详情/确认开枪、订单确认、支付成功(带有流程推荐)</p>
<h2 id="SpringBoot生态简介"><a href="#SpringBoot生态简介" class="headerlink" title="SpringBoot生态简介"></a>SpringBoot生态简介</h2><p>SpringBoot默认配置整合了很多框架，就像Maven整合了所有的jar包。并且SpringBoot设置了一个main方法作为启动应用的入口(这就是Spring+Boot)，启动所有项目。</p>
<h2 id="电商秒杀应用内容"><a href="#电商秒杀应用内容" class="headerlink" title="电商秒杀应用内容"></a>电商秒杀应用内容</h2><ul>
<li>商品列表页获取秒杀商品列表</li>
<li>进入商品详情页获取秒杀商品详情</li>
<li>秒杀开始后进入下单确认页，下单并支付成功</li>
</ul>
<h2 id="基础项目实战内容"><a href="#基础项目实战内容" class="headerlink" title="基础项目实战内容"></a>基础项目实战内容</h2><ul>
<li>使用IDEA+Maven搭建SpringBoot开发环境</li>
<li>集成MyBatis操作数据库</li>
<li>实现秒杀项目</li>
</ul>
<h2 id="应用SpringBoot完成基础项目搭建-1"><a href="#应用SpringBoot完成基础项目搭建-1" class="headerlink" title="应用SpringBoot完成基础项目搭建"></a>应用SpringBoot完成基础项目搭建</h2><h3 id="使用IDEA创建Maven项目"><a href="#使用IDEA创建Maven项目" class="headerlink" title="使用IDEA创建Maven项目"></a>使用IDEA创建Maven项目</h3><p>使用Maven创建项目，因为有了SpringBoot，所以创建的时候我们选择<code>maven-archetype-quickstart</code>来作为启动模板</p>
<p><img src="https://i.loli.net/2020/05/05/HuB47J2mDeM3cxd.png" alt="使用Maven创建项目.png"></p>
<p>然后搭建起来项目，在src下创建一个resources文件用来存储Spring Boot项目的一些文件等等。</p>
<h3 id="引入SpringBoot依赖包实现简单的WEB项目"><a href="#引入SpringBoot依赖包实现简单的WEB项目" class="headerlink" title="引入SpringBoot依赖包实现简单的WEB项目"></a>引入SpringBoot依赖包实现简单的WEB项目</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.miaoshaproject<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>miaosha<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>miaosha<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- FIXME change it to the project's website --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.example.com<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span><span class="comment">&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- clean lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#clean_Lifecycle --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-clean-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- default lifecycle, jar packaging: see https://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_jar_packaging --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.22.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-install-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-deploy-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- site lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#site_Lifecycle --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-site-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-project-info-reports-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>完成后，需要在入口的App.java中进行SpringBoot的配置,使用<code>@EnableAutoConfiguration</code>注解，使用后SpringBoot会帮助我们自动启动一个内置的Tomcat并且添加进去默认的配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.miaoshaproject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.EnableAutoConfiguration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Hello world!</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//加上SpringBoot对应的注解，使得App启动类变成自动化可以支持配置的Bean，并且可以开启整个的基于SpringBoot的自动化配置</span></span><br><span class="line"><span class="comment">//加了这个配置后，项目会把Redis的依赖、数据库的依赖、对Spring容器的依赖等等全都加载到项目中</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println( <span class="string">"Hello World!"</span> );</span><br><span class="line">        <span class="comment">//启动对应的Spring Boot项目</span></span><br><span class="line">        SpringApplication.run(App<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们如何用SpringBoot来搞定SpringMVC的功能呢？</p>
<p>先加<code>@RestController</code>注解，然后定义一个用<code>@RequestMapping</code>注解注释的方法，当用户访问”/“路径的时候，会调用<code>home()</code>方法。也就是说，用<code>@RestController</code>和<code>@RequestMapping</code>这两个注解实现了传统Spring MVC需要配置servlet、web.xml等等复杂的配置。SpringBoot用这两个注解就可以搞定了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.miaoshaproject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.EnableAutoConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Hello world!</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//加上SpringBoot对应的注解，使得App启动类变成自动化可以支持配置的Bean，并且可以开启整个的基于SpringBoot的自动化配置</span></span><br><span class="line"><span class="comment">//加了这个配置后，项目会把Redis的依赖、数据库的依赖、对Spring容器的依赖等等全都加载到项目中</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="comment">//实现Spring MVC的注解</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">home</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"ni hao,zhe shi HOME method!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println( <span class="string">"Hello World!"</span> );</span><br><span class="line">        <span class="comment">//启动对应的Spring Boot项目</span></span><br><span class="line">        SpringApplication.run(App<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MyBatis接入SpringBoot项目"><a href="#MyBatis接入SpringBoot项目" class="headerlink" title="MyBatis接入SpringBoot项目"></a>MyBatis接入SpringBoot项目</h3><p>接下来引入Mybatis来实现对数据库的读和写操作。</p>
<p>首先，SpringBoot实际上提供了一个可以使用默认化的配置，在resources文件夹下可以创建properties配置文件来作为默认的配置。</p>
<p>我们这里定义一个默认的配置文件，<code>application.properties</code>，在其中配置服务端的默认端口，比如改成8090：</p>
<p><code>server.port=8090</code></p>
<p>则项目启动的时候Tomcat默认的端口就是8090。</p>
<p>然后再pom.xml配置文件中加入对mybatis起效的配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.41<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>分别是对数据库的依赖、阿里巴巴数据库连接池的依赖、mybatis对spring-boot进行操作的依赖。</p>
<p>然后再加上其他的配置，最后如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.miaoshaproject<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>miaosha<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>miaosha<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- FIXME change it to the project's website --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.example.com<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.41<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span><span class="comment">&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- clean lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#clean_Lifecycle --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-clean-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- default lifecycle, jar packaging: see https://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_jar_packaging --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.22.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-install-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-deploy-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- site lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#site_Lifecycle --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-site-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-project-info-reports-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.41<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">id</span>&gt;</span>mybatis generator<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>generate<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--允许移动生成文件，即对应生成的文件是否可以被二次移动，默认为false--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">verbose</span>&gt;</span>true<span class="tag">&lt;/<span class="name">verbose</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--允许自动覆盖，但是企业中开发千万别设置为true--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">overwrite</span>&gt;</span>true<span class="tag">&lt;/<span class="name">overwrite</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--这个配置很关键，是mybatis-generator的配置文件--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configurationFile</span>&gt;</span></span><br><span class="line">              src/main/resources/mybatis-generator.xml</span><br><span class="line">            <span class="tag">&lt;/<span class="name">configurationFile</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Mybatis自动生成器的使用方式"><a href="#Mybatis自动生成器的使用方式" class="headerlink" title="Mybatis自动生成器的使用方式"></a>Mybatis自动生成器的使用方式</h3><p>接下来编写mybatis-generator文件，这个文件编写过程是比较漫长的。</p>
<p>首先按照之前在pom.xml中配置的，在resources文件夹下创建mybatis-generator.xml文件，现在还是空的，我们先设计并实现数据库，这样才能用mybatis-generator工具生成供mybatis使用的工具类。</p>
<p>对于企业级开发，实际上数据库的模型设计非常重要，要设计的好才行。</p>
<p>我们创建一个数据库(miaosha)，创建多张表。为其中设置多个属性。</p>
<p><img src="https://i.loli.net/2020/05/06/Tuq6CjaJRbpwXdI.png" alt="数据库user_info表.png"></p>
<p>为了安全考虑，密码是加密的字符串，不和这些属性设置在一张表里，而是单独设置成一张表(user_password)。</p>
<p><img src="https://i.loli.net/2020/05/06/k5sa13LmytQpWfr.png" alt="数据库密码表user_password.png"></p>
<p>然后当然就是使用Mybatis的配置文件<code>mybatis-generator.xml</code>进行配置。注意一些路径需要我们根据项目修改模板、创建对应的文件夹。</p>
<p>在使用的时候，配置maven的启动项：</p>
<p><img src="https://i.loli.net/2020/05/06/A6joSuxRNO1Z9aI.png" alt="mybatis-generator插件使用.png"></p>
<p>需要注意，实际开发中，很少会使用复杂的查询，就算用到了，我们也宁愿用自动编写的方式去做，而不是直接在SQL语句中使用对应的example去做。我们可以在<code>mybatis-generator.xml</code>中配置属性来将example去除掉。具体做法是写:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"user_info"</span>  <span class="attr">domainObjectName</span>=<span class="string">"UserDO"</span> <span class="attr">enableCountByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableUpdateByExample</span>=<span class="string">"false"</span> <span class="attr">enableDeleteByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableSelectByExample</span>=<span class="string">"false"</span> <span class="attr">selectByExampleQueryId</span>=<span class="string">"false"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"user_password"</span>  <span class="attr">domainObjectName</span>=<span class="string">"UserPasswordDO"</span> <span class="attr">enableCountByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableUpdateByExample</span>=<span class="string">"false"</span> <span class="attr">enableDeleteByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableSelectByExample</span>=<span class="string">"false"</span> <span class="attr">selectByExampleQueryId</span>=<span class="string">"false"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样，在生成了对应的类文件之后，不需要example之类的文件：</p>
<p><img src="https://i.loli.net/2020/05/06/1U7YRaoeTl6SJLH.png" alt="mybatis-generator工具生成类文件.png"></p>
<p>接下来需要接入mybatis对应的mybatis的数据源了(刚才是使用mybatis-generator工具生成了个根据数据库内容而供mybatis使用的映射类。但是mybatis和数据库本身还没有连接上)</p>
<p>在配置文件application.properties中进行配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">8090</span></span><br><span class="line"><span class="meta">mybatis.mapperLocations</span>=<span class="string">classpath:mapping/*.xml</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.datasource.name</span>=<span class="string">miaosha</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://URL/miaosha</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">root</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用druid数据源</span></span><br><span class="line"><span class="meta">spring.datasource.type</span>=<span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line"><span class="meta">spring.datasource.driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure>

<p>然后再App.java中编写，让SpringBoot扫描Mybatis的一些配置文件和之后要做的一些service的封装。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加上SpringBoot对应的注解，使得App启动类变成自动化可以支持配置的Bean，并且可以开启整个的基于SpringBoot的自动化配置</span></span><br><span class="line"><span class="comment">//加了这个配置后，项目会把Redis的依赖、数据库的依赖、对Spring容器的依赖等等全都加载到项目中</span></span><br><span class="line"><span class="comment">//@EnableAutoConfiguration</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//@SpringBootApplication和@EnableAutoConfiguration异曲同工，都是把App类交给Spring托管，并且</span></span><br><span class="line"><span class="comment">//可以指定它是一个主启动类</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span>(scanBasePackages = &#123;<span class="string">"com.miaoshaproject"</span>&#125;)</span><br><span class="line"><span class="comment">//实现Spring MVC的注解</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="comment">//设置存放dao的位置</span></span><br><span class="line"><span class="meta">@MapperScan</span>(<span class="string">"com.miaoshaproject.dao"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserDOMapper userDOMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">home</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserDO userDO = userDOMapper.selectByPrimaryKey(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(userDO == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"用户对象不存在！"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> userDO.getName();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println( <span class="string">"Hello World!"</span> );</span><br><span class="line">        <span class="comment">//启动对应的Spring Boot项目</span></span><br><span class="line">        SpringApplication.run(App<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，真正企业级项目中，这个只能作为调试用。企业级项目中需要通过SpringMVC进行创建。</p>
<h2 id="用户模块开发"><a href="#用户模块开发" class="headerlink" title="用户模块开发"></a>用户模块开发</h2><h3 id="使用SpringMVC方式开发用户信息"><a href="#使用SpringMVC方式开发用户信息" class="headerlink" title="使用SpringMVC方式开发用户信息"></a>使用SpringMVC方式开发用户信息</h3><p>模拟真正企业级项目开发。</p>
<p>首先，自上而下，需要一个controller层，然后往下是service层。</p>
<p>UserService接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.miaoshaproject.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过用户ID获取用户对象的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getUserById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UserServiceImpl，接口实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Bennett_Wang on 2020/5/7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//表明是service</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserDOMapper userDOMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用userDOMapper获取到对应的用户dataobject</span></span><br><span class="line">        UserDO userDO = userDOMapper.selectByPrimaryKey(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这里为什么在<code>getUserById()</code>方法中没有返回值呢？</p>
<p>这点非常重要，在企业级项目开发中，是要分层的。首先之前定义的dataobject包，里面存储的都是和数据库一一对应的字段，dataobject中不含有逻辑，是一个最简单的映射。</p>
<p>但是在Service层中，不可以简单地把对应数据库的映射直接后传返回给想要这个Service的服务。也就是说，<font color=#FF0000>在Service层，必须要有一个Model的概念</font>。</p>
<p>在service层下新建一个model包。这个model才是我们真正定义SpringMVC中业务逻辑交互的模型的概念。</p>
<p>我们定义一个UserModel类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Byte gender;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String telphone;</span><br><span class="line">    <span class="keyword">private</span> String registerMode;</span><br><span class="line">    <span class="keyword">private</span> String thirdPartyId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String encrptPassword;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getEncrptPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> encrptPassword;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEncrptPassword</span><span class="params">(String encrptPassword)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.encrptPassword = encrptPassword;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Byte <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGender</span><span class="params">(Byte gender)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTelphone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> telphone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTelphone</span><span class="params">(String telphone)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.telphone = telphone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRegisterMode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> registerMode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRegisterMode</span><span class="params">(String registerMode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.registerMode = registerMode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getThirdPartyId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> thirdPartyId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setThirdPartyId</span><span class="params">(String thirdPartyId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.thirdPartyId = thirdPartyId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意，这里关键在于密码。dataobject只是对数据库的映射，UserModel类中有密码，这才是User被操作的真正的类对象。</p>
<p>然后，我们需要在<code>UserPasswordDOMapper.xml</code>文件中进行配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectByUserId"</span> <span class="attr">parameterType</span>=<span class="string">"java.lang.Integer"</span> <span class="attr">resultMap</span>=<span class="string">"BaseResultMap"</span>&gt;</span></span><br><span class="line">    select</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"Base_Column_List"</span> /&gt;</span></span><br><span class="line">    from user_password</span><br><span class="line">    where user_id = #&#123;userId,jdbcType=INTEGER&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后再在<code>UserPasswordDOMapper.java</code>文件中定义之前id中已经写好的<code>selectByUserId</code>方法。</p>
<p><code>UserPasswordDO selectByUserId(Integer userId);</code></p>
<p>然后重构<code>UserServiceImpl.java</code>文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//表明是service</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserDOMapper userDOMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserPasswordDOMapper userPasswordDOMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserModel <span class="title">getUserById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用userDOMapper获取到对应的用户dataobject</span></span><br><span class="line">        UserDO userDO = userDOMapper.selectByPrimaryKey(id);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(userDO == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通过用户id获取对应的用户加密密码信息</span></span><br><span class="line">        UserPasswordDO userPasswordDO = userPasswordDOMapper.selectByUserId(userDO.getId());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> convertFromDataObject(userDO,userPasswordDO);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> UserModel <span class="title">convertFromDataObject</span><span class="params">(UserDO userDO, UserPasswordDO userPasswordDO)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//处理userDO为null这个异常</span></span><br><span class="line">        <span class="keyword">if</span>(userDO == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        UserModel userModel = <span class="keyword">new</span> UserModel();</span><br><span class="line">        BeanUtils.copyProperties(userDO,userModel);</span><br><span class="line">        <span class="comment">//处理密码为空这个异常</span></span><br><span class="line">        <span class="keyword">if</span>(userPasswordDO != <span class="keyword">null</span>) &#123;</span><br><span class="line">            userModel.setEncrptPassword(userPasswordDO.getEncrptPassword());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> userModel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时返回的是UserModel了，根据UserDO来获取到用户的dataobject内容，再同时根据UserPasswordDO来进一步获取用户的密码。</p>
<p>最后在controller中写请求的URL的内容逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@Controller用来标记，让Spring能扫描到</span></span><br><span class="line"><span class="meta">@Controller</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/get"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserModel <span class="title">getUser</span><span class="params">(@RequestParam(name = <span class="string">"id"</span>)</span> Integer id) </span>&#123;</span><br><span class="line">        <span class="comment">//调用service服务获取对应id的用户对象并返回给前端</span></span><br><span class="line">        UserModel userModel = userService.getUserById(id);</span><br><span class="line">        <span class="keyword">return</span> userModel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后启动系统，访问<a href="http://localhost:8090/user/get?id=1，可以得到对应的保存在数据库中的结果。" target="_blank" rel="noopener">http://localhost:8090/user/get?id=1，可以得到对应的保存在数据库中的结果。</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"第一个用户"</span>,</span><br><span class="line">  <span class="attr">"gender"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"age"</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">"telphone"</span>: <span class="string">"134578856541"</span>,</span><br><span class="line">  <span class="attr">"registerMode"</span>: <span class="string">"byphone"</span>,</span><br><span class="line">  <span class="attr">"thirdPartyId"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"encrptPassword"</span>: <span class="string">"asdfdsgsfdgsd"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然用户的密码被加密过，但是用户的密码不能够直接被前端请求得到，这样的做法非常不专业。</p>
<p>如何解决呢？——问题出在我们把userModel直接返回给了前端。前端只需要拿到需要展示的内容即可，不要把整个领域模型都拿给前端。</p>
<p>我们在controller包下定义view model，定义一个viewobject包，把需要返回给前端的模型都定义在这个包下。然后在这个包下定义<code>UserVO</code>，其字段与UserModel相比，只需要给前端返回的字段即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserVO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Byte gender;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String telphone;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Byte <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGender</span><span class="params">(Byte gender)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTelphone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> telphone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTelphone</span><span class="params">(String telphone)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.telphone = telphone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义通用的返回对象——返回正确信息"><a href="#定义通用的返回对象——返回正确信息" class="headerlink" title="定义通用的返回对象——返回正确信息"></a>定义通用的返回对象——返回正确信息</h3><p>实际开发中，如果就按照上面写的，程序直接返回需要在前端展示的内容，那么如果程序出错了，不加以处理的话，直接返回一个错误码，前端的调试是无从下手的。</p>
<p>创建一个response包，用来编写返回的内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonReturnType</span> </span>&#123;</span><br><span class="line">    <span class="comment">//表明对应请求的返回处理结果"success"或"fail"</span></span><br><span class="line">    <span class="keyword">private</span> String status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若status=success，则data内返回前端需要的json数据</span></span><br><span class="line">    <span class="comment">//若status=fail，则data内使用通用的错误码格式</span></span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个通用的创建方法</span></span><br><span class="line">    <span class="comment">//如果不带有status，则创建对象成功</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CommonReturnType <span class="title">create</span><span class="params">(Object result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CommonReturnType.create(result, <span class="string">"success"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个"二重奏"的函数</span></span><br><span class="line">    <span class="comment">//使用函数重载的方式，构造成功创建的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CommonReturnType <span class="title">create</span><span class="params">(Object result, String status)</span> </span>&#123;</span><br><span class="line">        CommonReturnType type = <span class="keyword">new</span> CommonReturnType();</span><br><span class="line">        type.setStatus(status);</span><br><span class="line">        type.setData(result);</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStatus</span><span class="params">(String status)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面进行使用这个类,修改UserController方法中的<code>getUser()</code>方法，改变返回的对象的类型为CommonReturnType：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/get"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonReturnType <span class="title">getUser</span><span class="params">(@RequestParam(name = <span class="string">"id"</span>)</span> Integer id) </span>&#123;</span><br><span class="line">        <span class="comment">//调用service服务获取对应id的用户对象并返回给前端</span></span><br><span class="line">        UserModel userModel = userService.getUserById(id);</span><br><span class="line"></span><br><span class="line">        UserVO userVO = convertFromModel(userModel);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        //将核心领域模型用户对象转换为可供UI使用的viewobject</span></span><br><span class="line"><span class="comment">//        return convertFromModel(userModel);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回通用对象</span></span><br><span class="line">        <span class="keyword">return</span> CommonReturnType.create(userVO);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>之后启动项目，会发现返回结果中带有status状态码。而且状态码和data分开：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"status"</span>: <span class="string">"success"</span>,</span><br><span class="line">  <span class="attr">"data"</span>: &#123;</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"第一个用户"</span>,</span><br><span class="line">    <span class="attr">"gender"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"age"</span>: <span class="number">30</span>,</span><br><span class="line">    <span class="attr">"telphone"</span>: <span class="string">"134578856541"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义通用的返回对象——返回错误信息"><a href="#定义通用的返回对象——返回错误信息" class="headerlink" title="定义通用的返回对象——返回错误信息"></a>定义通用的返回对象——返回错误信息</h3><p>上一节定义了success的返回值。这里可以再定义一下出了错，fail的返回值。</p>
<p>首先要自己定义对应的通用的错误形式。创建一个error包。接下来一个比较取巧的方法，是尝试在一个可视化界面中能够完整的对应的描述。</p>
<p>创建一个接口<code>CommonError</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CommonError</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getErrCode</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getErrMsg</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonError <span class="title">setErrMsg</span><span class="params">(String errMsg)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后定义一个枚举，把对应的error的信息取出来。</p>
<p>注意，在分布式开发的时候，经常需要做的就是要在<strong>全局有一个统一的状态码</strong>的流。企业级开发中，需要在全局有统一的码的对应。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.miaoshaproject.error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EmBusinessError implements CommonError &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通用错误类型10001</span></span><br><span class="line">    PARAMETER_VALIDATION_ERROR(<span class="number">10001</span>,<span class="string">"参数不合法"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通用错误类型10002</span></span><br><span class="line">    UNKNOWN_ERROR(<span class="number">10002</span>,<span class="string">"未知错误"</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//20000开头为用户信息相关错误定义</span></span><br><span class="line">    USER_NOT_EXIST(<span class="number">20001</span>,<span class="string">"用户不存在"</span>)</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有了构造方法，当USER_NOT_EXIST被定义出来之后，可以构造出来实现了CommonError的子类</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EmBusinessError</span><span class="params">(<span class="keyword">int</span> errCode,String errMsg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.errCode = errCode;</span><br><span class="line">        <span class="keyword">this</span>.errMsg = errMsg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> errCode;</span><br><span class="line">    <span class="keyword">private</span> String errMsg;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getErrCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.errCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getErrMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.errMsg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonError <span class="title">setErrMsg</span><span class="params">(String errMsg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.errMsg = errMsg;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来新建一个Exception来处理所有会报的异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//包装器业务异常类实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessException</span> <span class="keyword">extends</span> <span class="title">Exception</span> <span class="keyword">implements</span> <span class="title">CommonError</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CommonError commonError;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接接收EmBusinessError的传参用于构造业务异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BusinessException</span><span class="params">(CommonError commonError)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.commonError = commonError;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收自定义errMsg的方式构造业务异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BusinessException</span><span class="params">(CommonError commonError, String errMsg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.commonError = commonError;</span><br><span class="line">        <span class="keyword">this</span>.commonError.setErrMsg(errMsg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getErrCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.commonError.getErrCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getErrMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.commonError.getErrMsg();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonError <span class="title">setErrMsg</span><span class="params">(String errMsg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.commonError.setErrMsg(errMsg);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一来，<code>EmBusinessError</code>和<code>BusinessException</code>都实现了<code>CommonError</code>这个接口，这样的话外部使用这两个类，都有对应的errCode和errMsg的组装定义。并且需要共同实现一个setErrMsg方法，可以覆盖原本Enum中定义的errMsg。</p>
<p>在controller中尝试使用这两个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@Controller用来标记，让Spring能扫描到</span></span><br><span class="line"><span class="meta">@Controller</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/get"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonReturnType <span class="title">getUser</span><span class="params">(@RequestParam(name = <span class="string">"id"</span>)</span> Integer id) <span class="keyword">throws</span> BusinessException </span>&#123;</span><br><span class="line">        <span class="comment">//调用service服务获取对应id的用户对象并返回给前端</span></span><br><span class="line">        UserModel userModel = userService.getUserById(id);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//若获取的对应用户信息不存在</span></span><br><span class="line">        <span class="keyword">if</span>(userModel == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.USER_NOT_EXIST);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        UserVO userVO = convertFromModel(userModel);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        //将核心领域模型用户对象转换为可供UI使用的viewobject</span></span><br><span class="line"><span class="comment">//        return convertFromModel(userModel);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回通用对象</span></span><br><span class="line">        <span class="keyword">return</span> CommonReturnType.create(userVO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> UserVO <span class="title">convertFromModel</span><span class="params">(UserModel userModel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(userModel == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        UserVO userVO = <span class="keyword">new</span> UserVO();</span><br><span class="line">        BeanUtils.copyProperties(userModel,userVO);</span><br><span class="line">        <span class="keyword">return</span> userVO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是此时如果访问了不存在的用户(比如id=2)，那么页面还是会报500，因为我们没有针对异常进行处理。下面来处理抛出的异常。</p>
<h3 id="定义通用的返回对象——异常处理"><a href="#定义通用的返回对象——异常处理" class="headerlink" title="定义通用的返回对象——异常处理"></a>定义通用的返回对象——异常处理</h3><p>接下来使用SpringBoot自带的SpringMVC的HandlerException来解决通用的异常处理。</p>
<p>一开始，只会把异常抛出到Tomcat的容器层，而这个容器层处理异常的方式只会返回500的错误页。但是这里其实可以定义exceptionhandler解决未被controller层吸收的exception异常。</p>
<p>为什么有这样的设计思想呢？——<font color=#FF0000>对于web系统，controller层的异常在某种意义上来说是业务处理的最后一道关口</font>。为了让用户看到的页面不是单纯一个500异常的很挫的页面，我们可以自定义500页面并且返回。</p>
<p>使用方式，可以直接用注解<code>@ExceptionHandler</code>。代码都是写在controller层的<code>UserController.java</code>中</p>
<p>实际上对于BusinessError这种异常来说，不应该直接返回500的服务器异常，而应该写代码指定说是业务逻辑上出了问题，不是服务端不能处理的错误。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义exceptionhandler解决未被controller层吸收的controller层</span></span><br><span class="line"><span class="comment">//@ExceptionHandler中参数这里使用了异常的根类(Exception.class)</span></span><br><span class="line"><span class="meta">@ExceptionHandler</span>(Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ResponseStatus</span>(<span class="title">HttpStatus</span>.<span class="title">OK</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ResponseBody</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">Object</span> <span class="title">handlerException</span>(<span class="title">HttpServletRequest</span> <span class="title">request</span>,<span class="title">Exception</span> <span class="title">ex</span>) </span>&#123;</span><br><span class="line">    Map&lt;String,Object&gt; responseData = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(ex <span class="keyword">instanceof</span> BusinessException) &#123;</span><br><span class="line">        BusinessException businessException = (BusinessException) ex;</span><br><span class="line">        responseData.put(<span class="string">"errCode"</span>,businessException.getErrCode());</span><br><span class="line">        responseData.put(<span class="string">"errMsg"</span>,businessException.getErrMsg());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        responseData.put(<span class="string">"errCode"</span>,EmBusinessError.UNKNOWN_ERROR.getErrCode());</span><br><span class="line">        responseData.put(<span class="string">"errMsg"</span>,EmBusinessError.UNKNOWN_ERROR.getErrMsg());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> CommonReturnType.create(responseData,<span class="string">"fail"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样在发送请求的时候，如果不能够根据id找到用户，那么会抛出用户不存在的异常。</p>
<p>但是如果异常不是之前写好的”找不到用户”，那么目前可以划分到”未知错误”，会返回得到”未知错误”。</p>
<p>到了这里，其实还可以<strong>用面向对象的思维方式进行优化</strong>。因为虽然这部分写在了<code>UserController.java</code>中，但是这个逻辑其实是所有controller都想用的公用逻辑。我们把它集成到一个BaseController中(当然，UserController中就可以删掉这部分代码)，然后让userController继承BaseController即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseController</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义exceptionhandler解决未被controller层吸收的controller层</span></span><br><span class="line">    <span class="comment">//@ExceptionHandler中参数这里使用了异常的根 类(Exception.class)</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">HttpStatus</span>.<span class="title">OK</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseBody</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">Object</span> <span class="title">handlerException</span>(<span class="title">HttpServletRequest</span> <span class="title">request</span>, <span class="title">Exception</span> <span class="title">ex</span>) </span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; responseData = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//如果ex不是BusinessException，抛出"未知异常"，这是为了程序的健壮性</span></span><br><span class="line">        <span class="keyword">if</span>(ex <span class="keyword">instanceof</span> BusinessException) &#123;</span><br><span class="line">            BusinessException businessException = (BusinessException) ex;</span><br><span class="line">            responseData.put(<span class="string">"errCode"</span>,businessException.getErrCode());</span><br><span class="line">            responseData.put(<span class="string">"errMsg"</span>,businessException.getErrMsg());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            responseData.put(<span class="string">"errCode"</span>, EmBusinessError.UNKNOWN_ERROR.getErrCode());</span><br><span class="line">            responseData.put(<span class="string">"errMsg"</span>,EmBusinessError.UNKNOWN_ERROR.getErrMsg());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> CommonReturnType.create(responseData,<span class="string">"fail"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下我们做了哪些事情：</p>
<ol>
<li>我们自己定义了CommonReturnType，可以用对应的<code>String status</code>加一个<code>Object data</code>的方式返回所有的JSON序列化方式对应的对象，摒弃了<code>HTTPStatus Code+Tomcat自带Error页</code>的方式去处理。</li>
<li>定义了BussinessException，统一管理我们想要的错误码。</li>
<li>在BaseController中定义了一个通用的<code>handlerException</code>类，来解决未被controller层吸收的Exception，并且使用了<code>errCode+errMsg</code>的统一的定义方式，吃掉了内部所有的不可预知的异常。</li>
</ol>
<p>到此为止，我们就已经完成了项目<strong>基础能力建设</strong>的工作了。下面需要开始搭建<strong>模型能力的管理</strong>部分。</p>
<h3 id="用户模型管理——otp验证码获取"><a href="#用户模型管理——otp验证码获取" class="headerlink" title="用户模型管理——otp验证码获取"></a>用户模型管理——otp验证码获取</h3><p>什么是<strong>模型能力管理</strong>呢？在开发中，会有一个领域模型的概念。比如用户这个模型会有多个步骤来构建一个完整的生命周期，比如注册是第一步、用户信息浏览登录是第二步，等等。</p>
<p>对于用户管理，我们接下来要做的就是：</p>
<ul>
<li>otp短信获取</li>
<li>otp注册用户</li>
<li>用户手机登录</li>
</ul>
<p>所谓otp，就是给用户发一条短信，让用户把短信中的验证码作为注册的信息。</p>
<p>在<code>UserController</code>中写这段代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HttpServletRequest httpServletRequest;<span class="comment">//虽然这里用了注入，是Bean，但是不只是单例模式的问题。</span></span><br><span class="line">    <span class="comment">//Spring Bean包装了HttpServlet，其本质是一个proxy，其内部有ThreadLocal方式的Map让用户多线程使用</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/getotp"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="comment">//用户获取otp短信接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonReturnType <span class="title">getOtp</span><span class="params">(@RequestParam(name = <span class="string">"telphone"</span>)</span>String telphone) </span>&#123;</span><br><span class="line">        <span class="comment">//1.需要按照一定的规则生成OTP验证码，这里采用随机数的生成方式</span></span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> randomInt = random.nextInt(<span class="number">99999</span>);<span class="comment">//此时随机数取值为：[0,99999)</span></span><br><span class="line">        randomInt += <span class="number">10000</span>;<span class="comment">//此时随机数randomInt的取值范围：[10000,109999)</span></span><br><span class="line">        String otpCode = String.valueOf(randomInt);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.将OTP验证码与对应用户的手机号关联。在企业级项目中，适合用Redis的分布式处理的方式</span></span><br><span class="line">        <span class="comment">//这里暂时先只使用httpsession的方式绑定用户手机号和OTPCODE</span></span><br><span class="line">        <span class="comment">//拿到httpsession的方式，只需要注入HttpServletRequest</span></span><br><span class="line">        httpServletRequest.getSession().setAttribute(telphone,otpCode);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.将OTP验证码通过短信通道发送给用户(这个功能暂时省略，涉及第三方短信通道)</span></span><br><span class="line">        <span class="comment">//在这里为了调试方便，直接打印到命令行</span></span><br><span class="line">        System.out.println(<span class="string">"telphone = "</span> + telphone + <span class="string">" &amp; otpCode = "</span> + otpCode);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> CommonReturnType.create(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>进行这段代码的功能调试，可以输入URL:<a href="http://localhost:8090/user/getotp?telphone=13544444444，得到的结果是：" target="_blank" rel="noopener">http://localhost:8090/user/getotp?telphone=13544444444，得到的结果是：</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"status"</span>: <span class="string">"success"</span>,</span><br><span class="line">  <span class="string">"data"</span>: <span class="keyword">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用户模型管理——Metronic模板简介"><a href="#用户模型管理——Metronic模板简介" class="headerlink" title="用户模型管理——Metronic模板简介"></a>用户模型管理——Metronic模板简介</h3><p>下面采取前后端分离的模式，把用户注册的界面做出来。</p>
<p>这里的前端界面，使用了Metronic模板，实际上这个模板是基于Bootstrap的。只需要引入一行CSS或者JS代码，就可以实现很酷炫的效果。</p>
<p>作为后端开发，实际上在admin这样的开发，对于页面美化要求不高，那么是要后端自己写的。</p>
<h3 id="用户模型管理——getotp页面实现"><a href="#用户模型管理——getotp页面实现" class="headerlink" title="用户模型管理——getotp页面实现"></a>用户模型管理——getotp页面实现</h3><p>这个页面主要实现输入用户的手机的框，然后再加一个submit的按钮来完成获取用户短信的内容。</p>
<p>需要注意，在输入手机号的这一栏，我们用到了name和id。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;input <span class="attribute">type</span>=<span class="string">"text"</span> <span class="attribute">placeholder</span>=<span class="string">"手机号"</span> <span class="attribute">name</span>=<span class="string">"telphone"</span> <span class="attribute">id</span>=<span class="string">"telphone"</span>&gt;</span><br></pre></td></tr></table></figure>

<p>为什么呢？因为这里用到的是前后端分离的项目，要用ajax请求，而不用post的方式。</p>
<p>整个的页面代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">	&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">	&lt;script src=<span class="string">"static/assets/global/plugins/jquery-1.11.0.min.js"</span> type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">		</span><br><span class="line">	&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">	&lt;title&gt;GETOTP&lt;/</span>title&gt;</span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp">	&lt;div&gt;</span></span><br><span class="line"><span class="regexp">		&lt;h3&gt;获取otp信息&lt;/</span>h3&gt;</span><br><span class="line">		&lt;div&gt;</span><br><span class="line">			&lt;label&gt;手机号&lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">			&lt;div&gt;</span></span><br><span class="line"><span class="regexp">				&lt;input type="text" placeholder="手机号" name="telphone" id="telphone"&gt;</span></span><br><span class="line"><span class="regexp">			&lt;/</span>div&gt;</span><br><span class="line">		&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">		&lt;div&gt;</span></span><br><span class="line"><span class="regexp">			&lt;button id="getotp" type="submit"&gt;</span></span><br><span class="line"><span class="regexp">				获取otp短信</span></span><br><span class="line"><span class="regexp">			&lt;/</span>button&gt;</span><br><span class="line">		&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">	&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">	jQuery(document).ready(function()&#123;</span></span><br><span class="line"><span class="regexp">		/</span><span class="regexp">/绑定otp的click事件用于向后端发送手机验证码的请求</span></span><br><span class="line"><span class="regexp">		$("#getotp").on("click",function()&#123;</span></span><br><span class="line"><span class="regexp">			var telphone = $("#telphone").val();</span></span><br><span class="line"><span class="regexp">			if(telphone == null || telphone == "")&#123;</span></span><br><span class="line"><span class="regexp">				alert("手机号不能为空");</span></span><br><span class="line"><span class="regexp">				/</span><span class="regexp">/这里返回false是为了不让它被冒泡传递到上一层</span></span><br><span class="line"><span class="regexp">				return false;</span></span><br><span class="line"><span class="regexp">			&#125;</span></span><br><span class="line"><span class="regexp">			$.ajax(&#123;</span></span><br><span class="line"><span class="regexp">				type:"POST",</span></span><br><span class="line"><span class="regexp">				contentType:"application/</span>x-www-form-urlencoded<span class="string">",</span></span><br><span class="line"><span class="string">				url:"</span>http:<span class="comment">//localhost:8090/user/getotp",</span></span><br><span class="line">				data:&#123;</span><br><span class="line">					<span class="string">"telphone"</span>:$(<span class="string">"#telphone"</span>).val(),</span><br><span class="line">				&#125;,</span><br><span class="line">				success:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">					<span class="keyword">if</span>(data.status == <span class="string">"success"</span>) &#123;</span><br><span class="line">						alert(<span class="string">"otp已经发送到了您的手机上，请注意查收"</span>);</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						alert(<span class="string">"otp发送失败，原因为"</span> + data.data.errMsg);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;,</span><br><span class="line"></span><br><span class="line">				error:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">					alert(<span class="string">"otp发送失败，原因为"</span> + data.responseText);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">	&#125;);</span><br><span class="line">	</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure>

<p>这样写完需要注意，此时如果直接把otp从后端发送到ajax的前端页面，会出现跨域错误，因为。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Access</span> <span class="keyword">to</span> XMLHttpRequest at <span class="string">'http://localhost:8090/user/getotp'</span> <span class="keyword">from</span> origin <span class="string">'null'</span> has been blocked <span class="keyword">by</span> CORS <span class="keyword">policy</span>: <span class="keyword">No</span> <span class="string">'Access-Control-Allow-Origin'</span> <span class="keyword">header</span> <span class="keyword">is</span> present <span class="keyword">on</span> the requested resource.</span><br></pre></td></tr></table></figure>

<p>虽然请求能够正确地达到服务端，并且服务端也能正确返回，但是ajax的回调认定，他们俩的域不同，这种回调是不安全的。因此会报错并且走不到ajax的success的block中。</p>
<p>在SpringBoot中提供了简单的注解形式，加上<code>@CrossOrigin</code>即可。</p>
<h3 id="用户模型管理——getotp页面美化"><a href="#用户模型管理——getotp页面美化" class="headerlink" title="用户模型管理——getotp页面美化"></a>用户模型管理——getotp页面美化</h3><p>上面完成的页面效果太简单了，我们需要美化一下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">	&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">	&lt;link rel=<span class="string">"stylesheet"</span> type=<span class="string">"text/css"</span> href=<span class="string">"static/assets/global/plugins/bootstrap/css/bootstrap.min.css"</span>&gt;</span><br><span class="line">	&lt;link rel=<span class="string">"stylesheet"</span> type=<span class="string">"text/css"</span> href=<span class="string">"static/assets/global/css/components.css"</span>&gt;</span><br><span class="line">	&lt;link rel=<span class="string">"stylesheet"</span> type=<span class="string">"text/css"</span> href=<span class="string">"static/assets/admin/pages/css/login.css"</span>&gt;</span><br><span class="line">	&lt;script src=<span class="string">"static/assets/global/plugins/jquery-1.11.0.min.js"</span> type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">		</span><br><span class="line">	&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">	&lt;title&gt;GETOTP&lt;/</span>title&gt;</span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">&lt;body class="login"&gt;</span></span><br><span class="line"><span class="regexp">	&lt;div class="content"&gt;</span></span><br><span class="line"><span class="regexp">		&lt;h3 class="form-title"&gt;获取otp信息&lt;/</span>h3&gt;</span><br><span class="line">		&lt;div&gt;</span><br><span class="line">			&lt;label <span class="class"><span class="keyword">class</span></span>=<span class="string">"control-label"</span>&gt;手机号&lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">			&lt;div class="form-group"&gt;</span></span><br><span class="line"><span class="regexp">				&lt;input class="form-control" type="text" placeholder="手机号" name="telphone" id="telphone"&gt;</span></span><br><span class="line"><span class="regexp">			&lt;/</span>div&gt;</span><br><span class="line">		&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">		&lt;div class="form-actions"&gt;</span></span><br><span class="line"><span class="regexp">			&lt;button id="getotp" type="submit" class="btn blue"&gt;</span></span><br><span class="line"><span class="regexp">				获取otp短信</span></span><br><span class="line"><span class="regexp">			&lt;/</span>button&gt;</span><br><span class="line">		&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">	&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br></pre></td></tr></table></figure>

<p>做法其实就是引入样式模板中写好的class即可。</p>
<h3 id="用户模型管理——用户注册功能实现"><a href="#用户模型管理——用户注册功能实现" class="headerlink" title="用户模型管理——用户注册功能实现"></a>用户模型管理——用户注册功能实现</h3><p>在UserController中写一个注册方法，如果没通过校验，则报错。如果通过校验，需要在UserService接口中声明register方法，并且在UserServbiceImpl中实现这个方法。</p>
<p>在实现过程中，我们还需要引入一个Apache的Common包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-lang3 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后完成注册和两个对应的转化的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//为了保证user和userPassword都在一个事务中，要加上事务的注解</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(UserModel userModel)</span> <span class="keyword">throws</span> BusinessException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(userModel == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(userModel.getName())</span><br><span class="line">            || userModel.getGender() == <span class="keyword">null</span></span><br><span class="line">            || userModel.getAge() == <span class="keyword">null</span></span><br><span class="line">            || StringUtils.isEmpty(userModel.getTelphone())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实现model -&gt; dataobject方法</span></span><br><span class="line">        UserDO userDO = convertFromModel(userModel);</span><br><span class="line">        userDOMapper.insertSelective(userDO);</span><br><span class="line"></span><br><span class="line">        UserPasswordDO userPasswordDO = convertPasswordFromModel(userModel);</span><br><span class="line">        userPasswordDOMapper.insertSelective(userPasswordDO);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> UserPasswordDO <span class="title">convertPasswordFromModel</span><span class="params">(UserModel userModel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(userModel == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        UserPasswordDO userPasswordDO = <span class="keyword">new</span> UserPasswordDO();</span><br><span class="line">        userPasswordDO.setEncrptPassword(userModel.getEncrptPassword());</span><br><span class="line">        userPasswordDO.setUserId(userModel.getId());</span><br><span class="line">        <span class="keyword">return</span> userPasswordDO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> UserDO <span class="title">convertFromModel</span><span class="params">(UserModel userModel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(userModel == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        UserDO userDO = <span class="keyword">new</span> UserDO();</span><br><span class="line">        BeanUtils.copyProperties(userModel,userDO);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> userDO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> UserModel <span class="title">convertFromDataObject</span><span class="params">(UserDO userDO, UserPasswordDO userPasswordDO)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//处理userDO为null这个异常</span></span><br><span class="line">        <span class="keyword">if</span>(userDO == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        UserModel userModel = <span class="keyword">new</span> UserModel();</span><br><span class="line">        BeanUtils.copyProperties(userDO,userModel);</span><br><span class="line">        <span class="comment">//处理密码为空这个异常</span></span><br><span class="line">        <span class="keyword">if</span>(userPasswordDO != <span class="keyword">null</span>) &#123;</span><br><span class="line">            userModel.setEncrptPassword(userPasswordDO.getEncrptPassword());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> userModel;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意，为什么用的是<code>insertSelective()</code>而不是直接用selective()呢?</p>
<p>因为用<code>insertSelective()</code>不会用null字段覆盖数据库中原有的字段，而单纯的Selective()会允许null字段覆盖数据库原有字段。这个对于update()很有必要。</p>
<p>在一般数据库设计中应当尽量避免使用null字段。因为：</p>
<ol>
<li>Java对于空字段的处理本身是非常脆弱的</li>
<li>null字段对于前端展示很多时候是没有什么意义的</li>
</ol>
<p>但是也不是说一定要不使用null。比如有时候我们需要给属性的手机号加上索引，那么手机是否为唯一索引会是一个问题。</p>
<p>完成UserController函数中的register方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用户注册接口</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/register"</span>,method = &#123;RequestMethod.POST&#125;,consumes = &#123;CONTENT_TYPE_FORMED&#125;)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonReturnType <span class="title">register</span><span class="params">(@RequestParam(name = <span class="string">"telphone"</span>)</span>String telphone,</span></span><br><span class="line"><span class="function">                                 @<span class="title">RequestParam</span><span class="params">(name = <span class="string">"otpCode"</span>)</span>String otpCode,</span></span><br><span class="line"><span class="function">                                 @<span class="title">RequestParam</span><span class="params">(name = <span class="string">"name"</span>)</span>String name,</span></span><br><span class="line"><span class="function">                                 @<span class="title">RequestParam</span><span class="params">(name = <span class="string">"gender"</span>)</span>Integer gender,</span></span><br><span class="line"><span class="function">                                 @<span class="title">RequestParam</span><span class="params">(name = <span class="string">"age"</span>)</span>Integer age,</span></span><br><span class="line"><span class="function">                                 @<span class="title">RequestParam</span><span class="params">(name = <span class="string">"password"</span>)</span>String password) <span class="keyword">throws</span> BusinessException</span>&#123;</span><br><span class="line">    <span class="comment">//验证手机号和对应的otpCode相符合</span></span><br><span class="line">    String inSessionOtpCode = (String)<span class="keyword">this</span>.httpServletRequest.getSession().getAttribute(telphone);</span><br><span class="line">    <span class="keyword">if</span>(!com.alibaba.druid.util.StringUtils.equals(otpCode,inSessionOtpCode)) &#123; <span class="comment">//这个StringUtils中已经做了判空处理</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR,<span class="string">"短信验证码不符合"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用户注册流程</span></span><br><span class="line">    UserModel userModel = <span class="keyword">new</span> UserModel();</span><br><span class="line">    userModel.setName(name);</span><br><span class="line">    userModel.setGender(gender);</span><br><span class="line">    userModel.setAge(age);</span><br><span class="line">    userModel.setTelphone(telphone);</span><br><span class="line">    userModel.setRegisterMode(<span class="string">"byphone"</span>);</span><br><span class="line">    userModel.setEncrptPassword(MD5Encoder.encode(password.getBytes()));</span><br><span class="line"></span><br><span class="line">    userService.register(userModel);</span><br><span class="line">    <span class="keyword">return</span> CommonReturnType.create(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来解决前端界面的问题。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">	&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">	&lt;link rel=<span class="string">"stylesheet"</span> type=<span class="string">"text/css"</span> href=<span class="string">"static/assets/global/plugins/bootstrap/css/bootstrap.min.css"</span>&gt;</span><br><span class="line">	&lt;link rel=<span class="string">"stylesheet"</span> type=<span class="string">"text/css"</span> href=<span class="string">"static/assets/global/css/components.css"</span>&gt;</span><br><span class="line">	&lt;link rel=<span class="string">"stylesheet"</span> type=<span class="string">"text/css"</span> href=<span class="string">"static/assets/admin/pages/css/login.css"</span>&gt;</span><br><span class="line">	&lt;script src=<span class="string">"static/assets/global/plugins/jquery-1.11.0.min.js"</span> type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">		</span><br><span class="line">	&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">	&lt;title&gt;注册&lt;/</span>title&gt;</span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">&lt;body class="login"&gt;</span></span><br><span class="line"><span class="regexp">	&lt;div class="content"&gt;</span></span><br><span class="line"><span class="regexp">		&lt;h3 class="form-title"&gt;用户注册&lt;/</span>h3&gt;</span><br><span class="line">		&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-group"</span>&gt;</span><br><span class="line">			&lt;label <span class="class"><span class="keyword">class</span></span>=<span class="string">"control-label"</span>&gt;手机号&lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">			&lt;div&gt;</span></span><br><span class="line"><span class="regexp">				&lt;input class="form-control" type="text" placeholder="手机号" name="telphone" id="telphone"/</span>&gt;</span><br><span class="line">			&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">		&lt;/</span>div&gt;</span><br><span class="line">		&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-group"</span>&gt;</span><br><span class="line">			&lt;label <span class="class"><span class="keyword">class</span></span>=<span class="string">"control-label"</span>&gt;验证码&lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">			&lt;div&gt;</span></span><br><span class="line"><span class="regexp">				&lt;input class="form-control" type="text" placeholder="验证码" name="otpCode" id="otpCode"/</span>&gt;</span><br><span class="line">			&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">		&lt;/</span>div&gt;</span><br><span class="line">		&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-group"</span>&gt;</span><br><span class="line">			&lt;label <span class="class"><span class="keyword">class</span></span>=<span class="string">"control-label"</span>&gt;用户昵称&lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">			&lt;div&gt;</span></span><br><span class="line"><span class="regexp">				&lt;input class="form-control" type="text" placeholder="用户昵称" name="name" id="name"/</span>&gt;</span><br><span class="line">			&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">		&lt;/</span>div&gt;</span><br><span class="line">		&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-group"</span>&gt;</span><br><span class="line">			&lt;label <span class="class"><span class="keyword">class</span></span>=<span class="string">"control-label"</span>&gt;性别&lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">			&lt;div&gt;</span></span><br><span class="line"><span class="regexp">				&lt;input class="form-control" type="text" placeholder="性别" name="gender" id="gender"/</span>&gt;</span><br><span class="line">			&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">		&lt;/</span>div&gt;</span><br><span class="line">		&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-group"</span>&gt;</span><br><span class="line">			&lt;label <span class="class"><span class="keyword">class</span></span>=<span class="string">"control-label"</span>&gt;年龄&lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">			&lt;div&gt;</span></span><br><span class="line"><span class="regexp">				&lt;input class="form-control" type="text" placeholder="年龄" name="age" id="age"/</span>&gt;</span><br><span class="line">			&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">		&lt;/</span>div&gt;</span><br><span class="line">		&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-group"</span>&gt;</span><br><span class="line">			&lt;label <span class="class"><span class="keyword">class</span></span>=<span class="string">"control-label"</span>&gt;密码&lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">			&lt;div&gt;</span></span><br><span class="line"><span class="regexp">				&lt;input class="form-control" type="password" placeholder="密码" name="password" id="password"/</span>&gt;</span><br><span class="line">			&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">		&lt;/</span>div&gt;</span><br><span class="line">		&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-actions"</span>&gt;</span><br><span class="line">			&lt;button id=<span class="string">"register"</span> type=<span class="string">"submit"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"btn blue"</span>&gt;</span><br><span class="line">				提交注册</span><br><span class="line">			&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">		&lt;/</span>div&gt;</span><br><span class="line">	&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">	jQuery(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="comment">//绑定otp的click事件用于向后端发送手机验证码的请求</span></span><br><span class="line">		$(<span class="string">"#register"</span>).on(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="keyword">var</span> telphone = $(<span class="string">"#telphone"</span>).val();</span><br><span class="line">			<span class="keyword">var</span> password = $(<span class="string">"#password"</span>).val();</span><br><span class="line">			<span class="keyword">var</span> age = $(<span class="string">"#age"</span>).val();</span><br><span class="line">			<span class="keyword">var</span> gender = $(<span class="string">"#gender"</span>).val();</span><br><span class="line">			<span class="keyword">var</span> name = $(<span class="string">"#name"</span>).val();</span><br><span class="line">			<span class="keyword">var</span> otpCode = $(<span class="string">"#otpCode"</span>).val();</span><br><span class="line">			<span class="keyword">if</span>(telphone == <span class="literal">null</span> || telphone == <span class="string">""</span>)&#123;</span><br><span class="line">				alert(<span class="string">"手机号不能为空"</span>);</span><br><span class="line">				<span class="comment">//这里返回false是为了不让它被冒泡传递到上一层</span></span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(password == <span class="literal">null</span> || password == <span class="string">""</span>)&#123;</span><br><span class="line">				alert(<span class="string">"密码不能为空"</span>);</span><br><span class="line">				<span class="comment">//这里返回false是为了不让它被冒泡传递到上一层</span></span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(age == <span class="literal">null</span> || age == <span class="string">""</span>)&#123;</span><br><span class="line">				alert(<span class="string">"年龄不能为空"</span>);</span><br><span class="line">				<span class="comment">//这里返回false是为了不让它被冒泡传递到上一层</span></span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(gender == <span class="literal">null</span> || gender == <span class="string">""</span>)&#123;</span><br><span class="line">				alert(<span class="string">"年龄不能为空"</span>);</span><br><span class="line">				<span class="comment">//这里返回false是为了不让它被冒泡传递到上一层</span></span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(name == <span class="literal">null</span> || name == <span class="string">""</span>)&#123;</span><br><span class="line">				alert(<span class="string">"姓名不能为空"</span>);</span><br><span class="line">				<span class="comment">//这里返回false是为了不让它被冒泡传递到上一层</span></span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(otpCode == <span class="literal">null</span> || otpCode == <span class="string">""</span>)&#123;</span><br><span class="line">				alert(<span class="string">"验证码不能为空"</span>);</span><br><span class="line">				<span class="comment">//这里返回false是为了不让它被冒泡传递到上一层</span></span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			$.ajax(&#123;</span><br><span class="line">				type:<span class="string">"POST"</span>,</span><br><span class="line">				contentType:<span class="string">"application/x-www-form-urlencoded"</span>,</span><br><span class="line">				url:<span class="string">"http://localhost:8090/user/register"</span>,</span><br><span class="line">				data:&#123;</span><br><span class="line">					<span class="string">"telphone"</span>:$(<span class="string">"#telphone"</span>).val(),</span><br><span class="line">					<span class="string">"password"</span>:password,</span><br><span class="line">					<span class="string">"age"</span>:age,</span><br><span class="line">					<span class="string">"gender"</span>:gender,</span><br><span class="line">					<span class="string">"name"</span>:name,</span><br><span class="line">					<span class="string">"otpCode"</span>:otpCode</span><br><span class="line">				&#125;,</span><br><span class="line">				xhrFields:&#123;<span class="attr">withCredentials</span>:<span class="literal">true</span>&#125;,</span><br><span class="line">				success:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">					<span class="keyword">if</span>(data.status == <span class="string">"success"</span>) &#123;</span><br><span class="line">						alert(<span class="string">"注册成功"</span>);</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						alert(<span class="string">"注册失败，原因为"</span> + data.data.errMsg);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;,</span><br><span class="line"></span><br><span class="line">				error:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">					alert(<span class="string">"注册失败，原因为"</span> + data.responseText);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">	&#125;);</span><br><span class="line">	</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure>

<p>需要注意，后端做了校验，前端也要做校验。因为校验总是要在离用户最近的地方。这样用户的体验更好。</p>
<p>遇到的问题：</p>
<ol>
<li>加了CrossOrigin注解，也没有办法直接做到跨域共享</li>
</ol>
<p>解决方法是指定更细的ajax请求域。</p>
<p><code>@CrossOrigin(allowCredentials = &quot;true&quot;,allowedHeaders = &quot;*&quot;)</code></p>
<ul>
<li><code>DEFAULT_ALOWED_HEADERS</code>允许跨域传输所有的header参数，将用于使用token放入header域做session共享的跨域请求。</li>
<li><code>DEFAULT_ALLOW_CREDENTIALS = true</code>：需要配合前端设置 xhrFields 授信后使得跨域session共享</li>
</ul>
<ol start="2">
<li>在发送ajax请求的时候，我们需要指定<code>xhrField</code>对应的参数：</li>
</ol>
<p><code>xhrFields:{withCredentials:true}</code></p>
<p>这个参数用于允许跨域的授信请求，使其session变成跨域可授信。</p>
<ol start="3">
<li>在MD5加密的时候不能直接用Util工具，要写出复杂一些的加密方法</li>
</ol>
<p>如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">EncodeByMd5</span><span class="params">(String str)</span> <span class="keyword">throws</span> NoSuchAlgorithmException, UnsupportedEncodingException </span>&#123;</span><br><span class="line">    <span class="comment">//确定计算方法</span></span><br><span class="line">    MessageDigest md5 = MessageDigest.getInstance(<span class="string">"MD5"</span>);</span><br><span class="line">    BASE64Encoder base64en = <span class="keyword">new</span> BASE64Encoder();</span><br><span class="line">    <span class="comment">//加密字符串</span></span><br><span class="line">    String newstr = base64en.encode(md5.digest(str.getBytes(<span class="string">"utf-8"</span>)));</span><br><span class="line">    <span class="keyword">return</span> newstr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，在UserDOMapper中，因为要保证id是感知到数据库进行自增的，需要设置两个参数：</p>
<p><code>&lt;insert id=&quot;insertSelective&quot; parameterType=&quot;com.miaoshaproject.dataobject.UserDO&quot; keyProperty=&quot;id&quot; useGeneratedKeys=&quot;true&quot;&gt;</code></p>
<p>此外，要保证手机号不能重复，即数据库中不能出现重的手机号。解决方法就是在user_info表中将telphone字段设置成唯一索引。</p>
<p>插入索引后，为了给用户好的体验，把可能报的异常catch住。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现model -&gt; dataobject方法</span></span><br><span class="line">UserDO userDO = convertFromModel(userModel);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    userDOMapper.insertSelective(userDO);</span><br><span class="line">&#125; <span class="keyword">catch</span> (DuplicateKeyException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR,<span class="string">"手机号已被注册"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用户模型管理——用户登录功能实现"><a href="#用户模型管理——用户登录功能实现" class="headerlink" title="用户模型管理——用户登录功能实现"></a>用户模型管理——用户登录功能实现</h3><p>要完成这个功能，需要在UserService中定义新的登录方法(当然，先在接口中声明)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    telphone:用户注册手机</span></span><br><span class="line"><span class="comment">    password:用户加密后的密码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">UserModel <span class="title">validateLogin</span><span class="params">(String telphone, String encrptPassword)</span> <span class="keyword">throws</span> BusinessException</span>;</span><br></pre></td></tr></table></figure>

<p>然后实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserModel <span class="title">validateLogin</span><span class="params">(String telphone, String encrptPassword)</span> <span class="keyword">throws</span> BusinessException </span>&#123;</span><br><span class="line">    <span class="comment">//通过用户的手机获取用户登录信息</span></span><br><span class="line">    <span class="comment">//拿到对应的对象</span></span><br><span class="line">    UserDO userDO = userDOMapper.selectByTelphone(telphone);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(userDO == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.USER_LOGIN_FAIL);</span><br><span class="line">    &#125;</span><br><span class="line">    UserPasswordDO userPasswordDO = userPasswordDOMapper.selectByUserId(userDO.getId());</span><br><span class="line">    UserModel userModel = convertFromDataObject(userDO, userPasswordDO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//比对用户信息内加密的密码是否和传输进来的密码相匹配</span></span><br><span class="line">    <span class="keyword">if</span>(!StringUtils.equals(encrptPassword,userModel.getEncrptPassword())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.USER_LOGIN_FAIL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> userModel;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，完成方法的时候需要在框架的xml文件中写出selectByTelphone</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectByTelphone"</span> <span class="attr">resultMap</span>=<span class="string">"BaseResultMap"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    WARNING - @mbg.generated</span></span><br><span class="line"><span class="comment">    This element is automatically generated by MyBatis Generator, do not modify.</span></span><br><span class="line"><span class="comment">    This element was generated on Wed May 06 18:05:52 CST 2020.</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">  select</span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"Base_Column_List"</span> /&gt;</span></span><br><span class="line">  from user_info</span><br><span class="line">  where telphone = #&#123;telphone,jdbcType=CARCHAR&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后要在对应的UserDOMapper中加上这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">UserDO <span class="title">selectByTelphone</span><span class="params">(String telphone)</span></span>;</span><br></pre></td></tr></table></figure>

<p>完成登录验证方法后再完成登录的方法。</p>
<p>一般的初级登录凭证为类似Token之类的东西，而不使用用户的session。后面我们会用到使用分布式会话session的机制，去解决分布式环境下用户登录的问题，但是现在我们先假设用户是单点session登录。</p>
<p>在验证方法中，返回UserModel，当用户登录成功后，将userModel返回给controller层。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用户登录接口</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/login"</span>,method = &#123;RequestMethod.POST&#125;,consumes = &#123;CONTENT_TYPE_FORMED&#125;)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonReturnType <span class="title">login</span><span class="params">(@RequestParam(name = <span class="string">"telphone"</span>)</span>String telphone,</span></span><br><span class="line"><span class="function">                              @<span class="title">RequestParam</span><span class="params">(name = <span class="string">"password"</span>)</span>String password) <span class="keyword">throws</span> BusinessException, UnsupportedEncodingException, NoSuchAlgorithmException </span>&#123;</span><br><span class="line">    <span class="comment">//入参校验</span></span><br><span class="line">    <span class="keyword">if</span>(org.apache.commons.lang3.StringUtils.isEmpty(telphone) ||</span><br><span class="line">            StringUtils.isEmpty(password)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用户登录服务,用来校验用户登录是否合法</span></span><br><span class="line">    UserModel userModel = userService.validateLogin(telphone,<span class="keyword">this</span>.EncodeByMd5(password));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将登录凭证加入到用户登录成功的session内</span></span><br><span class="line">    <span class="keyword">this</span>.httpServletRequest.getSession().setAttribute(<span class="string">"IS_LOGIN"</span>,<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">this</span>.httpServletRequest.getSession().setAttribute(<span class="string">"LOGIN_USER"</span>,userModel);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> CommonReturnType.create(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决登录后端，下面来写登录前端。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body <span class="class"><span class="keyword">class</span></span>=<span class="string">"login"</span>&gt;</span><br><span class="line">	&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"content"</span>&gt;</span><br><span class="line">		&lt;h3 <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-title"</span>&gt;用户登陆&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">		&lt;div class="form-group"&gt;</span></span><br><span class="line"><span class="regexp">			&lt;label class="control-label"&gt;手机号&lt;/</span>label&gt;</span><br><span class="line">			&lt;div&gt;</span><br><span class="line">				&lt;input  <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-control"</span> type=<span class="string">"text"</span> placeholder=<span class="string">"手机号"</span> name=<span class="string">"telphone"</span> id=<span class="string">"telphone"</span>/&gt;</span><br><span class="line">			&lt;<span class="regexp">/div&gt;	</span></span><br><span class="line"><span class="regexp">		&lt;/</span>div&gt;</span><br><span class="line">		&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-group"</span>&gt;</span><br><span class="line">		&lt;label <span class="class"><span class="keyword">class</span></span>=<span class="string">"control-label"</span>&gt;密码&lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">			&lt;div&gt;</span></span><br><span class="line"><span class="regexp">				&lt;input  class="form-control" type="password" placeholder="密码" name="password" id="password"/</span>&gt;</span><br><span class="line">			&lt;<span class="regexp">/div&gt;	</span></span><br><span class="line"><span class="regexp">		&lt;/</span>div&gt;			</span><br><span class="line">		&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-actions"</span>&gt;</span><br><span class="line">			&lt;button <span class="class"><span class="keyword">class</span></span>=<span class="string">"btn blue"</span> id=<span class="string">"login"</span> type=<span class="string">"submit"</span>&gt;</span><br><span class="line">				登陆</span><br><span class="line">			&lt;<span class="regexp">/button&gt;	</span></span><br><span class="line"><span class="regexp">			&lt;button class="btn green" id="register" type="submit"&gt;</span></span><br><span class="line"><span class="regexp">				注册</span></span><br><span class="line"><span class="regexp">			&lt;/</span>button&gt;	</span><br><span class="line">		&lt;<span class="regexp">/div&gt;	</span></span><br><span class="line"><span class="regexp">	&lt;/</span>div&gt;	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">	jQuery(document).ready(function()&#123;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">		$("#register").on("click",function()&#123;</span></span><br><span class="line"><span class="regexp">			window.location.href="getotp.html";</span></span><br><span class="line"><span class="regexp">		&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">		$("#login").on("click",function()&#123;</span></span><br><span class="line"><span class="regexp">			var telphone = $("#telphone").val();</span></span><br><span class="line"><span class="regexp">			var password = $("#password").val();</span></span><br><span class="line"><span class="regexp">			if(telphone == null || telphone == "")&#123;</span></span><br><span class="line"><span class="regexp">				alert("手机号不能为空");</span></span><br><span class="line"><span class="regexp">				return false;</span></span><br><span class="line"><span class="regexp">			&#125;</span></span><br><span class="line"><span class="regexp">			if(password == null || password == "")&#123;</span></span><br><span class="line"><span class="regexp">				alert("密码不能为空");</span></span><br><span class="line"><span class="regexp">				return false;</span></span><br><span class="line"><span class="regexp">			&#125;</span></span><br><span class="line"><span class="regexp">	</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">			$.ajax(&#123;</span></span><br><span class="line"><span class="regexp">				type:"POST",</span></span><br><span class="line"><span class="regexp">				contentType:"application/</span>x-www-form-urlencoded<span class="string">",</span></span><br><span class="line"><span class="string">				url:"</span>http:<span class="comment">//localhost:8090/user/login",</span></span><br><span class="line">				data:&#123;</span><br><span class="line">					<span class="string">"telphone"</span>:$(<span class="string">"#telphone"</span>).val(),</span><br><span class="line">					<span class="string">"password"</span>:password</span><br><span class="line">				&#125;,</span><br><span class="line">				xhrFields:&#123;<span class="attr">withCredentials</span>:<span class="literal">true</span>&#125;,</span><br><span class="line">				success:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">					<span class="keyword">if</span>(data.status == <span class="string">"success"</span>)&#123;</span><br><span class="line">						alert(<span class="string">"登陆成功"</span>);</span><br><span class="line">						<span class="built_in">window</span>.location.href=<span class="string">"listitem.html"</span>;</span><br><span class="line">					&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">						alert(<span class="string">"登陆失败，原因为"</span>+data.data.errMsg);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;,</span><br><span class="line">				error:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">					alert(<span class="string">"登陆失败，原因为"</span>+data.responseText);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试，可以实现登录功能。</p>
<h3 id="优化校验规则"><a href="#优化校验规则" class="headerlink" title="优化校验规则"></a>优化校验规则</h3><p>之前完成了基本开发，但是对于企业级应用，这个代码还有不足。</p>
<p>对于注册，我们完成了初步的判空的提示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(userModel == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(StringUtils.isEmpty(userModel.getName())</span><br><span class="line">    || userModel.getGender() == <span class="keyword">null</span></span><br><span class="line">    || userModel.getAge() == <span class="keyword">null</span></span><br><span class="line">    || StringUtils.isEmpty(userModel.getTelphone())) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是比如对于age，除了不为空，还有范围的界定，等等。所以我们还需要别的方式来进行一些优化。</p>
<p>导入jar包：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.4.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>创建一个validator包，里面新建一个VlidationResult类，为验证后的结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidationResult</span> </span>&#123;</span><br><span class="line">    <span class="comment">//校验结果是否有错</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> hasErrors;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存放错误信息的map</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; errorMsgMap;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHasErrors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hasErrors;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHasErrors</span><span class="params">(<span class="keyword">boolean</span> hasErrors)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hasErrors = hasErrors;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">getErrorMsgMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> errorMsgMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setErrorMsgMap</span><span class="params">(Map&lt;String, String&gt; errorMsgMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.errorMsgMap = errorMsgMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现通用的通过格式化字符串信息获取错误的msg方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getErrMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> StringUtils.join(errorMsgMap.values().toArray(),<span class="string">","</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类完成了应用程序和validation之间的对接。</p>
<p>然后实现这个Validator的具体操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidatorImpl</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Validator validator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现校验方法并返回校验结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ValidationResult <span class="title">validate</span><span class="params">(Object bean)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ValidationResult result = <span class="keyword">new</span> ValidationResult();</span><br><span class="line">        Set&lt;ConstraintViolation&lt;Object&gt;&gt; constraintViolationSet = validator.validate(bean);</span><br><span class="line">        <span class="keyword">if</span>(constraintViolationSet.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//有错误</span></span><br><span class="line">            result.setHasErrors(<span class="keyword">true</span>);</span><br><span class="line">            constraintViolationSet.forEach(constraintViolation -&gt; &#123;</span><br><span class="line">                String errMsg = constraintViolation.getMessage();</span><br><span class="line">                String propertyName = constraintViolation.getPropertyPath().toString();</span><br><span class="line">                result.getErrorMsgMap().put(propertyName,errMsg);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当Spring Bean初始化完成之后，会回调ValidatorImpl的这个afterPropertiesSet方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//将hibernate validator通过工厂的初始化方式使其实例化</span></span><br><span class="line">        <span class="comment">//得到实例化校验器</span></span><br><span class="line">        <span class="keyword">this</span>.validator = Validation.buildDefaultValidatorFactory().getValidator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建了一个新的Bean。</p>
<p>对UserModel中的一些属性加上约束：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NotBlank</span>(message = <span class="string">"用户名不能为空"</span>)</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NotBlank</span>(message = <span class="string">"性别不能为空"</span>)</span><br><span class="line"><span class="keyword">private</span> Byte gender;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NotBlank</span>(message = <span class="string">"年龄不能为空"</span>)</span><br><span class="line"><span class="meta">@Min</span>(value = <span class="number">0</span>,message = <span class="string">"年龄必须大于0岁"</span>)</span><br><span class="line"><span class="meta">@Max</span>(value = <span class="number">150</span>,message = <span class="string">"年龄必须小于150岁"</span>)</span><br><span class="line"><span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NotBlank</span>(message = <span class="string">"手机号不能为空"</span>)</span><br><span class="line"><span class="keyword">private</span> String telphone;</span><br><span class="line"><span class="keyword">private</span> String registerMode;</span><br><span class="line"><span class="keyword">private</span> String thirdPartyId;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NotBlank</span>(message = <span class="string">"密码不能为空"</span>)</span><br><span class="line"><span class="keyword">private</span> String encrptPassword;</span><br></pre></td></tr></table></figure>

<p>接下来在UserServiceImpl中引入这个新定义的Bean:</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ValidatorImpl validator;</span><br></pre></td></tr></table></figure>

<p>然后注释掉原来的方法，将新方法使用起来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//        if(StringUtils.isEmpty(userModel.getName())</span></span><br><span class="line"><span class="comment">//            || userModel.getGender() == null</span></span><br><span class="line"><span class="comment">//            || userModel.getAge() == null</span></span><br><span class="line"><span class="comment">//            || StringUtils.isEmpty(userModel.getTelphone())) &#123;</span></span><br><span class="line"><span class="comment">//            throw new BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        ValidationResult result = validator.validate(userModel);</span><br><span class="line">        <span class="keyword">if</span>(result.isHasErrors()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR,result.getErrMsg());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>然后当用户注册的时候，输入的属性值有了限制。</p>
<h2 id="商品模块开发"><a href="#商品模块开发" class="headerlink" title="商品模块开发"></a>商品模块开发</h2><h3 id="商品模型模型——商品创建"><a href="#商品模型模型——商品创建" class="headerlink" title="商品模型模型——商品创建"></a>商品模型模型——商品创建</h3><h3 id="商品模型模型——商品列表"><a href="#商品模型模型——商品列表" class="headerlink" title="商品模型模型——商品列表"></a>商品模型模型——商品列表</h3><h3 id="商品模型模型——商品列表页面"><a href="#商品模型模型——商品列表页面" class="headerlink" title="商品模型模型——商品列表页面"></a>商品模型模型——商品列表页面</h3><h3 id="商品模型模型——商品详情页面"><a href="#商品模型模型——商品详情页面" class="headerlink" title="商品模型模型——商品详情页面"></a>商品模型模型——商品详情页面</h3><h2 id="交易模块开发"><a href="#交易模块开发" class="headerlink" title="交易模块开发"></a>交易模块开发</h2><h3 id="交易模型管理——交易模型创建"><a href="#交易模型管理——交易模型创建" class="headerlink" title="交易模型管理——交易模型创建"></a>交易模型管理——交易模型创建</h3><h3 id="交易模型管理——交易下单"><a href="#交易模型管理——交易下单" class="headerlink" title="交易模型管理——交易下单"></a>交易模型管理——交易下单</h3><h2 id="秒杀模块开发"><a href="#秒杀模块开发" class="headerlink" title="秒杀模块开发"></a>秒杀模块开发</h2><h3 id="秒杀模型管理——活动模型创建"><a href="#秒杀模型管理——活动模型创建" class="headerlink" title="秒杀模型管理——活动模型创建"></a>秒杀模型管理——活动模型创建</h3><h3 id="秒杀模型管理——活动模型与商品模型结合"><a href="#秒杀模型管理——活动模型与商品模型结合" class="headerlink" title="秒杀模型管理——活动模型与商品模型结合"></a>秒杀模型管理——活动模型与商品模型结合</h3>]]></content>
      <categories>
        <category>Project Note</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Seckill</tag>
      </tags>
  </entry>
  <entry>
    <title>MINI Spring MVC</title>
    <url>/2020/05/01/MINI-Spring-MVC/</url>
    <content><![CDATA[<blockquote>
<p>在乎的是，自己以及他所在乎的人，能不能够秉持着自己的心意与信念，在人生中大部分时间里都能自在、快乐</p>
</blockquote>
<a id="more"></a>

<p>项目github地址：<a href="https://github.com/wmsheng/MINI-SpringMVC" target="_blank" rel="noopener">https://github.com/wmsheng/MINI-SpringMVC</a></p>
<h1 id="项目框架搭建"><a href="#项目框架搭建" class="headerlink" title="项目框架搭建"></a>项目框架搭建</h1><h2 id="搭建基于Gradle的项目"><a href="#搭建基于Gradle的项目" class="headerlink" title="搭建基于Gradle的项目"></a>搭建基于Gradle的项目</h2><p>首先进行项目的”骨架”的搭建。</p>
<p>使用Gradle作为依赖创建项目，相比Maven，Gradle的优势在于：</p>
<ul>
<li>发扬Maven的约定大于配置的思想(为了迁移方便，其可以直接使用Maven的配置)</li>
<li>使用DSL语言 提供函数支持</li>
<li>方便性上：Json格式，而且免安装</li>
</ul>
<p>先创建Gradle项目，然后创建子的<code>Module</code>模块.</p>
<p>子模块需要创建多个。这里创建这么几个：framework框架模块、test测试模块，创建好后如下图：</p>
<p><img src="https://i.loli.net/2020/05/01/zOtfjiuqSY2KVpw.png" alt="创建项目1.png"></p>
<p>因为我们不需要在项目的父模块中写代码，只需要在子模块中写，所以可以删除父模块层中的src包。</p>
<p><img src="https://i.loli.net/2020/05/01/XIAgkvUjuBapqDt.png" alt="删除src包.png"></p>
<p>可以看到，右侧中有配置文件，默认使用了很多配置项。Maven中一行就能完成的配置，在Gradle中一行就可以完成。</p>
<p>在配置subprojects的时候，其中的所有配置项都会被子模块继承。但是可以注意，当子模块中有父模块中重复的配置项时，会以范围更近的子模块为主，会覆盖父模块的配置。</p>
<p>在配置好之后，可以进行打包，命令是</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">gradle build</span></span><br></pre></td></tr></table></figure>

<p>在打包成功后，各个子模块中都会多出一个build文件夹，而在libs文件夹下就是jar包文件。如下图：</p>
<p><img src="https://i.loli.net/2020/05/01/iayHjgFVd8I6CUw.png" alt="gradle_build之后.png"></p>
<h2 id="仿Spring搭建项目结构"><a href="#仿Spring搭建项目结构" class="headerlink" title="仿Spring搭建项目结构"></a>仿Spring搭建项目结构</h2><p>我们已经创建好了framework和test这两个模块，分别对应<code>框架模块</code>和<code>应用模块</code>。应用模块主要用来测试，框架可以支撑应用模块，而应用模块可以反馈框架。</p>
<p>重点在于框架模块。Spring包的模块划分主要可以分为两层。一层是核心层(Core)，它是Spring框架的基石。其包括：</p>
<ul>
<li>Beans包：负责Spring的Bean的维护和管理</li>
<li>Core包：Spring中经常用到的工具包</li>
<li>Context包：提供Spring根据不同产品的需求所完成的接口，是进入Spring的入口</li>
<li>SpEL：Spring的R式语言包，可以提供查询、操作数据的功能</li>
</ul>
<p>再往上，一个是数据层，Data。这里主要用于对数据的增删改查。其中有JDBC、ORM的针对数据操作的模型。</p>
<p>还有一个是对外的Web应用包，其中有MVC模型和对Servlet的封装。</p>
<p>如下图：</p>
<p><img src="https://i.loli.net/2020/05/02/O1fd8kQI2UEZjC6.png" alt="Spring包结构.png"></p>
<p>我们这个项目主要是MINI，所以目的是实现SpringMVC的一部分重要模块。</p>
<ul>
<li>实现Core模块，包括core、beans、context包</li>
<li>实现Web，集成web和webmvc</li>
<li>添加starter，实现类spring-boot的启动方式</li>
</ul>
<p>开发中，我们将test模块和frameword模块进行了关联，重点是在test模块的gradle配置文件中进行配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">'java'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group <span class="string">'wms.mooc.com'</span></span><br><span class="line">version <span class="string">'1.0-SNAPSHOT'</span></span><br><span class="line"></span><br><span class="line">sourceCompatibility = <span class="number">1.8</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    testCompile group: <span class="string">'junit'</span>, name: <span class="string">'junit'</span>, version: <span class="string">'4.12'</span></span><br><span class="line">    compile(project(<span class="string">':framework'</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subprojects &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">jar&#123;</span><br><span class="line">    manifest&#123;</span><br><span class="line">        attributes <span class="string">"Main-Class"</span>:<span class="string">"com.mooc.wms.Application"</span></span><br><span class="line">    &#125;</span><br><span class="line">    from&#123;</span><br><span class="line">        configurations.compile.collect&#123;</span><br><span class="line">            it.isDirectory() ? it : zipTree(it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dependencies中配置了编译过程中要关联的其他子模块的名字，注意写法。这里关联的是framework模块。</p>
<h1 id="集成服务器"><a href="#集成服务器" class="headerlink" title="集成服务器"></a>集成服务器</h1><p>接下来进行服务器Web服务器和Servelet的集成，可以被称作是项目的载体。</p>
<p>首先回顾一下JavaWeb模型。我们的程序想要对外提供服务，必须借助Web服务器。常见的web服务器有Tomcat、Netty、Nginx等。</p>
<ul>
<li>监听一个TCP端口(本地启动一般监听localhost,80,8080)</li>
<li>负责转发请求，回收相应(Nginx转发给PHP程序、Tomcat转发给Java程序)</li>
<li>本身没有业务逻辑，只负责<strong>连接操作系统和应用程序代码</strong></li>
</ul>
<h2 id="系统Web服务模型"><a href="#系统Web服务模型" class="headerlink" title="系统Web服务模型"></a>系统Web服务模型</h2><p>首先，客户端会向web服务器发送一个请求，通过网络到达web服务器所在的操作系统。</p>
<p>但是从网络传输过去的信息只能是一些bit流，我们无法直接读取其中的信息。这些bit流通过网卡到达了操作系统。然后操作系统的TCP/IP栈专门负责解析这些bit流，再之后操作系统会把这些信息(端口、IP、字节流)都发送给Web服务器来进行处理。</p>
<p>到达Web服务器之后，Web服务器会连接到应用程序，由应用程序处理其中的逻辑和进行操作。</p>
<p>处理完之后，会把结果原路返回，再相应回客户端。</p>
<p>具体流程如下图所示：</p>
<p><img src="https://i.loli.net/2020/05/02/9cbQ6J7PCXl4aSO.png" alt="系统web服务模型.png"></p>
<h2 id="请求分发流程"><a href="#请求分发流程" class="headerlink" title="请求分发流程"></a>请求分发流程</h2><p><img src="https://i.loli.net/2020/05/02/e5AT24oBkEC8s1O.png" alt="请求分发流程.png"></p>
<p>上图是一个抽象的比喻，发信人和收信人的关系。</p>
<p>邮局就好像是TCP端口，不论有没有信件往来，它都在那里等着。一旦有信件往来，它就把这个信件交给一个快递员，也就是web服务器。这个web服务器每天守着一个TCP端口，如果有消息派发给他，他就赶快把消息送出，再把回复收回，再把回复发到给发信人。</p>
<p>就好像快递员不能拆开快递一样，服务器只能充当操作系统和应用程序的连接着，他们不能负责具体业务，只负责高效而准确地发送任务。</p>
<p>那么，web服务器是怎么分发请求的呢？——这就不得不介绍Servlet</p>
<p>实际上，Servlet是一种复合的含义。</p>
<ul>
<li>Servlet是一种规范：它约束了Java服务器与业务类的通信方式。试想不同的服务器有不同的通信方式，那么你每一台服务器都要单独写一套逻辑，那么学习成本高，迁移也会非常困难</li>
<li>Servlet是一个接口：javax.servlet.Servlet，这个是用代码来表达Servlet这种规范的方法</li>
<li>Servlet是一种Java类：实现了Servlet接口的应用程序类。每一个实现了Servlet应用接口的类都可以成为是一个Servlet。大型服务一般需要多个Servlet共同合作来完成。</li>
</ul>
<p>到这里，可以再补充一下系统Web服务模型，里面的Servlet实际上可以更细化：</p>
<p><img src="https://i.loli.net/2020/05/02/7mpViCo4DBIkFad.png" alt="系统web服务模型细化Servlet.png"></p>
<p>实际上，SpringBoot中通过向框架中集成Web服务器来实现的。我们这里使用Tomcat来进行集成。</p>
<p>使用Tomcat服务器有以下一些特点：</p>
<ul>
<li>Java原生，运行在JVM上</li>
<li>多种并发模型，高性能</li>
<li>支持嵌入式应用程序</li>
</ul>
<p>具体流程很简单，我们只需要在项目中：</p>
<ol>
<li>引入Tomcat包</li>
<li>实例化一个Tomcat类</li>
<li>调用Tomcat的start方法</li>
</ol>
<p>走这三步，就可以启动Tomcat服务器。</p>
<h2 id="集成Tomcat服务器"><a href="#集成Tomcat服务器" class="headerlink" title="集成Tomcat服务器"></a>集成Tomcat服务器</h2><p>首先，我们为tomcat引入一个tomcat包，写在gradle的配置文件中。</p>
<p>在Maven官网查找Tomcat Embed Core, <a href="https://mvnrepository.com/search?q=tomcat。选一个版本，这里选8.5.23，配置`framework`的gradle中。" target="_blank" rel="noopener">https://mvnrepository.com/search?q=tomcat。选一个版本，这里选8.5.23，配置`framework`的gradle中。</a></p>
<p>导入成功后，在framework的web包下创建server包，然后完成相应逻辑任务。</p>
<p>TomcatServer.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mooc.wms.web.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.LifecycleException;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.startup.Tomcat;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Bennett_Wang on 2020/5/2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TomcatServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Tomcat tomcat;</span><br><span class="line">    <span class="keyword">public</span> String[] args;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TomcatServer</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.args = args;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startServer</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">        tomcat = <span class="keyword">new</span> Tomcat();</span><br><span class="line">        tomcat.setPort(<span class="number">6699</span>);</span><br><span class="line">        tomcat.start();</span><br><span class="line"></span><br><span class="line">        Thread awaitThread = <span class="keyword">new</span> Thread(<span class="string">"tomcat_await_thread"</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                TomcatServer.<span class="keyword">this</span>.tomcat.getServer().await();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        awaitThread.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">        awaitThread.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TestServlet.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mooc.wms.web.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Bennett_Wang on 2020/5/2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        res.getWriter().println(<span class="string">"test"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Tomcat容器内，Servlet容器并不是直接依附在Tomcat容器里的，而是会分成四个级别，Tomcat用这四个级别进行容器的解耦。这四个级别分别是：</p>
<ol>
<li>Engine容器：最顶级容器，可以理解为Tomcat的总控中心</li>
<li>Host容器：管理主机信息和他们的子容器</li>
<li>Context：最接近Servlet的容器，可以通过它设置资源属性和管理骨架</li>
<li>Wrapper：负责Servlet的加载、初始化、执行、销毁</li>
</ol>
<p>我们这里只往Context容器内注册一个Servlet即可。</p>
<p>为了建立Tomcat和Servlet的关联，我们需要在TomcatServer.java类中加入如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化Context容器</span></span><br><span class="line">Context context = <span class="keyword">new</span> StandardContext();</span><br><span class="line">context.setPath(<span class="string">""</span>);</span><br><span class="line">context.addLifecycleListener(<span class="keyword">new</span> Tomcat.FixContextListener());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建TestServlet实例</span></span><br><span class="line">TestServlet servlet = <span class="keyword">new</span> TestServlet();</span><br><span class="line"><span class="comment">//使用Tomcat的静态方法addServlet</span></span><br><span class="line">Tomcat.addServlet(context,<span class="string">"testServlet"</span>,servlet)</span><br><span class="line">        .setAsyncSupported(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将Context容器和"testServlet"实例关联起来</span></span><br><span class="line">context.addServletMappingDecoded(<span class="string">"/test.json"</span>,<span class="string">"testServlet"</span>);</span><br><span class="line">tomcat.getHost().addChild(context);</span><br></pre></td></tr></table></figure>

<p>此时，启动之后，可以用<code>localhost:6699/test.json</code>访问到页面，当然，结果只有一个输出的”test”，即为<code>TestServlet.java</code>中的service函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    res.getWriter().println(<span class="string">"test"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="集成服务器总结"><a href="#集成服务器总结" class="headerlink" title="集成服务器总结"></a>集成服务器总结</h2><p>总而言之，这里使用了Web服务模型，其中最重要的是使用了Servlet标准，<strong>它规定了Web服务器和应用程序之间的通信方式</strong>。</p>
<p>最后，要把这个流程真正运行起来，要一个Web服务器。这里我们仿照Spring Boot，往框架里嵌入了一个Tomcat的Web服务器，实现了Servlet接口，往Tomcat中注册了一个Servlet实例，实现了真正的请求响应。即上面往<code>TomcatServer.java</code>中加入的代码。</p>
<h1 id="控制器Controller的实现"><a href="#控制器Controller的实现" class="headerlink" title="控制器Controller的实现"></a>控制器Controller的实现</h1><p>Controller可以看做是项目的入口了。</p>
<h2 id="传统项目的实现"><a href="#传统项目的实现" class="headerlink" title="传统项目的实现"></a>传统项目的实现</h2><p>传统项目中，为了解决请求分发，需要配置Servlet，因为Servlet经常会有很多，所以经常需要配置大量内容到web.xml中(在classpath下的web.xml中配置URI到Servlet的映射,Tomcat会在启动时自动加载这个文件)，每个业务都需要添加一个Servlet，而每个Servlet都对应一个URI。</p>
<p>这样在小型项目中可能没太多不妥。但是随着项目发展，这样传统的配置方式的问题会逐渐暴露：</p>
<ul>
<li>配置集中，大而杂，不易管理(特别是Servlet的职责没有明确界限时，很容易把URI配置错)</li>
<li>需要多次实现Servlet接口，不必要(Servlet接口有五个方法，虽然我们一般只需要实现service方法，但是实现了接口，其他方法哪怕是空的，也要写上啊)</li>
</ul>
<h2 id="Spring框架"><a href="#Spring框架" class="headerlink" title="Spring框架"></a>Spring框架</h2><p>Spring框架解决这个问题的方式，就是引入了<code>DispatcherServlet</code>作为”总管”，它直接在Tomcat中配置了根目录路径符，表示所有的请求都由它来受理。</p>
<p>当然，我们不能把所有业务都写在<code>DispatcherServlet</code>中。Spring做的另一件事，是把所有的Servlet都简化成了一个一个的”Mapping Handler”。在代码中，就是Controller类中的一个方法。<strong>一般用<code>requestMapping</code>来注解</strong>。所以实际中会有请求打到<code>DispatcherServlet</code>上，然后通过<code>DispatcherServlet</code>发送到Mapping Handler上，再由Mapping Handler处理，之后返回。</p>
<p>总结起来，用Spring框架进行调度的优势：</p>
<ol>
<li>用注解，实现简单，按需实现(需要用哪个方法，就用哪个注解即可)</li>
<li>配置分散，不杂乱(可以通过多个Controller把业务逻辑的界限定义的很清晰)</li>
<li>容器内实现，易控制(真正的分发变成了框架处理，不再受web服务器的控制，修改和拓展更方便)</li>
</ol>
<h2 id="实战添加web组件"><a href="#实战添加web组件" class="headerlink" title="实战添加web组件"></a>实战添加web组件</h2><p>首先将之前定义的TestServlet该名字，改成DispatcherServlet。</p>
<p>然后修改Tomcat和Servlet联系的方式，名字都改成dispatcherServlet。并且修改MappingDecoded的路径，改成”/“，表示根目录符，表示根目录下所有的URI。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建TestServlet实例</span></span><br><span class="line">        DispatcherServlet servlet = <span class="keyword">new</span> DispatcherServlet();</span><br><span class="line">        <span class="comment">//使用Tomcat的静态方法addServlet</span></span><br><span class="line">        Tomcat.addServlet(context,<span class="string">"dispatcherServlet"</span>,servlet)</span><br><span class="line">                .setAsyncSupported(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将Context容器和"testServlet"实例关联起来</span></span><br><span class="line">        context.addServletMappingDecoded(<span class="string">"/"</span>,<span class="string">"dispatcherServlet"</span>);</span><br><span class="line">        tomcat.getHost().addChild(context);</span><br></pre></td></tr></table></figure>

<p>接下来再在web包下面添加MVC包。MVC包中添加Controller、RequestMapping和RequestParam这三个我们常用的注解。</p>
<p>@Controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mooc.wms.web.mvc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="comment">//生命周期为运行期</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="comment">//作用目标是：类</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Controller &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@RequestMapping</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mooc.wms.web.mvc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="comment">//目标：Controller中的方法</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RequestMapping &#123;</span><br><span class="line">    <span class="comment">//需要添加属性用来保存映射的URI</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@RequestParam</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mooc.wms.web.mvc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="comment">//这个注解目标是Controller注解的参数</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.PARAMETER)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RequestParam &#123;</span><br><span class="line">    <span class="comment">//需要添加一个参数用来表示他要接收的param String中的key</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，在测试类中创建一个controllers包，里面创建一个<code>SalaryController</code>类，对上面的注解进行使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mooc.wms.controllers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mooc.wms.web.mvc.Controller;</span><br><span class="line"><span class="keyword">import</span> com.mooc.wms.web.mvc.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> com.mooc.wms.web.mvc.RequestParam;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Bennett_Wang on 2020/5/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SalaryController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/get_salary.json"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getSalary</span><span class="params">(@RequestParam(<span class="string">"name"</span>)</span> String name,</span></span><br><span class="line"><span class="function">                             @<span class="title">RequestParam</span><span class="params">(<span class="string">"experience"</span>)</span> String experience) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果此时将程序运行起来，访问<code>localhost:6699/get_salary.json</code>，还是只会显示”test”。也就是说，这些Controller并没有生效。</p>
<p>为什么？因为现在框架并不知道我们添加了哪些controller。想要让框架知道我们定义了哪些controller，这时候就需要使用Java的类加载器了。</p>
<p>类加载器，即ClassLoader。<strong>ClassLoader的作用</strong>：</p>
<ul>
<li>通过<strong>类全限定名</strong>获取类的二进制字节流(全限定名是包括了包路径的类名)</li>
<li>解析二进制字节流，获取Class类实例——实际上，所有的.java文件在被编译成.class二进制文件后，都已经成为了二进制的字节码。得到类的二进制字节码后，类加载器通过虚拟机来解析这些二进制字节码，把它初始化成类，然后就可以获取到这个类的class实例了。</li>
<li>加载classpath下的静态资源——这个特性是我们获取类全限定名的关键，虽然我们可以使用类加载器来获取需要的类，但我们不知道项目下所有的类的全限定名。想要获取到这些全限定名，还需要从类文件入手，因为我们不可能自己定义一个类名列表，每次有新的类文件添加都往列表中添加。</li>
</ul>
<p>需要指出，我们能够通过Java的类文件来获取到类的全限定名，这要归功于Java类文件规范。</p>
<ul>
<li>统一的Resource抽象——H5页面、类等等，都是资源</li>
<li>每个Java类文件和类名对应——类名末尾加上.class后缀，就是文件名，这个规范也很巧妙</li>
<li>类包名和文件夹路径对应</li>
</ul>
<h2 id="手写类扫描获取类定义"><a href="#手写类扫描获取类定义" class="headerlink" title="手写类扫描获取类定义"></a>手写类扫描获取类定义</h2><p>在core包中添加类扫描器——ClassScanner</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mooc.wms.core;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.JarURLConnection;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.jar.JarEntry;</span><br><span class="line"><span class="keyword">import</span> java.util.jar.JarFile;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Bennett_Wang on 2020/5/3</span></span><br><span class="line"><span class="comment"> * 类扫描器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassScanner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Class&lt;?&gt;&gt; scanClasses(String packageName) <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//存储扫描包的类</span></span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; classList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//把包名转换为文件路径，即把包名中的"."换成"/"就可以了</span></span><br><span class="line">        String path = packageName.replace(<span class="string">"."</span>,<span class="string">"/"</span>);</span><br><span class="line">        <span class="comment">//使用类加载器，通过路径加载文件</span></span><br><span class="line">        <span class="comment">//获取默认类加载器</span></span><br><span class="line">        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        <span class="comment">//调用getResource()方法，其返回的是可遍历的URL资源</span></span><br><span class="line">        Enumeration&lt;URL&gt; resources = classLoader.getResources(path);</span><br><span class="line">        <span class="keyword">while</span>(resources.hasMoreElements()) &#123;</span><br><span class="line">            <span class="comment">//获取资源</span></span><br><span class="line">            URL resource = resources.nextElement();</span><br><span class="line">            <span class="comment">//获取资源后，要判断资源的类型，可以用protocol属性获取到</span></span><br><span class="line">            <span class="comment">//因为这个项目最后会打包成jar包，所以我们设置资源类型为jar包，当资源类型为jar包的时候</span></span><br><span class="line">            <span class="comment">//进行处理</span></span><br><span class="line">            <span class="keyword">if</span>(resource.getProtocol().contains(<span class="string">"jar"</span>)) &#123;</span><br><span class="line">                <span class="comment">//如果是jar包，则尝试获取jar包路径，jar包路径可以通过jarURLConnection获取</span></span><br><span class="line">                JarURLConnection jarURLConnection = (JarURLConnection) resource.openConnection();</span><br><span class="line">                <span class="comment">//可以用这个jarURLConnection获取到jar包的路径名</span></span><br><span class="line">                String jarFilePath = jarURLConnection.getJarFile().getName();</span><br><span class="line">                classList.addAll(getClassesFromJar(jarFilePath,path));</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// todo</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> classList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 此方法通过jar包的路径来获取到jar包所有的类</span></span><br><span class="line"><span class="comment">     * String jarFilePath为jar包的路径</span></span><br><span class="line"><span class="comment">     * String path——一个jar包可能有多个类文件，可以用path指定哪些类文件是我们需要的，path为类的相对路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Class&lt;?&gt;&gt; getClassesFromJar(String jarFilePath,String path) <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        JarFile jarFile = <span class="keyword">new</span> JarFile(jarFilePath);</span><br><span class="line">        Enumeration&lt;JarEntry&gt; jarEntries = jarFile.entries();</span><br><span class="line">        <span class="keyword">while</span>(jarEntries.hasMoreElements()) &#123;</span><br><span class="line">            JarEntry jarEntry = jarEntries.nextElement();</span><br><span class="line">            String entryName = jarEntry.getName();<span class="comment">// com/mooc/wms/test/Test.class</span></span><br><span class="line">            <span class="keyword">if</span>(entryName.startsWith(path) &amp;&amp; entryName.endsWith(<span class="string">".class"</span>)) &#123;</span><br><span class="line">                String classFullName = entryName.replace(<span class="string">"/"</span>,<span class="string">"."</span>).substring(<span class="number">0</span>,entryName.length() - <span class="number">6</span>);</span><br><span class="line">                classes.add(Class.forName(classFullName));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> classes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>试用一下这个类扫描器，在框架的入口类<code>MiniApplication</code>中尝试获取所有的class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiniApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Class&lt;?&gt; cls, String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello mini-spring!"</span>);</span><br><span class="line">        TomcatServer tomcatServer = <span class="keyword">new</span> TomcatServer(args);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            tomcatServer.startServer();</span><br><span class="line">            List&lt;Class&lt;?&gt;&gt; classList = ClassScanner.scanClasses(cls.getPackage().getName());</span><br><span class="line">            classList.forEach(it -&gt; System.out.println(it.getName()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行时可以发现控制台会输出各个以我们包路径开头的类。</p>
<h2 id="控制器的初始化"><a href="#控制器的初始化" class="headerlink" title="控制器的初始化"></a>控制器的初始化</h2><p>上一节获取了所有controller类，但是这些类并不能真正响应我们的服务，我们还需要把Controller中定义的Mapping Handler提取出来才能使用。提取的方式可以使用反射。</p>
<blockquote>
<p>反射：Java中的高级特性，框架实现的关键，经常用于框架中的动态设计。</p>
<p>反射的特点：</p>
<ul>
<li>活跃于运行时(Runtime)——普通程序在编译前就已经确定了代码该使用哪个属性，调用哪个方法等等。但是反射在运行时可以动态地获取类的属性和方法实例。</li>
<li>获取属性和方法实例——上面已经提到，反射可以在运行时动态地获取属性和方法实例</li>
<li>动态实例化类——不用new关键字了。可以用反射保存Controller里面的Mapping Handler了，有请求到来时再次调用</li>
</ul>
</blockquote>
<p>具体实现：先定义Mapping Handler的数据结构，在框架的web包中再添加一个handler子包。在子包下定义一个MappingHandler，每个MappingHandler都是一个请求映射器。在它的属性里保存它要处理的URI、对应的Controller方法等等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mooc.wms.web.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Bennett_Wang on 2020/5/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MappingHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">//要处理的URI</span></span><br><span class="line">    <span class="keyword">private</span> String uri;</span><br><span class="line">    <span class="comment">//对应的controller方法</span></span><br><span class="line">    <span class="keyword">private</span> Method method;</span><br><span class="line">    <span class="comment">//对应的controller类</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; controller;</span><br><span class="line">    <span class="comment">//调用方法需要的参数</span></span><br><span class="line">    <span class="keyword">private</span> String[] args;</span><br><span class="line"></span><br><span class="line">    MappingHandler(String uri, Method method,Class&lt;?&gt; cls,String[] args) &#123;</span><br><span class="line">        <span class="keyword">this</span>.uri = uri;</span><br><span class="line">        <span class="keyword">this</span>.method = method;</span><br><span class="line">        <span class="keyword">this</span>.controller = cls;</span><br><span class="line">        <span class="keyword">this</span>.args = args;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，添加一些管理器来管理这些handler。取名为HandlerManager</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mooc.wms.web.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mooc.wms.web.mvc.Controller;</span><br><span class="line"><span class="keyword">import</span> com.mooc.wms.web.mvc.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> com.mooc.wms.web.mvc.RequestParam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Parameter;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Bennett_Wang on 2020/5/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//静态属性，用于保存多个mappingHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;MappingHandler&gt; mappingHandlerList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一个方法，把controller中的类挑选出来，然后初始化mappingHandler方法初始化成mappingHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">resolveMappingHandler</span><span class="params">(List&lt;Class&lt;?&gt;&gt; classList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Class&lt;?&gt; cls : classList) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cls.isAnnotationPresent(Controller<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                <span class="comment">//如果Controller注解存在，我们解析这个controller类</span></span><br><span class="line">                parseHandlerFromController(cls);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//完善子方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parseHandlerFromController</span><span class="params">(Class&lt;?&gt; cls)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先用反射获取到这个类的所有方法</span></span><br><span class="line">        Method[] methods = cls.getDeclaredMethods();</span><br><span class="line">        <span class="comment">//遍历所有方法，找到对应的requestMapping注解的方法</span></span><br><span class="line">        <span class="keyword">for</span>(Method method : methods) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!method.isAnnotationPresent(RequestMapping<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到这个方法后，从这个方法的属性中获取所有构成MappingHandler的属性</span></span><br><span class="line">            <span class="comment">//首先是uri，可以直接从注解的属性中获取到</span></span><br><span class="line">            String uri = method.getDeclaredAnnotation(RequestMapping<span class="class">.<span class="keyword">class</span>).<span class="title">value</span>()</span>;</span><br><span class="line">            <span class="comment">//之后的所需要的参数，我们初始化一个容器来暂时存储一下</span></span><br><span class="line">            List&lt;String&gt; paramNameList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">//遍历方法所有的参数，依次判断并找到被requestParam注解的参数</span></span><br><span class="line">            <span class="keyword">for</span>(Parameter parameter : method.getParameters()) &#123;</span><br><span class="line">                <span class="keyword">if</span>(parameter.isAnnotationPresent(RequestParam<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                    paramNameList.add(parameter.getDeclaredAnnotation(RequestParam<span class="class">.<span class="keyword">class</span>).<span class="title">value</span>())</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            String[] params = paramNameList.toArray(<span class="keyword">new</span> String[paramNameList.size()]);</span><br><span class="line">            <span class="comment">//方法和类都是已知的，下面来构造MappingHandler</span></span><br><span class="line">            MappingHandler mappingHandler = <span class="keyword">new</span> MappingHandler(uri,method,cls,params);</span><br><span class="line">            <span class="comment">//最后把构造好的handler放到管理器的静态属性里</span></span><br><span class="line">            HandlerManager.mappingHandlerList.add(mappingHandler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，在DispatcherHandler类里面使用这个handler。在service()方法中进行定义，当一个请求发送过来之后，我们依次判断这些handler能不能处理这些请求，如果能处理，就响应结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(MappingHandler mappingHandler : HandlerManager.mappingHandlerList) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(mappingHandler.handle(req,res)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>完善一下MappingHandler中的方法，添加handle方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MappingHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">//要处理的URI</span></span><br><span class="line">    <span class="keyword">private</span> String uri;</span><br><span class="line">    <span class="comment">//对应的controller方法</span></span><br><span class="line">    <span class="keyword">private</span> Method method;</span><br><span class="line">    <span class="comment">//对应的controller类</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; controller;</span><br><span class="line">    <span class="comment">//调用方法需要的参数</span></span><br><span class="line">    <span class="keyword">private</span> String[] args;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handle</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException, InvocationTargetException, IOException </span>&#123;</span><br><span class="line">        String requestUri = ((HttpServletRequest) req).getRequestURI();</span><br><span class="line">        <span class="comment">//判断handler中的uri和请求的uri是否相等</span></span><br><span class="line">        <span class="keyword">if</span>(!uri.equals(requestUri)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果uri相等，那么我们需要调用handler里的method方法</span></span><br><span class="line">        <span class="comment">//首先我们准备一下参数</span></span><br><span class="line">        Object[] parameters = <span class="keyword">new</span> Object[args.length];</span><br><span class="line">        <span class="comment">//通过参数名依次从ServletRequest里面获取到这个参数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            parameters[i] = req.getParameter(args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//实例化controller，将异常抛出去上层</span></span><br><span class="line">        Object ctl = controller.newInstance();</span><br><span class="line">        <span class="comment">//由于controller可能会返回多种类型，我们用object来存储结果</span></span><br><span class="line">        Object response = method.invoke(ctl,parameters);</span><br><span class="line">        <span class="comment">//把方法返回的结果放入到ServletResponse里面去</span></span><br><span class="line">        res.getWriter().println(response.toString());</span><br><span class="line">        <span class="comment">//处理成功后返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MappingHandler(String uri, Method method,Class&lt;?&gt; cls,String[] args) &#123;</span><br><span class="line">        <span class="keyword">this</span>.uri = uri;</span><br><span class="line">        <span class="keyword">this</span>.method = method;</span><br><span class="line">        <span class="keyword">this</span>.controller = cls;</span><br><span class="line">        <span class="keyword">this</span>.args = args;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后别忘了在入口的MiniApplication中调用HandlerManager来初始化所有的MappingHandler</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiniApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Class&lt;?&gt; cls, String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello mini-spring!"</span>);</span><br><span class="line">        TomcatServer tomcatServer = <span class="keyword">new</span> TomcatServer(args);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            tomcatServer.startServer();</span><br><span class="line">            List&lt;Class&lt;?&gt;&gt; classList = ClassScanner.scanClasses(cls.getPackage().getName());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//在框架入口类中调用HandlerManager来初始化所有的MappingHandler</span></span><br><span class="line">            HandlerManager.resolveMappingHandler(classList);</span><br><span class="line"></span><br><span class="line">            classList.forEach(it -&gt; System.out.println(it.getName()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="控制器实现章节的重点"><a href="#控制器实现章节的重点" class="headerlink" title="控制器实现章节的重点"></a>控制器实现章节的重点</h2><p>当servlet太多时，使用web服务器配置来维护servlet是很困难的，由此提出了DispatcherServlet。</p>
<ul>
<li>DispatcherServlet有很重要的意义</li>
<li>通过类加载机制实现类的扫描，并且从中挑选出了controller</li>
<li>通过反射实现mappingHandler，真正实现了Spring中的DispatcherServlet</li>
</ul>
<h1 id="Bean管理-IOC-amp-DI"><a href="#Bean管理-IOC-amp-DI" class="headerlink" title="Bean管理(IOC&amp;DI)"></a>Bean管理(IOC&amp;DI)</h1><p>Bean的管理，当然是Spring框架能够运行的基石。</p>
<h2 id="bean管理"><a href="#bean管理" class="headerlink" title="bean管理"></a>bean管理</h2><p>之前已经实现了对controller的解析，可以使用框架来添加controller来搭建web服务了。但仅有一个controller是不够的，要实现MVC，还需要将项目复杂的逻辑抽离到Module里。在Spring中一般用Service来表示。而当service较多的时候，每个请求重复创建会有较大的性能损耗，<strong>所以Spring抽象出了Bean这么一个概念</strong>。</p>
<h3 id="什么是bean"><a href="#什么是bean" class="headerlink" title="什么是bean?"></a>什么是bean?</h3><p>bean本质也是一种对象，但是比较特殊：</p>
<ul>
<li>生命周期较长——从JVM启动，服务的初始化开始，在服务结束，JVM初始化结束的时候结束。</li>
<li>可见性较大——普通对象只是在创建的代码块中可见，但bean在整个虚拟机中都是可见的</li>
<li>维护成本高，默认是单例模式</li>
</ul>
<h3 id="bean的优势"><a href="#bean的优势" class="headerlink" title="bean的优势"></a>bean的优势</h3><ul>
<li>运行期效率高——使用bean之前不需要再初始化，而且不需要每次都是用service对象生成，可以让代码更干净</li>
<li>统一维护，便于管理和扩展——让一些比如添加类代理等的操作变得更加简单</li>
<li>单例模式可以让每次使用bean的时候不需要做各种setProperty，也不用处理各种链式依赖</li>
</ul>
<h3 id="普通类创建方式和bean的对比"><a href="#普通类创建方式和bean的对比" class="headerlink" title="普通类创建方式和bean的对比"></a>普通类创建方式和bean的对比</h3><p><img src="https://i.loli.net/2020/05/04/VY5RcKdmFnyxLUg.png" alt="传统方式创建对象.png"></p>
<p>如图所示，A和B类都含有一个Z属性，当我们实例化A和B的时候，会自动实例化Z；情况更复杂一些的话，有一个类C，里面有属性B，那么实例化C的时候也会实例化B，并且初始化了属性Z。</p>
<p>当我们实例化完A、B、C三个对象之后，整个虚拟机中就有了三个Z对象，造成极大的性能浪费。</p>
<h3 id="Spring的实现方式"><a href="#Spring的实现方式" class="headerlink" title="Spring的实现方式"></a>Spring的实现方式</h3><ul>
<li>包扫描并自动装配(反射)，不使用显示的”new”来创建对象</li>
<li>bean在虚拟机中会通过beanFactory统一管理维护，beanFactory是接口，可以通过类型、名字获取到bean</li>
<li>依赖注入</li>
</ul>
<h2 id="控制反转-依赖注入"><a href="#控制反转-依赖注入" class="headerlink" title="控制反转/依赖注入"></a>控制反转/依赖注入</h2><p>依赖注入和控制反转是有区别的。</p>
<ul>
<li>IOC(Inversion Of Control)：一种思想，用来降低代码之间的耦合度</li>
<li>DI(Dependency Injection)：实现IOC的方式，类A中定义对象B，初始化A的时候B也会被定义好</li>
</ul>
<p>用控制反转创建对象如下图所示：</p>
<p><img src="https://i.loli.net/2020/05/04/a6LQ2MhzrZiyqHF.png" alt="控制反转创建Bean.png"></p>
<p>每创建一个对象，就把该对象放入到BeanFactory中，下次再需要这个对象的时候可以直接去BeanFactory中去找。这样每个对象都只有一个，节约了大量内存空间。</p>
<h3 id="实现依赖注入的方式"><a href="#实现依赖注入的方式" class="headerlink" title="实现依赖注入的方式"></a>实现依赖注入的方式</h3><p>具体步骤为：</p>
<ol>
<li>扫描包，获得类定义(已完成)</li>
<li>初始化Bean，并实现依赖注入</li>
<li>解决Bean初始化顺序问题</li>
</ol>
<p>流程示意图：</p>
<p><img src="https://i.loli.net/2020/05/04/ReXNvMfG7J24ci6.png" alt="依赖注入实现顺序.png"></p>
<h3 id="具体代码实现"><a href="#具体代码实现" class="headerlink" title="具体代码实现"></a>具体代码实现</h3><p>创建两个Annotation注解类：@Bean和@Autowired</p>
<p>@Bean:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mooc.wms.beans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Bean &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Autowired:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mooc.wms.beans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Autowired &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个BeanFactory用来实现Bean工厂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mooc.wms.beans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mooc.wms.web.mvc.Controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Bennett_Wang on 2020/5/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//映射在后期可能需要并发处理，故用ConcurrentHashMap</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Class&lt;?&gt;, Object&gt; classToBean = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个方法用来从映射里获取Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getBean</span><span class="params">(Class&lt;?&gt; cls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> classToBean.get(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//完善Bean初始化的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initBean</span><span class="params">(List&lt;Class&lt;?&gt;&gt; classList)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; toCreate = <span class="keyword">new</span> ArrayList&lt;&gt;(classList);</span><br><span class="line">        <span class="keyword">while</span>(toCreate.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> remainSize = toCreate.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; toCreate.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(finishCreate(toCreate.get(i))) &#123;</span><br><span class="line">                    toCreate.remove(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(toCreate.size() == remainSize) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"cycle dependency!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">finishCreate</span><span class="params">(Class&lt;?&gt; cls)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        <span class="comment">//首先判断其是否需要初始化为Bean。如果其不需要被初始化为Bean，</span></span><br><span class="line">        <span class="comment">//则直接返回true,然后把它从初始化列表中删除</span></span><br><span class="line">        <span class="keyword">if</span>(!cls.isAnnotationPresent(Bean<span class="class">.<span class="keyword">class</span>) &amp;&amp; !<span class="title">cls</span>.<span class="title">isAnnotationPresent</span>(<span class="title">Controller</span>.<span class="title">class</span>)) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object bean = cls.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Field field : cls.getDeclaredFields()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(field.isAnnotationPresent(Autowired<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                Class&lt;?&gt; fieldType = field.getType();</span><br><span class="line">                Object reliantBean = BeanFactory.getBean(fieldType);</span><br><span class="line">                <span class="keyword">if</span>(reliantBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                field.set(bean,reliantBean);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        classToBean.put(cls,bean);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在启动类MiniApplication入口中初始化Bean工厂，初始化Bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiniApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Class&lt;?&gt; cls, String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello mini-spring!"</span>);</span><br><span class="line">        TomcatServer tomcatServer = <span class="keyword">new</span> TomcatServer(args);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            tomcatServer.startServer();</span><br><span class="line">            List&lt;Class&lt;?&gt;&gt; classList = ClassScanner.scanClasses(cls.getPackage().getName());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用Bean工厂初始化Bean</span></span><br><span class="line">            BeanFactory.initBean(classList);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//在框架入口类中调用HandlerManager来初始化所有的MappingHandler</span></span><br><span class="line">            HandlerManager.resolveMappingHandler(classList);</span><br><span class="line"></span><br><span class="line">            classList.forEach(it -&gt; System.out.println(it.getName()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在MappingHandler中使用Bean工厂来利用controller来初始化Bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//映射在后期可能需要并发处理，故用ConcurrentHashMap</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Class&lt;?&gt;, Object&gt; classToBean = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个方法用来从映射里获取Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getBean</span><span class="params">(Class&lt;?&gt; cls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> classToBean.get(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//完善Bean初始化的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initBean</span><span class="params">(List&lt;Class&lt;?&gt;&gt; classList)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; toCreate = <span class="keyword">new</span> ArrayList&lt;&gt;(classList);</span><br><span class="line">        <span class="comment">//写一个循环来初始化Bean</span></span><br><span class="line">        <span class="keyword">while</span>(toCreate.size() != <span class="number">0</span>) &#123; <span class="comment">//当容器中还有类定义时，我们不断遍历，看类定义能否初始化为Bean</span></span><br><span class="line">            <span class="comment">//每初始化一个Bean,就把它从容器中删掉</span></span><br><span class="line">            <span class="keyword">int</span> remainSize = toCreate.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; toCreate.size(); i++) &#123;</span><br><span class="line">                <span class="comment">//如果完成了创建，就把它从容器中删除</span></span><br><span class="line">                <span class="keyword">if</span>(finishCreate(toCreate.get(i))) &#123;</span><br><span class="line">                    toCreate.remove(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果每次遍历之后容器大小没有变化，那么就是陷入了死循环，我们要抛出异常</span></span><br><span class="line">            <span class="keyword">if</span>(toCreate.size() == remainSize) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"cycle dependency!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建完成则返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">finishCreate</span><span class="params">(Class&lt;?&gt; cls)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        <span class="comment">//首先判断其是否需要初始化为Bean。如果其不需要被初始化为Bean，</span></span><br><span class="line">        <span class="comment">//则直接返回true,然后把它从初始化列表中删除</span></span><br><span class="line">        <span class="keyword">if</span>(!cls.isAnnotationPresent(Bean<span class="class">.<span class="keyword">class</span>) &amp;&amp; !<span class="title">cls</span>.<span class="title">isAnnotationPresent</span>(<span class="title">Controller</span>.<span class="title">class</span>)) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//bean的初始化</span></span><br><span class="line">        Object bean = cls.newInstance();</span><br><span class="line">        <span class="comment">//遍历属性，看它有没有需要解决的依赖</span></span><br><span class="line">        <span class="keyword">for</span>(Field field : cls.getDeclaredFields()) &#123;</span><br><span class="line">            <span class="comment">//如果这个属性被Autowired注解了，表示它需要使用依赖注入来解决这个依赖</span></span><br><span class="line">            <span class="keyword">if</span>(field.isAnnotationPresent(Autowired<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                <span class="comment">//此时需要从Bean工厂中获取被依赖的Bean</span></span><br><span class="line">                <span class="comment">//先拿到属性的类型</span></span><br><span class="line">                Class&lt;?&gt; fieldType = field.getType();</span><br><span class="line">                <span class="comment">//通过类型从Bean工厂内获取Bean</span></span><br><span class="line">                Object reliantBean = BeanFactory.getBean(fieldType);</span><br><span class="line">                <span class="keyword">if</span>(reliantBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                field.set(bean,reliantBean);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        classToBean.put(cls,bean);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，框架部分就完成了。</p>
<h2 id="测试模块"><a href="#测试模块" class="headerlink" title="测试模块"></a>测试模块</h2><p>测试部分是很重要的。</p>
<p>在测试模块中，我们再添加一个service包，在这个包中添加SalaryService类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mooc.wms.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mooc.wms.beans.Bean;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Bennett_Wang on 2020/5/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SalaryService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">calSalary</span><span class="params">(Integer experience)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> experience * <span class="number">5000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来在controller中使用这个service</p>
<p>使用流程：首先在SalaryController中声明SalaryService的依赖，也就是让两者有组合的关系，添加Autowired注解。</p>
<p>然后再SalaryController中使用SalaryService的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mooc.wms.controllers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mooc.wms.beans.Autowired;</span><br><span class="line"><span class="keyword">import</span> com.mooc.wms.service.SalaryService;</span><br><span class="line"><span class="keyword">import</span> com.mooc.wms.web.mvc.Controller;</span><br><span class="line"><span class="keyword">import</span> com.mooc.wms.web.mvc.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> com.mooc.wms.web.mvc.RequestParam;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Bennett_Wang on 2020/5/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SalaryController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SalaryService salaryService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/get_salary.json"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getSalary</span><span class="params">(@RequestParam(<span class="string">"name"</span>)</span> String name,</span></span><br><span class="line"><span class="function">                             @<span class="title">RequestParam</span><span class="params">(<span class="string">"experience"</span>)</span> String experience) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> salaryService.calSalary(Integer.parseInt(experience));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后gradle build项目，再访问<a href="http://localhost:6699/get_salary.json?experience=3&amp;name=listl，可以得到结果。" target="_blank" rel="noopener">http://localhost:6699/get_salary.json?experience=3&amp;name=listl，可以得到结果。</a></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>Bean的介绍</li>
<li>依赖注入和控制反转</li>
<li>解决依赖顺序的简单策略</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>搭建了框架，主要使用gradle进行，和Spring各个包的功能等</li>
<li>嵌入集成服务器Servlet</li>
<li>使用类加载器进行资源扫描，获取项目下的类定义，以及controller的解析以及请求映射器的初始化</li>
<li>Bean管理，Bean的使用和控制反转，是Spring框架的核心</li>
</ol>
]]></content>
      <categories>
        <category>Project Note</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode SQL</title>
    <url>/2020/04/26/leetcode-SQL/</url>
    <content><![CDATA[<blockquote>
<p>天才是长期劳动的结果。 —— 牛顿</p>
</blockquote>
<p>包含LeetCode上数据库相关题目。</p>
<a id="more"></a>

<h2 id="175-Combine-Two-Tables-组合两个表-Easy"><a href="#175-Combine-Two-Tables-组合两个表-Easy" class="headerlink" title="175.Combine Two Tables(组合两个表)(Easy)"></a><a href="https://leetcode-cn.com/problems/combine-two-tables/" target="_blank" rel="noopener">175.Combine Two Tables(组合两个表)(Easy)</a></h2><p>SQL Schema：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> Person (PersonId <span class="built_in">int</span>, FirstName <span class="built_in">varchar</span>(<span class="number">255</span>), LastName <span class="built_in">varchar</span>(<span class="number">255</span>))</span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> Address (AddressId <span class="built_in">int</span>, PersonId <span class="built_in">int</span>, City <span class="built_in">varchar</span>(<span class="number">255</span>), State <span class="built_in">varchar</span>(<span class="number">255</span>))</span><br><span class="line"><span class="keyword">Truncate</span> <span class="keyword">table</span> Person</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Person (PersonId, LastName, FirstName) <span class="keyword">values</span> (<span class="string">'1'</span>, <span class="string">'Wang'</span>, <span class="string">'Allen'</span>)</span><br><span class="line"><span class="keyword">Truncate</span> <span class="keyword">table</span> Address</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Address (AddressId, PersonId, City, State) <span class="keyword">values</span> (<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'New York City'</span>, <span class="string">'New York'</span>)</span><br></pre></td></tr></table></figure>

<p>表1: <code>Person</code></p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="code">+-------------+</span>---------+</span><br><span class="line">| 列名         | 类型     |</span><br><span class="line"><span class="code">+-------------+</span>---------+</span><br><span class="line">| PersonId    | int     |</span><br><span class="line">| FirstName   | varchar |</span><br><span class="line">| LastName    | varchar |</span><br><span class="line"><span class="code">+-------------+</span>---------+</span><br><span class="line">PersonId 是上表主键</span><br></pre></td></tr></table></figure>

<p>表2: <code>Address</code></p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="code">+-------------+</span>---------+</span><br><span class="line">| 列名         | 类型    |</span><br><span class="line"><span class="code">+-------------+</span>---------+</span><br><span class="line">| AddressId   | int     |</span><br><span class="line">| PersonId    | int     |</span><br><span class="line">| City        | varchar |</span><br><span class="line">| State       | varchar |</span><br><span class="line"><span class="code">+-------------+</span>---------+</span><br><span class="line">AddressId 是上表主键</span><br></pre></td></tr></table></figure>

<p>Write a SQL query for a report that provides the following information for each person in the Person table, regardless if there is an address for each of those people:</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line"><span class="built_in">FirstName,</span> LastName, City, State</span><br></pre></td></tr></table></figure>

<hr>
<p>解：题意为，编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息：</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line"><span class="built_in">FirstName,</span> LastName, City, State</span><br></pre></td></tr></table></figure>

<p>这道题考查的是SQL连接查询，非常经典的查询过程可以浓缩成这张图，非常利于记忆：</p>
<p><img src="https://i.loli.net/2020/04/26/SigLJWzUyx1XuIj.png" alt="数据库多表查询连接记忆图.png"></p>
<p>这道题实际上是想通过PersonId来将Person表和Address进行连接查询，而且结果要展示Person所有的信息和Address表中的部分信息。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">SELECT FirstName,LastName,City,State</span><br><span class="line"><span class="keyword">FROM</span> Person as P</span><br><span class="line">left join<span class="built_in"> Address </span>as Addr</span><br><span class="line">on P.PersonId = Addr.PersonId;</span><br></pre></td></tr></table></figure>

<p>总的来说，这道题还是很简单的。</p>
<h2 id="176-Second-Highest-Salary-第二高的薪水-Easy"><a href="#176-Second-Highest-Salary-第二高的薪水-Easy" class="headerlink" title="176.Second Highest Salary(第二高的薪水)(Easy)"></a><a href="https://leetcode-cn.com/problems/second-highest-salary/" target="_blank" rel="noopener">176.Second Highest Salary(第二高的薪水)(Easy)</a></h2><p><a href="https://leetcode-cn.com/problems/second-highest-salary/solution/tu-jie-sqlmian-shi-ti-ru-he-cha-zhao-di-ngao-de-sh/" target="_blank" rel="noopener">详细题解可以参考这篇文章</a></p>
<p>编写一个 SQL 查询，获取 Employee 表中第二高的薪水（Salary） 。</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="code">+----+</span>--------+</span><br><span class="line">| Id | Salary |</span><br><span class="line"><span class="code">+----+</span>--------+</span><br><span class="line">| 1  | 100    |</span><br><span class="line">| 2  | 200    |</span><br><span class="line">| 3  | 300    |</span><br><span class="line"><span class="code">+----+</span>--------+</span><br></pre></td></tr></table></figure>

<p>例如上述 Employee 表，SQL查询应该返回 200 作为第二高的薪水。如果不存在第二高的薪水，那么查询应返回 null。</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="code">+---------------------+</span></span><br><span class="line">| SecondHighestSalary |</span><br><span class="line"><span class="code">+---------------------+</span></span><br><span class="line">| 200                 |</span><br><span class="line"><span class="code">+---------------------+</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithms Note</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s Basic I</title>
    <url>/2020/04/07/Docker-K8s-Basic-I/</url>
    <content><![CDATA[<blockquote>
<p>面对赢不了的挑战有两个选择：要不就投降，要不就让自己变得更强。</p>
</blockquote>
<a id="more"></a>

<p>Docker或者说容器，实现概念主要基于CGroups(限制每个进程的资源)、NameSpace(隔离不同的容器进程)、rootFS(文件系统，挂载到主机上)。</p>
<p>下面着重讲一下K8s四组基本概念。</p>
<h1 id="K8s四组基本概念"><a href="#K8s四组基本概念" class="headerlink" title="K8s四组基本概念"></a>K8s四组基本概念</h1><h2 id="Pod-Pod控制器"><a href="#Pod-Pod控制器" class="headerlink" title="Pod/Pod控制器"></a>Pod/Pod控制器</h2><h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><p>K8s集群中运行的最小单元不是容器，而是Pod。</p>
<ul>
<li>Pod是K8S里能被运行的最小的逻辑单元(原子单元)</li>
<li><strong>1个Pod里面可以运行多个容器</strong>，他们共享UTS+NET+IPC名称空间</li>
<li>可以把Pod看成豌豆荚，而同一个Pod内的每个容器是一颗颗豌豆</li>
<li>一个Pod里运行多个容器，又称作：<strong>边车(SideCar)模式</strong>(类似从动轮)</li>
</ul>
<h3 id="Pod控制器"><a href="#Pod控制器" class="headerlink" title="Pod控制器"></a>Pod控制器</h3><ul>
<li>Pod控制器是Pod启动的一种模板，用来<strong>保证在K8S里启动的Pod应始终按照人们的预期运行</strong>(副本数、生命周期、健康状态检查…)</li>
<li>K8S内提供了众多的Pod控制器，常用的有以下几种：<ul>
<li><font color=#FF0000>Deployment</font>（真正暴露在外面的）</li>
<li><font color=#FF0000>DeamonSet</font>（每个运算节点上都起一份）</li>
<li>ReplicaSet（Deployment管理ReplicaSet，ReplicaSet管理Pod,ReplicaSet不直接暴露在外面）</li>
<li>StatefulSet（管理有状态应用）</li>
<li>Job（管理普通任务）</li>
<li>Cronjob（管理定时任务）</li>
</ul>
</li>
</ul>
<h2 id="Name-Namespace"><a href="#Name-Namespace" class="headerlink" title="Name/Namespace"></a>Name/Namespace</h2><h3 id="Name"><a href="#Name" class="headerlink" title="Name"></a>Name</h3><ul>
<li>由于K8S内部，使用”资源”来定义每一种逻辑概念(功能)，所以每种”资源”，都应该有自己的”名称”</li>
<li>“资源”有api版本(apiVersion)、类别(kind)、元数据(metadata)、定义清单(spec)、状态(status)等配置信息</li>
<li>“名称”通常定义在”资源”的”元数据”信息里</li>
</ul>
<h3 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h3><ul>
<li>随着项目增多、人员数量增加、集群规模扩大，需要一种能够隔离K8S内各种”资源”的方法，这就是Namespace命名空间</li>
<li>Namespace可以理解为K8S内部的虚拟集群组</li>
<li>不同名称空间内的”资源”，名称可以相同，相同名称空间内的同种”资源”，”名称”不能相同</li>
<li>合理地使用K8S的名称空间，使得集群管理员能够更好地对交付到K8S里的服务进行分类管理和浏览</li>
<li>K8S里默认的Namespace有：default、kube-system、kube-public</li>
<li>查询K8S里特定”资源”要带上相应的名称空间(Namespace)，不带默认查询default空间</li>
</ul>
<h2 id="Label-Label选择器"><a href="#Label-Label选择器" class="headerlink" title="Label/Label选择器"></a>Label/Label选择器</h2><h3 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h3><ul>
<li><strong>标签是K8S特色的管理方式</strong>，便于分类管理资源对象</li>
<li>一个标签可以对应多个资源，一个资源也可以有多个标签，它们是<strong>多对多的</strong>关系。</li>
<li>一个资源拥有多个标签，可以实现不同维度的管理(一个资源可以打上各种各样的标签，比如可以打上污点、容忍度等)</li>
<li>标签的组成：key=value(键值对)</li>
<li>与标签类似的，还有一种”注解”(annotations)</li>
</ul>
<p>Label的定义有限制，长度要小于63，必须以字母或数字开头，中间值也有要求。(官网原话：Valid label values must be 63 characters or less nad must be empty or begin and end with an alphanumeric character([a-z0-9A-Z]) with dashes(_),dots(.), and alphanumerics between).</p>
<h3 id="Label选择器"><a href="#Label选择器" class="headerlink" title="Label选择器"></a>Label选择器</h3><ul>
<li>给资源打上Label之后，<strong>可以使用标签选择器过滤指定的标签，然后执行我们想要的操作</strong></li>
<li>标签选择器目前有两种：基于等值关系(等于、不等于)和基于集合关系(属于、不属于、存在)</li>
<li>许多资源支持内嵌标签选择器字段<ul>
<li>matchLabels</li>
<li>matchExperssions</li>
</ul>
</li>
</ul>
<h2 id="Service-Ingress-最重要"><a href="#Service-Ingress-最重要" class="headerlink" title="Service/Ingress(最重要)"></a>Service/Ingress(最重要)</h2><h3 id="Service-暴露在OSI第四层，暴露IP和端口"><a href="#Service-暴露在OSI第四层，暴露IP和端口" class="headerlink" title="Service(暴露在OSI第四层，暴露IP和端口)"></a>Service(暴露在OSI第四层，暴露IP和端口)</h3><ul>
<li>在K8S的”世界”里，虽然每个Pod都会被分配一个单独的IP地址，但这个IP地址会随着Pod的销毁而消失(Pod有生命周期，而且每次重启Pod的IP都会变化，那么IP地址每次都变化，怎么<strong>调度流量</strong>呢？每次都去修改IP么？不行，想到了巧妙的Service)</li>
<li>Service(服务)就是用来解决这个问题的核心概念</li>
<li>一个Service可以看做是一组提供相同服务的Pod的对外访问接口</li>
<li>Service作用于哪些Pod是通过标签选择器来定义的</li>
</ul>
<h3 id="Ingress-暴露在应用层"><a href="#Ingress-暴露在应用层" class="headerlink" title="Ingress(暴露在应用层)"></a>Ingress(暴露在应用层)</h3><ul>
<li>Ingress是K8S集群里工作在OSI网络参考模型下的应用层(第7层)的应用，对外直接暴露的接口</li>
<li>Service只能进行L4流量调度，表现形式是ip + port</li>
<li>Ingress则可以调度不同业务域、不同URL访问路径的业务流量</li>
</ul>
<p><strong>如果用了HTTP和HTTPS协议，那么暴露应用的时候绝大时候都是用Ingress暴露</strong>。</p>
<p>查找逻辑关系是，Ingress去找Service，然后Service去找Pod。</p>
<h1 id="K8S核心组件与核心附件"><a href="#K8S核心组件与核心附件" class="headerlink" title="K8S核心组件与核心附件"></a>K8S核心组件与核心附件</h1><h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><ul>
<li><p><strong>配置存储中心</strong>：etcd服务(类似ZK，主要用来存储节点元数据信息，比如资源配置，类似MySQL，etcd是非关系型数据库)</p>
</li>
<li><p><strong>主控(master)节点</strong></p>
<ul>
<li>kube-apiserver服务</li>
</ul>
<p><strong>详解</strong>：apiserver是整个K8S的大脑，提供了集群管理的REST API接口(包括鉴权、数据校验及集群状态变更)；负责其他模块之间的数据交互；是资源配额控制的入口；提供完备的集群安全机制；</p>
<ul>
<li>kube-controller-manager服务</li>
</ul>
<p><strong>详解</strong>：由一系列控制器组成，通过apiserver监控整个集群的状态，并确保集群处于预期的工作状态。</p>
<ul>
<li>kube-scheduler服务</li>
</ul>
<p><strong>详解</strong>：主要功能是接收调度pod到适合的运算节点上</p>
</li>
<li><p><strong>运算(node)节点</strong></p>
<ul>
<li>kube-kubelet服务</li>
</ul>
<p><strong>详解</strong>：简单来说，kubelet的功能就是定时从某个地方获取节点上pod的期望状态(运行什么容器、网络状态配置等等)，并调用对应的容器平台接口以达到这个状态；kubelet还会定时汇报当前节点状态给apiserver，以供调度的时候使用；镜像和容器的清理工作，保证节点上的镜像不会沾满存储空间。</p>
<p>可见，kubelet功能很多，很核心。</p>
<ul>
<li>kube-proxy服务</li>
</ul>
<p><strong>详解</strong>：proxy是K8S每个节点上运行网络的代理，是service资源的代理。说白了，是建立了pod网络和集群网络的关系(clusterip与podip的关系)；常用三种流量调度模式：Userspace(已经被废弃)、Iptables(濒临被废弃)、Ipvs(推荐使用)。实际proxy提供的是service的虚拟网络。</p>
</li>
</ul>
<h2 id="CLI客户端"><a href="#CLI客户端" class="headerlink" title="CLI客户端"></a>CLI客户端</h2><ul>
<li>kubectl</li>
</ul>
<p>详解：给Pod提供网络</p>
<h2 id="核心附件"><a href="#核心附件" class="headerlink" title="核心附件"></a>核心附件</h2><ul>
<li>CNI网络插件：flannel/calico</li>
<li>服务发现用插件：coredns</li>
<li>服务暴露用插件：traefik</li>
<li>GUI管理插件：Dashboard</li>
</ul>
<h1 id="生产经验-K8S三条网络"><a href="#生产经验-K8S三条网络" class="headerlink" title="生产经验(K8S三条网络)"></a>生产经验(K8S三条网络)</h1><p>这里说的生产经验，实际上是<strong>如何规划K8S的三条网络</strong>。如下图所示：</p>
<p><img src="https://i.loli.net/2020/04/07/I8uqR3yH562KJdB.png" alt="K8S三条网络.png"></p>
<p>上图可以很清晰地展现K8S的三个网络：节点网络、Pod网络、Service网络。</p>
<p>宿主机器的网络，或者说Node网络，就是图中的<strong>节点网络</strong>。</p>
<p>Pod通过从宿主机上NAT，得到Pod网络，过程中利用了docker0设备，所有docker容器会从docker通过NAT映射出来。</p>
<p>需要注意，<code>kube-proxy</code><strong>连接了Pod网络和Service网络，其中Service网络是虚的网络</strong>。</p>
<p>举例：</p>
<ul>
<li>Service网络可以设置为：<code>192.168.0.0/16</code>，Pod网络可以设置为<code>172.7.0.0/16</code>，节点网络可以设置为<code>10.4.7.0/24</code></li>
<li>Node1和Node2分别设置为：<code>10.4.7.21</code>和<code>10.4.7.22</code>，然后Node1对应的pod网络是<code>172.7.21.0/24</code>和<code>172.7.22.0/24</code>。</li>
</ul>
<p>上述设计经过了严格考虑，三条网络分别对应了三个私有地址，即10段的私有地址、172.7段的私有地址和192.168段的私有地址。(这个设计在很多生产环境上都在使用)</p>
<p>首先，因为Service网络是虚拟的网络，所以用<code>192.168.x.x/16</code>没有问题。</p>
<p>然后，因为pod的网络也经过了规划，所以我们一看到比如<code>172.7.21.4</code>之类的IP，就能知道是Node1节点上的pod，<font color=#FF0000>这样的对应关系有助于排错</font>。</p>
<p>在规划pod的IP和Node的IP的时候，也是有讲究的。比如我们的Node1设置IP为<code>10.4.7.1</code>，每一位都有自己的含义：10代表公网的私有地址、4代表机房，也就是不同楼层的哪个机房、7代表不同的项目或者环境，比如7代表公共开发部NCE基础研发部，8代表NCE应用研发部，9和10代表生产环境等，也就是<strong>第三位用来区分业务和环境，可以用来做物理隔离</strong>。此外，pod的网络也要根据Node来变化，比如Node1的第二位是5，即<code>10.5.7.1</code>,那么此时pod网络可以设置第二位为17，即<code>172.17.21.0/24</code>，以此类推。</p>
<p>所以，在规划Node网络和Pod网络的时候，我们最好要达到，一看到某个pod的IP，就知道是哪台机器上的，因为有可能pod挂的时候会挂一批，那么能通过pod的IP找到Node，就很利于排错。</p>
<h1 id="K8S服务发现和负载均衡"><a href="#K8S服务发现和负载均衡" class="headerlink" title="K8S服务发现和负载均衡"></a>K8S服务发现和负载均衡</h1><p><a href="http://www.cnblogs.com/leidaxia/p/6485639.html" target="_blank" rel="noopener">可以参考这篇文章</a></p>
<p><a href="https://blog.csdn.net/weixin_39891030/article/details/86480333" target="_blank" rel="noopener">详细的负载均衡可以参考这篇文章</a></p>
<p><a href="https://baijiahao.baidu.com/s?id=1651231426160391377&wfr=spider&for=pc" target="_blank" rel="noopener">一个基于Service做服务发现和负载均衡的案例</a></p>
<p>之前我们已经了解到 pod 的网络跟机器不是同一个段的网络，那怎么让 pod 网络暴露出去给外部访问，从而提供给外部的用户去调用的？这时就需要<strong>服务发现</strong>。而如果pod使用rc创建了多个副本，那么service就能代理多个相同的pod，通过<strong>kube-proxy，实现负载均衡</strong>。</p>
<p>一个模型如图所示：</p>
<p><img src="https://i.loli.net/2020/04/07/dgby9EwWrpjfoMK.png" alt="K8S服务发现和负载均衡.png"></p>
<p>在 K8s 里面，服务发现与负载均衡就是 K8s <strong>Service</strong>。上图就是在 K8s 里 Service 的架构，K8s service 向上提供了外部网络以及 pod 网络的访问，即外部网络可以通过 service 去访问，pod 网络也可以通过 K8s Service 去访问。</p>
<p>向下，K8s 对接了另外一组 pod，即可以通过 K8s Service 的方式去负载均衡到一组 pod 上面去，这样相当于解决了前面所说的复发性问题，或者提供了统一的访问入口去做服务发现，然后又可以给外部网络访问，解决不同的 pod 之间的访问，提供统一的访问地址。</p>
<p>service：服务，是一个虚拟概念，逻辑上代理后端pod。众所周知，pod生命周期短，状态不稳定，pod异常后新生成的pod ip会发生变化，之前pod的访问方式均不可达。通过service对pod做代理，service有固定的ip和port，ip:port组合自动关联后端pod，即使pod发生改变，kubernetes内部更新这组关联关系，使得service能够匹配到新的pod。这样，通过service提供的固定ip，用户再也不用关心需要访问哪个pod，以及pod是否发生改变，大大提高了服务质量。</p>
<p>每个节点都有一个组件<strong>kube-proxy</strong>，实际上是为service服务的，通过kube-proxy，实现流量从service到pod的转发，<strong>kube-proxy也可以实现简单的负载均衡功能</strong>。</p>
<p>kube-proxy代理模式：userspace方式：kube-proxy 在节点上为每一个服务创建一个临时端口，service的IP：port 过来的流量转发到这个临时端口上，kube-proxy会用内部的负载均衡机制（轮询），选择一个后端pod，然后建立iptables，把流量导入这个pod里面。</p>
<h2 id="K8S服务发现"><a href="#K8S服务发现" class="headerlink" title="K8S服务发现"></a>K8S服务发现</h2><p>服务发现在微服务架构里，服务之间经常进行通信，服务发现就是解决不同服务之间通信的问题。比如一个nginx的pod，要访问一个mysql服务，就需要知道mysql服务的ip和port，获取ip和port的过程就是服务发现。</p>
<p>kubernetes 支持两种服务发现模式：</p>
<ol>
<li><strong>环境变量</strong></li>
</ol>
<p>Pod创建的时候，服务的ip和port会以环境变量的形式注入到pod里，比如pod创建时有一个redis-master服务，服务ip地址是10.0.0.11，port是6379，则会把下面一系列环境变量注入到pod里，通过这些环境变量访问redis-master服务。 REDIS_MASTER_SERVICE_HOST=10.0.0.11REDIS_MASTER_SERVICE_PORT=6379REDIS_MASTER_PORT=t</p>
<ol start="2">
<li><strong>dns</strong></li>
</ol>
<p>K8s集群会内置一个dns服务器，<strong>service创建成功后，会在dns服务器里导入一些记录，想要访问某个服务，通过dns服务器解析出对应的ip和port，从而实现服务访问</strong></p>
<p>service 是微服务架构中的微服务。service 定义了一个服务的访问入口地址，前端的应用（pod）通过这个入口访问其背后的一组由pod副本组成的集群实例，service与其后端pod副本集群之间是通过label seletor 实现无缝对接的。而rc的功能实际上是保证servic的服务能力和服务质量处于预期的标准</p>
<p>通常我们的系统是由多个提供不同业务能力而又彼此独立的微服务单元所组成，服务之间通过tcp／ip进行通信，从而形成了强大而又灵活的弹性网络，拥有了强大的分布式能力，弹性扩展能力，容错能力。</p>
<h2 id="K8S的Service如何进行服务发现和负载均衡"><a href="#K8S的Service如何进行服务发现和负载均衡" class="headerlink" title="K8S的Service如何进行服务发现和负载均衡"></a>K8S的Service如何进行服务发现和负载均衡</h2><p>service可以将pod ip封装起来，即使pod发生重建，依然可以通过service来访问pod提供的服务，service还小程度地解决了负载均衡的问题。</p>
<p>运行在每个node上的<strong>kube-proxy</strong>进程其实就是一个<strong>智能的软件负载均衡器</strong>，他负责<strong>把service的请求转发到后端的某个pod实例</strong>。<strong>Kube-proxy</strong> 的默认模式是 iptables，它支持相当复杂的基于规则的 IP 管理。iptables 模式下，负载分配的本地方法是随机选择——<strong>由一个传入的请求去随机选择一个服务中的 pod。</strong>早先版本（以及原来的默认模式）的 kube-proxy 模式是 userspace，它使用循环的负载分配，在 IP 列表上来分配下一个可以使用的 pod，然后更换（或置换）该列表。</p>
<p><strong>kube-dns可以解决Service的发现问题</strong>，k8s将Service的名称当做域名注册到kube-dns中，通过Service的名称就可以访问其提供的服务。</p>
<h2 id="真正的负载均衡：Ingress"><a href="#真正的负载均衡：Ingress" class="headerlink" title="真正的负载均衡：Ingress"></a>真正的负载均衡：Ingress</h2><p>上面讲到了支持K8S负载均衡的两种方式，即kube-proxy和service，但是这些并不是真正的负载均衡。为了实现真正的负载均衡，当前最流行、最灵活、应用于很多领域的方法是<strong>Ingress</strong>，它通过在专门的 Kubernetes pod 中的Controller(控制器)进行操作。</p>
<p>控制器包括一个 Ingress 资源——一组管理流量的规则和一个应用这些规则的守护进程。 控制器有自己内置的负载均衡特性，具备一些相当复杂的功能。你还可以让 Ingress 资源包含更复杂的负载均衡规则，来满足对具体系统或供应商的负载均衡功能和需求。</p>
<p>除了 Ingress，还可以使用负载均衡器类型的服务来替代它。该服务使用基于云服务的外部负载均衡器。负载均衡器只能与 AWS、Azure、OpenStack、CloudStack 和 Google Compute Engine 等特定的云服务提供商一起使用，且均衡器的功能根据提供者而定。除此之外其他的负载均衡方法可以从服务提供商以及第三方获得。</p>
<p><font color=#FF000>但是总的来说，还是推荐Ingress</font>。当前 Ingress 是首选的负载均衡方法。因为它是作为一个基于 pod 的控制器在 Kubernetes 内部执行，因此对 Kubernetes 功能的访问相对不受限制（不同于外部负载均衡器，它们中的一些可能无法在 pod 层面访问）。Ingress 资源中包含的可配置规则支持非常详细和高度细化的负载均衡，可以根据应用程序的功能要求极其运行条件进行定制。</p>
]]></content>
      <categories>
        <category>Study Note</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>K8s</tag>
        <tag>MicroService</tag>
      </tags>
  </entry>
  <entry>
    <title>zookeeper I</title>
    <url>/2020/04/05/zookeeper-study-I/</url>
    <content><![CDATA[<blockquote>
<p>成功的奥秘在于目标的坚定。——迪斯雷利</p>
</blockquote>
<a id="more"></a>

<h1 id="zookeeper一般的使用场景"><a href="#zookeeper一般的使用场景" class="headerlink" title="zookeeper一般的使用场景"></a>zookeeper一般的使用场景</h1><p>分布式一般都会考虑到分布式锁，而zookeeper是用在分布式锁里很常用的。</p>
<p>大致来说，zk的使用场景如下：</p>
<p>（1）<strong>分布式协调</strong>：这个其实是zk很经典的一个用法，简单来说，就好比，你A系统发送个请求到mq，然后B消息消费之后处理了。那A系统如何知道B系统的处理结果？用zk就可以实现分布式系统之间的协调工作。A系统发送请求之后可以在zk上对某个节点的值注册个监听器，一旦B系统处理完了就修改zk那个节点的值，A立马就可以收到通知，完美解决。</p>
<p>zookeeper一开始的定位就是做分布式协调。让多个系统协调起来，某个系统要感知另一个系统当前的处理结果和状态。</p>
<p>分布式协调如下图：</p>
<p><img src="https://i.loli.net/2020/04/05/fcaQClX3VsUiKDj.png" alt="01_zookeeper的分布式协调场景.png"></p>
<p>（2）<strong>分布式锁</strong>：对某一个数据连续发出两个修改操作，两台机器同时收到了请求，但是只能一台机器先执行另外一个机器再执行。那么此时就可以使用zk分布式锁，一个机器接收到了请求之后先获取zk上的一把分布式锁，就是可以去创建一个znode，接着执行操作；然后另外一个机器也尝试去创建那个znode，结果发现自己创建不了，因为被别人创建了。。。。那只能等到另一个机器执行完，把锁释放掉，后来的机器才能执行。</p>
<p>分布式锁如下图：</p>
<p><img src="https://i.loli.net/2020/04/05/8yYBEMILhCmcqRb.png" alt="02_zookeeper的分布式锁场景.png"></p>
<p>（3）<strong>元数据/配置信息管理</strong>：zk可以用作很多系统的配置信息的管理，比如kafka、storm等等很多分布式系统都会选用zk来做一些元数据、配置信息的管理，包括dubbo注册中心也支持zk</p>
<p>举例，服务A在三台机器上，这些数据放到了dubbo数据中心，然后dubbo会基于zookeeper的元数据来保存这个配置信息，此后只要数据有了变化，zookeeper会实时监听，并且把更新的数据告诉调用者。</p>
<p>实际上，消息队列Kafka，流式计算引擎Storm，都基于zookeeper的元数据管理。</p>
<p><img src="https://i.loli.net/2020/04/05/FSBk2iP71Zq6gnz.png" alt="03_zookeeper的元数据_配置管理场景.png"></p>
<p>（4）<strong>HA高可用性</strong>：就是实现主备系统。这个应该是很常见的，比如hadoop、hdfs、yarn等很多大数据系统，都选择基于zk来开发HA高可用机制，就是一个重要进程一般会做主备两个，<strong>主进程挂了立马通过zk感知到切换到备用进程</strong>。</p>
<p><img src="https://i.loli.net/2020/04/05/bGYwFHIctL1JgqR.png" alt="04_zookeeper的HA高可用性场景.png"></p>
<p>临时节点名字是active，具体可以被设置成active是worker01或者work02。</p>
<p>一开始设置成了worker01，那么只由worker01工作，但是如果worker01挂掉了，那么这个临时节点会被ZK删除掉，然后重新定义一个新的active节点，并且赋值为worker02。</p>
<h1 id="Zookeeper内部原理-面试重点"><a href="#Zookeeper内部原理-面试重点" class="headerlink" title="Zookeeper内部原理(面试重点)"></a>Zookeeper内部原理(面试重点)</h1><h2 id="Zookeeper选举机制-详细算法参考paxos"><a href="#Zookeeper选举机制-详细算法参考paxos" class="headerlink" title="Zookeeper选举机制(详细算法参考paxos)"></a>Zookeeper选举机制(详细算法参考paxos)</h2><p>选举机制，即如何选出集群中的Leader(集群中只有一个Leader，其他都是follower)。</p>
<p>1）<strong>半数机制</strong>：只有集群中半数以上机器存活，集群才能可用。所以<font color=#FF0000>zookeeper适合安装奇数台服务器</font>。</p>
<p>举个例子，如果你集群中有5台机器，那么挂掉2台还可以工作，挂掉3台就不行了。如果集群有6台机器，那么挂掉3台也不可以工作了，所以一般建议配成奇数台机器。</p>
<p>2）Zookeeper虽然在配置文件中并没有指定Master和Slave，但是ZK工作时，是有一个节点为Leader，其他则为Follower，Leader是通过内布的选举机制临时产生的。</p>
<p>3）以一个简单的例子说明选举过程</p>
<p>假设现在有五台服务器组成的ZK集群，它们的id从1-5，同时它们都是最新启动的，即没有历史数据，而且每台机器存放的数据量也是一样的。假设这些服务器依序启动，会发生什么？如何选举？</p>
<p>五台机器如下图所示：</p>
<p><img src="https://i.loli.net/2020/04/05/5ewx9ln2PodcmkE.png" alt="ZK选举.png"></p>
<p>一开始，第一台机器Server1启动，会自动投自己一票，但是因为此时节点数量未过半，所以节点1处于Looking状态。后面Server2启动，也会投自己，然后Server1会投给2，因为id最大，但是因为未过半所以还是处于Looking状态。后面类似，后面来的，myid大的，就投票给它。</p>
<p>但是注意，只要Leader选出来了，就是既定事实，不能变了。</p>
<p>所以，<strong>当每个机器新加入集群的时候，首先会投票给自己，如果票投给自己选不出来Leader，那么会把它这一票投给id号大的。一旦某个机器得到的选票过半，它就是leader，后面再加入机器，也不能是Leader，因为Leader已经定了</strong>。（<font color=#FF0000>注意，ZK启动的时候知道有多少台服务器，因为你已经写了数据到ZK的配置文件里了</font>）</p>
<h2 id="Zookeeper节点类型"><a href="#Zookeeper节点类型" class="headerlink" title="Zookeeper节点类型"></a>Zookeeper节点类型</h2><p>一共分为两大类，四种。</p>
<p><strong>持久节点(Persistent)</strong>：客户端和服务端断开连接后，创建的节点不删除。</p>
<p>持久类节点分为两种：</p>
<ul>
<li><strong>持久化目录节点</strong>：客户端与ZK断开连接后，该节点仍然存在</li>
<li><strong>持久化顺序编号目录节点</strong>：客户端与ZK断开连接后，该节点依旧存在，只是ZK会对该节点名称进行书序编号。</li>
</ul>
<p><strong>说明</strong>：创建znode时设置顺序标识，znode名称后会附加一个值，顺序号是一个单调递增的计数器，由父节点维护。而有顺序号的节点有一个用处：<font color=#FF0000>顺序号可以被用于为所有的事件进行全局排序，这样客户端可以通过顺序号推断事件的顺序</font>。</p>
<p><strong>临时节点(Ephemeral)</strong>：客户端和服务端断开连接后，创建的节点会被自己删除。</p>
<p>临时节点也分为两类：</p>
<ul>
<li><strong>临时目录节点</strong>：客户端与ZK断开连接后，该节点被删除</li>
<li><strong>临时顺序编号目录节点</strong>：客户端与ZK断开连接后，该节点被删除，只是ZK给该节点名称进行顺序编号。</li>
</ul>
<p>为什么有的节点要在断开连接后删除？——有必要，有一些服务器记录的是其他服务器是否在线的数据，所以如果节点断开连接后，删除记录，那么查询的时候查不到数据，说明用户已经下线。</p>
<p>四种类型的节点如下图所示：</p>
<p><img src="https://i.loli.net/2020/04/05/kM13iAvalV8EuC7.png" alt="节点类型.png"></p>
<h2 id="Zookeeper监听器原理-详细参考Raft算法"><a href="#Zookeeper监听器原理-详细参考Raft算法" class="headerlink" title="Zookeeper监听器原理(详细参考Raft算法)"></a>Zookeeper监听器原理(详细参考Raft算法)</h2><p>ZK监听器经常会被用到，因为其用到了观察者模式。</p>
<p><font color=#FF0000><strong>监听器会按照以下步骤工作</strong></font>：</p>
<p>1）创建main()线程</p>
<p>2）在main线程中创建zookeeper客户端对象(主要用于访问server服务器)，这时就会创建两个线程，一个负责正常业务通讯，即网络连接通信（connect），一个负责监听（listener）。</p>
<p>3）通过connect线程将注册的监听事件发送给zookeeper</p>
<p>4）在zookeeper注册监听器列表中将注册的监听事件添加到列表中</p>
<p>5）zookeeper监听到有数据或者路径变化，就会回调main()线程，将这个消息发送给listener线程，告诉客户端现在有事情发生，要处理。</p>
<p>6）listener线程内部调用process()方法</p>
<p>如下图所示：</p>
<p><img src="https://i.loli.net/2020/04/05/yEXHev2s7FZrVtL.png" alt="常见监听方式.png"></p>
<p><font color=#FF0000><strong>常见监听方式</strong></font>：</p>
<p>1）监听节点数据的变化：get path [watch]</p>
<p>2）监听子节点增减的变化：ls path [watch]</p>
<h1 id="分布式锁是什么？"><a href="#分布式锁是什么？" class="headerlink" title="分布式锁是什么？"></a>分布式锁是什么？</h1><h1 id="对比下redis和zk两种分布式锁的优劣？"><a href="#对比下redis和zk两种分布式锁的优劣？" class="headerlink" title="对比下redis和zk两种分布式锁的优劣？"></a>对比下redis和zk两种分布式锁的优劣？</h1>]]></content>
      <categories>
        <category>Interview Note</category>
      </categories>
      <tags>
        <tag>Interview</tag>
        <tag>Study</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Distributed system + Dubbo</title>
    <url>/2020/04/05/Dubbo-I/</url>
    <content><![CDATA[<blockquote>
<p>盼望一件事会发生的人祈祷；相信一件事将发生的人专注；让一件事能发生的人行动</p>
</blockquote>
<a id="more"></a>

<h1 id="分布式系统及相关知识"><a href="#分布式系统及相关知识" class="headerlink" title="分布式系统及相关知识"></a>分布式系统及相关知识</h1><p>分布式业务系统，是把原来用java开发的一个大块系统，给拆分成多个子系统，多个子系统之间互相调用，形成一个大系统的整体。假设原来你做了一个OA系统，里面包含了权限模块、员工模块、请假模块、财务模块，一个工程，里面包含了一堆模块，模块与模块之间会互相去调用，1台机器部署。现在如果你把他这个系统给拆开，权限系统，员工系统，请假系统，财务系统，4个系统，4个工程，分别在4台机器上部署</p>
<p>一个请求过来，完成这个请求，这个员工系统，调用权限系统，调用请假系统，调用财务系统，4个系统分别完成了一部分的事情，最后4个系统都干完了以后，才认为是这个请求已经完成了。</p>
<p>一个最简单的分布式系统如下图所示：</p>
<p><img src="https://i.loli.net/2020/04/05/UPWJya3tTqIekvO.png" alt="最简单分布式系统01.png"></p>
<p>分布式系统使用较多一款开源RPC框架的是Dubbo，它是一款高性能，轻量级的框架，有三大核心能力：面向接口的远程方法调用、智能容错和负载均衡，以及服务自动注册和发现。</p>
<p>Dubbo简单入门案例<a href="https://blog.csdn.net/abcwanglinyong/article/details/81906027" target="_blank" rel="noopener">可以参考这篇博客</a>,<a href="https://www.cnblogs.com/lfs2640666960/archive/2019/08/01/11283366.html" target="_blank" rel="noopener">和这篇博客</a></p>
<p>Dubbo可以把每个子系统抽象成一个服务。</p>
<p><img src="https://i.loli.net/2020/04/05/tcRXusaTdAn4jKq.png" alt="01_什么是最简单的分布式系统.png"></p>
<p>分布式系统，一句话给你解释一下，就是原来20万行代码的系统，现在拆分成20个小系统，每个小系统1万行代码。原本代码之间直接就是基于spring调用，现在拆分开来了，20个小系统部署在不同的机器上，得基于dubbo搞一个rpc调用，接口与接口之间通过网络通信来请求和响应。就这个意思。</p>
<h2 id="CAP-理论"><a href="#CAP-理论" class="headerlink" title="CAP 理论"></a>CAP 理论</h2><p>CAP理论，即CAP Theorem。</p>
<p>什么是CAP理论？其实是指，对于一个分布式系统，不能同时满足以下三点：</p>
<ul>
<li>一致性(Consistency)</li>
<li>可用性(Avaliability)</li>
<li>分区容错性(Partition Tolerance)</li>
</ul>
<h1 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h1><h2 id="为什么要进行系统拆分？"><a href="#为什么要进行系统拆分？" class="headerlink" title="为什么要进行系统拆分？"></a>为什么要进行系统拆分？</h2><p>提一嘴微服务，微服务是基于分布式系统的，会把系统拆得更散。</p>
<p>要是不拆分，一个大系统几十万行代码，20个人维护一份代码，简直是悲剧啊。代码经常改着改着就冲突了，各种代码冲突和合并要处理，非常耗费时间；经常我改动了我的代码，你调用了我，导致你的代码也得重新测试，麻烦的要死；然后每次发布都是几十万行代码的系统一起发布，大家得一起提心吊胆准备上线，几十万行代码的上线，可能每次上线都要做很多的检查，很多异常问题的处理，简直是又麻烦又痛苦；而且如果我现在打算把技术升级到最新的spring版本，还不行，因为这可能导致你的代码报错，我不敢随意乱改技术。</p>
<p>假设一个系统是20万行代码，其中小A在里面改了1000行代码，但是此时发布的时候是这个20万行代码的大系统一起发布。一起发布，就意味着20万上代码在线上就可能出现各种变化，20个人，每个人都要紧张地等在电脑面前，上线之后，检查日志，看自己负责的那一块儿有没有什么问题。</p>
<p>小A就检查了自己负责的1万行代码对应的功能，确保ok就闪人了；结果不巧的是，小A上线的时候不小心修改了线上机器的某个配置，导致另外小B和小C负责的2万行代码对应的一些功能，出错了</p>
<p>几十个人负责维护一个几十万行代码的单块应用，每次上线，准备几个礼拜，上线 -&gt; 部署 -&gt; 检查自己负责的功能</p>
<p>维护单块的应用，在从0到1的环节里，是很合适的，因为那个时候，是系统都没上线，没什么技术挑战，大家有条不紊的开发。ssh + mysql + tomcat，可能会部署几台机器吧。</p>
<p>结果不行了，后来系统上线了，业务快速发展，10万用户 -&gt; 100万用户 -&gt; 1000万用户 -&gt; 上亿用户了。</p>
<p><strong>拆分之后，整个世界清爽了</strong>，几十万行代码的系统，拆分成20个服务，平均每个服务就1~2万行代码，每个服务部署到单独的机器上。20个工程，20个git代码仓库里，20个程序员，每个人维护自己的那个服务就可以了，是自己独立的代码，跟别人没关系。再也没有代码冲突了，爽。每次就测试我自己的代码就可以了，爽。每次就发布我自己的一个小服务就可以了，爽。技术上想怎么升级就怎么升级，保持接口不变就可以了，爽。</p>
<p>所以简单来说，一句话总结，如果是 那种代码量多达几十万行的中大型项目，团队里有几十个人，那么如果不拆分系统，开发效率极其低下，问题很多。但是拆分系统之后，每个人就负责自己的一小部分就好了，可以随便玩儿随便弄。分布式系统拆分之后，可以大幅度提升复杂系统大型团队的开发效率。</p>
<p>但是同时，也要提醒的一点是，系统拆分成分布式系统之后，大量的分布式系统面临的问题也是接踵而来，所以后面的问题都是在围绕分布式系统带来的复杂技术挑战在说。</p>
<h2 id="如何进行系统拆分？"><a href="#如何进行系统拆分？" class="headerlink" title="如何进行系统拆分？"></a>如何进行系统拆分？</h2><p>这个问题说大可以很大，可以扯到领域驱动模型设计上去，说小了也很小。</p>
<p>系统拆分分布式系统，拆成多个服务，拆成微服务的架构，拆很多轮的。上来一个架构师第一轮就给拆好了，第一轮；团队继续扩大，拆好的某个服务，刚开始是1个人维护1万行代码，后来业务系统越来越复杂，这个服务是10万行代码，5个人；第二轮，1个服务 -&gt; 5个服务，每个服务2万行代码，每人负责一个服务。</p>
<p>如果是多人维护一个服务，&lt;=3个人维护这个服务；最理想的情况下，几十个人，1个人负责1个或2~3个服务；某个服务工作量变大了，代码量越来越多，某个同学，负责一个服务，代码量变成了10万行了，他自己不堪重负，他现在一个人拆开，5个服务，1个人顶着，负责5个人，接着招人，2个人，给那个同学带着，3个人负责5个服务，其中2个人每个人负责2个服务，1个人负责1个服务。</p>
<p>一个服务的代码不要太多，1万行左右，最多两三万。</p>
<p>大部分的系统，是要进行多轮拆分的，第一次拆分，可能就是将以前的多个模块该拆分开来了，比如说将电商系统拆分成订单系统、商品系统、采购系统、仓储系统、用户系统，等等吧。</p>
<p>但是后面可能每个系统又变得越来越复杂了，比如说采购系统里面又分成了供应商管理系统、采购单管理系统，订单系统又拆分成了购物车系统、价格系统、订单管理系统。</p>
<p>扯深了实在很深，所以这里先给大家举个例子，你自己感受一下，核心意思就是<strong>根据情况，先拆分一轮，后面如果系统更复杂了，可以继续分拆</strong>。根据自己负责系统的例子，来考虑一下就好了。</p>
<h2 id="拆分后不用dubbo可以吗？"><a href="#拆分后不用dubbo可以吗？" class="headerlink" title="拆分后不用dubbo可以吗？"></a>拆分后不用dubbo可以吗？</h2><p>当然可以了，大不了最次，就是各个系统之间，直接基于spring mvc，就纯http接口互相通信呗，还能咋样。但是这个肯定是有问题的，因为http接口通信维护起来成本很高，你要考虑超时重试、负载均衡等等各种乱七八糟的问题，比如说你的订单系统调用商品系统，商品系统部署了5台机器，你怎么把请求均匀地甩给那5台机器？这不就是负载均衡？你要是都自己搞那是可以的，但是确实很痛苦。</p>
<p>所以dubbo说白了，是一种rpc框架，就是本地就是进行接口调用，但是dubbo会代理这个调用请求，跟远程机器网络通信，给你处理掉负载均衡了、服务实例上下线自动感知了、超时重试了，等等乱七八糟的问题。那你就不用自己做了，用dubbo就可以了。</p>
<p><a href="http://www.ccutu.com/243972.html" target="_blank" rel="noopener">不了解RPC框架，可以查看这篇文章</a>、和 <a href="https://www.jianshu.com/p/eb66b0c4113d" target="_blank" rel="noopener">这篇文章</a></p>
<h2 id="Dubbo的工作原理？"><a href="#Dubbo的工作原理？" class="headerlink" title="Dubbo的工作原理？"></a>Dubbo的工作原理？</h2><p>第一层：service层，接口层，给服务提供者和消费者来实现的。用过Dubbo的话，都是写provider、consumer、api,然后可以简单启动。</p>
<p>第二层：config层，配置层，主要是对dubbo进行各种配置的</p>
<p>第三层：proxy层，(服务)代理层，透明生成客户端的stub和服务单的skeleton</p>
<p>第四层：registry层，(服务)注册层，负责服务的注册与发现</p>
<p>第五层：cluster层，集群层，封装多个服务提供者的路由以及负载均衡，将多个实例组合成一个服务</p>
<p>第六层：monitor层，监控层，对rpc接口的调用次数和调用时间进行监控</p>
<p>第七层：protocol层，远程调用层，封装rpc调用</p>
<p>第八层：exchange层，信息交换层，封装请求响应模式，同步转异步</p>
<p>第九层：transport层，网络传输层，抽象mina和netty为统一接口</p>
<p>第十层：serialize层，数据序列化层</p>
<p>工作流程：</p>
<ol>
<li>第一步，provider向注册中心去注册</li>
<li>第二步，consumer从注册中心订阅服务，注册中心会通知consumer注册好的服务</li>
<li>第三步，consumer调用provider。注意，consumer和provider之间通信的时候一定要用到代理的，因为代理可以更方便使用均衡负载等策略来提高系统性能。</li>
<li>第四步，consumer和provider都异步的通知监控中心</li>
</ol>
<p>总的工作原理如下图所示：</p>
<p><img src="https://i.loli.net/2020/04/05/G3vBUlAbEfc7y1M.png" alt="01_dubbo的工作原理.png"></p>
<h2 id="注册中心挂了可以继续通信吗？"><a href="#注册中心挂了可以继续通信吗？" class="headerlink" title="注册中心挂了可以继续通信吗？"></a>注册中心挂了可以继续通信吗？</h2><p>可以，因为刚开始初始化的时候，消费者会将提供者的地址等信息拉取到本地缓存，所以注册中心挂了不要紧，可以本地缓存信息继续通信。</p>
<h2 id="说一说一次RPC请求的流程？"><a href="#说一说一次RPC请求的流程？" class="headerlink" title="说一说一次RPC请求的流程？"></a>说一说一次RPC请求的流程？</h2><p>使用Dubbo的一次通讯请求流程大致如上图。</p>
<h2 id="Dubbo支持哪些通信协议？支持哪些序列化协议？"><a href="#Dubbo支持哪些通信协议？支持哪些序列化协议？" class="headerlink" title="Dubbo支持哪些通信协议？支持哪些序列化协议？"></a>Dubbo支持哪些通信协议？支持哪些序列化协议？</h2><p>这个问题也不会问得很深，可能就问一下，什么场景下使用什么协议，然后比较各种序列化协议的优缺点。</p>
<h3 id="dubbo支持不同的通信协议"><a href="#dubbo支持不同的通信协议" class="headerlink" title="dubbo支持不同的通信协议"></a>dubbo支持不同的通信协议</h3><p>1）dubbo协议</p>
<p>dubbo://192.168.0.1:20188</p>
<p>默认就是走dubbo协议的，单一长连接，NIO异步通信，<strong>基于hessian作为序列化协议</strong>。</p>
<p>什么是短连接和长连接？</p>
<p><strong>短连接</strong>：每次请求都发送和建立一个连接，建立之后用完了就失效。(下图最后一个为短连接)</p>
<p><strong>长链接</strong>：建立一个长期保存的连接，后续再有请求，继续用这个连接。(下图第一个为长连接)</p>
<p>适用的场景就是：传输数据量很小（每次请求在100kb以内），但是并发量很高</p>
<p> 如图：</p>
<p><img src="https://i.loli.net/2020/04/05/xQI7YeyRSsTh4JM.png" alt="01_dubbo的网络通信协议.png"></p>
<p>为了要支持高并发场景，一般是服务提供者就几台机器，但是服务消费者有上百台，可能每天调用量达到上亿次！此时用长连接是最合适的，就是跟每个服务消费者维持一个长连接就可以，可能总共就100个连接。然后后面直接基于长连接NIO异步通信，可以支撑高并发请求。</p>
<p>否则如果上亿次请求每次都是短连接的话，服务提供者会扛不住。</p>
<p>而且因为走的是单一长连接，所以传输数据量太大的话，会导致并发能力降低。所以一般建议是传输数据量很小，支撑高并发访问。</p>
<p><strong>hessian使用的最多，剩下四个方法用得比较少</strong>。</p>
<p>2）rmi协议</p>
<p>走 <u>java二进制序列化</u>，多个短连接，适合消费者和提供者数量差不多，适用于文件的传输，一般较少用</p>
<p>3）hessian协议</p>
<p>走<u>hessian序列化协议</u>，多个短连接，适用于提供者数量比消费者数量还多，适用于文件的传输，一般较少用</p>
<p>4）http协议</p>
<p>走json序列化</p>
<p>5）webservice</p>
<p>走SOAP文本序列化</p>
<h3 id="dubbo支持的序列化协议"><a href="#dubbo支持的序列化协议" class="headerlink" title="dubbo支持的序列化协议"></a>dubbo支持的序列化协议</h3><p>序列化：把数据转换成可以在网络上传输的格式(比如二进制)。</p>
<p>所以dubbo实际基于不同的通信协议，支持hessian、java二进制序列化、json、SOAP文本序列化多种序列化协议。但是hessian是其默认的序列化协议。</p>
]]></content>
      <categories>
        <category>Interview Note</category>
      </categories>
      <tags>
        <tag>Interview</tag>
        <tag>Study</tag>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>Java IO and Linux IO</title>
    <url>/2020/03/31/IO-JavaIO-Model/</url>
    <content><![CDATA[<blockquote>
<p>知识犹如人体的血液一样宝贵。——高士其</p>
</blockquote>
<a id="more"></a>

<p>参考文章：<a href="https://mp.weixin.qq.com/s?__biz=Mzg3MjA4MTExMw==&mid=2247484746&idx=1&sn=c0a7f9129d780786cabfcac0a8aa6bb7&source=41&scene=21#wechat_redirect" target="_blank" rel="noopener">漫话：如何给女朋友解释什么是Linux的五种IO模型？</a></p>
<h1 id="Java中的IO"><a href="#Java中的IO" class="headerlink" title="Java中的IO"></a>Java中的IO</h1><p><strong>Java中提供的IO有关的API，在文件处理的时候，其实依赖操作系统层面的IO操作实现的</strong>。比如在Linux 2.6以后，Java中<strong>NIO</strong>和<strong>AIO</strong>都是通过<strong>epoll</strong>来实现的，而在Windows上，AIO是通过IOCP来实现的。</p>
<p>可以把Java中的<strong>BIO(同步阻塞阻塞IO,Blocking I/O)、NIO(同步非阻塞IO, New I/O)和AIO(异步非阻塞IO,Asynchronous I/O)</strong>理解为是Java语言对操作系统的各种IO模型的封装。程序员在使用这些API的时候，不需要关心操作系统层面的知识，也不需要根据不同操作系统编写不同的代码。只需要使用Java的API就可以了。</p>
<p>但是在Linux(UNIX)操作系统中，共有五种IO模型，分别是：<strong>阻塞IO模型、非阻塞IO模型、IO复用模型、信号驱动IO模型以及异步IO模型</strong>。</p>
<h1 id="操作系统的IO"><a href="#操作系统的IO" class="headerlink" title="操作系统的IO"></a>操作系统的IO</h1><h2 id="什么是IO"><a href="#什么是IO" class="headerlink" title="什么是IO"></a>什么是IO</h2><p>我们常说的IO，指的是文件的输入和输出，但是在操作系统层面，可以理解是：<strong>把数据从硬件（硬盘）中读取到用户空间中的过程</strong>。</p>
<p>用钓鱼做例子，钓鱼的时候，刚开始鱼是在鱼塘里面的，我们的钓鱼动作的最终结束标志是鱼从鱼塘中被我们钓上来，放入鱼篓中。</p>
<p>这里面的鱼塘就可以映射成磁盘，中间过渡的鱼钩可以映射成内核空间，最终放鱼的鱼篓可以映射成用户空间。一次完整的钓鱼（IO）操作，是鱼（文件）从鱼塘（硬盘）中转移（拷贝）到鱼篓（用户空间）的过程。</p>
<h2 id="阻塞IO模型"><a href="#阻塞IO模型" class="headerlink" title="阻塞IO模型"></a>阻塞IO模型</h2><p>我们钓鱼的时候，有一种方式比较惬意，比较轻松，那就是我们坐在鱼竿面前，这个过程中我们什么也不做，双手一直把着鱼竿，就静静的等着鱼儿咬钩。一旦手上感受到鱼的力道，就把鱼钓起来放入鱼篓中。然后再钓下一条鱼。</p>
<p>映射到Linux操作系统中，这就是一种最简单的IO模型，即阻塞IO。 <strong>阻塞 I/O 是最简单的 I/O 模型，一般表现为进程或线程等待某个条件，如果条件不满足，则一直等下去。条件满足，则进行下一步操作</strong>。</p>
<p>这种钓鱼方式相对来说比较简单，对于钓鱼的人来说，不需要什么特制的鱼竿，拿一根够长的木棍就可以悠闲的开始钓鱼了（实现简单）。缺点就是比较耗费时间，比较适合那种对鱼的需求量小的情况（并发低，时效性要求低）。</p>
<p>扩展：应用进程通过系统调用 <code>recvfrom</code> 接收数据，但由于内核还未准备好数据报，应用进程就会阻塞住，直到内核准备好数据报，<code>recvfrom</code> 完成数据报复制工作，应用进程才能结束阻塞状态。</p>
<h2 id="非阻塞IO模型"><a href="#非阻塞IO模型" class="headerlink" title="非阻塞IO模型"></a>非阻塞IO模型</h2><p><strong>应用进程与内核交互，目的未达到之前，不再一味的等着，而是直接返回。然后通过轮询的方式，不停的去问内核数据准备有没有准备好。如果某一次轮询发现数据已经准备好了，那就把数据拷贝到用户空间中</strong>。</p>
<p>应用进程通过 <code>recvfrom</code> 调用不停的去和内核交互，直到内核准备好数据。如果没有准备好，内核会返回<code>error</code>，应用进程在得到<code>error</code>后，过一段时间再发送<code>recvfrom</code>请求。在两次发送请求的时间段，进程可以先做别的事情。</p>
<p>这种方式钓鱼，和阻塞IO比，所使用的工具没有什么变化，但是钓鱼的时候可以做些其他事情，增加时间的利用率。</p>
<h2 id="信号驱动IO模型"><a href="#信号驱动IO模型" class="headerlink" title="信号驱动IO模型"></a>信号驱动IO模型</h2><p>我们钓鱼的时候，为了避免自己一遍一遍的去查看鱼竿，我们可以给鱼竿安装一个报警器。当有鱼儿咬钩的时候立刻报警。然后我们再收到报警后，去把鱼钓起来。</p>
<p>映射到Linux操作系统中，这就是<strong>信号驱动IO</strong>。<strong>应用进程在读取文件时通知内核，如果某个 socket 的某个事件发生时，请向我发一个信号。在收到信号后，信号对应的处理函数会进行后续处理</strong>。</p>
<p><strong>应用进程预先向内核注册一个信号处理函数，然后用户进程返回，并且不阻塞，当内核数据准备就绪时会发送一个信号给进程，用户进程便在信号处理函数中开始把数据拷贝到用户空间中</strong>。</p>
<p>这种方式钓鱼，和前几种相比，所使用的工具有了一些变化，需要有一些定制（实现复杂）。但是钓鱼的人就可以在鱼儿咬钩之前彻底做别的事儿去了。等着报警器响就行了。</p>
<h2 id="IO复用模型"><a href="#IO复用模型" class="headerlink" title="IO复用模型"></a>IO复用模型</h2><p>我们钓鱼的时候，为了保证可以最短的时间钓到最多的鱼，我们同一时间摆放多个鱼竿，同时钓鱼。然后哪个鱼竿有鱼儿咬钩了，我们就把哪个鱼竿上面的鱼钓起来。</p>
<p>映射到Linux操作系统中，这就是IO复用模型。<strong>多个进程的IO可以注册到同一个管道上，这个管道会统一和内核进行交互。当管道中的某一个请求需要的数据准备好之后，进程再把对应的数据拷贝到用户空间中</strong>。</p>
<p>IO多路转接是多了一个<code>select</code>函数，多个进程的IO可以注册到同一个<code>select</code>上，当用户进程调用该<code>select</code>，<code>select</code>会监听所有注册好的IO，如果所有被监听的IO需要的数据都没有准备好时，<code>select</code>调用进程会阻塞。当任意一个IO所需的数据准备好之后，<code>select</code>调用就会返回，然后进程在通过<code>recvfrom</code>来进行数据拷贝。</p>
<p><strong>这里的IO复用模型，并没有向内核注册信号处理函数，所以，他并不是非阻塞的</strong>。进程在发出<code>select</code>后，要等到<code>select</code>监听的所有IO操作中至少有一个需要的数据准备好，才会有返回，并且也需要再次发送请求去进行文件的拷贝。</p>
<p>这种方式的钓鱼，通过增加鱼竿的方式，可以有效的提升效率。</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>现在几乎所有服务器用的都是epoll实现的，属于IO多路复用的内容。</p>
<p>epoll是一种方案，放弃了多进程、多线程、多协程，而是用单进程和单线程来实现高并发。</p>
<p>实际开发中，不会要你重写一个epoll服务器和多进程服务器，但是要了解epoll。</p>
<p>传统的单线程非阻塞IO的性能瓶颈，在于FD(套接字返回的对象)每次都保存在应用程序空间(用户态)中，这样，每次使用的时候都需要从用户态往内核态来回一换一次(而且伴有FD数据的复制过程)，而且随着FD数量增加，服务器返回的FD的列表长度也会越长，导致性能低下。</p>
<p>但是epoll开创了新的存储方式：</p>
<ol>
<li><p><strong>共享内存</strong>，它定义了一块内存空间，这块空间既不属于用户空间，也不属于系统kernel空间，而是应用程序和kenel共享的。</p>
</li>
<li><p>在这个内存中所有添加的，判断的数据套接字，对应的数字描述符，我在检测的时候，不用轮询，而是<strong>事件通知</strong>。也就是把时间花在直接<strong>操作修改</strong>FD上，而不是查找。</p>
</li>
</ol>
<p>epoll原理图如下：</p>
<p><img src="https://i.loli.net/2020/04/02/doMyChETgSc1DxQ.png" alt="epoll原理图.png"></p>
<p>epoll优势：</p>
<ol>
<li><strong>减少了FD对象的用户态与内核态之间的复制过程</strong>。</li>
<li>采用<strong>事件通知</strong>的方式。FD对象很多，内部list很长的时候，也是个问题。</li>
</ol>
<h1 id="同步IO模型"><a href="#同步IO模型" class="headerlink" title="同步IO模型"></a>同步IO模型</h1><p>实际上，上面的四种IO模型：阻塞IO模型、非阻塞IO模型、IO复用模型和信号驱动IO模型，都是同步的IO模型。原因是因为，无论以上那种模型，<strong>真正的数据拷贝过程，都是同步进行的</strong>。</p>
<p>信号驱动难道不是异步的么？ 信号驱动，内核是在数据准备好之后通知进程，然后进程再通过<code>recvfrom</code>操作进行数据拷贝。我们可以认为数据准备阶段是异步的，但是，数据拷贝操作是同步的。所以，整个IO过程也不能认为是异步的。</p>
<p>我们把钓鱼过程，可以拆分为两个步骤：1、鱼咬钩（数据准备）。2、把鱼钓起来放进鱼篓里（数据拷贝）。无论以上提到的哪种钓鱼方式，在第二步，都是需要人主动去做的，并不是鱼竿自己完成的。所以，这个钓鱼过程其实还是同步进行的。</p>
<p>如果拿烧水这个例子和钓鱼来对比着说：</p>
<p><strong>烧水的报警器一响，整个烧水过程就完成了。水已经是开水了</strong>。 </p>
<p><strong>钓鱼的报警器一响，只能说明鱼儿已经咬钩了，但是还没有真正的钓上来</strong>。</p>
<p>所以 ，使用带有报警器的水壶烧水，<strong>烧水过程是异步的</strong>。</p>
<p>而使用带有报警器的鱼竿钓鱼，<strong>钓鱼的过程还是同步的</strong>。</p>
<h1 id="异步IO模型"><a href="#异步IO模型" class="headerlink" title="异步IO模型"></a>异步IO模型</h1><p>我们钓鱼的时候，采用一种高科技钓鱼竿，即全自动钓鱼竿。可以自动感应鱼上钩，自动收竿，更厉害的可以自动把鱼放进鱼篓里。然后，通知我们鱼已经钓到了，他就继续去钓下一条鱼去了。</p>
<p>映射到Linux操作系统中，这就是异步IO模型。<strong>应用进程把IO请求传给内核后，完全由内核去操作文件拷贝。内核完成相关操作后，会发信号告诉应用进程本次IO已经完成</strong>。</p>
<p>用户进程发起<code>aio_read</code>操作之后，给内核传递描述符、缓冲区指针、缓冲区大小等，告诉内核当整个操作完成时，如何通知进程，然后就立刻去做其他事情了。当内核收到aio_read后，会立刻返回，然后内核开始等待数据准备，数据准备好以后，直接把数据拷贝到用户控件，然后再通知进程本次IO已经完成。</p>
<p>这种方式的钓鱼，无疑是最省事儿的。啥都不需要管，只需要交给鱼竿就可以了。</p>
<h1 id="五种IO模型对比"><a href="#五种IO模型对比" class="headerlink" title="五种IO模型对比"></a>五种IO模型对比</h1><p>五种IO模型如下图：</p>
<p><img src="https://i.loli.net/2020/03/31/D8sA4qMPuxrbvQy.png" alt="五种IO模型对比.png"></p>
<h1 id="select-和-epoll"><a href="#select-和-epoll" class="headerlink" title="select 和 epoll"></a>select 和 epoll</h1>]]></content>
      <categories>
        <category>Interview Note</category>
      </categories>
      <tags>
        <tag>Interview</tag>
        <tag>Java</tag>
        <tag>Linux</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis and Cache</title>
    <url>/2020/03/31/Redis-cache/</url>
    <content><![CDATA[<blockquote>
<p>古之立大事者，不惟有超世之才，亦必有坚韧不拔之志。——苏轼</p>
</blockquote>
<a id="more"></a>

<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>缓存是<strong>高并发</strong>场景下提高热点数据访问性能的一个有效手段，在开发项目时会经常使用到。缓存的类型分为：<strong>本地缓存、分布式缓存和多级缓存</strong>。</p>
<p><strong>本地缓存</strong>就是在<strong>进程的内存中进行缓存</strong>，比如我们的JVM堆中，可以用LRUMap来实现，也可以使用Ehcache这样的工具来实现。本地缓存是内存访问，没有远程交互开销，性能最好，但是受限于单机容量，一般缓存较小且无法扩展。</p>
<p><strong>分布式缓存</strong>可以很好得解决这个问题。分布式缓存一般都具有良好的水平扩展能力，对较大数据量的场景也能应付自如。缺点就是需要进行远程请求，性能不如本地缓存。</p>
<p>为了平衡这种情况，实际业务中一般采用多级缓存，本地缓存只保存访问频率最高的部分热点数据，其他的热点数据放在分布式缓存中。</p>
<p>Redis是非关系型数据库，虽然也是数据库，但是它是保存在内存中的，所以读写速度非常快，经常被用于<strong>缓存</strong>。此外Redis也经常被用于<strong>分布式锁</strong>。</p>
<h2 id="为什么要用缓存"><a href="#为什么要用缓存" class="headerlink" title="为什么要用缓存"></a>为什么要用缓存</h2><p>主要从“高性能”和“高并发”这两点来看待这个问题。</p>
<h3 id="保证高性能"><a href="#保证高性能" class="headerlink" title="保证高性能"></a>保证高性能</h3><p>假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数据缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p>
<p>很常用的一个场景就是电商，一个商品的信息一天之内都不会改变，那么每个用户从数据库中查询都要比如800ms，那么此时如果用缓存，在第一次加载之后把数据放入到缓存中，这样后面其他用户查询的时候直接查缓存即可，性能可以提升非常多。</p>
<h3 id="保证高并发"><a href="#保证高并发" class="headerlink" title="保证高并发"></a>保证高并发</h3><p>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中 去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p>
<p>比如某个商品在中午有大量的访问请求，比如100万个，每秒4000个，MySQL是没办法承接这么大并发访问量的。可以分开访问，让3000个走缓存，剩下的1000个直接访问数据库。</p>
<p>为什么内存可以承受3000个访问量？——内存读写能力很强，别说4000/s，4万/s都可以。但是数据库别超过2000/s。</p>
<h1 id="怎么保证redis是高并发以及高可用的？"><a href="#怎么保证redis是高并发以及高可用的？" class="headerlink" title="怎么保证redis是高并发以及高可用的？"></a>怎么保证redis是高并发以及高可用的？</h1><h2 id="总的回答"><a href="#总的回答" class="headerlink" title="总的回答"></a>总的回答</h2><p><strong>redis高并发</strong>：主从架构，一主多从，一般来说，很多项目其实就足够了，单主用来写入数据，单机几万QPS，多从用来查询数据，多个从实例可以提供每秒10万的QPS。</p>
<p>redis高并发的同时，还需要容纳大量的数据：一主多从，每个实例都容纳了完整的数据，比如redis主就10G的内存量，其实你就最多只能容纳10g的数据量。如果你的缓存要容纳的数据量很大，达到了几十g，甚至几百g，或者是几t，那你就需要redis集群，而且用redis集群之后，可以提供可能每秒几十万的读写并发。</p>
<p><strong>redis高可用</strong>：如果你做主从架构部署，其实就是加上哨兵就可以实现，任何一个实例宕机，自动会进行主备切换。</p>
<h2 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h2><p>经典问题是：<strong>如何保证Redis的高并发和高可用？redis的主从复制原理能介绍一下么？redis的哨兵原理能介绍一下么？</strong></p>
<p>其实问这个问题，主要是考考你，redis单机能承载多高并发？如果单机扛不住如何扩容抗更多的并发？redis会不会挂？既然redis会挂那怎么保证redis是高可用的？</p>
<p>这里先介绍如何保证高可用高并发，<strong>哨兵</strong>放到了Redis章节里面去看。</p>
<p><strong>redis高并发</strong>：主从架构，一主多从，一般来说，很多项目其实就足够了，单主用来写入数据，虽然单机最多只能承载几万QPS(也因此，不能让所有请求一把全都打到单机Redis上)，但是如果用多从用来查询数据，多个从实例可以提供每秒10万+的QPS。所以说，redis不能支持高并发的原因，就两个字：<strong>单机</strong></p>
<p>redis高并发的同时，还需要容纳大量的数据：一主多从，每个实例都容纳了完整的数据，比如redis主就10G的内存量，其实你就最多只能容纳10g的数据量。如果你的缓存要容纳的数据量很大，达到了几十g，甚至几百g，或者是几t，那你就需要redis集群，而且用redis集群之后，可以提供可能每秒几十万的读写并发。</p>
<p><strong>redis高可用</strong>：如果你做主从架构部署，其实就是加上哨兵就可以了，就可以实现，任何一个实例宕机，自动会进行主备切换。</p>
<p>实际上，Redis在使用中经常需要做到读写分离。因为redis缓存读的操作远远比写操作多。多到什么程度？可能写请求也就一秒钟几千，一两千。但是大量的请求都是读，一秒钟二十万次读。</p>
<p>所以要做读写分离，也就是做主从架构，master redis(主)把数据都复制到slave redis(从)上，从而可以支持10万+读QPS。</p>
<p>过程如下图所示：</p>
<p><img src="https://i.loli.net/2020/04/02/vIz3cR4LutWBjAP.png" alt="redis主从实现读写分离支撑10万_的高并发.png"></p>
<p>所有读的操作都走slave redis，写操作才走master redis。这个就是redis的<code>redis replication基本原理</code>，本质就是<strong>复制</strong>数据的操作。</p>
<h2 id="redis-replication核心机制"><a href="#redis-replication核心机制" class="headerlink" title="redis replication核心机制"></a>redis replication核心机制</h2><ol>
<li>redis采用异步方式复制数据到slave节点，不过redis 2.8开始，slave node会周期性地确认自己每次复制的数据量</li>
<li>一个master node可以配置多个slave node</li>
<li>slave node也可以连接其他的slave node</li>
<li>slave node做复制的时候，不会block master node的正常工作</li>
<li>slave node在做复制的时候，也不会block对自己的查询操作，它会用旧的数据集来提供服务; 但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了</li>
<li>slave node主要用来进行横向扩容，做读写分离，扩容的slave node可以提高读的吞吐量</li>
</ol>
<p>需要注意，如果开启了主从架构，那么master必须开启持久化，不建议用slave node作为master node的数据热备，因为那样的话，如果你关掉master的持久化，可能在master宕机重启的时候数据是空的，然后可能一经过复制，salve node数据也丢了。如果master没开持久化，那么重启之后数据拷贝，slave数据也会丢失。</p>
<p>此外，master的各种备份方案，要不要做，万一说本地的所有文件丢失了; 从备份中挑选一份rdb去恢复master; 这样才能确保master启动的时候，是有数据的。</p>
<h3 id="redis-replication的完整流运行程和原理的深入剖析"><a href="#redis-replication的完整流运行程和原理的深入剖析" class="headerlink" title="redis replication的完整流运行程和原理的深入剖析"></a>redis replication的完整流运行程和原理的深入剖析</h3><p>主要对redis replication的复制的完整流程、数据同步相关核心机制、全量复制流程、增量复制流程、heartbeat、异步复制进行介绍。</p>
<h4 id="redis-replication复制完整流程"><a href="#redis-replication复制完整流程" class="headerlink" title="redis replication复制完整流程"></a>redis replication复制完整流程</h4><ol>
<li>slave node启动，仅仅保存master node的信息，包括master node的host和ip，但是复制流程没开始(master host和ip是从哪儿来的？redis.conf里面的slaveof配置的!)</li>
<li>slave node内部有个定时任务，每秒检查是否有新的master node要连接和复制，如果发现，就跟master node建立socket网络连接</li>
<li>slave node发送ping命令给master node</li>
<li>口令认证，如果master设置了requirepass，那么salve node必须发送masterauth的口令过去进行认证</li>
<li>master node第一次执行全量复制，将所有数据发给slave node</li>
<li>master node后续持续将写命令，异步复制给slave node</li>
</ol>
<p><img src="https://i.loli.net/2020/04/02/3uXVSlacFJ1PRAO.png" alt="复制的完整的基本流程.png"></p>
<h4 id="数据同步相关的核心机制"><a href="#数据同步相关的核心机制" class="headerlink" title="数据同步相关的核心机制"></a>数据同步相关的核心机制</h4><p>指的就是第一次slave连接msater的时候，执行的全量复制，那个过程里面你的一些细节的机制</p>
<ol>
<li>master和slave都会维护一个offset</li>
</ol>
<p>master会在自身不断累加offset，slave也会在自身不断累加offset。</p>
<p>slave每秒都会上报自己的offset给master，同时master也会保存每个slave的offset。</p>
<p>这个倒不是说特定就用在全量复制的，主要是master和slave都要知道各自的数据的offset，才能知道互相之间的数据不一致的情况</p>
<ol start="2">
<li>backlog</li>
</ol>
<p>master node有一个backlog，默认是1MB大小</p>
<p>master node给slave node复制数据时，也会将数据在backlog中同步写一份</p>
<p>backlog主要是用来做全量复制中断候的增量复制的</p>
<ol start="3">
<li>master run id</li>
</ol>
<p>通过<code>info server</code>，可以看到master run id。</p>
<p>如果根据host+ip定位master node，是不靠谱的，如果master node重启或者数据出现了变化，那么slave node应该根据不同的run id区分，run id不同就做全量复制。</p>
<p><strong>为什么会不靠谱？</strong></p>
<p>举个例子：</p>
<p>一开始master和slave都有100万条数据，我们现在master数据出了问题，我们想切换回之前版本的数据，那么一般用RDB恢复。RDB可能是20个小时之前的数据，那么此时slave中的数据一开始是和master同步的，而且如果slave也用offset等信息来要求数据同步，那么也是有问题的，需要把已经用RDB回复的数据再全量复制到slave中。</p>
<p>所以，master在使用RDB恢复数据之后，master的run id会变化，此时slave通过检测run id，发现run id变化了，就会触发全量复制，master把数据再复制到slave，这样slave中的数据也是正确的了。</p>
<p>如下图：</p>
<p><img src="https://i.loli.net/2020/04/02/AtoXb4kK1S36yVQ.png" alt="maste run id的作用.png"></p>
<p>如果需要不更改run id重启redis，可以使用redis-cli debug reload命令</p>
<ol start="4">
<li>psync</li>
</ol>
<p>从节点使用psync从master node进行复制，psync runid offset</p>
<p>master node会根据自身的情况返回响应信息，可能是FULLRESYNC runid offset触发全量复制，可能是CONTINUE触发增量复制</p>
<h4 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h4><p>当master node想要把数据全部复制给slave，那么进行全量复制。</p>
<ol>
<li>master执行<code>bgsave</code>，在本地生成一份rdb快照文件</li>
<li>master node将rdb快照文件发送给salve node，如果rdb复制时间超过60秒（<code>repl-timeout</code>），那么slave node就会认为复制失败，可以适当调节大这个参数</li>
<li>对于千兆网卡的机器，一般每秒传输100MB，6G文件，很可能超过60s</li>
<li>master node在生成rdb时，会将所有新的写命令缓存在内存中，在salve node保存了rdb之后，再将新的写命令复制给salve node</li>
<li><code>client-output-buffer-limit slave</code> 256MB 64MB 60，如果在复制期间，内存缓冲区持续消耗超过64MB，或者一次性超过256MB，那么停止复制，复制失败</li>
<li>slave node接收到rdb之后，清空自己的旧数据，然后重新加载rdb到自己的内存中，同时基于旧的数据版本对外提供服务</li>
<li>如果slave node开启了AOF，那么会立即执行BGREWRITEAOF，重写AOF</li>
</ol>
<p>rdb生成、rdb通过网络拷贝、slave旧数据的清理、slave aof rewrite，很耗费时间</p>
<p>如果复制的数据量在4G~6G之间，那么很可能全量复制时间消耗到1分半到2分钟</p>
<h4 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h4><ol>
<li>如果全量复制过程中，master-slave网络连接断掉，那么salve重新连接master时，会触发增量复制</li>
<li>master直接从自己的backlog中获取部分丢失的数据，发送给slave node，默认backlog就是1MB</li>
<li>msater就是根据slave发送的psync中的offset来从backlog中获取数据的</li>
</ol>
<h4 id="heartbeat"><a href="#heartbeat" class="headerlink" title="heartbeat"></a>heartbeat</h4><p>主从节点互相都会发送heartbeat信息</p>
<p>master默认每隔10秒发送一次heartbeat，salve node每隔1秒发送一个heartbeat</p>
<h4 id="异步复制"><a href="#异步复制" class="headerlink" title="异步复制"></a>异步复制</h4><p>master每次接收到写命令之后，现在内部写入数据，然后异步发送给slave node</p>
<h2 id="redis主从复制原理、断点续传、无磁盘化复制、过期key处理"><a href="#redis主从复制原理、断点续传、无磁盘化复制、过期key处理" class="headerlink" title="redis主从复制原理、断点续传、无磁盘化复制、过期key处理"></a>redis主从复制原理、断点续传、无磁盘化复制、过期key处理</h2><h3 id="主从复制原理和步骤"><a href="#主从复制原理和步骤" class="headerlink" title="主从复制原理和步骤"></a>主从复制原理和步骤</h3><p>当启动一个slave node的时候，它会发送一个Ping命令给master node看看两者能不能互通。</p>
<p>如果这是slave node重新连接master node，那么master node仅仅会复制给slave部分缺少的数据; 否则如果是slave node第一次连接master node，那么会触发一次full resynchronization(全量复制)</p>
<p>开始full resynchronization的时候，master会启动一个后台线程，开始生成一份RDB快照文件，同时还会将从客户端收到的所有写命令缓存在内存中。RDB文件生成完毕之后，master会将这个RDB发送给slave，slave会先写入本地磁盘，然后再从本地磁盘加载到内存中。然后master会将内存中缓存的写命令发送给slave，slave也会同步这些数据。</p>
<p>slave node如果跟master node有网络故障，断开了连接，会自动重连。master如果发现有多个slave node都来重新连接，仅仅会启动一个rdb save操作，用一份数据服务所有slave node。</p>
<p>如下图所示：</p>
<p><img src="https://i.loli.net/2020/04/02/286CfTvWxjnLmws.png" alt="redis主从复制的原理.png"></p>
<h3 id="主从复制断点续传"><a href="#主从复制断点续传" class="headerlink" title="主从复制断点续传"></a>主从复制断点续传</h3><p>从redis 2.8开始，就支持主从复制的断点续传，如果主从复制过程中，网络连接断掉了，那么可以接着上次复制的地方，继续复制下去，而不是从头开始复制一份</p>
<p>master node会在内存中常见一个backlog，master和slave都会保存一个replica offset还有一个master id，offset就是保存在backlog中的。如果master和slave网络连接断掉了，slave会让master从上次的replica offset开始继续复制</p>
<p>但是如果没有找到对应的offset，那么就会执行一次resynchronization。</p>
<h3 id="无磁盘化复制"><a href="#无磁盘化复制" class="headerlink" title="无磁盘化复制"></a>无磁盘化复制</h3><p>master在内存中直接创建rdb，然后发送给slave，不会在自己本地落地磁盘了</p>
<p>repl-diskless-sync<br>repl-diskless-sync-delay，等待一定时长再开始复制，因为要等更多slave重新连接过来</p>
<h3 id="过期key处理"><a href="#过期key处理" class="headerlink" title="过期key处理"></a>过期key处理</h3><p>slave不会过期key，只会等待master过期key。如果master过期了一个key，或者通过LRU淘汰了一个key，那么会模拟一条del命令发送给slave。</p>
<h2 id="redis主从架构下如何才能做到99-99-的高可用性？"><a href="#redis主从架构下如何才能做到99-99-的高可用性？" class="headerlink" title="redis主从架构下如何才能做到99.99%的高可用性？"></a>redis主从架构下如何才能做到99.99%的高可用性？</h2><h3 id="不可用的系统"><a href="#不可用的系统" class="headerlink" title="不可用的系统"></a>不可用的系统</h3><p>正常情况，用户访问我们的系统(比如是电商系统)，没问题。</p>
<p>但是可能会出现的情况是：后台系统宕机了、或者JVM进程OOM了、或者CPU打满了，不工作了、系统磁盘塞满了……<strong>总之导致系统挂掉了，不能提供服务了，那么这时候如果只抢修机器，这段时间系统没法访问，会造成巨大损失</strong>。——这是不可用的系统。</p>
<h3 id="可用系统"><a href="#可用系统" class="headerlink" title="可用系统"></a>可用系统</h3><p>和上面一样，系统崩了，但是如果我们系统设计的比较好，可以做到快速的主从切换。</p>
<p>一个基于哨兵的高可用性系统如下图所示：</p>
<p><img src="https://i.loli.net/2020/04/03/mA6Gjp57lD2YWHX.png" alt="redis基于哨兵的高可用性.png"></p>
<p>注意这里的哨兵sentinal node，监控master有没有挂掉。</p>
<p>有关哨兵sentinal 到后面详细讲解。</p>
<p>这样我们的系统不可用的时间能够大大缩短。</p>
<h3 id="99-99-可用？-高可用"><a href="#99-99-可用？-高可用" class="headerlink" title="99.99%可用？(高可用)"></a>99.99%可用？(高可用)</h3><p>实际上这个道理理解起来很简单，如果我们的系统能够保证全年<strong>99.99%</strong>的时间都是可用的，我们的系统就是有高可用性的。与之对比的是，如果这个时间只有<strong>80%</strong>左右，那么这会是一个低可用的系统。</p>
<h3 id="不可用系统"><a href="#不可用系统" class="headerlink" title="不可用系统"></a>不可用系统</h3><p>我们已经做了读写分离，读操作都交给了slave节点。当slave挂掉的时候，不会影响整个的可用性，还有其他的slave在提供相同数据下的相同的对外查询服务。</p>
<p>但是如果master挂掉了，就没法写数据了！或者说，master挂掉了，整个系统就相当于不可用了，缓存不能用了，大量访问会涌入到mysql中。</p>
<p><img src="https://i.loli.net/2020/04/03/jXU6ypAv9DRcFrY.png" alt="redis的不可用.png"></p>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p>首先来看Redis相关知识图谱：</p>
<p><img src="https://i.loli.net/2020/03/31/jHm7KrIlEhioawx.png" alt="Redis相关问题图谱.png"></p>
<h2 id="Redis为什么快？"><a href="#Redis为什么快？" class="headerlink" title="Redis为什么快？"></a>Redis为什么快？</h2><p>三点原因：</p>
<ol>
<li>采用了多路复用io阻塞机制</li>
<li>数据结构简单，操作节省时间</li>
<li>运行在内存中，速度当然快</li>
</ol>
<h2 id="为什么Redis用单线程还能很快"><a href="#为什么Redis用单线程还能很快" class="headerlink" title="为什么Redis用单线程还能很快"></a>为什么Redis用单线程还能很快</h2><p>单线程的Redis在瓶颈是cpu的io时（这不是大多数应用的实际应用场景），确实速度会比多线程慢。但是，我们实际应用场景中很少会遇到瓶颈是CPU的io的情况，这时候单线程优势就凸显出来了。</p>
<p>实现很简单！性能又不会比多线程差，并且，单线程确实不用处理上下文的切换，cpu利用率会比多线程高，这时候采用单线程实现是一种很划算的做法。</p>
<h2 id="为什么要用-redis-而不用-map-guava-做缓存"><a href="#为什么要用-redis-而不用-map-guava-做缓存" class="headerlink" title="为什么要用 redis 而不用 map/guava 做缓存?"></a>为什么要用 redis 而不用 map/guava 做缓存?</h2><p>之前有提到，缓存实际上分为本地缓存和分布式缓存两种。Redis属于分布式缓存，那么本地缓存如果能解决问题，为什么要用分布式缓存呢？——答案很明显，本地缓存不够用。下面分析一下。</p>
<p>以 Java 为例，使用自带的 LRUMap 或者 guava 实现的是本地缓存，主要的特点是 轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。</p>
<p>使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致 性。缺点是需要保持 redis 或 memcached服务的高可用，整个程序架构上较为复杂。 </p>
<h2 id="Redis的功能总结"><a href="#Redis的功能总结" class="headerlink" title="Redis的功能总结"></a>Redis的功能总结</h2><p>Bitmap位图是支持按bit位来存储信息，可以用来实现BloomFilter；HyperLogLog提供不精确的去重计数功能，比较适合用来做大规模数据的去重统计，例如统计UV；Geospatial 可以用来保存地理位置，并作位置距离计算或者根据半径计算位置等。这三个其实也可以算作一种数据结构。</p>
<p>pub/sub 功能是订阅发布功能，可以用作简单的消息队列。</p>
<p>Pipeline可以批量执行一组指令，一次性返回全部结果，可以减少频繁的请求应答。</p>
<p>Redis 支持提交 Lua 脚本来执行一系列的功能。</p>
<p>最后一个功能是事务，但 Redis 提供的不是严格的事务，Redis 只保证串行执行命令，并且能保证全部执行，但是执行命令失败时并不会回滚，而是会继续执行下去。</p>
<h2 id="Redis和memcached的区别"><a href="#Redis和memcached的区别" class="headerlink" title="Redis和memcached的区别"></a>Redis和memcached的区别</h2><p>现在公司一般都用Redis实现缓存，因为Redis的优势更多也更实用。</p>
<p>主要有四点：</p>
<ol>
<li><strong>redis支持更丰富的数据类型（支持更复杂的应用场景）</strong>：Redis不仅仅支持简单的k/v类型的数据，同时还提供 list，set，zset，hash等数据结构的存储。memcache支持简单的数据类型，String。 </li>
<li><strong>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memecache把数据全部存在内存之中</strong>。所以Redis不仅仅可以用作缓存，也可以用做NoSQL数据库。</li>
<li><strong>集群模式</strong>：memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 redis 目前是原生支持 cluster 模式的. </li>
<li><strong>Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的多路 IO 复用模型</strong>。这样做的原因有2个：一个是因为采用了异步非阻塞的事件处理机制；另一个是缓存数据都是内存操作，IO时间不会太长，单线程可以避免上下文切换产生的代价。</li>
</ol>
<p>其他区别可以参考这张表格：</p>
<p><img src="https://i.loli.net/2020/03/31/yU4deTfWuItC7NG.png" alt="Redis和memcache区别.png"></p>
<h2 id="redis常见数据结构以及使用场景分析"><a href="#redis常见数据结构以及使用场景分析" class="headerlink" title="redis常见数据结构以及使用场景分析"></a>redis常见数据结构以及使用场景分析</h2><h3 id="1-String"><a href="#1-String" class="headerlink" title="1.String"></a>1.String</h3><blockquote>
<p><strong>常用命令</strong>：set,get,decr,incr,mget等</p>
</blockquote>
<p>string类型是Redis中最常使用的类型，内部的实现是通过SDS（SimpleDynamicString）来存储的。SDS类似于Java中的ArrayList，可以通过预分配冗余空间的方式来减少内存的频繁分配。</p>
<p>String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。 常规key-value缓存应用； 常规计数：微博数，粉丝数等。</p>
<p>String最大可以存储512M，它是线程安全的，所以可以包含任何内容(比如jpg格式图片，序列化对象等)</p>
<p>Redis有原子性，让我们不用考虑并发。比如记录某网站用户访问次数，web只需要拼接用户id和当前日期，两者一起作为key。每次用户访问它的时候执行incr即可。</p>
<h3 id="2-Hash"><a href="#2-Hash" class="headerlink" title="2.Hash"></a>2.Hash</h3><blockquote>
<p>常用命令： hget,hset,hgetall 等。</p>
</blockquote>
<p>hash类型在Redis中有ziplist和hashtable两种实现。当Hash表中所有的key和value字符串长度都小于64字节且键值对数量小于512个时，使用压缩表来节省空间；超过时，转为使用hashtable</p>
<p>Hash 是一个 string 类型的 ﬁeld 和 value 的映射表，<strong>hash 特别适合用于存储对象</strong>，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以Hash数据结构来存储用户信息，商品信息等等。</p>
<p>比如下面我就用 hash 类型存放了我本人的一些信息：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">key = JavaUser666666</span><br><span class="line">value = &#123;</span><br><span class="line">	<span class="string">"id"</span> : 1,</span><br><span class="line">	<span class="string">"name"</span> : <span class="string">"Bennett"</span>,</span><br><span class="line">	<span class="string">"age"</span> : 66,</span><br><span class="line">	<span class="string">"location"</span> : <span class="string">"HongKong"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个hash可以存储多个组的键值对。实际中我们常用JSON文件存储用户信息，所以用hash存储JSON文件再合适不过了！</p>
<h3 id="3-List"><a href="#3-List" class="headerlink" title="3.List"></a>3.List</h3><blockquote>
<p>常用命令: lpush,rpush,lpop,rpop,lrange等</p>
</blockquote>
<p><strong>list 就是链表</strong>，Redis list 的应用场景非常多，也是Redis重要的数据结构之一，比如微博的关注列表，粉丝列表， 消息列表等功能都可以用Redis的 list 结构来实现。 </p>
<p>Redis list 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。有ziplist压缩列表和linkedlist双链表实现。ziplist是存储在一段连续的内存上，存储效率高，但是它不利于修改操作，适用于数据较少的情况；linkedlist在插入节点上复杂度很低，但它的内存开销很大，每个节点的地址不连续，容易产生内存碎片。此外在3.2版本后增加了quicklist，结合了两者的优点，quicklist本身是一个双向无环链表，它的每一个节点都是一个ziplist。</p>
<p>另外可以通过 lrange 命令，就是从某个元素开始读取多少个元素，可以基于 list 实现分页查询，这个很棒的一个功 能，基于 redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西（一页一页的往下走），性能高。 </p>
<p>在实践中可以看到，list的插入顺序实际上是类似栈的，后进先出。所以<strong>list可以轻松实现新闻更新、排行更新等功能</strong></p>
<h3 id="4-Set"><a href="#4-Set" class="headerlink" title="4.Set"></a>4.Set</h3><blockquote>
<p>常用命令： sadd,spop,smembers,sunion 等</p>
</blockquote>
<p>set 类型的内部实现可以是 intset 或者 hashtable，当集合中元素小于 512 且所有的数据都是数值类型时，才会使用 intset，否则会使用 hashtable。</p>
<p>set 对外提供的功能与list类似是一个列表的功能，特殊之处在于 <strong>set 是可以自动排重的</strong>。</p>
<p>当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在 一个set集合内的重要接口，这个也是list所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。 </p>
<p>比如：在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程，具体命令如下：</p>
<p><code>sinterstore key1 key2 key3     将交集存在key1内</code></p>
<p>如果向Set中插入重复的元素，会返回0，插入失败。而且插入多个元素之后我们会发现set是无序的。</p>
<h3 id="5-Sorted-Set"><a href="#5-Sorted-Set" class="headerlink" title="5.Sorted Set"></a>5.Sorted Set</h3><blockquote>
<p>常用命令： zadd,zrange,zrem,zcard等</p>
</blockquote>
<p>sortedset是有序集合，有序集合的实现可以是ziplist或者是skiplist跳表。有序集合的编码转换条件与hash和list有些不同，当有序集合中元素数量小于128个并且所有元素长度都小于 64 字节时会使用 ziplist，否则会转换成 skiplist。</p>
<p>和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。</p>
<p><strong>举例</strong>： 在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维 度的消息排行榜）等信息，适合使用 Redis 中的 SortedSet 结构进行存储。 </p>
<h2 id="redis设置过期时间-redis的过期策略"><a href="#redis设置过期时间-redis的过期策略" class="headerlink" title="redis设置过期时间(redis的过期策略)"></a>redis设置过期时间(redis的过期策略)</h2><p>碰到这个问题，简而言之的回答，就是围绕两点：<strong>定期删除+惰性删除。</strong></p>
<h3 id="我往Redis里写的数据怎么没了？"><a href="#我往Redis里写的数据怎么没了？" class="headerlink" title="我往Redis里写的数据怎么没了？"></a>我往Redis里写的数据怎么没了？</h3><p>缓存是基于内存的，大小是有限的，如果存储容量太大了，redis会把多余的干掉。类似，redis中可以设置数据的过期时间。</p>
<h3 id="我的数据明明已经过期了，为什么还占着内存？"><a href="#我的数据明明已经过期了，为什么还占着内存？" class="headerlink" title="我的数据明明已经过期了，为什么还占着内存？"></a>我的数据明明已经过期了，为什么还占着内存？</h3><p>原因：<strong>Redis的过期策略删除方式是定期删除和惰性删除相结合的</strong>，你设置的过期的Redis没有被Redis的过期策略删除掉，只有系统再次扫描的时候才会将其删除。</p>
<p>Redis中有个设置时间过期的功能，即对存储在 redis 数据库中的值可以设置一个过期时间。作为一个缓存数据库， 这是非常实用的。如我们一般项目中的 token 或者一些登录信息，尤其是短信验证码都是有时间限制的，按照传统 的数据库处理方式，一般都是自己判断过期，这样无疑会严重影响项目性能。<br>我们 set key 的时候，都可以给一个 expire time，就是过期时间，通过过期时间我们可以指定这个 key 可以存活的时间。</p>
<p>如果假设你设置了一批 key 只能存活1个小时，那么接下来1小时后，redis是怎么对这批key进行删除的？</p>
<p><strong>定期删除+惰性删除。</strong></p>
<p>通过名字大概就能猜出这两个删除方式的意思了。</p>
<ul>
<li><p><strong>定期删除</strong>：redis默认是每隔 100ms 就<strong>随机抽取</strong>一些设置了过期时间的key，检查其是否过期，如果过期就删 除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 redis 存了几十万个 key ，每隔100ms就遍历所 有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！</p>
</li>
<li><p><strong>惰性删除</strong>：定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被redis给删除掉。这是在<strong>访问时触发被动删除</strong>。这就是所谓的惰性删除，也是够懒的哈！</p>
</li>
</ul>
<p>但是仅仅通过设置过期时间还是有问题的。我们想一下：如果定期删除漏掉了很多过期 key，然后你也没及时去查， 也就没走惰性删除，此时会怎么样？如果大量过期key堆积在内存里，导致redis内存块耗尽了。怎么解决这个问题呢？</p>
<p>使用<strong>redis 内存淘汰机制</strong>。</p>
<h2 id="redis内存淘汰机制"><a href="#redis内存淘汰机制" class="headerlink" title="redis内存淘汰机制"></a>redis内存淘汰机制</h2><p><strong>如果redis的内存占用过多，那么之后会进行内存淘汰机制来让其他数据可以进入到redis中</strong>。下面介绍一下redis的淘汰机制。</p>
<p>提示：Redis的内存分配是使用jemalloc进行分配。jemalloc将内存空间划分为小、大、巨大三个范围，并在范围中划分了小的内存块，当存储数据时，选择大小最合适的内存块进行分配，有利于减小内存碎片。</p>
<p>一个问题：<strong>MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据？</strong></p>
<h3 id="redis-提供-6种数据淘汰策略："><a href="#redis-提供-6种数据淘汰策略：" class="headerlink" title="redis 提供 6种数据淘汰策略："></a>redis 提供 6种数据淘汰策略：</h3><ol>
<li>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选近少使用的数据淘汰 </li>
<li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰 </li>
<li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰 </li>
<li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除近少使用的key（这个是常用的）. </li>
<li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰 </li>
<li>no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li>
</ol>
<h2 id="Redis保证高可用的重要组件——哨兵"><a href="#Redis保证高可用的重要组件——哨兵" class="headerlink" title="Redis保证高可用的重要组件——哨兵"></a>Redis保证高可用的重要组件——哨兵</h2><h3 id="哨兵基本概念"><a href="#哨兵基本概念" class="headerlink" title="哨兵基本概念"></a>哨兵基本概念</h3><p>sentinal，即哨兵。</p>
<p>哨兵是redis集群架构中非常重要的一个组件，主要功能如下</p>
<ol>
<li><strong>集群监控</strong>，负责监控redis master和slave进程是否正常工作</li>
<li><strong>消息通知</strong>，如果某个redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员</li>
<li><strong>故障转移</strong>，如果master node挂掉了，会自动转移到slave node上</li>
<li><strong>配置中心</strong>，如果故障转移发生了，通知client客户端新的master地址</li>
</ol>
<p>哨兵本身也是分布式的，作为<strong>一个哨兵集群</strong>去运行，互相协同工作</p>
<ol>
<li>故障转移时，判断一个master node是宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举的问题</li>
<li>即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的，因为如果一个作为高可用机制重要组成部分的故障转移系统本身是单点的，那就很坑爹了</li>
</ol>
<p>目前采用的是sentinal 2版本，sentinal 2相对于sentinal 1来说，重写了很多代码，主要是让故障转移的机制和算法变得更加健壮和简单</p>
<h3 id="哨兵核心知识"><a href="#哨兵核心知识" class="headerlink" title="哨兵核心知识"></a>哨兵核心知识</h3><ol>
<li>哨兵至少需要3个实例，来保证自己的健壮性</li>
<li>哨兵 + redis主从的部署架构，是不会保证数据零丢失的，只能保证redis集群的高可用性</li>
<li>对于哨兵 + redis主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练</li>
</ol>
<h3 id="为什么哨兵集群只有2个节点无法正常工作？"><a href="#为什么哨兵集群只有2个节点无法正常工作？" class="headerlink" title="为什么哨兵集群只有2个节点无法正常工作？"></a>为什么哨兵集群只有2个节点无法正常工作？</h3><p>如题，在实际中，哨兵集群必须部署2个以上的节点才可以。下面进行分析：</p>
<p>如果哨兵集群仅仅部署了个2个哨兵实例，quorum=1。下图有一个Master(M1),一个Slave(R1)</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">+----+         +----+</span><br><span class="line">|<span class="string"> M1 </span>|<span class="string">---------</span>|<span class="string"> R1 </span>|</span><br><span class="line">|<span class="string"> S1 </span>|<span class="string">         </span>|<span class="string"> S2 </span>|</span><br><span class="line">+----+         +----+</span><br></pre></td></tr></table></figure>

<p>Configuration: quorum = 1</p>
<p>master宕机，s1和s2中只要有1个哨兵认为master宕机就可以进行切换，同时s1和s2中会选举出一个哨兵来执行故障转移.</p>
<p>如果这个时候，只有master(M1)挂掉了，2个哨兵的majority就是2（2的majority=2，3的majority=2，5的majority=3，4的majority=2），2个哨兵都运行着，就可以允许执行故障转移</p>
<p>但是如果整个M1和S1运行的机器宕机了，那么哨兵只有1个了，此时就没有majority来允许执行故障转移，虽然另外一台机器还有一个R1，但是故障转移不会执行</p>
<p><strong>看一下经典的3节点哨兵集群</strong></p>
<pre><code>       +----+
       | M1 |
       | S1 |
       +----+
|+----+   |   +----+
| R2 |----+----| R3 |
| S2 |         | S3 |
+----+         +----+</code></pre><p>Configuration: quorum = 2，majority</p>
<p>如果M1所在机器宕机了，那么三个哨兵还剩下2个，S2和S3可以一致认为master宕机，然后选举出一个来执行故障转移</p>
<p>同时3个哨兵的majority是2，所以还剩下的2个哨兵运行着，就可以允许执行故障转移</p>
<h3 id="redis哨兵主备切换的数据丢失问题：异步复制、集群脑裂"><a href="#redis哨兵主备切换的数据丢失问题：异步复制、集群脑裂" class="headerlink" title="redis哨兵主备切换的数据丢失问题：异步复制、集群脑裂"></a>redis哨兵主备切换的数据丢失问题：异步复制、集群脑裂</h3><p>这小节主要解决<strong>两个问题：1、两种数据丢失的情况；2、解决异步复制和脑裂导致的数据丢失</strong></p>
<p>Q：为什么会出现数据丢失？</p>
<p>A：<strong>一共有两种情况可能导致数据丢失</strong>：<font color=#FF0000><strong>异步复制</strong></font> 和 <font color=#FF0000><strong>集群脑裂</strong></font>。</p>
<p><strong>异步复制</strong>：在Client往Master node写数据之后，只要master自己没问题，它就会返回值给Client，然后异步把新写的数据同步给slave node。但是因为主从之间数据复制是异步的，所以可能master没有来得及把数据复制给slave node，master就挂了，那么数据本身还是在master上的。此时哨兵监测到了master挂了，把slave提升成master node，后面读写都基于这个新的master node。但是这样就使得新的master node没有之前丢失的数据。</p>
<p>具体过程如下图：</p>
<p><img src="https://i.loli.net/2020/04/04/3HopGCk7jRUBmzi.png" alt="异步复制导致的数据丢失问题.png"></p>
<p><strong>集群脑裂</strong>：整个集群中还是只有一个master node。本来正常运行的系统因为网络故障而形成了<strong>网络分区</strong>，导致哨兵访问不到master，以为master挂了，则把slave node提升成了master。但是原本的master其实没有挂掉，这就导致了有两个master，搞成了多个数据节点，形成了脑裂。而且可能client只能和master连接从而一段时间之内还只往master里面写数据。而当我们要做恢复的时候，把master切换成了slave，会把新的master(原先是slave)节点的数据拷贝过去，导致master原本的数据也丢了。</p>
<p>如下图：</p>
<p><img src="https://i.loli.net/2020/04/04/pHt8zjIYUO4fJFA.png" alt="集群脑裂导致的数据丢失问题.png"></p>
<p>具体文字如下：</p>
<h4 id="1、两种数据丢失的情况"><a href="#1、两种数据丢失的情况" class="headerlink" title="1、两种数据丢失的情况"></a>1、两种数据丢失的情况</h4><p>主备切换的过程，可能会导致数据丢失</p>
<ul>
<li>异步复制导致的数据丢失</li>
</ul>
<p>因为master -&gt; slave的复制是异步的，所以可能有部分数据还没复制到slave，master就宕机了，此时这些部分数据就丢失了</p>
<ul>
<li>脑裂导致的数据丢失</li>
</ul>
<p>脑裂，也就是说，某个master所在机器突然脱离了正常的网络，跟其他slave机器不能连接，但是实际上master还运行着</p>
<p>此时哨兵可能就会认为master宕机了，然后开启选举，将其他slave切换成了master</p>
<p>这个时候，集群里就会有两个master，也就是所谓的脑裂</p>
<p>此时虽然某个slave被切换成了master，但是可能client还没来得及切换到新的master，还继续写向旧master的数据可能也丢失了</p>
<p>因此旧master再次恢复的时候，会被作为一个slave挂到新的master上去，自己的数据会清空，重新从新的master复制数据</p>
<h4 id="2、解决异步复制和脑裂导致的数据丢失"><a href="#2、解决异步复制和脑裂导致的数据丢失" class="headerlink" title="2、解决异步复制和脑裂导致的数据丢失"></a>2、解决异步复制和脑裂导致的数据丢失</h4><p>用两个参数解决：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="built_in">min</span>-slaves-<span class="built_in">to</span>-<span class="built_in">write</span> <span class="number">1</span></span><br><span class="line"><span class="built_in">min</span>-slaves-<span class="built_in">max</span>-lag <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p><strong>要求至少有1个slave，数据复制和同步的延迟不能超过10秒</strong></p>
<p>如果说一旦所有的slave，数据复制和同步的延迟都超过了10秒钟，那么这个时候，master就不会再接收任何请求了</p>
<p>上面两个配置可以减少异步复制和脑裂导致的数据丢失</p>
<ul>
<li>减少异步复制的数据丢失</li>
</ul>
<p>有了min-slaves-max-lag这个配置，就可以确保说，一旦slave复制数据和ack延时太长，就认为可能master宕机后损失的数据太多了，那么就拒绝写请求，这样可以把master宕机时由于部分数据未同步到slave导致的数据丢失降低的可控范围内</p>
<p>如下图所示：</p>
<p><img src="https://i.loli.net/2020/04/04/XoAhKVFzWSafOe5.png" alt="异步复制导致数据丢失如何降低损失.png"></p>
<ul>
<li>减少脑裂的数据丢失</li>
</ul>
<p>如果一个master出现了脑裂，跟其他slave丢了连接，那么上面两个配置可以确保说，如果不能继续给指定数量的slave发送数据，而且slave超过10秒没有给自己ack消息，那么就直接拒绝客户端的写请求</p>
<p>这样脑裂后的旧master就不会接受client的新数据，也就避免了数据丢失</p>
<p>上面的配置就确保了，如果跟任何一个slave丢了连接，在10秒后发现没有slave给自己ack，那么就拒绝新的写请求</p>
<p>因此在脑裂场景下，最多就丢失10秒的数据</p>
<p>如下图所示：</p>
<p><img src="https://i.loli.net/2020/04/04/TQ7Vp4whzxF6Byl.png" alt="脑裂导致数据丢失的问题如何降低损失.png"></p>
<h3 id="redis哨兵的多个核心底层原理的深入解析（包含slave选举算法）"><a href="#redis哨兵的多个核心底层原理的深入解析（包含slave选举算法）" class="headerlink" title="redis哨兵的多个核心底层原理的深入解析（包含slave选举算法）"></a>redis哨兵的多个核心底层原理的深入解析（包含slave选举算法）</h3><h4 id="sdown和odown转换机制"><a href="#sdown和odown转换机制" class="headerlink" title="sdown和odown转换机制"></a>sdown和odown转换机制</h4><p>哨兵需要判断master有没有宕机，master一般会有两种宕机状态：主管宕机(sdown)和客观宕机(odown)。</p>
<p>sdown是主观宕机，就一个哨兵如果自己觉得一个master宕机了，那么就是主观宕机</p>
<p>odown是客观宕机，如果quorum数量的哨兵都觉得一个master宕机了，那么就是客观宕机</p>
<p>sdown达成的条件很简单，如果一个哨兵ping一个master，超过了<code>is-master-down-after-milliseconds</code>(在哨兵的配置文件中配置的)指定的毫秒数之后，就主观认为master宕机</p>
<p><strong>sdown到odown转换的条件</strong>很简单，如果一个哨兵在指定时间内，收到了quorum指定数量的其他哨兵也认为那个master是sdown了，那么就认为是odown了，客观认为master宕机</p>
<h4 id="哨兵和slave集群的自动发现机制"><a href="#哨兵和slave集群的自动发现机制" class="headerlink" title="哨兵和slave集群的自动发现机制"></a>哨兵和slave集群的自动发现机制</h4><p>哨兵互相之间的发现，是通过redis的pub/sub系统（消息发布和订阅系统）实现的，每个哨兵都会往<code>__sentinel__:hello</code>这个channel里发送一个消息，其他哨兵都会定时查看(或者说消费)这个channel里的消息，所以当某个哨兵发生变化的时候，其他哨兵都可以很快感知到这个变化。</p>
<p>每隔<strong>两秒钟</strong>，每个哨兵都会往自己监控的某个master+slaves对应的<code>__sentinel__:hello</code> channel里发送一个消息，内容是自己的host、ip和run id还有对这个master的监控配置</p>
<p>每个哨兵也会去监听自己监控的每个master+slaves对应的<code>__sentinel__:hello</code> channel，然后去感知到同样在监听这个master+slaves的其他哨兵的存在，也是通过这个途径，各个哨兵之间会交换对master的监控配置，互相进行监控配置的同步。</p>
<h4 id="slave配置的自动纠正"><a href="#slave配置的自动纠正" class="headerlink" title="slave配置的自动纠正"></a>slave配置的自动纠正</h4><p>哨兵会负责自动纠正slave的一些配置，比如slave如果要成为潜在的master候选人，哨兵会确保slave在复制现有master的数据; 如果slave连接到了一个错误的master上，比如故障转移之后，那么哨兵会确保它们连接到正确的master上。</p>
<h4 id="slave-gt-master的选举算法-重要"><a href="#slave-gt-master的选举算法-重要" class="headerlink" title="slave-&gt;master的选举算法(重要)"></a>slave-&gt;master的选举算法(重要)</h4><p>很多时候为了保证系统仍然可用，需要在master挂掉的情况下把slave提为master，而slave节点经常有很多，这就涉及到了具体选哪一个slave作为新的master的问题了。</p>
<p>在选举的具体过程中，会考虑slave的一些信息：</p>
<ol>
<li>跟master断开连接的时长</li>
<li>slave优先级</li>
<li>复制offset</li>
<li>run id</li>
</ol>
<p>如果一个slave跟master断开连接已经超过了<code>down-after-milliseconds</code>的10倍，外加master宕机的时长，那么slave就被认为不适合选举为master(这一步可以认为相当于先做一个过滤)</p>
<p>计算公式：</p>
<p><code>(down-after-milliseconds * 10) + milliseconds_since_master_is_in_SDOWN_state</code></p>
<p>接下来会对slave进行排序</p>
<ol>
<li>按照slave优先级进行排序，<code>slave priority</code>(这其实也是一个配置项，默认值是100)越低，优先级就越高</li>
<li>如果slave priority相同，那么看replica offset(当前slave复制了master的数据量)，哪个slave复制了越多的数据，offset越靠后，优先级就越高</li>
<li>如果上面两个条件都相同，那么选择一个run id比较小的那个slave</li>
</ol>
<h4 id="quorum和majority"><a href="#quorum和majority" class="headerlink" title="quorum和majority"></a>quorum和majority</h4><p>每次一个哨兵要做主备切换，首先需要quorum数量的哨兵都认为了sdown，然后才可以转换成odown，然后选举出一个哨兵来做切换，这个哨兵还得得到majority哨兵的授权，才能正式执行切换</p>
<p>如果quorum &lt; majority，比如5个哨兵，majority就是3，quorum设置为2，那么就3个哨兵授权就可以执行切换</p>
<p>但是如果quorum &gt;= majority，那么必须quorum数量的哨兵都授权，比如5个哨兵，quorum是5，那么必须5个哨兵都同意授权，才能执行切换</p>
<h4 id="configuration-epoch"><a href="#configuration-epoch" class="headerlink" title="configuration epoch"></a>configuration epoch</h4><p>其实是指配置的版本号。哨兵会对一套redis master+slave进行监控，有相应的监控的配置。</p>
<p>执行切换的那个哨兵，会从要切换到的新master（salve-&gt;master）那里得到一个configuration epoch，这就是一个version号，每次切换的version号都必须是唯一的</p>
<p>如果第一个选举出的哨兵切换失败了，那么其他哨兵，会等待failover-timeout时间，然后接替继续执行切换，此时会重新获取一个新的configuration epoch，作为新的version号</p>
<h4 id="configuration传播"><a href="#configuration传播" class="headerlink" title="configuration传播"></a>configuration传播</h4><p>哨兵完成切换之后，会在自己本地更新生成最新的master配置，然后同步给其他的哨兵，就是通过之前说的pub/sub消息机制</p>
<p>这里之前的version号就很重要了，因为各种消息都是通过一个channel去发布和监听的，所以一个哨兵完成一次新的切换之后，新的master配置是跟着新的version号的</p>
<p>其他的哨兵都是根据版本号的大小来更新自己的master配置的，<strong>只要作用就是在故障切换之前要拿到master相关的配置的版本号，切换之后要根据版本号把最新的配置传播给其他的哨兵</strong>。</p>
<h2 id="Redis持久化-怎么保证redis挂掉之后再重启数据可以进行恢复"><a href="#Redis持久化-怎么保证redis挂掉之后再重启数据可以进行恢复" class="headerlink" title="Redis持久化(怎么保证redis挂掉之后再重启数据可以进行恢复)"></a>Redis持久化(怎么保证redis挂掉之后再重启数据可以进行恢复)</h2><p>Redis不同于Memcached的很重一点就是，Redis支持持久化，而且支持两种不同的持久化操作。</p>
<p><strong>redis持久化的意义，在于故障恢复</strong>。比如你部署了一个redis，作为cache缓存，当然也可以保存一些较为重要的数据。如果没有持久化的话，redis遇到灾难性故障的时候，就会丢失所有的数据。</p>
<p>如果通过持久化将数据搞一份儿在磁盘上去，然后定期比如说同步和备份到一些云存储服务上去，那么就可以保证数据不丢失全部，还是可以恢复一部分数据回来的。</p>
<p>Redis的一种持久 化方式叫快照（snapshotting，RDB）,另一种方式是只追加文件（append-only  ﬁle,AOF）.这两种方法各有千秋。</p>
<p>Redis提供了RDB和AOF两种持久化方式，RDB是把<strong>内存中的数据集以快照形式写入磁盘</strong>，实际操作是通过fork子进程执行，采用二进制压缩存储；AOF是以<strong>文本日志</strong>的形式记录Redis处理的每一个<strong>写入或删除操作</strong>。</p>
<p>RDB和AOF原理参考图：</p>
<p><img src="https://i.loli.net/2020/04/01/NjiBpV1aJbKZSmW.png" alt="AOF和RDB读持久化方式.png"></p>
<h3 id="快照（snapshotting）持久化（RDB）"><a href="#快照（snapshotting）持久化（RDB）" class="headerlink" title="快照（snapshotting）持久化（RDB）"></a>快照（snapshotting）持久化（RDB）</h3><p><strong>RDB：保存某个时间点的全量数据快照</strong>。</p>
<p><strong>简单来说，RDB模式就是让Redis每隔一段时间(几分钟、几个小时、几天)保存一次当前Redis里面所有的数据</strong>。</p>
<p>RDB 把整个 Redis 的数据保存在单一文件中，比较适合用来做灾备，但缺点是快照保存完成之前如果宕机，这段时间的数据将会丢失，另外保存快照时可能导致服务短时间不可用。</p>
<p>Redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis创建快照之后，可以对快照进行 备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis主从结构，主要用来提高Redis性 能），还可以将快照留在原地以便重启服务器的时候使用。</p>
<p>快照持久化是Redis默认采用的持久化方式，在redis.conf配置文件中默认有此下配置：</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">save <span class="number">900</span> <span class="number">1</span>              #在<span class="number">900</span>秒(<span class="number">15</span>分钟)之后，如果至少有<span class="number">1</span>个<span class="type">key</span>发生变化，Redis就会自动触发BGSAVE命令 创建快照。</span><br><span class="line">save <span class="number">300</span> <span class="number">10</span>            #在<span class="number">300</span>秒(<span class="number">5</span>分钟)之后，如果至少有<span class="number">10</span>个<span class="type">key</span>发生变化，Redis就会自动触发BGSAVE命令创 建快照。</span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span>        #在<span class="number">60</span>秒(<span class="number">1</span>分钟)之后，如果至少有<span class="number">10000</span>个<span class="type">key</span>发生变化，Redis就会自动触发BGSAVE命令创 建快照。</span><br></pre></td></tr></table></figure>

<p>RDB需要手动触发，一般用<code>BGSAVE</code>,可以fork，即派生出一个子进程来创建RDB文件，不阻塞服务器进程。</p>
<p><strong>RDB优点</strong>： </p>
<ol>
<li>RDB会生成多个数据文件，每个数据文件都代表了某一个时刻中redis的数据，这种多个数据文件的方式，<strong>非常适合做冷备</strong>，可以将这种完整的数据文件发送到一些远程的安全存储上去，比如说Amazon的S3云服务上去，在国内可以是阿里云的ODPS分布式存储上，然后可以根据配置，把每个一段时间就把当前最新的RDB存储的数据发送到目标服务器。以预定好的备份策略来定期备份redis中的数据</li>
<li>RDB对redis对外提供的读写服务，影响非常小，可以让redis保持高性能，因为redis主进程只需要fork一个子进程，让子进程执行磁盘IO操作来进行RDB持久化即可。</li>
<li>相对于AOF持久化机制来说，直接基于RDB数据文件来重启和恢复redis进程，更加快速</li>
</ol>
<p><strong>说明</strong>：<font color=#FF0000>主要针对RDB三点优势进行详细说明</font>。</p>
<ol>
<li><font color=#FF0000>为什么RDB更适合做冷备？</font>——实际上，RDB可以做冷备(生成多个文件，每个文件都代表了某一个时刻的完整数据快照)，但AOF也可以做冷备(只有一个文件，但可以每隔一定时间，去copy一份这个文件出来)。那么RDB做冷备的优势在哪儿？第一点：RDB是由Redis去控制固定时长生成快照文件的，比较方便。而AOF需要自己去写一些脚本才能完成这个事情，需要各种定时。第二点：RDB数据做冷备，在最坏的情况下，数据恢复的速度比AOF快(AOF存储日志，恢复的时候要执行所有指令才能恢复，而RDB只是数据文件，恢复的时候只需要加载到内存中即可)。</li>
<li><font color=#FF0000>为什么RDB性能更高？</font>——因为RDB每次只写Redis内存，只是在一定的时候，才会将数据写入磁盘中；而AOF每次都要写文件，虽然可以快速写入os cache中，但还是开销比直接写内存大，也就是比RDB略慢</li>
<li><font color=#FF0000>为什么RDB更快速？</font>——参考第一点的第二部分，即：RDB数据做冷备，在最坏的情况下，数据恢复的速度比AOF快(AOF存储日志，恢复的时候要执行所有指令才能恢复，而RDB只是数据文件，恢复的时候只需要加载到内存中即可</li>
</ol>
<p>综合上述优点，RDB适合做冷备份。</p>
<p><strong>RDB缺点</strong>：</p>
<ol>
<li>如果想要在redis故障时，尽可能少的丢失数据，那么RDB没有AOF好。一般来说，RDB数据快照文件，都是每隔5分钟，或者更长时间生成一次，这个时候就得接受一旦redis进程宕机，那么会丢失最近5分钟的数据。也就是说，<font color=#FF0000>RDB比较容易丢数据</font>,这也是RDB最大缺点，<strong>导致RDB不适合做第一优先的回复方案，如果你依赖RDB做第一优先恢复方案，会导致数据丢失比较多</strong>。</li>
<li>RDB每次在fork子进程来执行RDB快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒。所以，一般不要让RDB的间隔时间太长，否则每次生成的RDB文件太大了，对redis本身性能可能有影响。</li>
</ol>
<p>RDB数据丢失问题如下图所示：</p>
<p><img src="https://i.loli.net/2020/04/04/Z3Ryl1WaFtGPpun.png" alt="RDB丢失数据的问题.png"></p>
<h3 id="AOF（append-only-ﬁle）持久化"><a href="#AOF（append-only-ﬁle）持久化" class="headerlink" title="AOF（append-only ﬁle）持久化"></a>AOF（append-only ﬁle）持久化</h3><p>AOF会稍微复杂一点，<strong>简单来说，Redis每次被写入数据的时候，都会写入到磁盘的AOF文件里</strong>。注意这个过程会经过Linux OS Cache，因为现代操作系统中，写文件不是直接写磁盘的，会先写到os cache，然后过一段时间后再从os cache写到disk file.<strong>实际中一般每隔一秒，调用一次操作系统FSYNC操作，强制将os cache中的数据刷入磁盘文件中</strong>。</p>
<p>但是，<strong>因为AOF文件只有一个，所以AOF文件会越写越大</strong>。不能让redis内存中的数据无限增长而让AOF无限增大。解决方法就是定期rewrite，一般用LRU算法。</p>
<p>AOF 对日志文件的写入操作使用的追加模式，AOF文件里面保存的是写的指令，所以会不断膨胀。<strong>有灵活的同步策略，支持每秒同步、每次修改同步和不同步</strong>，缺点就是<strong>相同规模的数据集，AOF 要大于 RDB，AOF 在运行效率上往往会慢于 RDB</strong>。</p>
<p><strong>与快照持久化相比，AOF持久化 的实时性更好，因此已成为主流的持久化方案</strong>。默认情况下Redis没有开启 AOF（append only ﬁle）方式的持久化，可以通过<code>appendonly</code>参数开启：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">appendonly</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure>

<p>开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。AOF文件的 保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是appendonly.aof。</p>
<p>在Redis的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">appendfsync always     #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度 appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘 appendfsync no      #让操作系统决定何时进行同</span><br></pre></td></tr></table></figure>

<p>为了兼顾数据和写入性能，用户可以考虑 appendfsync everysec选项 ，让Redis每秒同步一次AOF文件，Redis性能 几乎没受到任何影响。而且这样即使出现系统崩溃，用户多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操 作的时候，Redis还会优雅的放慢自己的速度以便适应硬盘的大写入速度。 </p>
<p><strong>AOF优点</strong>：</p>
<ol>
<li><strong>AOF可以更好的保护数据不丢失</strong>，<font color=#FF0000>一般AOF会每隔1秒，通过一个后台线程执行一次fsync操作</font>，保证os cache中的数据写入磁盘中，即使redis进程挂了，只最多丢失1秒钟的数据</li>
<li><strong>AOF日志文件以append-only模式写入，所以没有任何磁盘寻址的开销，写入性能非常高</strong>，而且文件不容易破损，即使<strong>文件尾部破损</strong>，也很容易修复</li>
<li><strong>AOF日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。</strong>因为在rewrite log的时候，会对其中的指令进行压缩，创建出一份需要恢复数据的最小日志出来。再创建新日志文件的时候，老的日志文件还是照常写入。当新的merge后的日志文件ready的时候，再交换新老日志文件即可。</li>
<li>AOF可读性高(如果打开RDB文件，发现全是乱码，没法读。但AOF保存的数据是可读的)，<strong>适合保存增量数据，数据不易丢失</strong>。也就是说，日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据</li>
</ol>
<p><strong>AOF缺点</strong>：</p>
<ol>
<li>对于同一份数据来说，<strong>AOF日志文件通常比RDB数据快照文件更大</strong></li>
<li>AOF开启后，<strong>支持的写QPS会比RDB支持的写QPS低</strong>，因为AOF一般会配置成每秒fsync一次日志文件，当然，每秒一次fsync，性能也还是很高的。注意，<font color=#FF0000>如果你要保证一条数据都不丢，也是可以的，AOF的fsync设置成每写一条数据就做一次fsync。但是，这样也可以说完蛋了，因为redis的QPS会大降。</font></li>
<li>以前AOF发生过bug，就是通过AOF记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。所以说，类似AOF这种较为复杂的基于命令日志/merge/回放的方式，比基于RDB每次持久化一份完整的数据快照文件的方式，<strong>更加脆弱一些，容易有bug</strong>。不过AOF就是为了避免rewrite过程导致的bug，因此每次rewrite并不是基于旧的指令日志进行merge的，而是基于当时内存中的数据进行指令的重新构建，这样健壮性会好很多。</li>
<li><strong>总的来说，AOF唯一比较大的缺点，其实是做数据恢复的时候，会比较慢，还有做冷备，定期的备份，不太方便，可能要自己手写很复杂的脚本才能实现，不适合做冷备</strong>。</li>
</ol>
<h4 id="AOF重写-rewrite"><a href="#AOF重写-rewrite" class="headerlink" title="AOF重写(rewrite)"></a>AOF重写(rewrite)</h4><p>AOF重写可以产生一个新的AOF文件，这个新的AOF文件和原有的AOF文件所保存的数据库状态一样，但体积更小。</p>
<p>AOF重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有AOF文件进行任伺读 入、分析或者写入操作。</p>
<p>在执行 BGREWRITEAOF 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新AOF文件期 间，记录服务器执行的所有写命令。当子进程完成创建新AOF文件的工作之后，服务器会将重写缓冲区中的所有内容 追加到新AOF文件的末尾，使得新旧两个AOF文件所保存的数据库状态一致。后，服务器用新的AOF文件替换旧的 AOF文件，以此来完成AOF文件重写操作。</p>
<p>rewrite过程如下图所示，rewrite的目标就是让AOF中存储的文件大小不超过设定容量，这过程可能需要重新定义一个AOF等操作。</p>
<p><img src="https://i.loli.net/2020/04/04/O273AfSoiCrVJL6.png" alt="AOF rewrite原理剖析.png"></p>
<h4 id="AOF和RDB如何选择"><a href="#AOF和RDB如何选择" class="headerlink" title="AOF和RDB如何选择"></a>AOF和RDB如何选择</h4><p><strong>一言蔽之，就是不要只选择一种，而是两种结合</strong>。</p>
<ol>
<li>不要仅仅使用RDB，因为那样会导致你<strong>丢失很多数据</strong></li>
<li>也不要仅仅使用AOF，因为那样有两个问题，第一，<strong>你通过AOF做冷备，没有RDB做冷备，来的恢复速度更快</strong>; 第二，<strong>RDB每次简单粗暴生成数据快照，更加健壮，可以避免AOF这种复杂的备份和恢复机制的bug</strong></li>
<li>综合使用AOF和RDB两种持久化机制，用AOF来保证数据不丢失，作为数据恢复的第一选择; 用RDB来做不同程度的冷备，在AOF文件都丢失或损坏不可用的时候，还可以使用RDB来进行快速的数据恢复</li>
</ol>
<h3 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h3><p>Redis 通过 MULTI、EXEC、WATCH 等命令来实现事务(transaction)功能。事务提供了一种将多个命令请求打包，然 后一次性、按顺序地执行多个命令的机制，并且在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令 请求，它会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求。</p>
<p>在传统的关系式数据库中，常常用 ACID 性质来检验事务功能的可靠性和安全性。在 Redis 中，事务总是具有原子性 （Atomicity)、一致性(Consistency)和隔离性（Isolation），并且当 Redis 运行在某种特定的持久化模式下时，事务 也具有持久性（Durability）。 </p>
<h3 id="Redis4-0对于持久化机制的优化"><a href="#Redis4-0对于持久化机制的优化" class="headerlink" title="Redis4.0对于持久化机制的优化"></a>Redis4.0对于持久化机制的优化</h3><p>Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 <code>aof-use-rdb-preamble</code> 开启）。</p>
<p>如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。 </p>
<p>如果同时使用RDB和AOF两种持久化机制，那么在redis重启的时候，会使用AOF来重新构建数据，因为AOF中的数据更加完整</p>
<h2 id="聊聊redis-cluster集群模式的原理吗？"><a href="#聊聊redis-cluster集群模式的原理吗？" class="headerlink" title="聊聊redis cluster集群模式的原理吗？"></a>聊聊redis cluster集群模式的原理吗？</h2><p>早前，redis如果要搞几个节点，每个节点存储一部分的数据，得借助一些中间件来实现，比如codis，或者twemproxy。你会读写这些中间件，然后这些中间件负责将你的数据分布式地存储在多台机器上的redis实例中。</p>
<p>但是最近几年，redis在不断发展，不断更新版本，现在redis默认支持集群模式( redis cluster)，你可以做到在多台机器上，部署多个redis实例，每个实例存储一部分的数据，同时每个redis主实例可以挂载redis从实例，从而可以做到当redis主实例挂掉之后可以切换到从实例顶上。</p>
<p>所以，现在redis最新版本大家用得都是redis cluster，也就是redis原生支持的redis集群模式，那么面试官肯定会就redis cluster给你几个连环炮。要是你没用过redis cluster，正常，以前很多人用codis之类的客户端来支持集群。但是，起码你得研究一下redis cluster吧！！</p>
<h3 id="如何在保持读写分离-高可用的架构下，还能横向扩容支撑1T-海量数据"><a href="#如何在保持读写分离-高可用的架构下，还能横向扩容支撑1T-海量数据" class="headerlink" title="如何在保持读写分离+高可用的架构下，还能横向扩容支撑1T+海量数据"></a>如何在保持读写分离+高可用的架构下，还能横向扩容支撑1T+海量数据</h3><p><font color=#FF0000>实际上，redis cluster的读写不是分离的，都是在master节点上做的,但是先讲原始情况，读写分离的情况，后面再扩展</font>。</p>
<p>原本的架构中，master被一个哨兵监听、master负责写操作，slave负责承载读操作、每次写入新数据都让master和salve同步。</p>
<p>但是这样的架构有一个很大的问题，就是当数据量非常大之后，怎么办？我们不能让数据量超过master的物理上限，但是如果master只有32G内存，我们要存储1T的数据，怎么办？？？用LRU类似算法进行淘汰？那系统就出现了很大的瓶颈了！——<strong>或许看出来了，问题在于只有一个master</strong></p>
<p>上述情景如下图所示：</p>
<p><img src="https://i.loli.net/2020/04/04/oeEhq8xtyPZT4kJ.png" alt="redis单master架构的容量的瓶颈问题.png"></p>
<p>那么，怎么才能够突破单机瓶颈，让redis支撑海量数据？</p>
<p><strong>解决方法，就是用多个master，做成redis cluster即可</strong>。</p>
<p>支撑N个redis master node，每个master node都可以挂载多个slave node</p>
<p>有多个master，一个负责一部分写请求，这样就可以支持redis的横向扩容了。读写分离的架构，对于每个master来说，写就写到master，然后读就从mater对应的slave去读。</p>
<p>redis通过master扩容来支持1T+数据量的原理如下图所示：</p>
<p><img src="https://i.loli.net/2020/04/04/VK36Aem7kfuTWnX.png" alt="redis如何通过master横向扩容支撑1T_数据量.png"></p>
<p>高可用，因为每个master都有salve节点，那么如果mater挂掉，redis cluster这套机制，就会自动将某个slave切换成master</p>
<p>一言蔽之：<strong>redis cluster（多master + 读写分离 + 高可用）</strong></p>
<p>我们只要基于redis cluster去搭建redis集群即可，不需要手工去搭建replication复制+主从架构+读写分离+哨兵集群+高可用</p>
<h4 id="redis-cluster-vs-replication-sentinal"><a href="#redis-cluster-vs-replication-sentinal" class="headerlink" title="redis cluster vs. replication + sentinal"></a>redis cluster vs. replication + sentinal</h4><p>有关 redis cluster vs. replication + sentinal，即两者该如何选择的问题</p>
<p>如果你的数据量很少，主要是承载高并发高性能的场景，比如你的缓存一般就几个G，单机足够了</p>
<p>replication，一个mater，多个slave，要几个slave跟你的要求的读吞吐量有关系，然后自己搭建一个sentinal集群，去保证redis主从架构的高可用性，就可以了。</p>
<p>redis cluster，主要是针对海量数据+高并发+高可用的场景，<strong>重点是海量数据</strong>，<font color=#FF0000>如果你的数据量很大，那么建议就用redis cluster</font>。</p>
<h3 id="数据分布算法"><a href="#数据分布算法" class="headerlink" title="数据分布算法"></a>数据分布算法</h3><p>主要介绍数据分布算法，包括 hash(最老最挫) -&gt; 一致性hash算法(使用memcached的需要好好研究) -&gt; redis cluster的hash slot算法。</p>
<p>用不同的算法，主要解决在多个master节点的时候，数据如何分布到这些节点上去的问题。</p>
<h4 id="回顾redis-cluster"><a href="#回顾redis-cluster" class="headerlink" title="回顾redis cluster"></a>回顾redis cluster</h4><p>redis cluster主要有两个特点：</p>
<ol>
<li>自动将数据进行分片，每个master上放一部分数据</li>
<li>提供内置的高可用支持，部分master不可用时，还是可以继续工作的</li>
</ol>
<p>在redis cluster架构下，每个redis要放开两个端口号，比如一个是6379(四位数端口)，另外一个就是加10000的端口号，比如16379(五位数端口)</p>
<p>16379端口号是用来进行节点间通信的，也就是cluster bus的东西，集群总线。cluster bus的通信(用二进制协议来通信，可以减少节点间通信的时候数据交换的量，减少网络带宽消耗)。用来进行故障检测，配置更新，故障转移授权。</p>
<p>cluster bus用了另外一种二进制的协议，主要用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间</p>
<h4 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h4><p>这种算法很老，也比较挫，<font color=#FF0000>但是现在很少有人用哈希算法用在缓存，一般分库分表会使用哈希算法</font>。</p>
<p>哈希算法就是在一个key来了之后，对节点数量取模，然后得到结果一定不大于节点数量。比如有3个master，对3取模，结果只能是0,1,2，然后存储到对应的master节点即可。</p>
<p>但是有一个很大的弊端，当一个master挂掉之后，会有1/n的数据丢失掉，要对剩下的机器取模，再分布。而对于高并发场景来说，这样不可接受，因为比如1/3不走缓存走数据库，那么数据库无法接受。所以，最大的问题是，只要一个master宕机，那么大量的数据需要重新计算写入缓存，风险很大。</p>
<p>如下图所示：</p>
<p><img src="https://i.loli.net/2020/04/04/QAZntCbRVpmrlYw.png" alt="最老土的hash算法以及弊端.png"></p>
<p><font color=#FF0000><strong>注意，上面不是1/3失效，而是几乎全部失效了</strong></font>。因为一个master失效了，再来的数据会根据2取模，这样很可能覆盖原来的数据，导致大部分请求都无法拿到请求，大量流量会涌入数据库中。</p>
<h4 id="一致性hash算法（自动缓存迁移）-虚拟节点（自动负载均衡）"><a href="#一致性hash算法（自动缓存迁移）-虚拟节点（自动负载均衡）" class="headerlink" title="一致性hash算法（自动缓存迁移）+虚拟节点（自动负载均衡）"></a>一致性hash算法（自动缓存迁移）+虚拟节点（自动负载均衡）</h4><p>所谓的一致性hash，就是搞了个圆环，key来了之后放到圆环对应的点上(每个店都有一个对应的hash值)。key落在圆环上以后，会<font color=#FF0000>顺时针旋转去寻找距离自己最近的一个节点</font>。</p>
<p><img src="https://i.loli.net/2020/04/04/bvlVaEgnsCNh5Mi.png" alt="一致性hash算法的讲解和优点.png"></p>
<p>一致性哈希算法可以保证某个master宕机之后，只有master上的数据受到影响，也就是1/n。<strong>对比一下之前哈希算法，丢失的是几乎100%的数据！</strong></p>
<p>一致性hash算法搞出来一个圆环，还挺有创意的。</p>
<p>但是可能造成<strong>缓存的热点</strong>问题，即大部分数据都堆积到了一个节点上。</p>
<p>解决方法：搞出来虚拟节点，给每个master都做了虚拟节点，这样在每个区间内，大量的数据都可以分布到不同的虚拟节点内，而不是按照顺时针顺序去走全都打入一个节点。</p>
<p>加入虚拟节点之后如下图所示：</p>
<p><img src="https://i.loli.net/2020/04/04/NOb6tmdW4HlkSj7.png" alt="一致性hash算法的虚拟节点实现负载均衡.png"></p>
<h4 id="hash-slot算法-redis用的方法"><a href="#hash-slot算法-redis用的方法" class="headerlink" title="hash slot算法(redis用的方法)"></a>hash slot算法(redis用的方法)</h4><p>redis cluster有固定的16384个hash slot，对每个key计算CRC16值，然后对16384取模，可以获取key对应的hash slot，然后把hash slot放到对应的节点上，这样很随机。</p>
<p>redis cluster中每个master都会持有部分slot，比如有3个master，那么可能每个master持有5000多个hash slot</p>
<p>hash slot让node的增加和移除很简单，增加一个master，就将其他master的hash slot移动部分过去，减少一个master，就将它的hash slot移动到其他master上去，移动hash slot的成本是非常低的。</p>
<p>而客户端的api，可以对指定的数据，让他们走同一个hash slot，通过hash tag来实现。</p>
<p>假设此时有一个master宕机了，那么其他节点不会被影响，因为key找的是hash slot，不是机器。而且就算宕机了，还是对16384取模，还是能找到一个位置。效果和一致性哈希圆环是一样的。</p>
<p>实际上，redis发现了某个机器宕机之后，会以最快的速度把宕机的机器上的hash slot发送到其他没挂的节点，然后再来新hash slot，找到原本的slot即可，不会丢。</p>
<p><img src="https://i.loli.net/2020/04/04/rFDjuf54k93gehG.png" alt="redis cluster hash slot算法.png"></p>
<p>尽量让hash slot在各个机器上均匀分布。</p>
<h3 id="redis-cluster的核心原理分析"><a href="#redis-cluster的核心原理分析" class="headerlink" title="redis cluster的核心原理分析"></a>redis cluster的核心原理分析</h3><p>redis cluster的核心原理，主要包含gossip通信、jedis smart定位、主备切换。</p>
<h4 id="节点间的内部通信机制"><a href="#节点间的内部通信机制" class="headerlink" title="节点间的内部通信机制"></a>节点间的内部通信机制</h4><h5 id="基础通信原理"><a href="#基础通信原理" class="headerlink" title="基础通信原理"></a>基础通信原理</h5><p>（1）redis cluster节点间采取gossip协议进行通信</p>
<p>跟集中式不同，不是将集群元数据（节点信息，故障，等等）集中存储在某个节点上，而是互相之间不断通信，保持整个集群所有节点的数据是完整的</p>
<p>维护集群的<strong>元数据</strong>用的，两种，一种为<strong>集中式</strong>，一种叫做<strong>gossip</strong></p>
<p><font color=#FF0000>集中式</font>：<strong>好处</strong>在于，元数据的更新和读取，时效性非常好，一旦元数据出现了变更，立即就更新到集中式的存储中(比如非常常用的zookeeper)，其他节点读取的时候立即就可以感知到; <strong>缺点</strong>在于，所有的元数据的更新压力全部集中在一个地方，可能会导致元数据的存储有压力。读数据都是从zookeeper里面读。</p>
<p>集中式存储和维护如下图：</p>
<p><img src="https://i.loli.net/2020/04/04/81M7ZIewQpV6uoU.png" alt="集中式的集群元数据存储和维护.png"></p>
<p><font color=#FF0000>gossip</font>：<strong>好处</strong>在于，元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续，打到所有节点上去更新，有一定的延时，降低了压力; <strong>缺点</strong>：元数据更新有延时，可能导致集群的一些操作会有一些滞后。Redis就是使用gossip协议的。</p>
<p>gossip原理维护元数据的原理如下图所示：</p>
<p><img src="https://i.loli.net/2020/04/04/DLg17C8fKquRE3h.png" alt="gossip协议维护集群元数据.png"></p>
<p>我们刚才做reshard，去做另外一个操作，会发现说，configuration error，达成一致</p>
<p>（2）10000端口</p>
<p>每个节点都有一个专门用于节点间通信的端口，就是自己提供服务的端口号+10000，比如7001，那么用于节点间通信的就是17001端口</p>
<p>每隔节点每隔一段时间都会往另外几个节点发送ping消息，同时其他几点接收到ping之后返回pong</p>
<p>（3）交换的信息</p>
<p>故障信息，节点的增加和移除，hash slot信息，等等</p>
<h5 id="gossip协议"><a href="#gossip协议" class="headerlink" title="gossip协议"></a>gossip协议</h5><p>gossip协议包含多种消息，包括ping，pong，meet，fail，等等</p>
<p>meet: 某个节点发送meet给新加入的节点，让新节点加入集群中，然后新节点就会开始与其他节点进行通信</p>
<p>在执行<code>redis-trib.rb add-node</code>的时候，其实内部就是发送了一个gossip meet消息，给新加入的节点，通知那个节点去加入我们的集群</p>
<p>ping: 每个节点都会频繁给其他节点发送ping，其中包含自己的状态还有自己维护的集群元数据，互相通过ping交换元数据</p>
<p>每个节点每秒都会频繁发送ping给其他的集群，ping，频繁的互相之间交换数据，互相进行元数据的更新</p>
<p>pong: 返回ping和meet，包含自己的状态和其他信息，也可以用于信息广播和更新</p>
<p>fail: 某个节点判断另一个节点fail之后，就发送fail给其他节点，通知其他节点，指定的节点宕机了</p>
<h5 id="ping消息探入"><a href="#ping消息探入" class="headerlink" title="ping消息探入"></a>ping消息探入</h5><p>ping很频繁，而且要携带一些元数据，所以可能会加重网络负担</p>
<p>每个节点每秒会执行10次ping，每次会选择5个最久没有通信的其他节点</p>
<p>当然如果发现某个节点通信延时达到了cluster_node_timeout / 2，那么立即发送ping，避免数据交换延时过长，落后的时间太长了</p>
<p>比如说，两个节点之间都10分钟没有交换数据了，那么整个集群处于严重的元数据不一致的情况，就会有问题。</p>
<p>所以cluster_node_timeout可以调节，如果调节比较大，那么会降低发送的频率</p>
<p>每次ping，一个是带上自己节点的信息，还有就是带上1/10其他节点的信息，发送出去，进行数据交换</p>
<p>至少包含3个其他节点的信息，最多包含总节点-2个其他节点的信息</p>
<h4 id="面向集群的jedis内部实现原理"><a href="#面向集群的jedis内部实现原理" class="headerlink" title="面向集群的jedis内部实现原理"></a>面向集群的jedis内部实现原理</h4><p>等下开发都会基于jedis，也就是说redis的java client客户端，redis cluster，jedis cluster api</p>
<p>jedis cluster api与redis cluster集群交互的一些基本原理</p>
<h5 id="基于重定向的客户端"><a href="#基于重定向的客户端" class="headerlink" title="基于重定向的客户端"></a>基于重定向的客户端</h5><p>redis-cli -c，自动重定向</p>
<p>（1）请求重定向</p>
<p>客户端可能会挑选任意一个redis实例去发送命令，每个redis实例接收到命令，都会计算key对应的hash slot。如果这个hash slot在本地就在本地处理，否则返回moved给客户端，让客户端进行重定向</p>
<p>cluster keyslot mykey，可以查看一个key对应的hash slot是什么</p>
<p>用redis-cli的时候，可以加入-c参数，支持自动的请求重定向，redis-cli接收到moved之后，会自动重定向到对应的节点执行命令</p>
<p>（2）计算hash slot</p>
<p>计算hash slot的算法，就是根据key计算CRC16值，然后对16384取模，拿到对应的hash slot</p>
<p>用hash tag可以手动指定key对应的slot，同一个hash tag下的key，都会在一个hash slot中，比如set mykey1:{100}和set mykey2:{100}</p>
<p>（3）hash slot查找</p>
<p>节点间通过gossip协议进行数据交换，就知道每个hash slot在哪个节点上</p>
<h5 id="smart-jedis"><a href="#smart-jedis" class="headerlink" title="smart jedis"></a>smart jedis</h5><p>（1）什么是smart jedis</p>
<p>基于重定向的客户端，很消耗网络IO，因为大部分情况下，可能都会出现一次请求重定向，才能找到正确的节点</p>
<p>所以大部分的客户端，比如java redis客户端，就是jedis，都是smart的</p>
<p>本地维护一份hashslot -&gt; node的映射表，缓存，大部分情况下，直接走本地缓存就可以找到hashslot -&gt; node，不需要通过节点进行moved重定向</p>
<p>（2）JedisCluster的工作原理</p>
<p>在JedisCluster初始化的时候，就会随机选择一个node，初始化hashslot -&gt; node映射表，同时为每个节点创建一个JedisPool连接池</p>
<p>每次基于JedisCluster执行操作，首先JedisCluster都会在本地计算key的hashslot，然后在本地映射表找到对应的节点</p>
<p>如果那个node正好还是持有那个hashslot，那么就ok; 如果说进行了reshard这样的操作，可能hashslot已经不在那个node上了，就会返回moved</p>
<p>如果JedisCluter API发现对应的节点返回moved，那么利用该节点的元数据，更新本地的hashslot -&gt; node映射表缓存</p>
<p>重复上面几个步骤，直到找到对应的节点，如果重试超过5次，那么就报错，JedisClusterMaxRedirectionException</p>
<p>jedis老版本，可能会出现在集群某个节点故障还没完成自动切换恢复时，频繁更新hash slot，频繁ping节点检查活跃，导致大量网络IO开销</p>
<p>jedis最新版本，对于这些过度的hash slot更新和ping，都进行了优化，避免了类似问题</p>
<p>（3）hashslot迁移和ask重定向</p>
<p>如果hash slot正在迁移，那么会返回ask重定向给jedis</p>
<p>jedis接收到ask重定向之后，会重新定位到目标节点去执行，但是因为ask发生在hash slot迁移过程中，所以JedisCluster API收到ask是不会更新hashslot本地缓存</p>
<p>已经可以确定说，hashslot已经迁移完了，moved是会更新本地hashslot-&gt;node映射表缓存的</p>
<h4 id="高可用性与主备切换原理-重要"><a href="#高可用性与主备切换原理-重要" class="headerlink" title="高可用性与主备切换原理(重要)"></a>高可用性与主备切换原理(重要)</h4><p>redis cluster的高可用的原理，几乎跟哨兵是类似的</p>
<h5 id="判断节点宕机"><a href="#判断节点宕机" class="headerlink" title="判断节点宕机"></a>判断节点宕机</h5><p>如果一个节点认为另外一个节点宕机，那么就是<font color=#FF0000>pfail(哨兵的sdown)</font>，<strong>主观宕机</strong></p>
<p>如果多个节点都认为另外一个节点宕机了，那么就是<font color=#FF0000>fail(哨兵的odown)</font>，<strong>客观宕机</strong>，跟哨兵的原理几乎一样，sdown，odown</p>
<p>在<code>cluster-node-timeout</code>内，某个节点一直没有返回pong，那么就被认为pfail</p>
<p>如果一个节点认为某个节点pfail了，那么会在gossip ping消息中，ping给其他节点，<strong>如果超过半数的节点</strong>都认为pfail了，那么就会变成fail</p>
<h5 id="从节点过滤"><a href="#从节点过滤" class="headerlink" title="从节点过滤"></a>从节点过滤</h5><p>对宕机的master node，从其所有的slave node中，选择一个切换成master node</p>
<p>检查每个slave node与master node断开连接的时间，如果超过了<code>cluster-node-timeout * cluster-slave-validity-factor</code>，那么就没有资格切换成master</p>
<p>这个也是跟哨兵是一样的，从节点超时过滤的步骤</p>
<h5 id="从节点选举"><a href="#从节点选举" class="headerlink" title="从节点选举"></a>从节点选举</h5><p>哨兵：对所有从节点进行排序，slave priority，offset，run id</p>
<p>每个从节点，都根据自己对master复制数据的offset，来设置一个选举时间，offset越大（复制数据越多）的从节点，选举时间越靠前，优先进行选举</p>
<p>所有的master node开始slave选举投票，给要进行选举的slave进行投票，如果大部分master node（N/2 + 1）都投票给了某个从节点，那么选举通过，那个从节点可以切换成master</p>
<p>从节点执行主备切换，从节点切换为主节点</p>
<h5 id="与哨兵比较"><a href="#与哨兵比较" class="headerlink" title="与哨兵比较"></a>与哨兵比较</h5><p>整个流程跟哨兵相比，非常类似，所以说，<strong>redis cluster功能强大，直接集成了replication和sentinal的功能</strong>。</p>
<h2 id="使用Redis的缺陷和可能碰到的问题"><a href="#使用Redis的缺陷和可能碰到的问题" class="headerlink" title="使用Redis的缺陷和可能碰到的问题"></a>使用Redis的缺陷和可能碰到的问题</h2><p>不考虑使用Redis过程中可能碰到的问题是不行的，因为实际中技术都有优劣存在。</p>
<p><img src="https://i.loli.net/2020/04/01/VUuqgeOJmDy8Fth.png" alt="缓存缺点.png"></p>
<p>其实这是问到缓存必问的，因为缓存雪崩和穿透，那是缓存最大的两个问题，要么不出现，一旦出现就是致命性的问题。所以面试官一定会问你。</p>
<h3 id="缓存雪崩及解决方案"><a href="#缓存雪崩及解决方案" class="headerlink" title="缓存雪崩及解决方案"></a>缓存雪崩及解决方案</h3><p>简而言之就是，如果缓存全部宕机，那么大量用户请求一下子全都落在了MySQL数据库上，那么MySQL承受不住，会挂掉。而且一重启就挂，一重启就挂！一个例子，就是曾经用户千万级的互联网公司，缓存全部宕机，从下午持续到凌晨三四点，公司损失几千万。</p>
<p>缓存雪崩现象图示：</p>
<p><img src="https://i.loli.net/2020/04/04/kSNRGfa85yeQqMA.png" alt="01_缓存雪崩现象.png"></p>
<p>解决方案主要分三个部分：事前、事中、事后。</p>
<ul>
<li><p><font color=#FF0000>事前</font>：<strong>让redis高可用，可以用主从+哨兵，做成redis cluster(之前讲过它包含哨兵和replication两个功能)形式，即一个master带一些slave，这样master挂了之后可以把slave提上来，避免全盘崩溃</strong>。(当然这样做还是可能出问题的，可能所有redis集群全部崩溃)。<strong>发现机器宕机尽快补上。选择合适的内存淘汰策略</strong>。</p>
</li>
<li><p><font color=#FF0000>事中</font>：可以<strong>在本地增加一个ehcache的缓存</strong>(但是面对真正的雪崩，是杯水车薪) <strong>+ hystrix限流&amp;降级</strong>，避免MySQL崩掉。所有的数据必须先经过限流组件，你可以限制每秒只能通过多少数据，比如一共5000个，你限制一次只能通过2000个，那么只能通过2000个。剩下的3000个怎么办？走降级——限流组件发现有3000个请求没法通过自己，会调用降级组件，返回一些默认的值或者空白的值。这样如果缓存挂了，但是数据库可能有限度地处理数据，只要数据库不死，你的系统就不会死，只是处理得慢一些，但是比整个挂掉要强得多。</p>
</li>
<li><p><font color=#FF0000>事后</font>：<strong>利用 redis 持久化机制保存的数据尽快恢复缓存</strong></p>
</li>
</ul>
<p>总的来说，事前靠高可用、事中靠本地缓存+限流(确保库不能死)、事后靠redis(Redis一定要开持久化)</p>
<p>主要就是事前、事中、事后三个方式来解决缓存雪崩的问题。</p>
<p>如下图：</p>
<p><img src="https://i.loli.net/2020/04/01/lAZxWFdKJRI5nLp.png" alt="缓存雪崩解决办法.png"></p>
<h3 id="缓存穿透及解决方案"><a href="#缓存穿透及解决方案" class="headerlink" title="缓存穿透及解决方案"></a>缓存穿透及解决方案</h3><p><strong>穿透就是指大量的请求在数据库中是查不到数据的</strong>。</p>
<p>一般是黑客故意去请求缓存中不存在的数据，(因为黑客是随意编造的数据来发的请求，数据库中根本没有，而且缓存里面也不会有，那么缓存就帮不了忙，而且每次都是这样，都只会去数据库里面找数据)。这个时候，导致所有的请求都落到数据库上，造成数据库短时间内承受大量 请求而崩掉。</p>
<p>如下图所示：</p>
<p><img src="https://i.loli.net/2020/04/04/MQb5IoRP3GfZ9wk.png" alt="03_缓存穿透现象以及解决方案.png"></p>
<p>可以用两种解决方法。</p>
<ul>
<li>第一种：每次系统A只要从数据库里没查到，就写一个空值到缓存里(VALUE统一附上UNKNOW值)，这样下次黑客发过来请求的时候，哪怕是假数据，缓存中也已经保存了，可以返回一个UNKNOW！这种方法简而言之，就是<font color=#FF0000>空对象缓存</font>。</li>
<li>第二种：如果恶意攻击非常多，可以考虑<font color=#FF0000>使用布隆过滤器</font>，可以快速判断请求是否存在于我们的缓存中。</li>
</ul>
<h3 id="缓存与数据库双写不一致"><a href="#缓存与数据库双写不一致" class="headerlink" title="缓存与数据库双写不一致"></a>缓存与数据库双写不一致</h3><p>你只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如 何解决一致性问题？这个是实际生产中很经常会遇到的问题。</p>
<p>这个问题要好好分析一下。</p>
<p>先介绍经典的缓存+数据库读写模式，然后分析如何解决缓存和数据库双写不一致的问题。</p>
<h4 id="缓存-数据库读写模式：cache-aside-pattern"><a href="#缓存-数据库读写模式：cache-aside-pattern" class="headerlink" title="缓存+数据库读写模式：cache aside pattern"></a>缓存+数据库读写模式：cache aside pattern</h4><p>cache aside pattern是最经典的缓存+数据库读写的模式。</p>
<p>cache aside pattern简单来说，就是两点：</p>
<ol>
<li>读的时候，先读缓存，缓存没有的话，那么就读数据库，然后取出数据后放入缓存，同时返回响应</li>
<li>更新的时候，<strong>先删除缓存，然后再更新数据库</strong></li>
</ol>
<p>如下图所示：</p>
<p><img src="https://i.loli.net/2020/04/04/2XAgrvV7uc8eBsD.png" alt="cache aside pattern.png"></p>
<p>优先去读redis，如果能读到，就返回数据。如果没在redis读到，则去读MySQL，并且之后把数据写入到redis里面去，同时返回数据。</p>
<p>如果要更新数据，先把redis里面的缓存删掉，再更新。</p>
<h4 id="为什么是删除缓存，而不是更新缓存呢？"><a href="#为什么是删除缓存，而不是更新缓存呢？" class="headerlink" title="为什么是删除缓存，而不是更新缓存呢？"></a>为什么是删除缓存，而不是更新缓存呢？</h4><p>原因很简单，很多时候，复杂点的缓存的场景，缓存有的时候不简单是数据库中直接取出来的值，而是放了很久都不会被访问的值。如果你为了这个很久不被访问的值去做计算(或者叫做更新)，是很不划算的，不如直接删除来得快。换句话说，你不常用这个缓存的话，没必要总是把缓存计算。</p>
<p>商品详情页的系统，修改库存，只是修改了某个表的某些字段，但是要真正把这个影响的最终的库存计算出来，可能还需要从其他表查询一些数据，然后进行一些复杂的运算，才能最终计算出现在最新的库存是多少，然后才能将库存更新到缓存中去。比如可能更新了某个表的一个字段，然后其对应的缓存，是需要查询另外两个表的数据，并进行运算，才能计算出缓存最新的值的。</p>
<p>但是，更新缓存的代价是很高的。是不是每次修改数据库的时候，都一定要将其对应的缓存去跟新一份？也许有的场景是这样的，但是对于比较复杂的缓存数据计算的场景，就不是这样了。如果你频繁修改一个缓存涉及的多个表，那么这个缓存会被频繁的更新，频繁地更新缓存。</p>
<p>但是问题在于，这个缓存到底会不会被频繁访问到？？？</p>
<p>举个例子，一个缓存涉及的表的字段，在1分钟内就修改了20次，或者是100次，那么缓存跟新20次，100次; 但是这个缓存在1分钟内就被读取了1次，有大量的冷数据。(<strong>数据访问其实遵循28法则，黄金法则，20%的数据，占用了80%的访问量</strong>)</p>
<p>实际上，如果你只是删除缓存的话，那么1分钟内，这个缓存不过就重新计算一次而已，开销大幅度降低。每次数据过来，就只是删除缓存，然后修改数据库，如果这个缓存，在1分钟内只是被访问了1次，那么只有那1次，缓存是要被重新计算的，所以可以设计成用缓存才去算缓存。</p>
<p>其实删除缓存，而不是更新缓存，就是一个lazy计算的思想，不要每次都重新做复杂的计算，不管它会不会用到，而是让它到需要被使用的时候再重新计算。</p>
<p>类似mybatis，hibernate的懒加载思想，用得时候才加载。</p>
<p>举一个懒加载的例子：查询一个部门，部门带了一个员工的list，没有必要说每次查询部门，都里面的1000个员工的数据也同时查出来啊，因为80%的情况，查这个部门，就只是要访问这个部门的信息就可以了。只有极少数的情况，先查部门，同时要访问里面的员工。按照lazy的思想，只有在你要访问里面的员工的时候，才会去数据库里面查询1000个员工。</p>
<h4 id="具体解决方案"><a href="#具体解决方案" class="headerlink" title="具体解决方案"></a>具体解决方案</h4><h5 id="最初级的缓存不一致问题以及解决方案"><a href="#最初级的缓存不一致问题以及解决方案" class="headerlink" title="最初级的缓存不一致问题以及解决方案"></a>最初级的缓存不一致问题以及解决方案</h5><p>问题：先修改数据库，成功了，再删除缓存，如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据出现不一致。</p>
<p>如下图所示：</p>
<p><img src="https://i.loli.net/2020/04/04/BcQAdCFKYIPHvnp.png" alt="最初级的数据库_缓存双写不一致问题.png"></p>
<p><font color=#FF0000>解决思路</font>：非常简单，就是cache aside pattern模式，<font color=#FF0000>一定要先删除缓存，再修改数据库</font>，如果删除缓存成功了，如果修改数据库失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致。</p>
<p>因为读的时候缓存没有，则读数据库中旧数据，然后更新到缓存中。如下图：</p>
<p><img src="https://i.loli.net/2020/04/04/ipEZAYWcCFIyBsM.png" alt="最初级的数据库_缓存双写不一致问题的解决方案.png"></p>
<h5 id="比较复杂的数据不一致问题分析"><a href="#比较复杂的数据不一致问题分析" class="headerlink" title="比较复杂的数据不一致问题分析"></a>比较复杂的数据不一致问题分析</h5><p>比较复杂的情况就是，数据发生了变更，哪怕你先删除了缓存，然后修改数据库，也会发生数据不一致的情况。</p>
<p>一个请求过来，要修改数据库的库存。此时按照cache aside pattern模式，会先去把缓存给删了，然后尝试修改数据库的库存数量。重点是，当修改还没有完成的时候，同时来了一个读请求，这个读请求会直接去读缓存，发现此时缓存是空的，那么这个请求就会发送请求给这个服务的其他接口，要把数据库中的数据拿出来放到缓存里面去(<strong>完全符合cache aside pattern的流程做的，异常原因是读写同时发生了</strong>)，此时把原先的库存写到了缓存里，返回的就是老的库存数据。而在这个读操作完成之后，MySQL才完成修改库存的写操作，这就造成了现在数据库的数据和缓存中的数据不一致的情况……有点悲催。</p>
<p>如下图所示：</p>
<p><img src="https://i.loli.net/2020/04/04/rSHfxikv3PhmpuR.png" alt="读写并发的时候复杂的数据库_缓存双写不一致的场景.png"></p>
<p>等等，我们其实可以在这里分析一下，<strong>为什么会发生这种复杂度，读写同时发生的情况</strong>？</p>
<p>可以说，这个情况的发生背景是<strong>上亿流量高并发场景，缓存才会出现这个问题</strong>。</p>
<p>因为只有在对一个数据在并发的进行读写的时候，才可能会出现这种问题，但是如果说你的并发量很低的话，特别是读并发很低，每天访问量就1万次，那么一般不会出现这种复杂的数据不一致的场景。</p>
<p>但是问题是，如果<strong>每天的是上亿的流量</strong>，<strong>每秒并发读是几万</strong>，每秒只要有数据更新的请求，就可能会出现上述的数据库+缓存不一致的情况。高并发了以后，问题是很多的！</p>
<p><font color=#FF0000>解决思路：<strong>数据库与缓存更新与读取操作进行异步串行化</strong></font>。(简略介绍)</p>
<p>一般来说，就是如果你的系统不是严格要求缓存+数据库必须一致性的话，缓存可以稍微的跟数据库偶尔有不一致的情况，<strong>最好不要做这个方案</strong>，因为如果你要保证数据库和缓存完全一致，要做读请求和写请求的串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况。</p>
<p>串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。</p>
<h3 id="Redis并发竞争Key-缓存击穿"><a href="#Redis并发竞争Key-缓存击穿" class="headerlink" title="Redis并发竞争Key(缓存击穿)"></a>Redis并发竞争Key(缓存击穿)</h3><p><strong>redis的并发竞争问题是什么？如何解决这个问题？了解Redis事务的CAS方案吗？</strong></p>
<p>这个也是线上非常常见的一个问题，就是多客户端同时并发写一个key，可能本来应该先到的数据后到了，导致数据版本错了。或者是多客户端同时获取一个key，修改值之后再写回去，只要<strong>顺序错了</strong>，数据就错了。</p>
<p>解决方法：<font color=#FF0000>分布式锁+加时间戳判断数据版本</font>。可以基于zookeeper(ZK)做分布式锁。然后不要让旧版本覆盖掉新版本。</p>
<p>需要提一嘴，如果你的系统不太可能出现这样的问题，那么其实没必要做这个锁，但是如果可能出现这样的情况，即请求可能一股脑过来，每个实例都可能拿到一个请求，分别更新数据，那么就需要有分布式锁。</p>
<p>先尝试获取分布式锁，如果能够获得，那么其他系统此时跑过来，也尝试获取分布式锁，那么它是获取不到锁的</p>
<p> 如下图所示：</p>
<p><img src="https://i.loli.net/2020/04/05/ewkUGrfdPb5hxJ6.png" alt="01_redis并发竞争问题以及解决方案.png"></p>
<p>而且redis自己就有天然解决这个问题的CAS类的乐观锁方案。</p>
<h2 id="公司生产环境的redis集群的部署架构是什么样的？"><a href="#公司生产环境的redis集群的部署架构是什么样的？" class="headerlink" title="公司生产环境的redis集群的部署架构是什么样的？"></a>公司生产环境的redis集群的部署架构是什么样的？</h2><p>生产环境中的redis是怎么部署的？你的redis是主从架构？集群架构？用了哪种集群方案？有没有做高可用保证？有没有开启持久化机制确保可以进行数据恢复？线上redis给几个G的内存？设置了哪些参数？压测后你们redis集群承载多少QPS？</p>
<p>redis cluster，10台机器，5台机器部署了redis主实例，另外5台机器部署了redis的从实例，每个主实例挂了一个从实例，5个节点对外提供读写服务，每个节点的读写高峰qps可能可以达到每秒5万，5台机器最多是25万读写请求/s。</p>
<p>机器是什么配置？32G内存+8核CPU+1T磁盘，但是分配给redis进程的是10g内存，一般线上生产环境，redis的内存尽量不要超过10g，超过10g可能会有问题。</p>
<p>5台机器对外提供读写，一共有50g内存。</p>
<p>因为每个主实例都挂了一个从实例，所以是高可用的，任何一个主实例宕机，都会自动故障迁移，redis从实例会自动变成主实例继续提供读写服务</p>
<p>你往内存里写的是什么数据？每条数据的大小是多少？商品数据，每条数据是10kb。100条数据是1mb，10万条数据是1g。常驻内存的是200万条商品数据，占用内存是20g，仅仅不到总内存的50%。</p>
<p>目前高峰期每秒就是3500左右的请求量</p>
<p>比如很多大型的互联网公司，其实基础架构的team，会负责缓存集群的运维。</p>
]]></content>
      <categories>
        <category>Interview Note</category>
      </categories>
      <tags>
        <tag>Interview</tag>
        <tag>Redis</tag>
        <tag>Cache</tag>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring</title>
    <url>/2020/03/25/Spring/</url>
    <content><![CDATA[<blockquote>
<p>成功的奥秘在于目标的坚定。——迪斯雷利</p>
</blockquote>
<a id="more"></a>

<p>参考文章：<a href="https://wiki.jikexueyuan.com/project/spring/ioc-containers.html" target="_blank" rel="noopener">极客学院Spring教程</a></p>
<p><a href="https://blog.csdn.net/weixin_43277643/article/details/84253237" target="_blank" rel="noopener">Spring Bean详细讲解 什么是Bean?</a></p>
<h1 id="Spring框架是什么"><a href="#Spring框架是什么" class="headerlink" title="Spring框架是什么"></a>Spring框架是什么</h1><p>Spring 是个java企业级应用的开源开发框架。Spring主要用来开发Java应用，但是有些扩展是针对构建J2EE平台的web应用。Spring 框架目标是简化Java企业级应用开发，并通过POJO为基础的编程模型促进良好的编程习惯。</p>
<h2 id="Spring框架的好处"><a href="#Spring框架的好处" class="headerlink" title="Spring框架的好处"></a>Spring框架的好处</h2><p>可以说是Spring框架的精髓：</p>
<ul>
<li>轻量，基本版本大约2MB</li>
<li>控制反转(IOC)：实现了松散耦合。对象们给出它们的依赖，而不是创建或查找依赖的对象们。</li>
<li>面向切面的编程(AOP)：Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。</li>
<li>容器：Spring 包含并管理应用中对象的生命周期和配置。</li>
<li>MVC框架：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。</li>
<li>事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。</li>
<li>异常处理：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常。</li>
</ul>
<h2 id="Spring的两种IOC容器——BeanFactory和ApplicationContext"><a href="#Spring的两种IOC容器——BeanFactory和ApplicationContext" class="headerlink" title="Spring的两种IOC容器——BeanFactory和ApplicationContext"></a>Spring的两种IOC容器——BeanFactory和ApplicationContext</h2><p>Spring 容器是 Spring 框架的核心。容器将创建对象，把它们连接在一起，配置它们，并管理他们的整个生命周期从创建到销毁。Spring 容器使用依赖注入（DI）来管理组成一个应用程序的组件。这些对象被称为 Spring Beans.</p>
<p>通过阅读配置元数据提供的指令，容器知道对哪些对象进行实例化，配置和组装。配置元数据可以通过 XML，Java 注释或 Java 代码来表示。下图是 Spring 如何工作的高级视图。 </p>
<p><img src="https://i.loli.net/2020/03/25/nEIgC9TfwFkYr1s.png" alt="Spring如何工作的高级视图.png"></p>
<p>Spring IoC 容器利用 Java 的 POJO 类和配置元数据来生成完全配置和可执行的系统或应用程序。</p>
<p>Spring提供了两种不同类型的容器：</p>
<ul>
<li><strong>BeanFactory容器</strong>，最简单的容器(太简单了，功能实现比较少，不推荐了)，给DI提供了基本支持。</li>
<li><strong>ApplicationContext容器</strong>，该容器添加了更多的企业特定的功能，例如从一个属性文件中解析文本信息的能力，发布应用程序事件给感兴趣的事件监听器的能力。该容器是由 org.springframework.context.ApplicationContext 接口定义。</li>
</ul>
<p><strong>ApplicationContext 容器包括 BeanFactory 容器的所有功能，所以通常建议使用 ApplicationContext。BeanFactory 仍然可以用于轻量级的应用程序，如移动设备或基于 applet 的应用程序，其中它的数据量和速度是显著。</strong></p>
<h3 id="Spring的基本模块——BeanFactory-BeanFactory容器"><a href="#Spring的基本模块——BeanFactory-BeanFactory容器" class="headerlink" title="Spring的基本模块——BeanFactory(BeanFactory容器)"></a>Spring的基本模块——BeanFactory(BeanFactory容器)</h3><p>BeanFactory是基本的Spring模块，提供spring 框架的基础功能，BeanFactory 是 任何以spring为基础的应用的核心。Spring 框架建立在此模块之上，它使Spring成为一个容器。</p>
<p>Bean 工厂是工厂模式的一个实现，提供了控制反转功能，用来把应用的配置和依赖从真正的应用代码中分离。</p>
<p>最常用的BeanFactory 实现是<strong>XmlBeanFactory</strong> 类。即org.springframework.beans.factory.xml.XmlBeanFactory ，它根据XML文件中的定义加载beans。这个容器从一个 XML 文件中读取配置元数据，由这些元数据来生成一个被配置化的系统或者应用。</p>
<p>需要注意，在资源宝贵的移动设备或者基于 applet 的应用当中， BeanFactory 会被优先选择。否则，一般使用的是 ApplicationContext，除非你有更好的理由选择 BeanFactory。</p>
<h3 id="ApplicationContext是什么？通常的实现是什么"><a href="#ApplicationContext是什么？通常的实现是什么" class="headerlink" title="ApplicationContext是什么？通常的实现是什么?"></a>ApplicationContext是什么？通常的实现是什么?</h3><p><em>Application Context</em> 是 spring 中较高级的容器。和 BeanFactory 类似，它可以加载配置文件中定义的 bean，将所有的 bean 集中在一起，当有请求的时候分配 bean。 另外，它增加了企业所需要的功能，比如，从属性文件从解析文本信息和将事件传递给所指定的监听器。这个容器在 <em>org.springframework.context.ApplicationContext interface</em> 接口中定义。</p>
<ul>
<li><strong>FileSystemXmlApplicationContext</strong> ：此容器从一个<strong>XML文件</strong>中加载已被定义的bean。在这里，你<font color=#FF0000>需要提供给构造器 XML 文件的完整路径</font></li>
<li><strong>ClassPathXmlApplicationContext</strong>：该容器从 XML 文件中加载已被定义的 bean。在这里，你<font color=#FF0000>不需要提供 XML 文件的完整路径</font>，只需正确配置 CLASSPATH 环境变量即可，因为，容器会从 CLASSPATH 中搜索 bean 配置文件。</li>
<li><strong>WebXmlApplicationContext</strong>：此容器加载一个XML文件，此文件定义了一个WEB应用的所有bean。</li>
</ul>
<h3 id="BeanFactory和ApplicationContext有什么区别？"><a href="#BeanFactory和ApplicationContext有什么区别？" class="headerlink" title="BeanFactory和ApplicationContext有什么区别？"></a>BeanFactory和ApplicationContext有什么区别？</h3><p>ApplicationContext 包含 BeanFactory 所有的功能，一般情况下，相对于 BeanFactory，ApplicationContext 会被推荐使用。BeanFactory 仍然可以在轻量级应用中使用，比如移动设备或者基于 applet 的应用程序。</p>
<h2 id="解释对象-关系映射集成模块"><a href="#解释对象-关系映射集成模块" class="headerlink" title="解释对象/关系映射集成模块"></a>解释对象/关系映射集成模块</h2><p>Spring 通过提供ORM模块，支持我们在直接JDBC之上使用一个对象/关系映射映射(ORM)工具，Spring 支持集成主流的ORM框架，如Hiberate,JDO和 iBATIS SQL Maps。Spring的事务管理同样支持以上所有ORM框架及JDBC</p>
<h1 id="Spring-Bean"><a href="#Spring-Bean" class="headerlink" title="Spring Bean"></a>Spring Bean</h1><h2 id="Spring-Bean是什么"><a href="#Spring-Bean是什么" class="headerlink" title="Spring Bean是什么"></a>Spring Bean是什么</h2><p>被称作 bean 的对象是构成应用程序的支柱也是由 Spring IoC 容器管理的。<strong>bean 是一个被实例化，组装，并通过 Spring IoC 容器所管理的对象</strong>。这些 bean 是由用容器提供的配置元数据创建。</p>
<h2 id="一个Spring-Bean定义包含什么"><a href="#一个Spring-Bean定义包含什么" class="headerlink" title="一个Spring Bean定义包含什么"></a>一个Spring Bean定义包含什么</h2><p>bean 定义包含称为<strong>配置元数据</strong>的信息。</p>
<p>Spring IOC容器管理Bean时，需要了解Bean的类名、名称、依赖项、属性、生命周期及作用域等信息。为此，Spring IOC提供了一系列配置项，用于Bean在IOC容器中的定义。已创建的Bean类需要在Spring配置文件中进行定义，Spring IOC容器才能对Bean进行组配和管理。</p>
<p>一些配置项如下表所示：</p>
<p><img src="https://i.loli.net/2020/03/25/PWQAFcpv4hqM9Ze.png" alt="bean的一些配置项.png"></p>
<h2 id="Spring-Bean加载机制"><a href="#Spring-Bean加载机制" class="headerlink" title="Spring Bean加载机制"></a>Spring Bean加载机制</h2><p>将Bean类添加到Spring IOC容器有三种方式</p>
<ul>
<li>一种方式是基于XML的配置文件；(现在很不推荐用，太久远了)</li>
<li>一种方式是基于注解的配置(Annotation-based configuration，从Spring2.5开始)；</li>
<li>一种方式是基于Java的配置(java-based configuration, 从Spring3.0开始)</li>
</ul>
<h2 id="Spring-Bean的生命周期-重要"><a href="#Spring-Bean的生命周期-重要" class="headerlink" title="Spring Bean的生命周期(重要)"></a>Spring Bean的生命周期(重要)</h2><p>理解 Spring bean 的生命周期很容易。当一个 bean 被实例化时，它可能需要执行一些初始化使它转换成可用状态。同样，当 bean 不再需要，并且从容器中移除时，可能需要做一些清除工作。</p>
<p>尽管还有一些在 Bean 实例化和销毁之间发生的活动，但是本章将只讨论两个重要的生命周期回调方法，它们在 bean 的初始化和销毁的时候是必需的。</p>
<p>为了定义安装和拆卸一个 bean，我们只要声明带有 init-method 和/或 destroy-method 参数的 。init-method 属性指定一个方法，在实例化 bean 时，立即调用该方法。同样，destroy-method 指定一个方法，只有从容器中移除 bean 之后，才能调用该方法。</p>
<p>简而言之，Spring Bean的生命周期可以分为九步：</p>
<p><a href="https://blog.csdn.net/w_linux/article/details/80086950?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">参考文章：Spring了解Bean的一生(生命周期)</a></p>
<p><a href="https://www.jianshu.com/p/3944792a5fff" target="_blank" rel="noopener">Spring Bean的生命周期</a> **,这篇文章也包含案例</p>
<h3 id="ApplicationContext-Bean的生命周期"><a href="#ApplicationContext-Bean的生命周期" class="headerlink" title="ApplicationContext Bean的生命周期"></a>ApplicationContext Bean的生命周期</h3><p><img src="https://i.loli.net/2020/03/25/HypdfUSJNYqAEzG.png" alt="ApplicationContextBean的生命周期.png"></p>
<p>ApplicationContext容器中，Bean的生命周期流程如上图所示，流程大致如下：</p>
<p>1.首先容器启动后，会对scope为singleton且非懒加载的bean进行实例化，</p>
<p>2.按照Bean定义信息配置信息，注入所有的属性，</p>
<p>3.如果Bean实现了BeanNameAware接口，会回调该接口的setBeanName()方法，传入该Bean的id，此时该Bean就获得了自己在配置文件中的id，</p>
<p>4.如果Bean实现了BeanFactoryAware接口,会回调该接口的setBeanFactory()方法，传入该Bean的BeanFactory，这样该Bean就获得了自己所在的BeanFactory，</p>
<p>5.如果Bean实现了ApplicationContextAware接口,会回调该接口的setApplicationContext()方法，传入该Bean的ApplicationContext，这样该Bean就获得了自己所在的ApplicationContext，</p>
<p>6.如果有Bean实现了BeanPostProcessor接口，则会回调该接口的postProcessBeforeInitialzation()方法，</p>
<p>7.如果Bean实现了InitializingBean接口，则会回调该接口的afterPropertiesSet()方法，</p>
<p>8.如果Bean配置了init-method方法，则会执行init-method配置的方法，</p>
<p>9.如果有Bean实现了BeanPostProcessor接口，则会回调该接口的postProcessAfterInitialization()方法，</p>
<p>10.经过流程9之后，就可以正式使用该Bean了,对于scope为singleton的Bean,Spring的ioc容器中会缓存一份该bean的实例，而对于scope为prototype的Bean,每次被调用都会new一个新的对象，期生命周期就交给调用方管理了，不再是Spring容器进行管理了</p>
<p>11.容器关闭后，如果Bean实现了DisposableBean接口，则会回调该接口的destroy()方法，</p>
<p>12.如果Bean配置了destroy-method方法，则会执行destroy-method配置的方法，至此，整个Bean的生命周期结束</p>
<h3 id="BeanFactory-Bean的生命周期"><a href="#BeanFactory-Bean的生命周期" class="headerlink" title="BeanFactory Bean的生命周期"></a>BeanFactory Bean的生命周期</h3><p><img src="https://i.loli.net/2020/03/25/NU6EPjKc7n2To1L.png" alt="BeanFactory Bean生命周期.png"></p>
<p>BeanFactoty容器中, Bean的生命周期如上图所示，与ApplicationContext相比，有如下几点不同:</p>
<p>1.BeanFactory容器中，不会调用ApplicationContextAware接口的setApplicationContext()方法，</p>
<p>2.BeanPostProcessor接口的postProcessBeforeInitialzation()方法和postProcessAfterInitialization()方法不会自动调用，必须自己通过代码手动注册</p>
<p>3.BeanFactory容器启动的时候，不会去实例化所有Bean,包括所有scope为singleton且非懒加载的Bean也是一样，而是在调用的时候去实例化。</p>
<h2 id="哪些是重要的bean生命周期方法？-你能重载它们吗？-setup和teardown"><a href="#哪些是重要的bean生命周期方法？-你能重载它们吗？-setup和teardown" class="headerlink" title="哪些是重要的bean生命周期方法？ 你能重载它们吗？(setup和teardown)"></a>哪些是重要的bean生命周期方法？ 你能重载它们吗？(setup和teardown)</h2><p>有两个重要的bean 生命周期方法，第一个是setup ， 它是在容器加载bean的时候被调用。第二个方法是 teardown  它是在容器卸载类的时候被调用。</p>
<p>bean 标签有两个重要的属性（init-method和destroy-method）。用它们你可以自己定制初始化和注销方法。它们也有相应的注解（@PostConstruct和@PreDestroy）。</p>
<p>换句话说：为了定义安装和拆卸一个 bean，我们只要声明带有 init-method 和/或 destroy-method 参数的 。init-method 属性指定一个方法(setup)，在实例化 bean 时，立即调用该方法。同样，destroy-method 指定一个方法(teardown)，只有从容器中移除 bean 之后，才能调用该方法。</p>
<h2 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h2><p>在IoC容器启动之后，并不会马上就实例化相应的bean，此时容器仅仅拥有所有对象的BeanDefinition(BeanDefinition：是容器依赖某些工具加载的XML配置信息进行解析和分析，并将分析后的信息编组为相应的BeanDefinition)。只有当getBean()调用时才是有可能触发Bean实例化阶段的活动。</p>
<p>当在 Spring 中定义一个 时，你必须声明该 bean 的作用域的选项。例如，为了强制 Spring 在每次需要时都产生一个新的 bean 实例，你应该声明 bean 的作用域的属性为 prototype。同理，如果你想让 Spring 在每次需要时都返回同一个bean实例，你应该声明 bean 的作用域的属性为 singleton。</p>
<p>Spring 框架支持以下五个作用域，如果你使用 web-aware ApplicationContext 时，其中三个是可用的。</p>
<p>如下表：</p>
<p><img src="https://i.loli.net/2020/03/25/iJZPArWfomIY9M6.png" alt="Bean的作用域.png"></p>
<h2 id="Spring框架中的单例bean是线程安全的么？"><a href="#Spring框架中的单例bean是线程安全的么？" class="headerlink" title="Spring框架中的单例bean是线程安全的么？"></a>Spring框架中的单例bean是线程安全的么？</h2><p>不是，Spring框架中的单例bean不是线程安全的。</p>
<h2 id="Spring-Bean小结"><a href="#Spring-Bean小结" class="headerlink" title="Spring Bean小结"></a>Spring Bean小结</h2><p>项目中的<strong>事务处理组件</strong>和<strong>实体类</strong>（POJO）可以作为Bean类，Bean类需要在Spring配置文件中进行定义，才能被IOC容器管理和组配。Spring IOC容器管理Bean时，需要了解Bean的<strong>类名、名称、依赖项、属性、生命周期及作用域等</strong>信息。为此，Spring IOC提供了一系列配置项，用于Bean在IOC容器中的定义。</p>
<h1 id="Spring-IOC-也称为依赖注入-DI"><a href="#Spring-IOC-也称为依赖注入-DI" class="headerlink" title="Spring IOC(也称为依赖注入(DI))"></a>Spring IOC(也称为依赖注入(DI))</h1><h2 id="Spring-IOC原理"><a href="#Spring-IOC原理" class="headerlink" title="Spring IOC原理"></a>Spring IOC原理</h2><p>IOC:控制反转也叫依赖注入。利用了<strong>工厂模式</strong></p>
<p>将对象交给容器管理，你只需要在spring配置文件总配置相应的bean，以及设置相关的属性，让spring容器来生成类的实例对象以及管理对象。在spring容器启动的时候，spring会把你在配置文件中配置的bean都初始化好，然后在你需要调用的时候，就把它已经初始化好的那些bean分配给你需要调用这些bean的类（假设这个类名是A），分配的方法就是调用A的setter方法来注入，而不需要你在A里面new这些bean了。</p>
<h2 id="什么是Spring的依赖注入？"><a href="#什么是Spring的依赖注入？" class="headerlink" title="什么是Spring的依赖注入？"></a>什么是Spring的依赖注入？</h2><p>依赖注入，是IOC的一个方面，是个通常的概念，它有多种解释。这概念是说你不用创建对象，而只需要描述它如何被创建。你不在代码里直接组装你的组件和服务，但是要在配置文件里描述哪些组件需要哪些服务，之后一个容器（IOC容器）负责把他们组装起来。</p>
<p>拿公司招聘岗位来举例。假设一个公司有产品、研发、测试等岗位。如果是公司根据岗位要求，逐个安排人选，如图中向下的箭头，这是正向流程。如果反过来，不用公司来安排候选人，而是由第三方猎头来匹配岗位和候选人，然后进行推荐，这就是控制反转。</p>
<h2 id="Spring-IOC容器是什么？"><a href="#Spring-IOC容器是什么？" class="headerlink" title="Spring IOC容器是什么？"></a>Spring IOC容器是什么？</h2><p>Spring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。</p>
<p>简而言之：“把某些业务对象的的控制权交给一个平台或者框架来统一管理，这个统一管理的平台可以称为IoC容器。”</p>
<p>举个例子：看下面这段代码：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">ApplicationContext appContext = <span class="keyword">new</span> <span class="constructor">ClassPathXmlApplicationContext(<span class="string">"cjj/models/beans.xml"</span>)</span>;</span><br><span class="line">Person p = (Person)appContext.get<span class="constructor">Bean(<span class="string">"person"</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码中，在创建ApplicationContext实例对象过程中会创建一个spring容器，该容器会读取配置文件”cjj/models/beans.xml”,并统一管理由该文件中定义好的所有bean实例对象，如果要获取某个bean实例，使用getBean方法就行了。例如我们只需要将Person提前配置在beans.xml文件中（可以理解为注入），之后我们可以不需使用new Person()的方式创建实例，而是通过容器来获取Person实例，这就相当于将Person的控制权交由spring容器了，差不多这就是控制反转的概念。</p>
<h2 id="Spring-IOC的优点？"><a href="#Spring-IOC的优点？" class="headerlink" title="Spring IOC的优点？"></a>Spring IOC的优点？</h2><p>IOC 或 依赖注入把应用的代码量降到最低。它使应用容易测试，单元测试不再需要单例和JNDI查找机制。最小的代价和最小的侵入性使松散耦合得以实现。IOC容器支持加载服务时的饿汉式初始化和懒加载。</p>
<h2 id="SpringIOC初始化过程-重要"><a href="#SpringIOC初始化过程-重要" class="headerlink" title="SpringIOC初始化过程(重要)"></a>SpringIOC初始化过程(重要)</h2><p>详细来说，其实Spring IOC初始化过程就是容器的初始化过程。</p>
<p>之前介绍Spring Bean的时候已经提到了，Spring Bean都是由Spring容器去管理的，而Spring主要有两个容器系列：</p>
<ol>
<li>实现BeanFactory接口的简单容器；</li>
<li>实现ApplicationContext接口的高级容器。</li>
</ol>
<p>ApplicationContext比较复杂，它不但继承了BeanFactory的大部分属性，还继承其它可扩展接口，扩展的了许多高级的属性，其接口定义如下：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">ApplicationContext</span> <span class="symbol">extends</span> <span class="symbol">EnvironmentCapable</span>, </span><br><span class="line">　　　　　　　　　　　　　　　　　　<span class="symbol">ListableBeanFactory</span>,    //继承于<span class="symbol">BeanFactory</span></span><br><span class="line">　　　　　　　　　　　　　　　　　　<span class="symbol">HierarchicalBeanFactory</span>,//继承于<span class="symbol">BeanFactory</span></span><br><span class="line">　　　　　　　　　　　　　　　　　　<span class="symbol">MessageSource</span>,            //</span><br><span class="line">　　　　　　　　　　　　　　　　　　<span class="symbol">ApplicationEventPublisher</span>,//</span><br><span class="line">　　　　　　　　　　　　　　　　　　<span class="symbol">ResourcePatternResolver</span>   //继承<span class="symbol">ResourceLoader</span>，用于获取<span class="symbol">resource</span>对象</span><br></pre></td></tr></table></figure>

<p>在BeanFactory子类中有一个DefaultListableBeanFactory类，它包含了基本Spirng IoC容器所具有的重要功能，开发时不论是使用BeanFactory系列还是ApplicationContext系列来创建容器基本都会使用到DefaultListableBeanFactory类，可以这么说，在spring中实际上把它当成默认的IoC容器来使用。</p>
<p>关于Spirng IoC容器的初始化过程在《Spirng技术内幕：深入解析Spring架构与设计原理》一书中有明确的指出，IoC容器的初始化过程可以分为三步：</p>
<ol>
<li><font color=#FF0000>Resource定位（Bean的定义文件定位）</font></li>
<li><font color=#FF0000>将Resource定位好的资源载入到BeanDefinition </font></li>
<li><font color=#FF0000>将BeanDefiniton注册到容器中 </font></li>
</ol>
<p>如下图：</p>
<p><img src="https://i.loli.net/2020/03/25/YNAar5mMChU2Dzc.png" alt="SpringIOC初始化过程.png"></p>
<p><a href="https://www.cnblogs.com/chenjunjie12321/p/6124649.html" target="_blank" rel="noopener">详细内容可以参考这篇博客</a></p>
<p><a href="https://www.javadoop.com/post/spring-ioc" target="_blank" rel="noopener">Spring IOC详细源码分析推荐这篇文章**</a></p>
<h2 id="Spring实现IOC的三种方式"><a href="#Spring实现IOC的三种方式" class="headerlink" title="Spring实现IOC的三种方式"></a>Spring实现IOC的三种方式</h2><h3 id="属性注入"><a href="#属性注入" class="headerlink" title="属性注入"></a>属性注入</h3><p>通过setXXX()方法注入Bean的属性值或者依赖对象，最常用。</p>
<ul>
<li>Spring首先会调用bean的默认构造函数实例化bean对象，然后再通过反射的方法来调用set方法来注入属性值。</li>
<li>属性注入要求bean提供一个默认的构造函数,并且得为需要注入的属性提供set方法</li>
</ul>
<h3 id="构造函数注入-构造器依赖注入"><a href="#构造函数注入-构造器依赖注入" class="headerlink" title="构造函数注入(构造器依赖注入)"></a>构造函数注入(构造器依赖注入)</h3><p>使用构造函数注入的前提是：bean必须提供带参的构造函数。</p>
<p>构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。</p>
<h3 id="工厂方法注入"><a href="#工厂方法注入" class="headerlink" title="工厂方法注入"></a>工厂方法注入</h3><p>注解的方式注入 @Autowired,@Resource,@Required。</p>
<h4 id="Autowired和-Resource的区别-重要"><a href="#Autowired和-Resource的区别-重要" class="headerlink" title="@Autowired和@Resource的区别(重要)"></a>@Autowired和@Resource的区别(重要)</h4><p>简而言之：@Autowired按<code>byType</code>(类型)自动注入，而@Resource则默认按<code>byName</code>(名字)自动注入。</p>
<p>@Autowired是在Spring2.5后引入的，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。 可以通过 @Autowired的使用来消除 set ，get方法。</p>
<p>@Resource有两个属性是比较重要的，分别是<code>name</code>和<code>type</code>，Spring 将@Resource注解的<code>name</code>属性解析为bean的名字，而<code>type</code>属性则解析为bean的类型。因此，如果使用<code>name</code>属性，则使用<code>byName</code>的自动注入策略，而使用<code>type</code>属性时则使用byType自动注入策略。如果既不指定<code>name</code>也不指定<code>type</code>属性，这时将通过反射机制使用<code>byName</code>自动注入策略。</p>
<h1 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h1><p>AOP是一个编程目标，”面向切面编程”的目标。实现这个目标，有哪些手段？——其中一个手段是Spring AOP,还有一个手段是AspectJ。Spring在2.5之后借用了AspectJ的语法，借鉴了其编程风格</p>
<h2 id="为什么需要AOP？"><a href="#为什么需要AOP？" class="headerlink" title="为什么需要AOP？"></a>为什么需要AOP？</h2><p>AOP可以说是对OOP的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。</p>
<p>例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</p>
<blockquote>
<p>将程序中的交叉业务逻辑（比如安全检查，日志，事务管理、缓存、对象池等），封装成一个切面，然后注入到目标对象（具体业务逻辑）中去。</p>
</blockquote>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>之所以这里单独列出来代理模式，主要因为AOP就是通过代理模式实现的(静态代理、动态代理)</p>
<p>代理模式是23种设计模式的一种，他是指一个对象A通过持有另一个对象B，可以具有B同样的行为的模式。为了对外开放协议，B往往实现了一个接口，A也会去实现接口。但是B是“真正”实现类，A则比较“虚”，他借用了B的方法去实现接口的方法。A虽然是“伪军”，但它可以增强B，在调用B的方法前后都做些其他的事情。Spring AOP就是使用了动态代理完成了代码的动态“织入”。</p>
<p>使用代理好处还不止这些，一个工程如果依赖另一个工程给的接口，但是另一个工程的接口不稳定，经常变更协议，就可以使用一个代理，接口变更时，只需要修改代理，不需要一一修改业务代码。从这个意义上说，所有调外界的接口，我们都可以这么做，不让外界的代码对我们的代码有侵入，这叫防御式编程。代理其他的应用可能还有很多。</p>
<p>上述例子中，类A写死持有B，就是B的静态代理。如果A代理的对象是不确定的，就是动态代理。动态代理目前有两种常见的实现，jdk动态代理和cglib动态代理。</p>
<h2 id="AOP实现原理"><a href="#AOP实现原理" class="headerlink" title="AOP实现原理"></a>AOP实现原理</h2><blockquote>
<p>AOP 实现的关键就在于 AOP 框架自动创建的 AOP 代理，AOP 代理则可分为静态代理和动态代理两大类，其中静态代理是指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强；而动态代理则在运行时借助于 JDK 动态代理、CGLIB 等在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。</p>
</blockquote>
<p>实现AOP(不是Spring AOP，而是AOP技术，即Spring AOP和AspectJ)的技术，主要分为两大类：</p>
<ul>
<li>一是采用<strong>动态代理技术</strong>(Spring AOP)，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；</li>
<li>二是采用<strong>静态织入(静态代理)</strong>的方式(AspectJ)，引入特定的语法创建“切面”，从而使得编译器可以在编译期间织入有关“切面”的代码.</li>
</ul>
<p><a href="https://www.jianshu.com/p/fe8d1e8bd63e" target="_blank" rel="noopener">https://www.jianshu.com/p/fe8d1e8bd63e</a></p>
<p><a href="https://www.cnblogs.com/puyangsky/p/6218925.html" target="_blank" rel="noopener">https://www.cnblogs.com/puyangsky/p/6218925.html</a></p>
<p><a href="https://juejin.im/post/5a55af9e518825734d14813f" target="_blank" rel="noopener">https://juejin.im/post/5a55af9e518825734d14813f</a></p>
<h1 id="JDK和CGLib动态代理性能对比"><a href="#JDK和CGLib动态代理性能对比" class="headerlink" title="JDK和CGLib动态代理性能对比"></a>JDK和CGLib动态代理性能对比</h1><p>关于两者之间的性能的话，JDK动态代理所创建的代理对象，在以前的JDK版本中，性能并不是很高，虽然在高版本中JDK动态代理对象的性能得到了很大的提升，但是他也并不是适用于所有的场景。主要体现在如下的两个指标中：</p>
<p>1、CGLib所创建的动态代理对象在实际运行时候的性能要比JDK动态代理高不少，有研究表明，大概要高10倍；</p>
<p>2、但是CGLib在创建对象的时候所花费的时间却比JDK动态代理要多很多，有研究表明，大概有8倍的差距；</p>
<p>3、因此，对于singleton的代理对象或者具有实例池的代理，因为无需频繁的创建代理对象，所以比较适合采用CGLib动态代理，反之，则比较适用JDK动态代理。</p>
<p><a href="https://blog.csdn.net/xlgen157387/article/details/82497594" target="_blank" rel="noopener">Spring AOP中的JDK和CGLib动态代理哪个效率更高？</a></p>
<p><a href="https://blog.csdn.net/flyfeifei66/article/details/81481222" target="_blank" rel="noopener">Java两种动态代理JDK动态代理和CGLIB动态代理</a></p>
<h1 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h1><p>这是Spring针对JDBC来设计的，事务和数据库的事务定义相同。</p>
<p>关于事务，老生常谈的就是ACID，然后三种事务并发可能的问题：脏读、不可重复读、幻读。针对这三种问题，设计了四种解决的隔离级别：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。</p>
<h2 id="Spring-事务中的隔离级别"><a href="#Spring-事务中的隔离级别" class="headerlink" title="Spring 事务中的隔离级别"></a>Spring 事务中的隔离级别</h2><p>而Spring的事务隔离级别就是根据上面四种隔离级别而设置的。加上”默认”的级别，一共有五种级别。具体说，TransactionDeﬁnition 接口中定义了五个表示隔离级别的常量： </p>
<ul>
<li><p><strong>TransactionDeﬁnition.ISOLATION_DEFAULT</strong>: 使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别. </p>
<ul>
<li><strong>TransactionDeﬁnition.ISOLATION_READ_UNCOMMITTED</strong>: 低的隔离级别，允许读取尚未提交的数据变 更，可能会导致脏读、幻读或不可重复读</li>
</ul>
</li>
<li><p><strong>TransactionDeﬁnition.ISOLATION_READ_COMMITTED</strong>: 允许读取并发事务已经提交的数据，可以阻止脏 读，但是幻读或不可重复读仍有可能发生</p>
</li>
<li><p><strong>TransactionDeﬁnition.ISOLATION_REPEATABLE_READ</strong>: 对同一字段的多次读取结果都是一致的，除非数据 是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。 </p>
</li>
<li><p><strong>TransactionDeﬁnition.ISOLATION_SERIALIZABLE</strong>: 高的隔离级别，完全服从ACID的隔离级别。所有的事 务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻 读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。 </p>
</li>
</ul>
<h2 id="Spring事务中的事务传播行为"><a href="#Spring事务中的事务传播行为" class="headerlink" title="Spring事务中的事务传播行为"></a>Spring事务中的事务传播行为</h2><p><strong>支持当前事务的情况</strong>：</p>
<ul>
<li><p>TransactionDeﬁnition.PROPAGATION_REQUIRED： 如果当前存在事务，则加入该事务；如果当前没有事 务，则创建一个新的事务。 </p>
</li>
<li><p>TransactionDeﬁnition.PROPAGATION_SUPPORTS： 如果当前存在事务，则加入该事务；如果当前没有事 务，则以非事务的方式继续运行。 </p>
</li>
<li><p>TransactionDeﬁnition.PROPAGATION_MANDATORY： 如果当前存在事务，则加入该事务；如果当前没有 事务，则抛出异常。（mandatory：强制性）</p>
</li>
</ul>
<p><strong>不支持当前事务的情况：</strong></p>
<ul>
<li><p>TransactionDeﬁnition.PROPAGATION_REQUIRES_NEW： 创建一个新的事务，如果当前存在事务，则把当 前事务挂起。 </p>
</li>
<li><p>TransactionDeﬁnition.PROPAGATION_NOT_SUPPORTED： 以非事务方式运行，如果当前存在事务，则把 当前事务挂起。 </p>
</li>
<li><p>TransactionDeﬁnition.PROPAGATION_NEVER： 以非事务方式运行，如果当前存在事务，则抛出异常。</p>
</li>
</ul>
<p><strong>其他情况：</strong></p>
<ul>
<li>TransactionDeﬁnition.PROPAGATION_NESTED： 如果当前存在事务，则创建一个事务作为当前事务的嵌套 事务来运行；如果当前没有事务，则该取值等价于TransactionDeﬁnition.PROPAGATION_REQUIRED。 </li>
</ul>
<h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><h1 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h1><p>有关Spring可能的问题：</p>
<p><img src="https://i.loli.net/2020/04/01/x5ez82BqCYZptEn.png" alt="SpringBoot知识系统.png"></p>
<p>最常问的问题之一：<strong>SpringBoot的启动流程？</strong></p>
<h2 id="Spring-Boot启动流程"><a href="#Spring-Boot启动流程" class="headerlink" title="Spring Boot启动流程"></a>Spring Boot启动流程</h2><ol>
<li>配置Environment</li>
<li>准备Context上下文，包括执行 ApplicationContext 的后置处理、初始化 Initializer、通知Listener 处理 ContextPrepared 和 ContextLoaded 事件。</li>
<li>执行 refreshContext，也就是前面介绍过的 AbstractApplicationContext 类的 refresh 方法。</li>
</ol>
<p>在SpringBoot中有两种上下文，一种是bootstrap,另外一种是application：</p>
<ul>
<li>bootstrap是应用程序的父上下文，会先于applicaton加载。bootstrap 主要用于从额外的资源来加载配置信息，还可以在本地外部配置文件中解密属性。</li>
<li>bootstrap 里面的属性会优先加载，默认也不能被本地相同配置覆盖。</li>
</ul>
<h2 id="Spring-Boot注解"><a href="#Spring-Boot注解" class="headerlink" title="Spring Boot注解"></a>Spring Boot注解</h2><ul>
<li><p>Starter是SpringBoot提供的无缝集成功能的一种方式，使用某个功能时开发者不需要关注各种依赖库的处理，不需要具体的配置信息，由SpringBoot自动配置进行Bean的创建。例如需要使用 Web 功能时，只需要在依赖中引入 Spring-boot-starter-web 即可。</p>
</li>
<li><p>Actuator 是用来对应用程序进行监视和管理，通过 RESTful API 请求来监管、审计、收集应用的运行情况。</p>
</li>
<li><p>DevTools 提供了一系列开发工具的支持，来提高开发效率。例如热部署能力等。</p>
</li>
<li><p>CLI 就是命令行接口，是一个命令行工具，支持使用 Groovy 脚本，可以快速搭建 Spring 原型项目。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Interview Note</category>
      </categories>
      <tags>
        <tag>Interview</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer fundamental Intergrated Interview-I</title>
    <url>/2020/03/20/Computer-fundamental-Interview-I/</url>
    <content><![CDATA[<blockquote>
<p>知识犹如人体的血液一样宝贵。——高士其</p>
</blockquote>
<a id="more"></a>


<p>其他精彩文章：<a href="https://www.jianshu.com/p/a61f012e84d5" target="_blank" rel="noopener">20+公司面试题总结及补充</a></p>
<h1 id="1-计算机网络"><a href="#1-计算机网络" class="headerlink" title="1.计算机网络"></a>1.计算机网络</h1><h2 id="1-1-HTTPS和HTTP"><a href="#1-1-HTTPS和HTTP" class="headerlink" title="1.1 HTTPS和HTTP"></a>1.1 HTTPS和HTTP</h2><p>HTTP是明文传输，不安全。HTTPS是加密之后的传输方式。</p>
<p>要弄清，先理解对称加密和非对称加密。</p>
<h3 id="对称加密-Symmetric-encryption-和非对称加密-Asymmetric-encryption"><a href="#对称加密-Symmetric-encryption-和非对称加密-Asymmetric-encryption" class="headerlink" title="对称加密(Symmetric encryption)和非对称加密(Asymmetric encryption)"></a>对称加密(Symmetric encryption)和非对称加密(Asymmetric encryption)</h3><h4 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h4><p>对称加密：在每次发送真实数据之前，服务器先生成一把密钥，然后先把密钥传输给客户端。之后服务器给客户端发送真实数据的时候，会用这把密钥对数据进行加密，客户端收到加密数据之后，用刚才收到的密钥进行解密。</p>
<p>如图：</p>
<p><img src="https://i.loli.net/2020/03/18/G9r3NBHycJA5Cts.png" alt="对称加密.png"></p>
<p>这里只画了服务器传送数据给客户端的情况，暂时只考虑这个单向，其实是一样的。</p>
<p>但是这里有一个<strong>致命</strong>的问题，就是秘钥在传输过程中会是以明文方式传输的，在传输过程中可能被拦截。(这也是二战时期图灵能够破解德军军情的原因)</p>
<p>具体来说：假如服务器用明文的方式传输密钥给客户端，然后密钥被中间人给捕获了，那么在之后服务器和客户端的加密传输过程中，中间人也可以用他捕获的密钥进行解密。这样的话，加密的数据在中间人看来和明文没啥两样。</p>
<p>所以对称加密的问题出在<strong>如何把秘钥安全地给客户端</strong>。</p>
<h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><p>让客户端和服务器都拥有两把钥匙，一个用来加密(公钥)，一个用来解密(私钥)。这两把钥匙一般都会用RSA Algorithm来生成。在通信之前不需要先同步秘钥，避免了在同步私钥过程中被黑客盗取信息的风险。</p>
<p>一把钥匙是公开的(全世界知道都没关系)，我们称之为<strong>公钥</strong>；另一把钥匙则是保密的(只有自己本人才知道)，我们称之为<strong>私钥</strong>。</p>
<p>虽然有一点违反常识，但是非对称加密能够做到：用公钥加密的原文，原公钥无法解密，只能用对应的私钥解密。</p>
<p>可以通过私钥计算出公钥，但是无法用公钥推导出私钥。</p>
<p>这且，<strong>用公钥加密的数据，只有<font color=#FF0000>对应的私钥</font>才能解密；用私钥加密的数据，只有<font color=#FF0000>对应的公钥</font>才能解密</strong>。</p>
<p>按照这个思路，服务器在给客户端传输数据的过程中，可以用客户端明文给他的公钥进行加密，然后客户端收到后，再用自己的私钥进行解密。客户端给服务器发送数据的时候也一样采取这样的方式。这样就能保持数据的安全传输了。</p>
<p>图解如下：</p>
<p><img src="https://i.loli.net/2020/03/18/Wspjk3vbEQzdScf.png" alt="非对称加密.png"></p>
<p>但是非对称加密在加密的时候速度比对称加密慢上百倍，所以直接用非对称加密的话效率很低。</p>
<p>因为对称加密不安全的主要原因是密钥无法安全交付给客户端，所以我们可以用非对称加密的方式传输加密过程中的密钥，之后我们就可以采取对称加密的方式来传输数据了。</p>
<p>具体做法：服务器用明文的方式给客户端发送自己的公钥，客户端收到公钥之后，会生成一把密钥(对称加密用的)，然后用服务器的公钥对这把密钥进行加密，之后再把密钥传输给服务器，服务器收到之后进行解密，最后服务器就可以安全着得到这把密钥了，而客户端也有同样一把密钥，他们就可以进行对称加密了。</p>
<p>但是非对称加密也不能保证安全，举个例子：</p>
<p>服务器以明文的方式给客户端传输公钥的时候，中间人截取了这把属于服务器的公钥，并且把<strong>中间人自己的公钥冒充服务器的公钥</strong>传输给了客户端。</p>
<p>之后客户端就会用中间人的公钥来加密自己生成的密钥。然后把被加密的密钥传输给服务器，这个时候中间人又<strong>把密钥给截取了</strong>，中间人用自己的私钥对这把被加密的密钥进行解密，解密后中间人就可以获得这把密钥了。</p>
<p>最后中间人再对这把密钥用刚才服务器的公钥进行加密，再发给服务器。如图：</p>
<p><img src="https://i.loli.net/2020/03/18/uoacZHrNE1MUzmF.png" alt="非对称加密的不安全性.png"></p>
<p>在这个过程中，中间人获取了对称加密中的密钥，在之后服务器和客户端的对称加密传输中，这些加密的数据对中间人来说，和明文没啥区别。</p>
<p>具体说来，非对称加密的不安全的原因主要是客户端不知道这把公钥是不是属于服务器的。</p>
<p>解决方法：数字证书。</p>
<h4 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h4><p>之所以非对称加密会不安全，是因为客户端不知道这把公钥是否是服务器的，因此，我们需要找到一种策略来证明这把公钥就是服务器的，而不是别人冒充的。</p>
<p>解决这个问题的方式就是使用数字证书，具体是这样的：</p>
<p>我们需要找到一个拥有公信力、大家都认可的认证中心(CA)。</p>
<p>服务器在给客户端传输公钥的过程中，会把公钥以及服务器的个人信息通过Hash算法生成信息摘要。</p>
<p>如图：</p>
<p><img src="https://i.loli.net/2020/03/18/sCcTNa9eULfPwpI.png" alt="服务器生成信息摘要.png"></p>
<p>为了防止信息摘要被调换，CA会提供私钥给服务器，服务器会用这个CA给的私钥来加密得到<strong>数字签名</strong>。</p>
<p>如图：</p>
<p><img src="https://i.loli.net/2020/03/18/p96xDFSVn3YXCUj.png" alt="服务器生成数字签名.png"></p>
<p>在生成了数字签名之后，服务端会把所有信息合成在一起，成为<strong>数字证书</strong>。</p>
<p><img src="https://i.loli.net/2020/03/18/tZbqOCITSged1z8.png" alt="合成数字签名等内容为数字证书.png"></p>
<p>客户端拿到证书之后，为了确认发送者确实是服务端，会利用CA给的公钥来对数字证书里面的数字签名进行解密来得到<strong>信息摘要</strong>，然后对数字证书里服务器的公钥以及个人信息进行Hash得到<strong>另外一份信息摘要</strong>，最后比较两者，相同，才能确认这份证书是服务端发送的，否则很可能被人动过手脚。</p>
<p><img src="https://i.loli.net/2020/03/18/xDHKZlhciMgfdNG.png" alt="客户端进行解析对比.png"></p>
<p>由此，可以保证服务器的公钥安全地交给了客户端。</p>
<h4 id="CA的公钥如何拿给客户端？服务器如何获得CA私钥？"><a href="#CA的公钥如何拿给客户端？服务器如何获得CA私钥？" class="headerlink" title="CA的公钥如何拿给客户端？服务器如何获得CA私钥？"></a>CA的公钥如何拿给客户端？服务器如何获得CA私钥？</h4><p>服务器一开始会向CA申请特定私钥。客户端很多浏览器都支持HTTPS方式，也都申请了证书。</p>
<p>更加形象的讲解内容可以参考<a href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&mid=2247485749&idx=1&sn=77f79a358ed59fd45f9b9dab68cfa34c&scene=21#wechat_redirect" target="_blank" rel="noopener">什么是数字签名</a></p>
<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>数字签名详解，参考<a href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&mid=2247485749&idx=1&sn=77f79a358ed59fd45f9b9dab68cfa34c&scene=21#wechat_redirect" target="_blank" rel="noopener">这篇文章</a></p>
<h3 id="SSL-TLS协议"><a href="#SSL-TLS协议" class="headerlink" title="SSL/TLS协议"></a>SSL/TLS协议</h3><p>SSL 即安全套接字层，它在 OSI 七层网络模型中处于第五层(网络层)</p>
<p>TLS 用于两个通信应用程序之间提供保密性和数据完整性。TLS 由记录协议、握手协议、警告协议、变更密码规范协议、扩展协议等几个子协议组成，综合使用了对称加密、非对称加密、身份认证等许多密码学前沿技术。</p>
<p>TLS 在根本上使用对称加密和 非对称加密 两种形式。</p>
<p>HTTPS在使用SSL/TLS传输的过程中，先会用非对称加密，然后用对称加密，也就是所谓的<strong>混合加密</strong>。</p>
<p>实际上混合加密在上面，优化非对称加密传输的过程中已经有详细介绍了。因为非对称加密算法(比如RSA)计算非常慢，而对称加密算法(比如AES)计算相对非对称快上一百倍，所以先用非对称加密算法，先用非对称加密解决<strong>秘钥交换</strong>的问题，然后用随机数产生对称算法使用的<code>会话密钥（session key）</code>，再用<code>公钥加密</code>。对方拿到密文后用<code>私钥解密</code>，取出会话密钥。这样，双方就实现了对称密钥的安全交换。</p>
<h3 id="HTTP状态码？-1开头到5开头的各种典型状态码"><a href="#HTTP状态码？-1开头到5开头的各种典型状态码" class="headerlink" title="HTTP状态码？(1开头到5开头的各种典型状态码)"></a>HTTP状态码？(1开头到5开头的各种典型状态码)</h3><p>客户端的每一次请求，服务器都必须给出回应。回应包括 HTTP 状态码和数据两部分。</p>
<p>HTTP 状态码就是一个三位数，一共有五种取值可能：</p>
<ul>
<li>1xx：指示信息——表示请求已经接收，继续处理，<font color=#FF0000>但是整个请求还没成功</font></li>
<li>2xx：成功——表示请求已被成功接收、理解、接受，已经成功处理了请求的状态代码</li>
<li>3xx：重定向——要完成请求，但是需要进一步操作(往往要再跳转一步)</li>
<li>4xx：客户端错误——请求有语法错误或请求无法实现</li>
<li>5xx：服务器错误——服务器未能实现合法的请求，表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求的错误。</li>
</ul>
<p>常见HTTP状态码及其作用：</p>
<p>200 OK：正常返回信息</p>
<p>400 Bad Request：客户端请求有语法错误，不能被服务器所理解</p>
<p>401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用</p>
<p>403 Forbidden：服务器收到请求，但拒绝提供服务(比如IP被禁了)</p>
<p>404 Note Found：请求资源不存在，eg.输入了错误的URL</p>
<p>500 Internal Server Error：服务器发生不可预期的错误</p>
<p>503 Server Unabaliable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常</p>
<h3 id="什么是HTTP的长连接和短连接？"><a href="#什么是HTTP的长连接和短连接？" class="headerlink" title="什么是HTTP的长连接和短连接？"></a>什么是HTTP的长连接和短连接？</h3><p><strong>短连接(HTTP/1.0中默认使用短连接)</strong>：客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中 断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像 文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。 </p>
<p>从<strong>HTTP/1.1起，默认使用长连接，用以保持连接特性</strong>。使用长连接的HTTP协议，会在响应头加入这行代码：</p>
<p><code>Connection:keep-alive</code></p>
<p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客 户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时 间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p>
<p>实际上，<strong>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接</strong>。</p>
<h3 id="一些可能有用的与HTTP有关的协议"><a href="#一些可能有用的与HTTP有关的协议" class="headerlink" title="一些可能有用的与HTTP有关的协议"></a>一些可能有用的与HTTP有关的协议</h3><p>在互联网中，任何协议都不会单独的完成信息交换，HTTP 也一样。虽然 HTTP 属于应用层的协议，但是它仍然需要其他层次协议的配合完成信息的交换，那么在完成一次 HTTP 请求和响应的过程中，需要哪些协议的配合呢？一起来看一下</p>
<h4 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h4><p>CDN的全称是<code>Content Delivery Network</code>，即<code>内容分发网络</code>，它应用了 HTTP 协议里的缓存和代理技术，代替源站响应客户端的请求。CDN 是构建在现有网络基础之上的网络，它依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有<code>内容存储</code>和<code>分发技术</code>。</p>
<p>打比方说你要去亚马逊上买书，之前你只能通过购物网站购买后从美国发货过海关等重重关卡送到你的家里，现在在中国建立一个亚马逊分基地，你就不用通过美国进行邮寄，从中国就能把书尽快给你送到。</p>
<h4 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h4><p>TCP/IP 我们一般称之为协议簇，什么意思呢？就是 TCP/IP 协议簇中不仅仅只有 TCP 协议和 IP 协议，它是一系列网络通信协议的统称。而其中最核心的两个协议就是 TCP / IP 协议，其他的还有 UDP、ICMP、ARP 等等，共同构成了一个复杂但有层次的协议栈。</p>
<p><font color=#FF0000>HTTP 使用 TCP 作为通信协议</font>，这是因为 TCP 是一种可靠的协议，而可靠能保证数据不丢失。</p>
<h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>计算机网络中的每个端系统都有一个 IP 地址存在，而把 IP 地址转换为便于人类记忆的协议就是 DNS 协议。</p>
<p>DNS 的全称是域名系统<code>（Domain Name System，缩写：DNS）</code>，它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。</p>
<h4 id="URI-URL"><a href="#URI-URL" class="headerlink" title="URI/URL"></a>URI/URL</h4><p>我们上面提到，你可以通过输入 <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> 地址来访问谷歌的官网，那么这个地址有什么规定吗？我怎么输都可以？AAA.BBB.CCC 是不是也行？当然不是的，你输入的地址格式必须要满足 URI 的规范。</p>
<p>URI的全称是（Uniform Resource Identifier），中文名称是统一资源标识符，使用它就能够唯一地标记互联网上资源。</p>
<p>URL的全称是（Uniform Resource Locator），中文名称是统一资源定位符，也就是我们俗称的网址，它实际上是 URI 的一个子集。</p>
<p>URI 不仅包括 URL，还包括 URN（统一资源名称），它们之间的关系如下</p>
<p><img src="https://i.loli.net/2020/03/18/nUXIerAGEjt1Fbo.png" alt="URLURI示意图.png"></p>
<h4 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h4><p>之前讲了很多了，重点是HTTPS和HTTP的区别：</p>
<p>HTTPS 和 HTTP 有很大的不同在于 HTTPS 是以安全为目标的 HTTP 通道，在 HTTP 的基础上通过传输加密和身份认证保证了传输过程的安全性。HTTPS 在 HTTP 的基础上增加了 SSL 层，也就是说 HTTPS = HTTP + SSL</p>
<h3 id="输入一个URL之后，整个请求过程是怎样的？"><a href="#输入一个URL之后，整个请求过程是怎样的？" class="headerlink" title="输入一个URL之后，整个请求过程是怎样的？"></a>输入一个URL之后，整个请求过程是怎样的？</h3><p>举例，访问地址为 <a href="http://www.someSchool.edu/someDepartment/home.index" target="_blank" rel="noopener">http://www.someSchool.edu/someDepartment/home.index</a></p>
<p>一共六步</p>
<ol>
<li>DNS服务器会首先进行域名的映射，找到访问<a href="http://www.someSchool.edu所在的地址，然后HTTP" target="_blank" rel="noopener">www.someSchool.edu所在的地址，然后HTTP</a> 客户端进程在 80 端口发起一个到服务器 <a href="http://www.someSchool.edu" target="_blank" rel="noopener">www.someSchool.edu</a> 的 TCP 连接（80 端口是 HTTP 的默认端口）。在客户和服务器进程中都会有一个套接字与其相连。</li>
<li>HTTP 客户端通过它的套接字向服务器发送一个 HTTP 请求报文。该报文中包含了路径 someDepartment/home.index 的资源，我们后面会详细讨论 HTTP 请求报文。</li>
<li>HTTP 服务器通过它的套接字接受该报文，进行请求的解析工作，并从其存储器(RAM 或磁盘)中检索出对象 <a href="http://www.someSchool.edu/someDepartment/home.index，然后把检索出来的对象进行封装，封装到" target="_blank" rel="noopener">www.someSchool.edu/someDepartment/home.index，然后把检索出来的对象进行封装，封装到</a> HTTP 响应报文中，并通过套接字向客户进行发送。</li>
<li>HTTP 服务器随即通知 TCP 断开 TCP 连接，实际上是需要等到客户接受完响应报文后才会断开 TCP 连接。</li>
<li>HTTP 客户端接受完响应报文后，TCP 连接会关闭。HTTP 客户端从响应中提取出报文中是一个 HTML 响应文件，并检查该 HTML 文件，然后循环检查报文中其他内部对象。</li>
<li>检查完成后，HTTP 客户端会把对应的资源通过显示器呈现给用户。</li>
</ol>
<p>这是个简单的例子，详细的例子可以参考<a href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&mid=2247485074&idx=1&sn=f4e44c4b675adc6e13b4704839c5a19d&scene=21#wechat_redirect" target="_blank" rel="noopener">这篇文章</a></p>
<h3 id="GET和POST报文形式"><a href="#GET和POST报文形式" class="headerlink" title="GET和POST报文形式"></a>GET和POST报文形式</h3><p>实际上HTTP的响应报文结构都是一样的，GET和POST只是会体现在协议版本的地方不同而已。</p>
<p>分为请求行、响应头、响应正文几个部分。每次响应可以没有正文，但是必须有请求头。注意请求头后面会空出来一行，再开始响应正文。</p>
<p>如下图：<br><img src="https://s2.ax1x.com/2020/02/28/30Hs3D.png" alt="HTTP响应报文"></p>
<p>一个例子：</p>
<p><img src="https://i.loli.net/2020/03/19/5B9UPNkcjZohXAv.png" alt="一个实例.png"></p>
<h3 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h3><p>可以从三个层面解释：</p>
<ul>
<li>HTTP报文层面：GET将请求信息放在URL中，POST放在报文体中。</li>
<li>数据库层面：GET符合幂等性 (对数据库的多次操作效果一样，PUT也是幂等的)和安全性 (操作不会改变数据库中的数据)，POST不符合。</li>
<li>其他层面：GET可以被缓存、被存储，而POST不行</li>
</ul>
<h3 id="255-255-255-255和0-0-0-0的作用"><a href="#255-255-255-255和0-0-0-0的作用" class="headerlink" title="255.255.255.255和0.0.0.0的作用"></a>255.255.255.255和0.0.0.0的作用</h3><p>255.255.255.255这个地址一般用来广播的时候使用，而0.0.0.0这个地址可以代表这是一个还没有分配 ip 的主机。</p>
<p>不过0.0.0.0还有其他作用，代表主机还没有分配ip地址只是其中的一个用处。例如：充当默认路由来使用，当一个路由器要发送路由表中无法查询的包时，如果设置了全零网络的路由时，我们就可以把这个包丢给全零网络的路由。</p>
<h3 id="TCP和UDP区别以及各自适用场景"><a href="#TCP和UDP区别以及各自适用场景" class="headerlink" title="TCP和UDP区别以及各自适用场景"></a>TCP和UDP区别以及各自适用场景</h3><p>UDP提供不可靠无连接的数据报传输服务，使用IP实现报文传输，根据协议端口号确定收发双方的应用程序，适用于一个服务器需要对多个客户端频繁的小数据请求进行服务的情况。TCP提供可靠的面向连接的数据流传输服务，TCP偏重于可靠性，而不是实时性，适用于一对一的传输大量数据的场合。</p>
<h3 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h3><p>流量控制与接收方的缓存状态相关。</p>
<p>一般来说，我们都希望数据能传输快一些。但是，<strong>如果发送方把数据发送得过快，接收方就可能来不及接收，这就会造成数据的丢失</strong>。</p>
<p><font color=#FF0000>所谓流量控制(flow control)就是让发送方的发送速率不要太快，要让接收方来得及接收</font>。</p>
<p>解决流量控制的问题的方法很多，比如停止-等待、滑动窗口等。</p>
<p>流量控制不是属于某一层特有的功能，比如数据链路层会要考虑，这里的TCP的也会要考虑(数据链路层的暂时不讨论)</p>
<p>TCP利用<strong>滑动窗口机制</strong>，可以比较好的成功做到流量控制。</p>
<p>详细过程可以参考这个<a href="https://www.bilibili.com/video/av50251501?from=search&seid=2105367062843188825" target="_blank" rel="noopener">教学视频</a></p>
<h3 id="TCP拥塞机制"><a href="#TCP拥塞机制" class="headerlink" title="TCP拥塞机制"></a>TCP拥塞机制</h3><p>拥塞控制与网络拥堵情况相关。</p>
<ul>
<li>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏。这种情况就叫做拥塞(congestion)。<ul>
<li>在计算机网络中的链路容量(即带宽)、交换节点中的缓存和处理机等，都是网络资源。</li>
</ul>
</li>
<li>若<font color=#FF0000>出现拥塞而不进行控制</font>，整个网络的<font color=#FF0000>吞吐量将随输入负荷的增加而下降</font>。</li>
</ul>
<p>就好比平时我们路上如果车流量太大，没有交警的疏导的话就容易造成堵塞。</p>
<p><img src="https://i.loli.net/2020/03/19/7DTeEOArayKsWFn.png" alt="TCP拥塞控制曲线.png"></p>
<p>拥塞控制是很难设计的，因为网络是高度动态的，有时候甚至是因为这个拥塞控制，导致了网络的拥堵。</p>
<p><strong>TCP的拥塞控制机制有四种算法</strong>：</p>
<ul>
<li>慢开始(slow-start)</li>
<li>拥塞避免(congestion avoidance)</li>
<li>快重传(fast retransmit)</li>
<li>快回复(fast recovery)</li>
</ul>
<p>下面介绍这四种拥塞控制算法，但是需要基于以下条件：</p>
<ul>
<li>数据总是单向传送，而另一个方向只传送确认。</li>
<li>接收方总是有足够大的缓存空间(即不考虑流量控制的必要)，因而发送方发送窗口的大小由网络的拥塞程度来决定。</li>
<li>以TCP报文段的个数作为讨论问题的单位，而不是以字节为单位。</li>
</ul>
<p>TCP拥塞控制的示意图如下：</p>
<p><img src="https://i.loli.net/2020/03/19/9tAPyYbSXFT5qJj.png" alt="TCP拥塞控制原理文字图.png"></p>
<p>简而言之，一开始拥塞窗口cwnd的大小会是2的指数级来增加，直到其大小达到了慢开始门限值(ssthresh)，后面就改用<font color=#FF0000>拥塞避免算法</font>，即每次让cwnd加1。整个传输过程曲线的一个详细例子如下图：</p>
<p><img src="https://i.loli.net/2020/03/19/JsDdO4mzlA1BijR.png" alt="拥塞重传超时重新进行.png"></p>
<p>在重新执行一次拥塞控制算法之后，整个的传输曲线是这样的：</p>
<p><img src="https://i.loli.net/2020/03/19/Ixpo25YevyRhL3M.png" alt="慢开始拥塞避免算法例子整个的曲线.png"></p>
<ul>
<li>“慢开始”是指一开始向网络注入的报文段少，不是指拥塞窗口cwnd增长速度慢；</li>
<li>“拥塞避免”不是指能完全避免拥塞，而是指在拥塞避免阶段将拥塞滑动窗口控制为按线性规律增长，使网络比较不容易出现拥塞。</li>
</ul>
<p>上述的慢开始算法和拥塞避免算法是一起的(TCP Tahoe版本)，在1988年被提出的。在1990年又增加了两个新的拥塞控制算法(<font color=#FF0000>改进TCP的性能</font>)，这就是快重传和快恢复(TCP Reno版本)。</p>
<ul>
<li>为什么要有改进的算法？原先的慢开始拥塞避免算法不好么？</li>
</ul>
<p>答：有时候，个别报文段会在网络中丢失，但是实际上网络并未发生拥塞。这会导致发送发认为已经发生拥塞，启动慢开始算法，把拥塞窗口(cwnd)设置为1，但是这会降低传输效率。</p>
<p>所谓快重传，就是使发送方<font color=#FF0000>尽快进行重传</font>，而不是等超时重传计时器超时了再重传。</p>
<p>具体做法：</p>
<ul>
<li>要求接收方不要等待自己发送数据时才进行捎带确认，而是<strong>立即发送确认</strong>。</li>
<li>即使收到了失序报文段也要立即发出对已收到的报文段的<strong>重复确认</strong>。</li>
<li>发送方一旦<font color=#FF0000>收到3个连续的重复确认</font>，就将相应的报文段<strong>立即重传</strong>，而不是等该报文段的重传计时器超时再重传。</li>
</ul>
<p>举一个图的例子，这里包含了TCP处理拥塞控制的四种方法：</p>
<p><img src="https://i.loli.net/2020/03/19/AdSc4CEVvQkrDIa.png" alt="综合四种方法的例子.png"></p>
<p>详细内容可以参考<a href="https://www.bilibili.com/video/av52266048/?spm_id_from=333.788.videocard.0" target="_blank" rel="noopener">这个教学视频</a></p>
<h3 id="选择重传协议-SR-——可靠性传输协议中的一个"><a href="#选择重传协议-SR-——可靠性传输协议中的一个" class="headerlink" title="选择重传协议(SR)——可靠性传输协议中的一个"></a>选择重传协议(SR)——可靠性传输协议中的一个</h3><p>重传协议只重发没有正确接收的帧，而不是重发所有的帧。发送方为每个发送的帧设置一个定时器，收到应答就停止计时，超时未收到应答，说明帧丢失或出错，重发该帧。接收方收到序号正确的帧，就向发送方发送ACK应答信号，如果发现序号不连接，有丢失帧现象，就向发送方发送NAK信号，请求重发制定序号的帧。</p>
<p>提一下其他发送方和接收方的其他两个可靠性传输的实现机制：停止-等待协议(SW)和后退N帧协议(GBN)</p>
<p><img src="https://i.loli.net/2020/03/19/qgGjK9ilPIpLAZo.png" alt="停止等待和后退N帧.png"></p>
<p>选择重传协议也是基于滑动窗口流量控制技术的。它的<strong>接受窗口尺寸和发送窗口尺寸都大于 1</strong>，以便能够一次性接受多个帧。如果采用 n 个比特对帧机型编号，为了避免接受端向前移动窗口后，新接收窗口与旧接收窗口产生重叠，发送窗口的最大尺寸应该不超过序列号范围的一半。</p>
<p>举个例子：</p>
<p><img src="https://i.loli.net/2020/03/20/MsaHLzIjCUAVh9O.png" alt="滑动窗口大小例子.png"></p>
<p>在这个例子中，有四个分组序号 0、1、2、3 且窗口长度为 3。假定发送了分组 0 至 2，并且接收方被正确接收且确认了。此时，接收方窗口落在 4、5、6 个分组上，其序号分别为 3、0、1.现在考虑两种情况。</p>
<p>在第一种情况下，如上图中的 a 图所示，对前 3 个分组的 ACK 丢失，因此发送方重传这些分组。因此，接收方下一步要接收序号为 0 的分组，即第一个发送分组的副本。</p>
<p>在第二种情况下，如上图中的 b 图所示，对前 3 个分组的 ACK 都被正确交付。因此发送方向前移动窗口并发送第 4、5、6 个分组，其序号分别为 3、0、1.序号为 3 的分组丢失，但序号为 0 的分组到达（一个包含新数据的分组）。</p>
<p>显然，接收方并不知道发送方那边出现了什么问题，对于接收方自己来说，上面两种情况是等价的。没有办法区分是第一个分组的重传还是第 5 个分组的初次传输。所以，窗口长度比序号空间小 1 时协议无法正常工作。但窗口应该有多小呢？</p>
<p>答案是：<strong><font color=#FF0000>窗口长度必须小于或等于序号空间大小的一半</font></strong>。</p>
<p>详细内容可以参考<a href="https://www.bilibili.com/video/av50124975?from=search&seid=13909578244053300305" target="_blank" rel="noopener">这个教学视频</a></p>
<p>以及<a href="https://blog.csdn.net/qq_22238021/article/details/80325285" target="_blank" rel="noopener">这篇文章</a></p>
<h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p>回答过程中最好不要只回答SYN、ACK这样，而是把服务端和客户端发送之后的状态也说出来。</p>
<p><img src="https://i.loli.net/2020/03/12/Lja9iFcHx2hubp8.jpg" alt="TCP三次握手"></p>
<p>刚开始两端都处于 closed 的状态，开始传输之后，服务端会被动大开，进入 listen 状态。然后：</p>
<ol>
<li><p>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号seq(x)。发送报文之后，客户端进入 SYN_Send 状态。</p>
</li>
<li><p>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 seq(y)，同时会把客户端的 x + 1 作为 ack 的值(大的ACK表示确认收到，小的ack才表示序列号，ack为当前报文段最后一个字节的编号+1)，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。</p>
</li>
<li><p>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 y + 1 作为 ack 的值，表示已经收到了服务端的 SYN 报文，之后客户端进入 establised 状态。</p>
</li>
</ol>
<p>4、服务器收到 ACK 报文之后，进入 establised 状态，此时，双方以建立起了链接。</p>
<h4 id="TCP三次握手涉及的问题"><a href="#TCP三次握手涉及的问题" class="headerlink" title="TCP三次握手涉及的问题"></a>TCP三次握手涉及的问题</h4><h5 id="1-三次握手的作用"><a href="#1-三次握手的作用" class="headerlink" title="1.三次握手的作用"></a>1.三次握手的作用</h5><p>三次握手的作用也是有好多的，多记住几个，保证不亏。例如：</p>
<ol>
<li><p>确认双方的接受能力、发送能力是否正常。</p>
</li>
<li><p>指定自己的初始化序列号，为后面的可靠传送做准备。</p>
</li>
<li><p>如果是 https 协议的话，三次握手这个过程，还会进行数字证书的验证以及加密密钥的生成到。</p>
</li>
</ol>
<h5 id="2-seq-ISN-是固定的么"><a href="#2-seq-ISN-是固定的么" class="headerlink" title="2.seq(ISN)是固定的么"></a>2.seq(ISN)是固定的么</h5><p>三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。</p>
<p>如果ISN是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。</p>
<h5 id="3-什么是半连接队列"><a href="#3-什么是半连接队列" class="headerlink" title="3.什么是半连接队列"></a>3.什么是半连接队列</h5><p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为<strong>半连接队列</strong>。当然还有一个<strong>全连接队列</strong>，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p>
<blockquote>
<p>这里在补充一点关于SYN-ACK 重传次数的问题：　服务器发送完SYN－ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超 过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s, 2s, 4s, 8s, ….</p>
</blockquote>
<h5 id="4-三次握手过程中可以携带数据吗"><a href="#4-三次握手过程中可以携带数据吗" class="headerlink" title="4.三次握手过程中可以携带数据吗"></a>4.三次握手过程中可以携带数据吗</h5><p>很多人可能会认为三次握手都不能携带数据，其实<strong>第三次握手的时候，是可以携带数据的</strong>。也就是说，第一次、第二次握手不可以携带数据，而<strong>第三次握手是可以携带数据的</strong>。</p>
<p>为什么这样呢？大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。也就是说，第一次握手可以放数据的话，其中一个简单的原因就是会让服务器更加容易受到攻击了。</p>
<p>而对于第三次的话，此时客户端已经处于 established 状态，也就是说，对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据页没啥毛病。</p>
<p>此外，三次握手还会涉及https加密过程。</p>
<h5 id="5-第一次握手时可能会出现SYN超时的问题——针对SYN-Flood的防护措施"><a href="#5-第一次握手时可能会出现SYN超时的问题——针对SYN-Flood的防护措施" class="headerlink" title="5.第一次握手时可能会出现SYN超时的问题——针对SYN Flood的防护措施"></a>5.第一次握手时可能会出现SYN超时的问题——针对SYN Flood的防护措施</h5><p><font color=#FF0000>面试回答建连的问题时，可以提到 SYN 洪水攻击发生的原因，就是 Server 端收到 Client 端的 SYN 请求后，发送了 ACK 和 SYN，但是 Client 端不进行回复，导致 Server 端大量的链接处在 SYN_RCVD 状态，进而影响其他正常请求的建连。可以设置 tcp_synack_retries = 0 加快半链接的回收速度，或者调大 tcp_max_syn_backlog 来应对少量的 SYN 洪水攻击。因为是Server端接收到了Client端的SYN包之后的回复的时候出现的问题，所以可以认为是首次握手时候产生的隐患。</font></p>
<h5 id="6-建立连接后，client出现问题了怎么办？"><a href="#6-建立连接后，client出现问题了怎么办？" class="headerlink" title="6.建立连接后，client出现问题了怎么办？"></a>6.建立连接后，client出现问题了怎么办？</h5><p>——保活机制：1.相对方发送保活探测报文，如果未接收到相应则继续发送。2.尝试次数达到了设定的保活探测次数但是仍未收到响应的话，则中断连接。</p>
<p>TCP设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
<h3 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h3><p>四次挥手也一样，千万不要对方一个 FIN 报文，我方一个 ACK 报文，再我方一个 FIN 报文，我方一个 ACK 报文。然后结束，最好是说的详细一点，例如想下面这样就差不多了，要把每个阶段的状态记好。</p>
<p><img src="https://i.loli.net/2020/03/12/P76skMIGWAO3Ntv.jpg" alt="四次挥手过程"></p>
<p>刚开始双方都处于 establised 状态，客户端先发起关闭请求，则：</p>
<ol>
<li><p>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号seq。之后客户端进入CLOSED_WAIT1状态。</p>
</li>
<li><p>第二次握手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ack 报文的序列号值，表明已经收到客户端的报文了，然后当然也会附上自己产生的序列号seq=y, 之后服务端进入 CLOSE_WAIT2状态。</p>
</li>
<li><p>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号seq=z。之后服务端进入 LAST_ACK 的状态。</p>
</li>
<li><p>第四次挥手：客户端收到 FIN 之后，一样发送一个 ack 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，之后客户端进入 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态。注意这里客户端不再生成新的序列号，而是使用之前的x+1和z+1</p>
</li>
<li><p>服务端收到 ACK 报文之后，就处于关闭连接了，进入 CLOSED 状态。</p>
</li>
</ol>
<h4 id="TCP四次挥手涉及的问题"><a href="#TCP四次挥手涉及的问题" class="headerlink" title="TCP四次挥手涉及的问题"></a>TCP四次挥手涉及的问题</h4><h5 id="1-为什么客户端在最后要有2MSL的等待时间才能进入CLOSED状态，即为什么要有TIME-WAIT时间？"><a href="#1-为什么客户端在最后要有2MSL的等待时间才能进入CLOSED状态，即为什么要有TIME-WAIT时间？" class="headerlink" title="1.为什么客户端在最后要有2MSL的等待时间才能进入CLOSED状态，即为什么要有TIME_WAIT时间？"></a>1.为什么客户端在最后要有2MSL的等待时间才能进入CLOSED状态，即为什么要有TIME_WAIT时间？</h5><p>原因有两个：</p>
<ol>
<li>保证TCP协议的全双工连接能够可靠关闭；</li>
<li>保证这次连接的重复数据段从网络中消失，防止端口被重用时可能产生数据混淆。</li>
</ol>
<p>虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假想网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p>
<h5 id="2-四次挥手过程中大量Socket处在TIME-WAIT和CLOSE-WAIT状态，该如何解决？"><a href="#2-四次挥手过程中大量Socket处在TIME-WAIT和CLOSE-WAIT状态，该如何解决？" class="headerlink" title="2.四次挥手过程中大量Socket处在TIME_WAIT和CLOSE_WAIT状态，该如何解决？"></a>2.四次挥手过程中大量Socket处在TIME_WAIT和CLOSE_WAIT状态，该如何解决？</h5><p>需要注意，在四次挥手的过程中，可以提到在实际应用中有可能遇到大量Socket处在TIME_WAIT或者CLOSE_WAIT状态的问题。一般开启 tcp_tw_reuse 和 tcp_tw_recycle 能够加快 TIME-WAIT 的 Sockets 回收；而大量 CLOSE_WAIT 可能是被动关闭的一方存在代码 bug，没有正确关闭链接导致的。</p>
<h3 id="一些状态的含义"><a href="#一些状态的含义" class="headerlink" title="一些状态的含义"></a>一些状态的含义</h3><blockquote>
<p>LISTEN - 侦听来自远方TCP端口的连接请求；</p>
</blockquote>
<blockquote>
<p>SYN-SENT -在发送连接请求后等待匹配的连接请求；</p>
</blockquote>
<blockquote>
<p>SYN-RECEIVED - 在收到和发送一个连接请求后等待对连接请求的确认；</p>
</blockquote>
<blockquote>
<p>ESTABLISHED- 代表一个打开的连接，数据可以传送给用户；</p>
</blockquote>
<blockquote>
<p>FIN-WAIT-1 - 等待远程TCP的连接中断请求，或先前的连接中断请求的确认；</p>
</blockquote>
<blockquote>
<p>FIN-WAIT-2 - 从远程TCP等待连接中断请求；</p>
</blockquote>
<blockquote>
<p>CLOSE-WAIT - 等待从本地用户发来的连接中断请求；</p>
</blockquote>
<blockquote>
<p>CLOSING -等待远程TCP对连接中断的确认；</p>
</blockquote>
<blockquote>
<p>LAST-ACK - 等待原来发向远程TCP的连接中断请求的确认；</p>
</blockquote>
<blockquote>
<p>TIME-WAIT -等待足够的时间以确保远程TCP接收到连接中断请求的确认；</p>
</blockquote>
<blockquote>
<p>CLOSED - 没有任何连接状态；</p>
</blockquote>
<h3 id="TCP三次握手和四次挥手的对比总结"><a href="#TCP三次握手和四次挥手的对比总结" class="headerlink" title="TCP三次握手和四次挥手的对比总结"></a>TCP三次握手和四次挥手的对比总结</h3><p>无论是建连还是断连，都是需要在两个方向上进行，只不过建连时，Server 端的 SYN 和 ACK 合并为一次发送，而断链时，<strong>两个方向上数据发送停止的时间可能不同，所以不能合并发送 FIN 和 ACK</strong>。</p>
<h3 id="TCP要三次握手的原因"><a href="#TCP要三次握手的原因" class="headerlink" title="TCP要三次握手的原因"></a>TCP要三次握手的原因</h3><p>TCP的握手为什么要三次呢？最后一次不要了，改为两次握手，可以么？</p>
<p>假如现在客户端想向服务端进行握手，它发送了第一个连接的请求报文，但是由于网络信号差或者服务器负载过多，这个请求没有立即到达服务端，而是在某个网络节点中长时间的滞留了，以至于滞留到客户端连接释放以后的某个时间点才到达服务端，那么这就是一个失效的报文，但是服务端接收到这个失效的请求报文后，就误认为客户端又发了一次连接请求，服务端就会想向客户端发出确认的报文，表示同意建立连接。</p>
<p>假如不采用三次握手，那么只要服务端发出确认，表示新的建立就连接了。但是现在客户端并没有发出建立连接的请求，其实这个请求是失效的请求，一切都是服务端在自相情愿，因此客户端是不会理睬服务端的确认信息，也不会向服务端发送确认的请求，但是服务器却认为新的连接已经建立起来了，并一直等待客户端发来数据，这样的情况下，服务端的很多资源就没白白浪费掉了。</p>
<p>采用三次握手的办法就是为了防止上述这种情况的发生，比如就在刚才的情况下，客户端不会向服务端发出确认的请求，服务端会因为收不到确认的报文，就知道客户端并没有要建立连接，那么服务端也就不会去建立连接，这就是三次握手的作用。</p>
<p>NOTE:<font color=#FF0000>用更专业的内容可以说，之前发送过程中滞留的包，是”<strong>已失效的连接请求报文段</strong>“</font></p>
<h3 id="TCP要四次挥手的原因"><a href="#TCP要四次挥手的原因" class="headerlink" title="TCP要四次挥手的原因"></a>TCP要四次挥手的原因</h3><p>TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工 模式，这就意味着，在客户端想要断开连接时，客户端向服务端发送<code>FIN</code>报文，只是表示客户端已经没有数据要发送了，但是这个时候客户端还是可以接收来自服务端的数据。</p>
<p>当服务端接收到<code>FIN</code>报文，并返回<code>ACK</code>报文，表示服务端已经知道了客户端要断开连接，客户端已经没有数据要发送了，但是这个时候服务端可能依然有数据要传输给客户端。</p>
<p>当服务端的数据传输完之后，服务端会发送<code>FIN</code>报文给客户端，表示服务端也没有数据要传输了，服务端同意关闭连接，之后，客户端收到<code>FIN</code>报文，立即发送给客户端一个<code>ACK</code>报文，确定关闭连接。在之后，客户端和服务端彼此就愉快的断开了这次的<code>TCP</code>连接。</p>
<p>或许会有疑问，为什么服务端的<code>ACK</code>报文和<code>FIN</code>报文都是分开发送的，但是在三次握手的时候却是<code>ACK</code>报文和<code>SYN</code>报文是一起发送的，因为在三次握手的过程中，当服务端收到客户端的SYN连接请求报文后，可以直接发送<code>SYN</code>+<code>ACK</code>报文。其中<code>ACK</code>报文是用来应答的，<code>SYN</code>报文是用来同步的。但是在关闭连接时，当服务端接收到<code>FIN</code>报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个<code>ACK</code>报文，告诉客户端，你发的<code>FIN</code>报文我收到了，只有等到服务端所有的数据都发送完了，才能发送<code>FIN</code>报文，<strong>因此<code>ACK</code>报文和<code>FIN</code>报文不能一起发送。所以断开连接的时候才需要四次挥手来完成</strong>。</p>
<h2 id="1-2-cookie和session的区别"><a href="#1-2-cookie和session的区别" class="headerlink" title="1.2 cookie和session的区别"></a>1.2 cookie和session的区别</h2><p>参考<a href="https://www.jianshu.com/p/2f7031a69f43" target="_blank" rel="noopener">这篇文章</a></p>
<ol>
<li>存储位置不同</li>
</ol>
<blockquote>
<p>cookie的数据信息存放在客户端浏览器上。</p>
</blockquote>
<blockquote>
<p>session的数据信息存放在服务器上。</p>
</blockquote>
<ol start="2">
<li>存储容量不同</li>
</ol>
<blockquote>
<p>单个cookie保存的数据&lt;=4KB，一个站点最多保存20个Cookie。</p>
</blockquote>
<blockquote>
<p>对于session来说并没有上限，但出于对服务器端的性能考虑，session内不要存放过多的东西，并且设置session删除机制。</p>
</blockquote>
<ol start="3">
<li>存储方式不同</li>
</ol>
<blockquote>
<p>cookie中只能保管ASCII字符串，并需要通过编码方式存储为Unicode字符或者二进制数据。</p>
</blockquote>
<blockquote>
<p>session中能够存储任何类型的数据，包括且不限于string，integer，list，map等。</p>
</blockquote>
<ol start="4">
<li>隐私策略不同</li>
</ol>
<blockquote>
<p>cookie对客户端是可见的，别有用心的人可以分析存放在本地的cookie并进行cookie欺骗，所以它是不安全的。</p>
</blockquote>
<blockquote>
<p>session存储在服务器上，对客户端是隐藏，不存在敏感信息泄漏的风险。</p>
</blockquote>
<ol start="5">
<li>有效期上不同</li>
</ol>
<blockquote>
<p>开发可以通过设置cookie的属性，达到使cookie长期有效的效果。</p>
</blockquote>
<blockquote>
<p>session依赖于名为JSESSIONID的cookie，而cookie JSESSIONID的过期时间默认为-1，只需关闭窗口该session就会失效，因而session不能达到长期有效的效果。</p>
</blockquote>
<ol start="6">
<li>服务器压力不同</li>
</ol>
<blockquote>
<p>cookie保管在客户端，不占用服务器资源。对于并发用户十分多的网站，cookie是很好的选择。</p>
</blockquote>
<blockquote>
<p>session是保管在服务器端的，每个用户都会产生一个session。假如并发访问的用户十分多，会产生十分多的session，耗费大量的内存。</p>
</blockquote>
<ol start="7">
<li>浏览器支持不同</li>
</ol>
<p>假如客户端浏览器不支持cookie：</p>
<blockquote>
<p>cookie是需要客户端浏览器支持的，假如客户端禁用了cookie，或者不支持cookie，则会话跟踪会失效。关于WAP上的应用，常规的cookie就派不上用场了。</p>
</blockquote>
<blockquote>
<p>运用session需要使用URL地址重写的方式。一切用到session程序的URL都要进行URL地址重写，否则session会话跟踪还会失效。</p>
</blockquote>
<p>假如客户端支持cookie：</p>
<blockquote>
<p>cookie既能够设为本浏览器窗口以及子窗口内有效，也能够设为一切窗口内有效。</p>
</blockquote>
<blockquote>
<p>session只能在本窗口以及子窗口内有效。</p>
</blockquote>
<ol start="8">
<li>跨域支持上不同</li>
</ol>
<blockquote>
<p>cookie支持跨域名访问。</p>
</blockquote>
<blockquote>
<p>session不支持跨域名访问。</p>
</blockquote>
<p>另外：现在正在淘汰cookie了，谷歌日前就在官方博客上说，将在未来两年淘汰cookie,即chrome逐步淘汰第三方cookie，但是由于市场占比的原因，这件事还有待进一步发展。</p>
<h2 id="HTTP、TCP、UDP、IP、ICMP、DNS、FTP等协议分别处于哪层？"><a href="#HTTP、TCP、UDP、IP、ICMP、DNS、FTP等协议分别处于哪层？" class="headerlink" title="HTTP、TCP、UDP、IP、ICMP、DNS、FTP等协议分别处于哪层？"></a>HTTP、TCP、UDP、IP、ICMP、DNS、FTP等协议分别处于哪层？</h2><p>以OSI七层模型来说：</p>
<ul>
<li>应用层：<strong>HTTP、FTP、DNS、</strong>Telnet、SMTP、</li>
<li>传输层：<strong>TCP、UDP</strong></li>
<li>网络层：<strong>IP、ICMP、</strong>RIP、OSPF、</li>
<li>数据链路层：<strong>ARP</strong>、PPP、RARP、MTU</li>
<li>物理层：ISO2110、IEEEE802、IEEEE802.2</li>
</ul>
<h2 id="Ping指令用的什么协议？在哪一层？"><a href="#Ping指令用的什么协议？在哪一层？" class="headerlink" title="Ping指令用的什么协议？在哪一层？"></a>Ping指令用的什么协议？在哪一层？</h2><p>Ping命令本身处于应用层，相当于一个应用程序，它直接使用网络层的ICMP回应报文来监听返回情况。(所以如果直接问ping在哪一层，答案是应用层)</p>
<h2 id="ARP协议的作用？"><a href="#ARP协议的作用？" class="headerlink" title="ARP协议的作用？"></a>ARP协议的作用？</h2><h3 id="什么是ARP协议？"><a href="#什么是ARP协议？" class="headerlink" title="什么是ARP协议？"></a>什么是ARP协议？</h3><p>ARP (Address Resolution Protocol) 是个地址解析协议。最直白的说法是：在IP以太网中，当一个上层协议要发包时，有了该节点的IP地址，ARP就能提供该节点的MAC地址。</p>
<h3 id="为什么要有ARP协议？"><a href="#为什么要有ARP协议？" class="headerlink" title="为什么要有ARP协议？"></a>为什么要有ARP协议？</h3><p>OSI 模式把网络工作分为七层，彼此不直接打交道，只通过接口(layre interface). IP地址在第三层, MAC地址在第二层。协议在发生数据包时，首先要封装第三层 （IP地址）和第二层 （MAC地址）的报头, 但协议只知道目的节点的IP地址，不知道其物理地址，又不能跨第二、三层，所以得用ARP的服务。</p>
<h2 id="路由器和交换机的区别？"><a href="#路由器和交换机的区别？" class="headerlink" title="路由器和交换机的区别？"></a>路由器和交换机的区别？</h2><p>交换机是一根网线上网，但是大家上网是分别拨号，各自使用自己的宽带，大家上网没有影响。而路由器比交换机多了一个虚拟拨号功能，通过同一台路由器上网的电脑是共用一个宽带账号，大家上网要相互影响。</p>
<p>交换机工作在中继层，交换机根据MAC地址寻址。路由器工作在网络层，根据IP地址寻址，路由器可以处理TCP/IP协议，而交换机不可以。</p>
<p>路由器工作于网络层，用来隔离广播域（子网），连接的设备分属不同子网，工作范围是多个子网之间，负责网络与网络之间通信。</p>
<p><strong>工作层次不同</strong></p>
<p>交换机主要工作在数据链路层（第二层）</p>
<p>路由器工作在网络层（第三层）。</p>
<p><strong>转发依据不同</strong></p>
<p>交换机转发所依据的对象时：MAC地址。（物理地址）</p>
<p>路由转发所依据的对象是：IP地址。（网络地址）</p>
<p><strong>主要功能不同</strong></p>
<p>交换机主要用于组建局域网，而路由主要功能是将由交换机组好的局域网相互连接起来，或者接入Internet。<br>交换机能做的，路由都能做。<br>交换机不能分割广播域，路由可以。<br>路由还可以提供防火墙的功能。<br>路由配置比交换机复杂。</p>
<h2 id="TCP粘包为什么会发生？怎么处理？"><a href="#TCP粘包为什么会发生？怎么处理？" class="headerlink" title="TCP粘包为什么会发生？怎么处理？"></a>TCP粘包为什么会发生？怎么处理？</h2><p>只有TCP会产生粘包问题，因为TCP是基于数据流的协议，而UDP是基于数据报的协议。也就是说，TCP认为消息不是一条一条的，而是”流”式的，是没有消息边界的。而UDP则是有消息边界的，接收方一次只接收一条独立的信息，所以不存在粘包问题。</p>
<p>TCP粘包指的是发送方发送的若干包数据到达接收方时粘成了一个很大的包，从接收方来看，是一个数据包的头紧接着另一个数据包的尾。</p>
<h3 id="发生TCP粘包主要是两个原因："><a href="#发生TCP粘包主要是两个原因：" class="headerlink" title="发生TCP粘包主要是两个原因："></a>发生TCP粘包主要是两个原因：</h3><ul>
<li><strong>发送方的原因</strong>：发送方默认开启Nagle算法(主要作用是减少网络中报文段的数量)，而Nagle算法主要做两件事：1.只在上一个分组得到确认之后才发送下一个分组；2.收集多个小分组，在一个确认到来之后一起发送。Nagle这两个功能造成了发送方可能会产生粘包问题。</li>
<li><strong>接收方原因</strong>：接收方接收到TCP包之后不会马上处理，而是会先放在缓存中，然后应用程序会从缓存里面读取到数据分组。但是这样一来如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。</li>
</ul>
<h3 id="解决粘包问题的两个方法："><a href="#解决粘包问题的两个方法：" class="headerlink" title="解决粘包问题的两个方法："></a>解决粘包问题的两个方法：</h3><p>经过上面原因的分析我们可以知道，可以在发送方和应用层两个层面解决TCP粘包问题，但是接收方没办法解决，从接受方的角度来看只能交给应用层处理。</p>
<ul>
<li>发送方可以选择关闭Nagle算法，使用TCP_NODELAY选项关闭</li>
<li>从应用层来解决可以有两种方法，主要目的都是从缓存中循环地一条一条地读数据，直到所有数据被处理完成。这里重点是如何判断每条数据的长度，重点解决方法有两个：</li>
</ul>
<ol>
<li><strong>格式化数据</strong>：给每条数据设置固有的格式(开始符、结束符，比叡设置每条数据的结尾都统一是”/0”)，</li>
<li><strong>统一发送长度</strong>：每次发送数据时都统一长度，然后将数据按照统一的长度发送。比如规定数据的前4位是数据的长度，之后应用层在处理时可以根据长度来判断每个分组的开始和结束位置。</li>
</ol>
<hr>
<p>其他有关路由器和交换机的知识：<a href="https://www.cnblogs.com/Lynn-Zhang/articles/5754336.html" target="_blank" rel="noopener">可以参考文章</a></p>
<h1 id="2-操作系统"><a href="#2-操作系统" class="headerlink" title="2.操作系统"></a>2.操作系统</h1><h2 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h2><p>从宏观上来回答：</p>
<p>a.进程是系统资源分配的最小单位，线程是程序执行的最小单位</p>
<p>b.进程使用独立的数据空间，而线程共享进程的数据空间</p>
<p>更深入一点：</p>
<ul>
<li>共享内存方面。因为进程间不能共享内存，所以我们会用一些进程间相互交互的方案，比较常见的就是通过TCP/IP的端口来实现。也有其他方案，但是TCP/IP是最通用的，其他方案可能和某个特定操作系统的相关性要更大一些。</li>
<li>进程与线程通信方面。进程通信比较难，线程间通信就很简单了，只要两个线程的指针指向同一块内存，它们之间就可以通信。</li>
<li>In terms of 开销，进程的开销当然比较大，因为我们要给它分配很多内存，而线程我们只是给它分配一个栈，分配一个PC指针(program counter)就可以了。此外，进程之间切换的开销会大于线程之间切换的开销。</li>
</ul>
<h2 id="进程间通信方式-IPC-Inter-Process-Communication"><a href="#进程间通信方式-IPC-Inter-Process-Communication" class="headerlink" title="进程间通信方式(IPC, Inter Process Communication)"></a>进程间通信方式(IPC, Inter Process Communication)</h2><p>总共七种方法：</p>
<ol>
<li>文件</li>
<li>管道/命名管道</li>
<li>Signal</li>
<li>共享内存</li>
<li>消息队列</li>
<li>同步机制，如信号量(semaphore)</li>
<li>Socket</li>
</ol>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>写一个文件：最简单的方法，一个进程写一个文件，另一个进程去访问这个文件，由此两个进程之间可以交换信息，得以通信。</p>
<h3 id="管道-命名管道"><a href="#管道-命名管道" class="headerlink" title="管道/命名管道"></a>管道/命名管道</h3><p>管道：两个进程之间建立消息通信的通道。不命名的管道一般是单向的，一方可以向另一方从管道里发送数据；命名管道可以单向也可以双向。</p>
<p>管道的通知机制类似于缓存，就像一个进程把数据放在某个缓存区域，然后等着另外一个进程去拿，并且是管道是单向传输的。</p>
<p>这种通信方式有什么缺点呢？显然，这种通信方式效率低下，你看，a 进程给 b 进程传输数据，只能等待 b 进程取了数据之后 a 进程才能返回。</p>
<p>所以管道不适合频繁通信的进程。当然，他也有它的优点，例如比较简单，能够保证我们的数据已经真的被其他进程拿走了。我们平时用 Linux 的时候，也算是经常用。</p>
<h3 id="Signal"><a href="#Signal" class="headerlink" title="Signal"></a>Signal</h3><p>Signal：linux系统中最常用。一个进程给另一个进程发送信号，一般是一串数字，这个数字有自己特定的含义。比如”kill”可以 send a signal to a process,强行”kill”掉。</p>
<p>比如kill -9,可以杀死进程</p>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>系统加载一个进程的时候，分配给进程的内存并不是实际物理内存，而是虚拟内存空间。那么我们可以让两个进程各自拿出一块虚拟地址空间来，然后映射到相同的物理内存中，这样，两个进程虽然有着独立的虚拟内存空间，但有一部分却是映射到相同的物理内存，这就完成了内存共享机制了。</p>
<p>换句话说：虽然进程之间是彼此独立的，但是操作系统可以提供一个机制，两个进程可以约定好，打开一个文件，这个文件映射到内存中，也就是多个进程使用同一块内存。</p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>我们可以用消息队列的通信模式来解决这个问题，例如 a 进程要给 b 进程发送消息，只需要把消息放在对应的消息队列里就行了，b 进程需要的时候再去对应的<br>消息队列里取出来。同理，b 进程要个 a 进程发送消息也是一样。这种通信方式也类似于缓存吧。</p>
<p>这种通信方式有缺点吗？答是有的，如果 a 进程发送的数据占的内存比较大，并且两个进程之间的通信特别频繁的话，消息队列模型就不大适合了。因为 a 发送的数据很大的话，意味发送消息（拷贝）这个过程需要花很多时间来读内存。</p>
<h3 id="同步机制，如信号量-semaphore"><a href="#同步机制，如信号量-semaphore" class="headerlink" title="同步机制，如信号量(semaphore)"></a>同步机制，如信号量(semaphore)</h3><p>信号量的本质就是一个计数器，用来实现进程之间的互斥与同步。例如信号量的初始值是 1，然后 a 进程来访问内存1的时候，我们就把信号量的值设为 0，然后进程b 也要来访问内存1的时候，看到信号量的值为 0 就知道已经有进程在访问内存1了，这个时候进程 b 就会访问不了内存1。所以说，信号量也是进程之间的一种通信方式。</p>
<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>最后一种，而且没回答出来这个其实整个答案都不算好。因为前面6种只能作为同一个机器的进程之间的通信，而Socket可以是不同机器的进程之间的通信。</p>
<p>可以在机器上开一个端口，作为一个服务器，让用户连接。这种通信包含了网络上的服务端和服务器的这种结构。</p>
<p>用浏览器去访问一个网站，这时浏览器的进程和远端服务器的进程要进行通信。</p>
<p>Socket可以作为不同机器之间进程的通信——通过客户端，服务器的方法。这里面走的一般是TCP的协议或者UDP的协议。</p>
<h2 id="死锁发生的四个条件和预防方式？"><a href="#死锁发生的四个条件和预防方式？" class="headerlink" title="死锁发生的四个条件和预防方式？"></a>死锁发生的四个条件和预防方式？</h2><p>什么是死锁？——死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种进程间相互阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为<strong>死锁进程</strong>。</p>
<h3 id="产生死锁的四个条件"><a href="#产生死锁的四个条件" class="headerlink" title="产生死锁的四个条件"></a>产生死锁的四个条件</h3><ol>
<li><strong>互斥条件</strong>：一个资源每次只能被一个进程使用，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</li>
<li><strong>请求与保持条件</strong>：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</li>
<li><strong>不可剥夺条件</strong>：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。</li>
<li><strong>循环等待条件</strong>：若干进程间形成首尾相接循环等待资源的关系</li>
</ol>
<p>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。</p>
<h3 id="避免死锁的方法"><a href="#避免死锁的方法" class="headerlink" title="避免死锁的方法"></a>避免死锁的方法</h3><p>系统对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源，如果分配后系统可能发生死锁，则不予分配，否则予以分配，这是一种保证系统不进入死锁状态的动态策略。 如果操作系统能保证所有进程在有限时间内得到需要的全部资源，则系统处于安全状态否则系统是不安全的。</p>
<h4 id="有序资源分配法"><a href="#有序资源分配法" class="headerlink" title="有序资源分配法"></a>有序资源分配法</h4><p>这种算法资源按某种规则系统中的所有资源统一编号（例如打印机为1、磁带机为2、磁盘为3、等等），申请时必须以上升的次序。系统要求申请进程：</p>
<p>1、对它所必须使用的而且属于同一类的所有资源，必须一次申请完；</p>
<p>2、在申请不同类资源时，必须按各类设备的编号依次申请。例如：进程PA，使用资源的顺序是R1，R2； 进程PB，使用资源的顺序是R2，R1；若采用动态分配有可能形成环路条件，造成死锁。</p>
<p>采用有序资源分配法：R1的编号为1，R2的编号为2；</p>
<p>PA：申请次序应是：1，2</p>
<p>PB：申请次序应是：1，2</p>
<p>这样就破坏了环路条件，避免了死锁的发生</p>
<h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><p>避免死锁算法中最有代表性的算法是Dijkstra E.W 于1968年提出的<a href="https://baike.baidu.com/item/银行家算法" target="_blank" rel="noopener">银行家算法</a>：</p>
<p>　　银行家算法是避免死锁的一种重要方法，防止死锁的机构只能确保上述四个条件之一不出现，则系统就不会发生死锁。通过这个算法可以用来解决生活中的实际问题，如银行贷款等。</p>
<p>　　程序实现思路银行家算法顾名思义是来源于银行的借贷业务，一定数量的本金要应多个客户的借贷周转，为了防止银行家资金无法周转而倒闭，对每一笔贷款，必须考察其是否能限期归还。在操作系统中研究资源分配策略时也有类似问题，系统中有限的资源要供多个进程使用，必须保证得到的资源的进程能在有限的时间内归还资源，以供其他进程使用资源。如果资源分配不当就会发生进程循环等待资源，严重则导致进程都无法继续执行下去的死锁现象。 </p>
<p>　　把一个进程需要和已占有资源的情况记录在进程控制中，假定进程控制块PCB其中“状态”有就绪态、等待态和完成态。当进程在处于等待态时，表示系统不能满足该进程当前的资源申请。“资源需求总量”表示进程在整个执行过程中总共要申请的资源量。显然，每个进程的资源需求总量不能超过系统拥有的资源总数， 银行算法进行资源分配可以避免死锁。</p>
<h2 id="死锁的检测和解除"><a href="#死锁的检测和解除" class="headerlink" title="死锁的检测和解除"></a>死锁的检测和解除</h2><p>检测死锁：这种方法并不须事先采取任何限制性措施，也不必检查系统是否已经进入不安全区，此方法允许系统在运行过程中发生死锁。但可通过系统所设置的检测机构，及时地检测出死锁的发生，并精确地确定与死锁有关的进程和资源。检测方法包括定时检测、效率低时检测、进程等待时检测等。</p>
<p>解除死锁：采取适当措施，在系统中将已发生的死锁解除。这是与检测死锁相配套的一种措施。当检测到系统中已发生死锁时，须将进程从死锁状态中解除。常用的实施方法是撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程，使之转为就绪状态，以继续运行。死锁的检测和解除措施，有可能使系统获得较好的资源利用率和吞吐量，但在实现上难度也最大。</p>
<p>解除死锁的具体方法有：</p>
<h3 id="资源剥夺法"><a href="#资源剥夺法" class="headerlink" title="资源剥夺法"></a>资源剥夺法</h3><p>挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。</p>
<h3 id="撤销进程法"><a href="#撤销进程法" class="headerlink" title="撤销进程法"></a>撤销进程法</h3><p>强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。</p>
<h3 id="进程回退法"><a href="#进程回退法" class="headerlink" title="进程回退法"></a>进程回退法</h3><p>让一个或多个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。</p>
<h2 id="经典进程调度算法"><a href="#经典进程调度算法" class="headerlink" title="经典进程调度算法"></a>经典进程调度算法</h2><h3 id="1-批处理时代"><a href="#1-批处理时代" class="headerlink" title="1.批处理时代"></a>1.批处理时代</h3><h4 id="1-FCFS-先来先服务"><a href="#1-FCFS-先来先服务" class="headerlink" title="1.FCFS(先来先服务)"></a>1.FCFS(先来先服务)</h4><p>每个进程按进入内存的时间先后排成一队。每当 CPU 上的进程运行完毕或者阻塞，我就会选择队伍最前面的进程，带着他前往 CPU 执行。</p>
<p>这一算法听起来简单又公平，然而好景不长，我收到了一个短进程的抱怨：”上次我前面排了一个长进程，等了足足 200 秒他才运行完。我只用 1 秒就运行结束了，就因为等他，我多花了这么长时间，太不值得了。”</p>
<p>我仔细一想， FCFS 算法确实有这个缺陷——短进程的响应时间太长了，用户交互体验会变差。</p>
<p>所以我决定，更换调度算法。</p>
<h4 id="2-SPN-段任务优先"><a href="#2-SPN-段任务优先" class="headerlink" title="2.SPN(段任务优先)"></a>2.SPN(段任务优先)</h4><p>这次我设计的算法叫做「短任务优先」（Shortest Process Next，SPN）。每次选择预计处理时间最短的进程。因此，在排队的时候，我会把短进程从队列里提到前面。</p>
<p>这一次，短进程得到了很好的照顾，进程的平均响应时间大大降低，我和操作系统都很满意。</p>
<p>但长进程们不干了：那些短进程天天插队，导致他们经常得不到 CPU 资源，造成了「饥饿」现象。</p>
<p>取消 SPN 算法的呼声越来越高。</p>
<p>这可是个大问题。FCFS 虽然响应时间长，但最后所有进程一定有使用 CPU 资源的机会。但 SPN 算法就不一样了，如果短进程源源不断加入队列，长进程们将永远得不到执行的机会——太可怕了。</p>
<p>因此，短任务优先算法需要得到改进。有什么方法既能照顾短进程，又能照顾长进程呢？</p>
<h4 id="3-HARRN-高响应比优先"><a href="#3-HARRN-高响应比优先" class="headerlink" title="3.HARRN(高响应比优先)"></a>3.HARRN(高响应比优先)</h4><p>经过和操作系统的讨论，我们决定综合考量进程的两个属性：等待时间和要求服务时间——等待时间长，要求服务时间短（就是短进程）的进程更容易被选中。</p>
<p>为了量化，我们制定了一个公式：响应比 = （等待时间+要求服务时间）/ 要求服务时间。响应比高的算法会先执行。我们称之为「高响应比优先」（Highest Response Ratio Next，HRRN）。</p>
<p>这个算法得到了长短进程的一致好评。虽然我的工作量增加了（每次调度前，我都要重新计算所有等待进程的响应比）但为了进程们的公平性，这一切都是值得的。</p>
<h3 id="2-并发时代"><a href="#2-并发时代" class="headerlink" title="2.并发时代"></a>2.并发时代</h3><p>新时代到了。</p>
<p>随着计算机的普及，个人用户大量增长，并发，即一次运行多个程序的需求出现了。这可难倒我了——处理器只有一个，怎么运行多个程序？</p>
<p>所幸 CPU 点醒了我：“我现在的运算速度既然这么快，何不发挥这项长处，弄一个「伪并行」出来？“</p>
<p>“伪并行？什么意思”</p>
<p>“就是看起来像并行，实际上还是串行。每个进程短时间交替使用我的资源，但在人类看来，这些进程就像在「同时」运行。”</p>
<h4 id="1-RR-时间片轮转算法"><a href="#1-RR-时间片轮转算法" class="headerlink" title="1.RR(时间片轮转算法)"></a>1.RR(时间片轮转算法)</h4><p>经过 CPU 的提醒，我很快制定出了新的调度算法——时间片轮转算法（Round Robin，RR）。</p>
<p>在这个算法里，每个进程将轮流使用 CPU 资源，只不过在他们开始运行时，我会为他们打开定时器，如果定时器到时间（或者执行阻塞操作），进程将被迫「下机」，切换至下一个进程。至于下一个进程的选择嘛，直接用 FCFS 就好了。</p>
<p>新的算法必然会面临新的问题，现在我的问题就是，时间片的长度怎么设计？</p>
<p>直观来看，时间片越短，固定时间里可运行的进程就越多，可 CPU 说过，切换进程是要消耗他不少指令周期的，时间片过短会导致大量 CPU 资源浪费在切换上下文上。时间片过长，短交互指令响应会变慢。所以具体怎么取，还得看交互时间大小（感觉像没说一样，但至少给了个标准嘛）。</p>
<p>这一阶段，我的工作量大大提升——以前十几秒都不用切换一次程序，现在倒好，一秒钟就得切换数十次。</p>
<h4 id="2-VRR-虚拟轮转法"><a href="#2-VRR-虚拟轮转法" class="headerlink" title="2.VRR(虚拟轮转法)"></a>2.VRR(虚拟轮转法)</h4><p>时间片轮转算法看起来十分公平——所有的进程时间片都是一样的。但事实真是这样吗？</p>
<p>I/O 密集型进程不这么认为，他对我说：“调度器大哥，时间片轮转没有照顾到我们这类进程啊！我们经常在 CPU 没呆到一半时间片，就遇到了阻塞操作，被你赶下去。而且我们在阻塞队列，往往要停留很长时间。等阻塞操作结束，我们还得在就绪队列排好长时间队。那些处理器密集型进程，使用了大部分的处理器时间，导致我们性能降低，响应时间跟不上”</p>
<p>考虑到这些进程的要求，我决定为他们创建一个新的辅助队列。阻塞解除的进程，将进入这个辅助队列，进行进程调度时，优先选择辅助队列里的进程。</p>
<p>这就是「虚拟轮转法」（Virtual Round Robin，VRR）。</p>
<p>从后来实际性能结果来看，这种方法确实优于轮转法。</p>
<h4 id="3-优先级调度"><a href="#3-优先级调度" class="headerlink" title="3.优先级调度"></a>3.优先级调度</h4><p>这个非常类似于优先队列的思想。</p>
<p>有一天，操作系统忽然找到我，神神秘秘的说：“调度器啊，你是知道的，我要给整个系统提供服务，可最近用户进程太多，导致我的服务进程有时候响应跟不上。我有点担心这会给系统稳定性造成影响。”</p>
<p>我一听，这可是个大事，系统不稳定那还得了？调度算法得换！</p>
<p>既然要让操作系统的服务得到足够的运行资源，那就，干脆让他们具有最高的 CPU 使用优先权吧。</p>
<p><strong>优先级调度算法</strong>就此产生了。</p>
<p>我向大家做出了规定——每个进程将被赋予一个<strong>优先级</strong>，自己根据自己的情况确定优先级数值，但是，用户进程的优先级<strong>不准高于</strong>内核进程的优先级。</p>
<p>切换程序的时候，我会从优先级 1 的队列里选择一个进程，如果优先级 1 队列为空，才会选择优先级 2 中的进程，以此类推。</p>
<p>当然，为了保证低优先级进程不会<strong>饥饿</strong>，我会调高等待时间长的进程的优先级。</p>
<p>使用这个算法，我更忙碌了，不仅需要大量切换进程，还需要动态调节优先级。可能这就是能力越大，责任越大吧。</p>
<p>不过我知道，正是因为我的存在，人类才能在计算机上运行多道程序——这令我感到自豪。</p>
<h2 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h2><p>出现互斥的根本原因就是进程在执行某一个操作(比如购票操作，在操作过程中某个进程买票了，减了一张，如果另外一个进程也访问了买票系统，买了票，又减了1，那导致卖了两张票出去，出错了)</p>
<p>这本质是进程之间冲突造成的，一个进程修改了共享的空间的数据，另一个一个线程再访问的时候自然就会出错。</p>
<p>这个是进程调度器的锅么？——因为貌似进程调度器负责调度进程啊！</p>
<p>但是，并不是。因为进程调度器也只负责做事，它只负责从<strong>就绪队列</strong>中选出来<strong>最应该使用CPU的进程而已</strong>。具体说来，调度器的时机是由<strong>中断</strong>决定的，也就是当进程时间片用完的时候，出现了时钟中断，然后被其他进程抢占了CPU资源。</p>
<p>但是能因此就禁止中断么？当然不行。<strong>中断禁用</strong>虽然可以防止进程在运行代码，但是计算机自己不能控制执行的功能，全部交给程序员，这是不合理的。</p>
<p>解决方法：<strong>加锁</strong>。</p>
<p>加锁是个比喻，其实<strong>「锁」</strong>只是一个共享变量，我们可以让它有 <code>OPEN</code> 和 <code>CLOSE</code> 这两个值。一个进程，比如说 A，进入临界区之前，先检查锁是不是 <code>OPEN</code> 状态，如果是的话，就把锁改为 <code>CLOSE</code> 状态 ，这样其他进程在进入临界区时，会发现锁已经 <code>CLOSE</code> 了，那就让他们<strong>循环等待</strong> ，直到 A 出临界区然后将锁打开。</p>
<p>内存眉头一皱，发现事情并没有这么简单——<strong>如果 A 发现锁是开着的，但在 A 还没有关闭锁之前，切换到了进程 B ，那么 B 也会发现锁是开着的，那么 B 也将能够进入临界区</strong>！</p>
<p>但是CPU说：”这对我来说，不是问题，已经有现成机制可以使用。”</p>
<p>原来计算机里有一条硬件支持的指令——<strong>TSL</strong>（test and set lock，测试并加锁），这条指令可以保证读字和写字的操作「<strong>不可分割</strong>」，也就是说，在这条指令结束前，就连其他处理器也不可能访问该内存字。</p>
<p>但是如果单纯设置这样的锁，一个进程没执行完，另一个不能执行，很可能会浪费CPU资源，所以单纯的TSL方案需要改进。</p>
<p>然而，磁盘想到了解决这个问题的方法。</p>
<p>利用<strong>信号量</strong>。。Dijkstra 提出，<code>P</code>操作是检测信号量是否为正值，如果不是，就阻塞调用它的进程。  <code>V</code>操作能唤醒一个被阻塞的进程，让他恢复执行 。</p>
<p>代码：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">// S 为信号量</span></span><br><span class="line"><span class="function"><span class="title">P</span><span class="params">(s)</span></span>:</span><br><span class="line">&#123;</span><br><span class="line">S = S - <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> (S &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        调用该 P 操作的进程阻塞，并插入相应的阻塞队列；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// S 为信号量</span></span><br><span class="line"><span class="function"><span class="title">V</span><span class="params">(s)</span></span>:</span><br><span class="line">&#123;</span><br><span class="line">S = S + <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> (S &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        从等待信号量 S 的阻塞队列里唤醒一个进程；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举个例子，购票操作。这里的 「购票操作」 就是我们要保护的临界区，我们要保证一次只能有一个线程进入。那我们就把 S 的初始值设为 1 。当线程 A 第一个调用 P(S) 后，S 的值就变成了 0 ，A 成功进入临界区。在 A 出临界区之前，线程 B 如果调用 P(S)， S 就变成 -1 ，满足 S &lt; 0 的判断条件，线程 B 就被阻塞了。等 A 调用 V(S) 后，S 的值又变成 0 ，满足 S &lt;= 0，就会把线程 B 唤醒，B 就能进入临界区了。“</p>
<p>而且信号量在这里有了可以增加线程运行速度的作用：<strong>S 的初始值可以控制有多少个线程进入临界区</strong>，太厉害了！</p>
<h2 id="锁-重量级锁、自旋锁、轻量级锁、偏向锁、悲观、乐观锁等"><a href="#锁-重量级锁、自旋锁、轻量级锁、偏向锁、悲观、乐观锁等" class="headerlink" title="锁(重量级锁、自旋锁、轻量级锁、偏向锁、悲观、乐观锁等)"></a>锁(重量级锁、自旋锁、轻量级锁、偏向锁、悲观、乐观锁等)</h2><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>如果你学过多线程，那么你肯定知道<strong>锁</strong>这个东西，至于为什么需要锁，我就不给你普及了，就当做你是已经懂的了。</p>
<p>我们知道，我们要进入一个同步、线程安全的方法时，是需要先获得这个方法的锁的，退出这个方法时，则会释放锁。如果获取不到这个锁的话，意味着有别的线程在执行这个方法，这时我们就会马上进入阻塞的状态，等待那个持有锁的线程释放锁，然后再把我们从阻塞的状态唤醒，我们再去获取这个方法的锁。</p>
<p>这种获取不到锁就马上进入阻塞状态的锁，我们称之为重量级锁。</p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>我们知道，线程从<strong>运行态</strong>进入<strong>阻塞态</strong>这个过程，是非常耗时的，因为不仅需要保存线程此时的执行状态，上下文等数据，还涉及到<strong>用户态</strong>到<strong>内核态</strong>的转换。当然，把线程从阻塞态唤醒也是一样，也是非常消耗时间的。</p>
<p>刚才我说线程拿不到锁，就会<strong>马上</strong>进入阻塞状态，然而现实是，它虽然这一刻拿不到锁，可能在下 0.0001 秒，就有其他线程把这个锁释放了。如果它慢0.0001秒来拿这个锁的话，可能就可以顺利拿到了，不需要经历<strong>阻塞/唤醒</strong>这个花时间的过程了。</p>
<p>然而重量级锁就是这么坑，它就是不肯等待一下，一拿不到就是要马上进入阻塞状态。为了解决这个问题，我们引入了另外一种愿意等待一段时间的锁 — <strong>自旋锁</strong>。</p>
<p>自旋锁就是，如果此时拿不到锁，它不马上进入阻塞状态，而是等待一段时间，看看这段时间有没其他人把这锁给释放了。怎么等呢？这个就类似于线程在那里做<strong>空循环</strong>，如果循环一定的次数还拿不到锁，那么它才会进入阻塞的状态。</p>
<p>至于是循环等待几次，这个是可以人为指定一个数字的。</p>
<h3 id="自适应自旋锁"><a href="#自适应自旋锁" class="headerlink" title="自适应自旋锁"></a>自适应自旋锁</h3><p>上面我们说的自旋锁，每个线程循环等待的次数都是一样的，例如我设置为 100次的话，那么线程在空循环 100 次之后还没拿到锁，就会进入阻塞状态了。</p>
<p>而自适应自旋锁就牛逼了，它不需要我们人为指定循环几次，它自己本身会进行判断要循环几次，而且每个线程可能循环的次数也是不一样的。而之所以这样做，主要是我们觉得，如果一个线程在不久前拿到过这个锁，或者它之前经常拿到过这个锁，那么我们认为<strong>它再次拿到锁的几率非常大</strong>，所以循环的次数会多一些。</p>
<p>而如果有些线程从来就没有拿到过这个锁，或者说，平时很少拿到，那么我们认为，它再次拿到的概率是比较小的，所以我们就让它循环的次数少一些。因为你在那里做空循环是很消耗 CPU 的。</p>
<p>所以这种能够根据线程最近获得锁的状态来调整循环次数的自旋锁，我们称之为<strong>自适应自旋锁</strong>。</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>上面我们介绍的三种锁：重量级、自旋锁和自适应自旋锁，他们都有一个特点，就是进入一个方法的时候，就会加上锁，退出一个方法的时候，也就释放对应的锁。</p>
<p>之所以要加锁，是因为他们害怕自己在这个方法执行的时候，被别人偷偷进来了，所以只能加锁，防止其他线程进来。这就相当于，每次离开自己的房间，都要锁上门，人回来了再把锁解开。</p>
<p>这实在是太麻烦了，如果根本就没有线程来和他们竞争锁，那他们不是白白上锁了？要知道，<strong>加锁</strong>这个过程是需要操作系统这个大佬来帮忙的，是很消耗时间的，。为了解决这种<strong>动不动就加锁</strong>带来的开销，轻量级锁出现了。</p>
<p>轻量级锁认为，当你在方法里面执行的时候，其实是很少刚好有人也来执行这个方法的，所以，当我们进入一个方法的时候根本就不用加锁，我们只需要<strong>做一个标记</strong>就可以了，也就是说，我们可以用一个变量来记录此时该方法是否有人在执行。也就是说，如果这个方法没人在执行，当我们进入这个方法的时候，采用CAS机制，把这个方法的状态标记为已经有人在执行，退出这个方法时，在把这个状态改为了<strong>没有人在执行了</strong>。</p>
<blockquote>
<p>之所以要用CAS机制来改变状态，是因为我们对这个状态的改变，不是一个原子性操作，所以需要CAS机制来保证操作的原子性。</p>
</blockquote>
<p>显然，<strong>比起加锁操作，这个采用CAS来改变状态的操作，花销就小多了</strong>。</p>
<p>然而可能会说，没人来竞争的这种想法，那是你说的而已，那如果万一有人来竞争说呢？也就是说，当一个线程来执行一个方法的时候，方法里面已经有人在执行了。</p>
<p>如果真的遇到了竞争，我们就会认为轻量级锁已经不适合了，我们就会把轻量级锁升级为重量级锁了。</p>
<p>所以轻量级锁适合用在那种，很少出现多个线程竞争一个锁的情况，也就是说，适合那种多个线程总是<strong>错开时间</strong>来获取锁的情况。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁就更加牛逼了，我们已经觉得轻量级锁已经够<strong>轻</strong>，然而偏向锁更加<strong>省事</strong>，偏向锁认为，你轻量级锁每次进入一个方法都需要用CAS来改变状态，退出也需要改变，多麻烦。</p>
<p>偏向锁认为，其实对于一个方法，是很少有两个线程来执行的，搞来搞去，其实也就一个线程在执行这个方法而已，相当于单线程的情况，居然是<strong>单线程</strong>，那就没必要加锁了。</p>
<p>不过毕竟实际情况的多线程，单线程只是自己认为的而已了，所以呢，偏向锁进入一个方法的时候是这样处理的：如果这个方法没有人进来过，那么一个线程首次进入这个方法的时候，会采用CAS机制，把这个方法标记为有人在执行了，和轻量级锁加锁有点类似，并且也会把该线程的 ID 也记录进去，相当于记录了哪个线程在执行。</p>
<p>然后，但这个线程退出这个方法的时候，它不会改变这个方法的状态，而是直接退出来，懒的去改，因为它认为除了自己这个线程之外，其他线程并不会来执行这个方法。</p>
<p>然后当这个线程想要再次进入这个方法的时候，会判断一下这个方法的状态，如果这个方法已经被标记为<strong>有人在执行了</strong>，并且线程的ID是自己，那么它就直接进入这个方法执行，啥也不用做</p>
<p>你看，多方便，第一次进入需要CAS机制来设置，以后进出就啥也不用干了，直接进入退出。</p>
<p>然而，现实总是残酷的，毕竟实际情况还是多线程，所以万一有其他线程来进入这个方法呢？如果真的出现这种情况，其他线程一看这个方法的ID不是自己，这个时候说明，至少有两个线程要来执行这个方法论，这意味着<strong>偏向锁已经不适用了</strong>，这个时候就会从偏向锁升级为轻量级锁。</p>
<p>所以呢，偏向锁适用于那种，始终只有一个线程在执行一个方法的情况。</p>
<h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><p>最开始我们说的三种锁，重量级锁、自旋锁和自适应自旋锁，进入方法之前，就一定要先加一个锁，这种我们为称之为<strong>悲观锁</strong>。悲观锁总认为，如果不事先加锁的话，就会出事，这种想法确实悲观了点。</p>
<p>而<strong>乐观锁</strong>却相反，认为不加锁也没事，我们可以先不加锁，如果出现了冲突，我们在想办法解决，例如 CAS 机制，上面说的轻量级锁，就是乐观锁的。不会马上加锁，而是等待真的出现了冲突，在想办法解决。</p>
<blockquote>
<p>互斥锁(重量级锁)也称为阻塞同步、悲观锁</p>
</blockquote>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>按照对方法加锁的量级，按照synchronized加锁的顺序，从轻到重，依次是：偏向锁-&gt;轻量级锁-&gt;重量级锁</p>
<h2 id="分页、分段、段页式是什么？"><a href="#分页、分段、段页式是什么？" class="headerlink" title="分页、分段、段页式是什么？"></a>分页、分段、段页式是什么？</h2><p>段页式的存储管理主要是从<strong>进程的存储空间</strong>来看的。</p>
<h3 id="页式存储管理"><a href="#页式存储管理" class="headerlink" title="页式存储管理"></a>页式存储管理</h3><p>页式存储管理主要做<strong>三件事</strong>（面试的时候这三点可以言简意赅，重要！）：</p>
<ol>
<li>将进程逻辑空间分成若干个大小相同的页面(<strong>等分</strong>)</li>
<li>相应的把物理内存空间分成页面大小的物理块</li>
<li>以页面为单位把进程空间装进物理内存中分散的物理块</li>
</ol>
<h4 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h4><p>首先，需要清楚<strong>页面</strong>的概念。</p>
<p>这个页面，就牵扯到了计算机组成原理的字和字块，其实这两者没有本质关联，但是字块和页面可以进行对比。</p>
<ul>
<li><font color=#FF0000>字块</font>是相对<strong>物理设备</strong>的定义</li>
<li><font color=#FF0000>页面</font>则是相对<strong>逻辑空间</strong>的定义</li>
</ul>
<p>实际上，在理解页式存储管理的时候，一般都会和内存碎片联系起来记忆学习。</p>
<p>如下图：</p>
<p><img src="https://i.loli.net/2020/04/26/8TGdotLS2Xicm9D.png" alt="页面空间分配示意图.png"></p>
<p>上图中，不同的节点用来存储页面，可以看到，图中示意的页面大小其实不太合适，因为这样的页面大小会导致节点二和节点三存不下，导致内存碎片地产生。</p>
<p>所以，我们在分配页面大小的时候需要注意两点：</p>
<ol>
<li>页面大小应当适中，过大会难以分配，过小内存碎片会过多</li>
<li>页面大小通常是512B(字节)~8K</li>
</ol>
<h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><p><font color=#FF0000>页表</font>记录进程逻辑空间与物理空间的映射。</p>
<p>如下图所示：</p>
<p><img src="https://i.loli.net/2020/04/26/gLTXpwbkv3u6nqY.png" alt="页表示意图.png"></p>
<p>页表负责记录不同页面对应哪一个字块。</p>
<h4 id="页式存储管理的问题和改进"><a href="#页式存储管理的问题和改进" class="headerlink" title="页式存储管理的问题和改进"></a>页式存储管理的问题和改进</h4><p>问题：现代计算机系统可以支持非常大的逻辑地址空间(2^32~2^64)，这样的话页表会变得非常大，需要占用非常多的存储空间.比如32位操作系统的寻址空间为4G，很占用空间。</p>
<p>为了解决这个问题，我们定义了多级页表。</p>
<p>多级页表如图：</p>
<p><img src="https://i.loli.net/2020/04/26/9mgez5UfqQuvxKb.png" alt="多级页表.png"></p>
<p>多级页表中首先有一个根页表，根页表的每一个字块都指向其他的页表。这样使用的时候内存中只需要加载根页表，后面再使用的时候直接根据根页表去找其指向的实际存储内容的页表。</p>
<p>页式存储管理的最大问题：<font color=#FF0000>若有一段连续的逻辑分布在多个页面中，将大大降低执行效率</font>，因为系统需要不断从内存中读取和访问不同的页面。</p>
<h3 id="段式存储管理"><a href="#段式存储管理" class="headerlink" title="段式存储管理"></a>段式存储管理</h3><p>段式存储主要做这么几件事：</p>
<ol>
<li>将进程逻辑空间划分成若干<font color=#FF0000>大小不相等</font>的块</li>
<li>根据<strong>连续的逻辑</strong>来对<strong>段的长度</strong>进行划分</li>
<li>使用主函数MAIN、子程序段X、子函数Y等进行空间分配</li>
</ol>
<p>同样我们需要用一个表来保存逻辑空间到物理空间的映射。使用的是<strong>段表</strong>。</p>
<p>一个段表的例子如下图：</p>
<p><img src="https://i.loli.net/2020/04/27/inHWrqzvbAswYja.png" alt="段表.png"></p>
<p>段表相比于页表，需要多一个<strong>段长</strong>的属性，因为段式存储管理是不等长的。</p>
<h3 id="段式存储管理和页式存储管理的对比"><a href="#段式存储管理和页式存储管理的对比" class="headerlink" title="段式存储管理和页式存储管理的对比"></a>段式存储管理和页式存储管理的对比</h3><p><strong>相同点</strong>：</p>
<p>段式存储和页式存储都离散地管理了进程的逻辑空间</p>
<p><strong>不同点</strong>：</p>
<ul>
<li>页是<strong>物理单位</strong>，段是是<strong>逻辑单位</strong></li>
<li>分也是为了合理利用空间，分段是满足用户要求</li>
<li>页大小由<strong>硬件固定</strong>，段长度可<strong>动态变化</strong></li>
<li>页表信息是<strong>一维</strong>的，段表信息是<strong>二维</strong>的</li>
</ul>
<h3 id="段页式存储管理"><a href="#段页式存储管理" class="headerlink" title="段页式存储管理"></a>段页式存储管理</h3><p>段页式的存储管理，旨在集中段式管理和页式管理的优点。</p>
<ul>
<li><p><strong>页式存储管理的优点</strong>：<strong>可以有效提高内存利用率</strong>(虽然存在内存碎片)；</p>
</li>
<li><p><strong>段式存储管理优点</strong>：<strong>分段可以更好满足用户需求</strong>(逻辑是用户定义的)</p>
</li>
</ul>
<p>所以我们在这里争取将两者优势结合，形成<strong>段页式存储管理</strong>。</p>
<p>段页式存储管理的核心原理：</p>
<ul>
<li>先将逻辑空间按段式管理分成若干段</li>
<li>再把段内空间按页式管理分成若干页</li>
</ul>
<p>段页式的逻辑图：</p>
<p><img src="https://i.loli.net/2020/04/27/iRpWt8VyL9roK6g.png" alt="段页式地址.png"></p>
<p>段页地址中，段号指进程逻辑空间具体哪一段、段内页号指段里面具体的某一页、页内地址为页里面具体的内容。</p>
<p>段式内存管理、页式内存管理和段页式内存管理的详细图示如下：</p>
<p><img src="https://i.loli.net/2020/04/27/iP2FN4tdET6zOrm.png" alt="段页式存储管理详细图.png"></p>
<p>需要明确，不论是这三种管理方式的哪一种，都是针对<strong>进程的存储空间</strong>进行管理，即都是为了将进程的存储空间映射到物理的内存空间中。</p>
<h1 id="3-计算机组成原理"><a href="#3-计算机组成原理" class="headerlink" title="3.计算机组成原理"></a>3.计算机组成原理</h1><h2 id="为什么寄存器比内存快？"><a href="#为什么寄存器比内存快？" class="headerlink" title="为什么寄存器比内存快？"></a>为什么寄存器比内存快？</h2><p>计算机的存储层次（memory hierarchy）之中，寄存器（register）最快，内存其次，最慢的是硬盘。</p>
<p>同样都是晶体管存储设备，为什么寄存器比内存快呢？</p>
<p><strong>原因一：距离不同</strong></p>
<p>距离不是主要因素，但是最好懂，所以放在最前面说。内存离CPU比较远，所以要耗费更长的时间读取。</p>
<p>以3GHz的CPU为例，电流每秒钟可以振荡30亿次，每次耗时大约为0.33纳秒。光在1纳秒的时间内，可以前进30厘米。也就是说，在CPU的一个时钟周期内，光可以前进10厘米。因此，如果内存距离CPU超过5厘米，就不可能在一个时钟周期内完成数据的读取，这还没有考虑硬件的限制和电流实际上达不到光速。相比之下，寄存器在CPU内部，当然读起来会快一点。</p>
<p>这里说明下：之所以是5厘米而不是10厘米，是因为算的是往返的路程。</p>
<p>距离对于桌面电脑影响很大，对于手机影响就要小得多。手机CPU的时钟频率比较慢（iPhone 5s为1.3GHz），而且手机的内存紧挨着CPU。</p>
<p><strong>原因二：硬件设计不同</strong></p>
<p>苹果公司新推出的iPhone 5s，CPU是A7，寄存器有6000多位（31个64位寄存器，加上32个128位寄存器）。而iPhone 5s的内存是1GB，约为80亿位（bit）。这意味着，高性能、高成本、高耗电的设计可以用在寄存器上，反正只有6000多位，而不能用在内存上。因为每个位的成本和能耗只要增加一点点，就会被放大80亿倍。</p>
<p><strong>原因三：工作方式不同</strong></p>
<p>寄存器的工作方式很简单，只有两步：</p>
<p>（1）找到相关的位</p>
<p>（2）读取这些位</p>
<p>内存的工作方式就要复杂得多：</p>
<p>（1）找到数据的指针。（指针可能存放在寄存器内，所以这一步就已经包括寄存器的全部工作了。）</p>
<p>（2）将指针送往内存管理单元（MMU），由MMU将虚拟的内存地址翻译成实际的物理地址。</p>
<p>（3）将物理地址送往内存控制器（memory controller），由内存控制器找出该地址在哪一根内存插槽（bank）上。</p>
<p>（4）确定数据在哪一个内存块（chunk）上，从该块读取数据。</p>
<p>（5）数据先送回内存控制器，再送回CPU，然后开始使用。</p>
<p>内存的工作流程比寄存器多出许多步。每一步都会产生延迟，累积起来就使得内存比寄存器慢得多。</p>
<p>为了缓解寄存器与内存之间的巨大速度差异，硬件设计师做出了许多努力，包括在CPU内部设置缓存、优化CPU工作方式，尽量一次性从内存读取指令所要用到的全部数据等等。</p>
<h1 id="4-Linux"><a href="#4-Linux" class="headerlink" title="4.Linux"></a>4.Linux</h1><h2 id="线上服务器CPU占用率高如何排查定位问题？"><a href="#线上服务器CPU占用率高如何排查定位问题？" class="headerlink" title="线上服务器CPU占用率高如何排查定位问题？"></a>线上服务器CPU占用率高如何排查定位问题？</h2><p>如果 cpu 很高，但项目的性能却更差了，你会怎么排查？而且还要具体定位到出问题的代码在那里</p>
<p>一个参考的回答，一共分成九步：</p>
<ol>
<li><p>top -c 查看所有的进程 </p>
</li>
<li><p>在1的基础上键入P让cpu从高到底排序</p>
</li>
<li><p>选择2中cpu占比最高的pid进程</p>
</li>
<li><p>top -Hp pid 查看pid对应的线程对cpu的占比</p>
</li>
<li><p>在4的页面键入P让当前pid的线程cpu占比从高到低排序</p>
</li>
<li><p>获取第5步骤中的线程占比最高的线程id,由于linux打印的id是16进制的</p>
</li>
<li><p>将第6的线程id十六进制转为10进制 print “%xn” tid</p>
</li>
<li><p>打印指定pid下指定tid的jstack日志,jstack pid | grep tid -C 10 –color</p>
</li>
<li><p>根据堆栈信息找到代码块</p>
</li>
</ol>
<p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&mid=2247485874&idx=1&sn=0edacadb71654e7642832b81d86b6c60&scene=21#wechat_redirect" target="_blank" rel="noopener">也可以参考这篇文章</a></p>
<h2 id="epoll和select"><a href="#epoll和select" class="headerlink" title="epoll和select"></a>epoll和select</h2><p>现在几乎所有服务器用的都是epoll实现的，属于IO多路复用的内容。</p>
<p>epoll是一种方案，放弃了多进程、多线程、多协程，而是用单进程和单线程来实现高并发。</p>
<p>实际开发中，不会要你重写一个epoll服务器和多进程服务器，但是要了解epoll。</p>
<p>传统的单线程非阻塞IO的性能瓶颈，在于FD(套接字返回的对象)每次都保存在应用程序空间(用户态)中，这样，每次使用的时候都需要从用户态往内核态来回一换一次(而且伴有FD数据的复制过程)，而且随着FD数量增加，服务器返回的FD的列表长度也会越长，导致性能低下。</p>
<p>但是epoll开创了新的存储方式：</p>
<ol>
<li><p><strong>共享内存</strong>，它定义了一块内存空间，这块空间既不属于用户空间，也不属于系统kernel空间，而是应用程序和kenel共享的。</p>
</li>
<li><p>在这个内存中所有添加的，判断的数据套接字，对应的数字描述符，我在检测的时候，不用轮询，而是<strong>事件通知</strong>。也就是把时间花在直接<strong>操作修改</strong>FD上，而不是查找。</p>
</li>
</ol>
<p>epoll原理图如下：</p>
<p><img src="https://i.loli.net/2020/04/02/doMyChETgSc1DxQ.png" alt="epoll原理图.png"></p>
<p>epoll优势：</p>
<ol>
<li><strong>减少了FD对象的用户态与内核态之间的复制过程</strong>。</li>
<li>采用<strong>事件通知</strong>的方式。FD对象很多，内部list很长的时候，也是个问题。</li>
</ol>
<p>总的来说，epoll只是轮询那些真正发生的流、但select会轮询所有的流，并且只依次顺序处理已经就绪的流，这种做法避免了大量的无用操作。</p>
<h1 id="5-数据库"><a href="#5-数据库" class="headerlink" title="5.数据库"></a>5.数据库</h1><h2 id="什么是sql注入？如何防止sql注入？"><a href="#什么是sql注入？如何防止sql注入？" class="headerlink" title="什么是sql注入？如何防止sql注入？"></a>什么是sql注入？如何防止sql注入？</h2><h3 id="什么是sql注入以及是如何产生的"><a href="#什么是sql注入以及是如何产生的" class="headerlink" title="什么是sql注入以及是如何产生的"></a>什么是sql注入以及是如何产生的</h3><p><a href="https://www.cnblogs.com/gyrgyr/p/9876569.html" target="_blank" rel="noopener">参考文章：https://www.cnblogs.com/gyrgyr/p/9876569.html</a></p>
<p>sql注入是一种<strong>将sql代码添加到输入参数中，传递到sql服务器解析并执行的一种攻击手段</strong>。</p>
<p>举例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> article <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>这条语句能查出来id为1的对应的内容。</p>
<p>但是当我们往id传的参数中注入sql代码时，就可以<strong>根据自己需求查询自己想要获取的内容</strong>。</p>
<p>举例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> article <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">OR</span> <span class="number">1</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p> id值传参数为 -1 OR 1=1 ,此时执行代码中id值带入了我们传参数的sql代码， 1=1 为真，OR 1=1便会查出表中所有的内容。达到攻击目的。所以sql注入攻击就是<strong>输入参数未经过滤，直接拼接到sql语句中，解析执行，达到预想之外的行为</strong>。</p>
<p><strong>SQL注入是如何产生的？</strong></p>
<ul>
<li>web开发人员无法保证所有的输入都已经过滤</li>
<li>攻击者利用发送给sql服务器的输入数据构造可执行代码</li>
<li>数据库未做相应安全配置(对web应用设置特定的数据库账号，而不使用root或管理员账号，特定数据库账号给予一些简单操作的权限，回收一些类似drop的操作权限)</li>
</ul>
<h3 id="进行sql注入攻击的手段"><a href="#进行sql注入攻击的手段" class="headerlink" title="进行sql注入攻击的手段"></a>进行sql注入攻击的手段</h3><p>这里介绍两种方式：</p>
<ol>
<li>数字注入</li>
</ol>
<p>sql中where条件的参数值为数字的语句进行修改攻击。</p>
<p>也就是上面提到的 id = -1 OR 1=1</p>
<ol start="2">
<li>字符串注入</li>
</ol>
<ul>
<li>以sql中的注释符号‘#’来实现攻击——我们只需要知道数据库中的某一个用户的用户名，比如peter,在表单输入时，在用户名列输入 “peter’#”,密码随意输入，点击登陆后便会显示登陆成功</li>
<li>以注释符号‘ – ’来实现攻击: 还是一样只需要知道数据库中的某一个用户的用户名，比如peter,在表单输入时，在用户名列输入 “peter’– ” （双中横线后还有空格）,密码随意输入，点击登陆后便会显示登陆成功。</li>
</ul>
<h3 id="预防SQL注入-三种方法"><a href="#预防SQL注入-三种方法" class="headerlink" title="预防SQL注入(三种方法)"></a>预防SQL注入(三种方法)</h3><ul>
<li>严格检查输入变量的类型和格式<ul>
<li>1.对数字类型的参数id的强校验（empty()为空验证和is_numeric()进行数字验证）</li>
<li>2.对字符串类型的参数的校验 （正则校验）。例如上面提到的登陆系统的用户名的校验，比如校验规则为 六位数字以上的字母或者数字，可以用preg_match(“/^[a-zA-Z0-9]{6,}$/“)</li>
</ul>
</li>
<li>过滤和转义特殊字符<ul>
<li>1.用php函数addslashes()进行转义（<a href="https://www.cnblogs.com/gyrgyr/p/9878381.html" target="_blank" rel="noopener">addslashes函数使用方法详解点这里</a>）：一般是对这些特殊字符进行转义：1.单引号（’）  2.双引号（”） 3.反斜杠（\） 4. NULL</li>
<li>2.用mysqli的php扩展中的函数 mysqli_real_escape_string()</li>
</ul>
</li>
</ul>
<p>注：这两种方法只做简单介绍用，但其实现在的黑客已经可以轻而易举的绕过这些函数，包括一些字符串替换 str_replace() 等，表着急，继续往下看，下面介绍的第三种防sql注入的方法还是比较实在，如果需要还是直接用下面的方法吧~</p>
<ul>
<li>利用预编译机制（mysqli 和 pdo）<ul>
<li>1.DML语句预编译（mysqli示例和pdo示例）<em>（<a href="https://www.cnblogs.com/gyrgyr/p/9895952.html" target="_blank" rel="noopener">使用mysqli需要开启扩展详细教程点我</a>）</em>   <em><a href="https://www.cnblogs.com/gyrgyr/p/9896204.html" target="_blank" rel="noopener">(使用pdo需要开启扩展详细教程点我)</a></em></li>
<li>2.DQL语句预编译（mysqli示例）</li>
</ul>
</li>
</ul>
<h2 id="数据库各种join语句的区别-left、inner、right"><a href="#数据库各种join语句的区别-left、inner、right" class="headerlink" title="数据库各种join语句的区别(left、inner、right)"></a>数据库各种join语句的区别(left、inner、right)</h2><p><a href="https://www.cnblogs.com/coder-programming/p/10668123.html" target="_blank" rel="noopener">带你了解数据库中JOIN的用法</a></p>
<p>在mysql数据库中经常会用到”join”，其中比较常用的是<code>left join</code>、<code>right join</code>、<code>inner join</code>。前三者实际上属于<code>outer join</code>，也就是其本质是<code>left outer join</code>、<code>right outer  join</code>，但是其关键字<code>outer</code>可以省略不写。</p>
<p>内连接用于返回满足连接条件的记录；而外连接则是内连接的扩展，它不仅会满足连接条件的记录，而且还会返回不满足连接条件的记录。</p>
<p>首先，当我们在进行多表联合查询的时候，会默认进行<strong>笛卡尔积</strong>运算。比如我们现在有两张表，一张Student表有5个项，一张Class表有3个项，则用<code>select * from Student,Class</code>查找的时候，会默认返回15个项（详见链接例子）</p>
<p>但是这是我们一般不用的方法。</p>
<ul>
<li><p><strong>内连接</strong>(inner join)：如用inner join，则返回满足条件的所有记录，默认情况下为内连接(inner join)</p>
</li>
<li><p><strong>左外连接</strong>(left join)：左外连接查询，不仅返回满足条件的所有记录，而且还会返回不满足连接条件的连接操作符左边表的其他行。即<font color=#FF0000>用left join查询的结果，左表为主表，右表连接可以为NULL</font>。比如我们在Student表中插入了一个新的学生，他没有ID，但是在查询过程中如果用了left join，就能够查出来他，但是ID对应的会是NULL。比如：<code>slelect stu.StudentName,cl.ClassName from Student stu **left join** Class cl on stu.StudentClassID=cl.ClassID</code>; </p>
</li>
<li><p><strong>右外连接</strong>(right join)：右外连接查询不仅返回满足条件的所有记录，而且还会返回不满足连接条件的连接操作符右边的其他行。即<font color=#FF0000>用right join查询的结果，右表为主表，左表连接可以为NULL</font>。还是和上面类似，如果我们在班级Class表中新增班级，但是没有针对这个班级新增学生，则当查询的时候，ClassName会有显示，但是StudentName会是NULL。查询语句样例：<code>select stu.StudentName,cl.ClassName from Student stu right join Class cl on stu.StudentClassID=cl.ClassID;</code></p>
</li>
</ul>
<h2 id="一条SQL语句执行得很慢的原因有哪些？"><a href="#一条SQL语句执行得很慢的原因有哪些？" class="headerlink" title="一条SQL语句执行得很慢的原因有哪些？"></a>一条SQL语句执行得很慢的原因有哪些？</h2><p>首先说一下总的答案：</p>
<p>一个 SQL 执行的很慢，我们要分两种情况讨论：</p>
<ol>
<li>大多数情况下很正常，偶尔很慢，则有如下原因</li>
</ol>
<p>(1)、数据库在刷新脏页，例如 redo log 写满了需要同步到磁盘。</p>
<p>(2)、执行的时候，遇到锁，如表锁、行锁。</p>
<ol start="2">
<li>这条 SQL 语句一直执行的很慢，则有如下原因。</li>
</ol>
<p>(1)、没有用上索引：例如该字段没有索引；由于对字段进行运算、函数操作导致无法用索引。</p>
<p>(2)、数据库选错了索引(数据库自己预测不使用你的索引能够更快)。主要由于统计失误，导致系统没有走索引，而是走了全表扫描，从而导致某条SQL执行很慢。</p>
<p>数据库在执行语句之前会做采样，如果采样之后发现走索引不比不走索引快，那么可能不走索引了，那么你定义的索引可能有问题，比如对表的覆盖程度不够。</p>
<h2 id="数据库事务的四大特性是什么？"><a href="#数据库事务的四大特性是什么？" class="headerlink" title="数据库事务的四大特性是什么？"></a>数据库事务的四大特性是什么？</h2><p><a href="https://www.cnblogs.com/lyr2015/p/5780698.html" target="_blank" rel="noopener">可以参考这篇文章</a></p>
<p><strong>ACID</strong></p>
<ul>
<li>Atomicity：<strong>原子性</strong>，一个事务要么全部完成，要么全部失败。通俗的另一种说法是：要么都做，要么都不做。比如银行取钱，我这边还没取完，你就不能操作我的账户。比较相似的是，如果一个用户正在操作他的账户，而且他的账户里面的钱的金额很大，可能出现的情况就是他点确认了，但是数据要处理几秒，那么这段时间这个账户也是不能被操作的。</li>
</ul>
<p><strong>原子性的核心是</strong>：利用一个undo日志来记录事务可以回滚的各个数据版本。即当目前执行的事务发生故障时，需要回滚，可以根据undo日志中的记录来知道事务回滚到哪一步停止。这样来保证事务由当下状态回滚到开始执行前的状态。</p>
<p><font color=#FF0000>不要把原子性和一致性、隔离性混淆。</font>原子性并不能保证看不到数据的中间状态，而一致性和隔离性才可以保障用户看不到数据的中间状态。</p>
<ul>
<li>Consistency，<strong>一致性</strong>，就是从<strong>一个状态转变到另一个状态，没有数据的中间状态</strong>。比如用户进行取钱操作，我们建立三个”视点”，在事务变化的过程中可以通过切换视点来读取事务在不同时刻的状态值。比如要解决一致性问题，我们可以用两种思路：将视点上移读取到旧数据、或者将视点下移读取到更新后的数据。总之，保持一致性就是保证不读取中间状态的数据。</li>
</ul>
<p>比如，视点1是读取事务开始前的旧数据，视点2代表读取事务结束后的新数据，视点3是读取事务执行中的中间状态的数据。如下图：</p>
<p><img src="https://i.loli.net/2020/04/18/ZfiVuADToB8StCQ.png" alt="一致性.png"></p>
<p>在处理一致性问题时，有两种方法：上移视点3到视点1，读取事务开始前的旧数据；下移视点3到视点2，读取更新后的新数据。可见保证一致性就是保证不读取中间状态的数据。</p>
<ul>
<li>Isolation，<strong>隔离性</strong>，<font color=#FF0000>隔离性实际上是以提高性能为目的，对一致性地破坏。</font>事务之间是互相独立的。一个事务的执行不能影响其他事务。</li>
<li>Durability，<strong>持久性</strong>，事务需要是持久的，比如介质受损了，比如断电之后，数据也还能保存。</li>
</ul>
<p>其中，Isolation，隔离性，是最关键的一个属性。</p>
<p>事务隔离级别有四个。事务会先begin transaction，然后开始做。</p>
<ul>
<li>Read uncommitted，<strong>读未提交</strong>，<strong>对所有事务只加写锁，不加读锁</strong>。即<strong>只有写写不可以并行</strong>。但是这回导致读事务读到一些中间状态的数据，即脏读。事务的隔离级别非常低，别的事务完成到了一半还没committ的时候，就能够被我读出来。（不能避免脏读）</li>
<li>Read Committed，<strong>读已提交</strong>，允许读后写并行。读到的任何数据都是提交的数据，避免读到中间的未提交的数据。但是无法避免不可重复读。因为读事务第一次读取数据之后，另一个写事务可能会修改此事务，导致读事务第二次读取数据和第一次所读到的不一样。但是这种场景并不是经常出现，系统的一致性可以接受，因此多数数据库的默认级别是读已提交。(可以避免脏读)</li>
<li>Repeatable Reads,<strong>可重复度</strong>，利用共享锁和排写锁实现。读读并行，禁止任何写事务并行。这个针对上一个，这种读法始终只能读取到我自己begin transaction时候的值。</li>
<li>Serializable，<strong>可序列化</strong>，事务隔离级别最高，并发性最差，利用排它锁实现。 针对同一资源，将所有的请求事务进行排序，一个一个顺序执行。最高限度的保证了数据的一致性。两个事务同时发生的时候，一定只会读取到其中一个的结果。</li>
</ul>
<h2 id="什么是MVCC？——不可重复读隔离方式的实现之一"><a href="#什么是MVCC？——不可重复读隔离方式的实现之一" class="headerlink" title="什么是MVCC？——不可重复读隔离方式的实现之一"></a>什么是MVCC？——不可重复读隔离方式的实现之一</h2><p><a href="https://www.cnblogs.com/lyr2015/p/5780698.html" target="_blank" rel="noopener">可以参考这篇文章</a></p>
<p><a href="https://blog.csdn.net/u013007900/article/details/78641913" target="_blank" rel="noopener">更详细的MVCC原理及实现，可以参考这篇文章</a></p>
<p>MVCC全称是：Multi-Version Concurrency Control,是一种<font color=#FF0000>不利用锁机制实现的隔离级别</font>，主要实现了在保证数据的一致性的前提下<strong>实现读写并行</strong>。</p>
<p>MVCC原理是给每一个数据的更新都添加一个<strong>版本号</strong>。当写事务正在进行时，此时过来一个读事务，读事务会首先生成一个版本号，即该事务想读取哪一个版本的数据。然后，写事务更新数据，读事务读取之前相应版本的数据，而保证了不出现不可重复读和脏读的情况。</p>
<p>之前提到，保证数据一致性有两种方式，要么<strong>将读事务读取视点1的数据</strong>，要么<strong>读取视点2的数据</strong>。在mvcc中保证数据一致性的方法选择的是，<font color=#FF0000>读取视点1的数据，即读取的是写事务开始之前的旧版本数据</font>。</p>
<p>实际上，<font color=#FF0000>MVCC是不可重复读隔离机制的实现方法之一</font>。mysql为了实现线程不阻塞，采用了mvvc机制，使用版本号进行事务的隔离，其采用的方式有点类似java的cas机制，最大好处就是不加锁，但是只有在Innodb的引擎下存在，其实就是实现行锁的一种方式，可以理解为乐观锁实现行锁，对于其他引擎主要是悲观锁实现行锁。</p>
<h2 id="并发事务执行的时候会有什么问题"><a href="#并发事务执行的时候会有什么问题" class="headerlink" title="并发事务执行的时候会有什么问题"></a>并发事务执行的时候会有什么问题</h2><p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对统一数据进行操 作）。并发虽然是必须的，但可能会导致以下的问题。</p>
<ul>
<li><p><strong>更新丢失</strong>（Lost to modify）: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事 务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1， 终结果A=19，事务1的修改被丢失。 （这个问题mysql所有事务隔离级别在数据库层面上都能避免，因为所有事务最低会在写的时候加锁，读的时候不加锁，但是写的时候加了写锁，就已经能够保证更新丢失这个问题了。）</p>
</li>
<li><p><strong>脏读</strong>（Dirty read）: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这 时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个 事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。 </p>
</li>
<li><p><strong>不可重复读</strong>（Unrepeatableread）: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务 也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的 数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。 </p>
</li>
<li><p><strong>幻读</strong>（Phantom read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发 事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就 好像发生了幻觉一样，所以称为幻读</p>
</li>
</ul>
<p><strong>解决方法</strong>：加上事务隔离级别</p>
<ul>
<li>更新丢失——Mysql所有事务隔离级别在数据库层面上均可避免。</li>
<li>脏读——READ-COMMITTED事务隔离级别以上可以避免</li>
<li>不可重复读——REPEATABLE-READ事务隔离级别以上可以避免</li>
<li>幻读——SERIALIZABLE事务隔离级别可避免</li>
</ul>
<p><strong>不可重复度和幻读区别</strong>：</p>
<p><strong>不可重复读的重点是修改，幻读的重点在于新增或者删除</strong>。</p>
<p>例1（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 ）：事务1中的A先生读取自己的工资为 1000的操 作还没完成，事务2中的B先生就修改了A的工资为2000，导 致A再读自己的工资时工资变为 2000；这就是不可重复 读。</p>
<p>例2（同样的条件, 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，事务1读取了所 有工资大于3000的人，共查到4条记录，这时事务2 又插入了一条工资大于3000的记录，事务1再次读取时查到的记 录就变为了5条，这样就导致了幻读。 </p>
<p>通过在写的时候加锁，可以解决脏读。</p>
<p>通过在读的时候加锁，可以解决不可重复读。</p>
<p>通过串行化，可以解决幻读。</p>
<p>以上这几种解决方案其实是数据库的几种隔离级别。</p>
<h2 id="讲一下数据库的隔离级别？"><a href="#讲一下数据库的隔离级别？" class="headerlink" title="讲一下数据库的隔离级别？"></a>讲一下数据库的隔离级别？</h2><p>SQL 标准定义了四个隔离级别： </p>
<ul>
<li><strong>READ-UNCOMMITTED</strong>(读取未提交)： 低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读 </li>
<li><strong>READ-COMMITTED</strong>(读取已提交): 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读 仍有可能发生 </li>
<li><strong>REPEATABLE-READ</strong>（可重复读）: 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修 改，可以阻止脏读和不可重复读，但幻读仍有可能发生。 </li>
<li><strong>SERIALIZABLE</strong>(可串行化): 高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务 之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li>
</ul>
<p>总结上面这几种情况如下图所示：</p>
<p><img src="https://s2.ax1x.com/2020/02/23/33EMr9.png" alt="33EMr9.png"></p>
<p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ</strong>（可重读）。我们可以通过 SELECT @@tx_isolation;命令来查看。</p>
<p>这里需要注意的是：与 SQL 标准不同的地方在于InnoDB 存储引擎在 <strong>REPEATABLE-READ</strong>（可重读）事务隔离级别 下使用的是Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的。所以 说InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ</strong>（可重读） 已经可以完全保证事务的隔离性要 求，即达到了 SQL标准的<strong>SERIALIZABLE</strong>(可串行化)隔离级别。 </p>
<p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是<strong>READ-COMMITTED</strong>(读取提交内容):，但是你要知道的是InnoDB 存储引擎默认使用 <strong>REPEATABLE-READ</strong>（可重读）并不会有任何性能损失。</p>
<p>InnoDB 存储引擎在 <strong>分布式事务</strong> 的情况下一般会用到<strong>SERIALIZABLE</strong>(可串行化)隔离级别。 </p>
<h2 id="什么是联合索引的最左匹配原则？"><a href="#什么是联合索引的最左匹配原则？" class="headerlink" title="什么是联合索引的最左匹配原则？"></a>什么是联合索引的最左匹配原则？</h2><blockquote>
<p>以下回答全部是基于MySQL的InnoDB引擎</p>
</blockquote>
<p>给出一张表作为例子：</p>
<p><img src="https://i.loli.net/2020/03/19/bUCv5cYonpATdFw.png" alt="一个例子.png"></p>
<p>如果我们按照 name 字段来建立索引的话，采用B+树的结构，大概的索引结构如下</p>
<p><img src="https://i.loli.net/2020/03/19/FASYKqlTmbegifL.png" alt="例子索引.png"></p>
<p>如果我们要进行模糊查找，查找name 以“张”开头的所有人的ID，即 sql 语句为</p>
<p><code>select ID from table where name like &#39;张%&#39;</code></p>
<p>由于在B+树结构的索引中，索引项是按照索引定义里面出现的字段顺序排序的，索引在查找的时候，可以快速定位到 ID 为 100的张一，然后直接向右遍历所有张开头的人，直到条件不满足为止。</p>
<p>也就是说，我们找到第一个满足条件的人之后，直接向右遍历就可以了，由于索引是有序的，所有满足条件的人都会聚集在一起。</p>
<p>但是，假设我们已经创建了联合索引(a,b,c)，那么系统默认会生成索引：(a)、(a,b)、(a,b,c)。</p>
<p>当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的<strong>最左匹配特性</strong>。</p>
<p>而这种定位到最左边，然后向右遍历寻找，就是我们所说的<strong>联合索引最左匹配原则</strong>。</p>
<h2 id="什么是聚簇索引和非聚簇索引？"><a href="#什么是聚簇索引和非聚簇索引？" class="headerlink" title="什么是聚簇索引和非聚簇索引？"></a>什么是聚簇索引和非聚簇索引？</h2><p>参考这篇文章：<a href="https://my.oschina.net/xiaoyoung/blog/3046779" target="_blank" rel="noopener">浅谈聚簇索引和非聚簇索引的区别</a></p>
<p>首先区别：</p>
<ul>
<li><strong>聚簇索引</strong>：将数据存储与索引放到了一块，找到索引也就找到了数据。(索引结构的叶子节点保存了行数据)</li>
<li><strong>非聚簇索引(辅助索引)</strong>：将数据与索引分开存储，索引结构的叶子节点指向了数据对应的位置</li>
</ul>
<h3 id="聚簇索引具有唯一性"><a href="#聚簇索引具有唯一性" class="headerlink" title="聚簇索引具有唯一性"></a>聚簇索引具有唯一性</h3><p>由于聚簇索引是将数据索引结构放到一块，所以一个表仅有一个聚簇索引。</p>
<h3 id="一个误区：把主键自动设为聚簇索引"><a href="#一个误区：把主键自动设为聚簇索引" class="headerlink" title="一个误区：把主键自动设为聚簇索引"></a>一个误区：把主键自动设为聚簇索引</h3><p><strong>聚簇索引默认是主键</strong>，如果表中没有定义主键，InnoDB 会选择一个<strong>唯一的非空索引</strong>代替。如果没有这样的索引，InnoDB 会<strong>隐式定义一个主键</strong>来作为聚簇索引。InnoDB 只聚集在同一个页面中的记录。包含相邻健值的页面可能相距甚远。</p>
<p><strong>如果你已经设置了主键为聚簇索引，必须先删除主键，然后添加我们想要的聚簇索引，最后恢复设置主键即可</strong>。</p>
<p>此时其他索引只能被定义为非聚簇索引。这个是最大的误区。有的主键还是无意义的自动增量字段，那样的话Clustered index对效率的帮助，完全被浪费了。</p>
<p>刚才说到了，聚簇索引性能最好而且具有唯一性，所以非常珍贵，必须慎重设置。<strong>一般要根据这个表最常用的SQL查询方式来进行选择，某个字段作为聚簇索引，或组合聚簇索引</strong>，这个要看实际情况。</p>
<p>记住我们的<strong>最终目的</strong>就是<strong>在相同结果集情况下，尽可能减少逻辑IO</strong>。</p>
<h3 id="InnoDB和MyISAM数据库的聚簇索引"><a href="#InnoDB和MyISAM数据库的聚簇索引" class="headerlink" title="InnoDB和MyISAM数据库的聚簇索引"></a>InnoDB和MyISAM数据库的聚簇索引</h3><p><img src="https://i.loli.net/2020/04/18/zQ8EkeM7bUOLcYF.png" alt="聚簇索引和非聚簇索引例子.png"></p>
<ol>
<li>InnoDB使用的是聚簇索引，将<strong>主键组织到一棵B+树</strong>中，而<strong>行数据就储存在叶子节点</strong>上，若使用”where id = 14”这样的条件查找主键，则<strong>按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据</strong>。</li>
<li>若<strong>对Name列进行条件搜索，则需要两个步骤</strong>：<strong>第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键</strong>。第二步<strong>使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据</strong>。（<strong>重点在于通过其他键需要建立辅助索引</strong>）</li>
</ol>
<p>MyISM使用的是非聚簇索引，<strong>非聚簇索引的两棵B+树看上去没什么不同</strong>，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于<strong>索引树是独立的，通过辅助键检索无需访问主键的索引树</strong>。</p>
<h3 id="聚簇索引的优势"><a href="#聚簇索引的优势" class="headerlink" title="聚簇索引的优势"></a>聚簇索引的优势</h3><p>看上去聚簇索引的效率明显要低于非聚簇索引，因为<strong>每次使用辅助索引检索都要经过两次B+树查找</strong>，这不是多此一举吗？聚簇索引的优势在哪？</p>
<ol>
<li>由于<strong>行数据和叶子节点存储在一起，同一页中会有多条行数据，访问同一数据页不同行记录时，已经把页加载到了Buffer中，再次访问的时候，会在内存中完成访问</strong>，不必访问磁盘。这样<strong>主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回</strong>了，<strong>如果按照主键Id来组织数据，获得数据更快</strong>。</li>
<li><strong>辅助索引使用主键作为”指针”而不是使用地址值作为指针的好处</strong>是，<strong>减少了当出现行移动或者数据页分裂时辅助索引的维护工作</strong>，<strong>使用主键值当作指针会让辅助索引占用更多的空间，换来的好处是InnoDB在移动行时无须更新辅助索引中的这个”指针”</strong>。<strong>也就是说行的位置（实现中通过16K的Page来定位）会随着数据库里数据的修改而发生变化（前面的B+树节点分裂以及Page的分裂），使用聚簇索引就可以保证不管这个主键B+树的节点如何变化，辅助索引树都不受影响</strong>。</li>
<li>聚簇索引适合用在排序的场合，非聚簇索引不适合</li>
<li>取出一定范围数据的时候，使用用聚簇索引</li>
<li>二级索引需要两次索引查找，而不是一次才能取到数据，因为存储引擎第一次需要通过二级索引找到索引的叶子节点，从而找到数据的主键，然后在聚簇索引中用主键再次查找索引，再找到数据</li>
<li>可以把<strong>相关数据保存在一起</strong>。例如实现电子邮箱时，可以根据用户 ID 来聚集数据，这样只需要从磁盘读取少数的数据页就能获取某个用户的全部邮件。如果没有使用聚簇索引，则每封邮件都可能导致一次磁盘 I/O。</li>
</ol>
<h3 id="聚簇索引的劣势"><a href="#聚簇索引的劣势" class="headerlink" title="聚簇索引的劣势"></a>聚簇索引的劣势</h3><ol>
<li><strong>维护索引很昂贵，特别是插入新行或者主键被更新导至要分页(page split)的时候</strong>。建议在大量插入新行后，选在负载较低的时间段，通过OPTIMIZE TABLE优化表，因为必须被移动的行数据可能造成碎片。使用独享表空间可以弱化碎片</li>
<li>表因为使用UUId（随机ID）作为主键，使数据存储稀疏，这就会出现聚簇索引有可能有比全表扫面更慢，所以建议使用int的auto_increment作为主键。主键的值是顺序的，所以 InnoDB 把每一条记录都存储在上一条记录的后面。当达到页的最大填充因子时（InnoDB 默认的最大填充因子是页大小的 15/16，留出部分空间用于以后修改），下一条记录就会写入新的页中。一旦数据按照这种顺序的方式加载，主键页就会近似于被顺序的记录填满（二级索引页可能是不一样的）</li>
<li>如果主键比较大的话，那辅助索引将会变的更大，因为<strong>辅助索引的叶子存储的是主键值；过长的主键值，会导致非叶子节点占用占用更多的物理空间</strong></li>
</ol>
<h2 id="MYSQL非主键索引的二次查找过程"><a href="#MYSQL非主键索引的二次查找过程" class="headerlink" title="MYSQL非主键索引的二次查找过程"></a>MYSQL非主键索引的二次查找过程</h2><p><a href="https://blog.csdn.net/yoga0301/article/details/80274235" target="_blank" rel="noopener">Mysql-InnoDB索引二次查找解决方案</a></p>
<p>因为Innodb二级索引存储的是主键，所以通过索引查找时，第一次查询是通过二级索引找到主键值，第二次查询是通过主键在聚簇索引找到对应的行位置。</p>
<h2 id="为什么用-B-树做索引而不用哈希表做索引"><a href="#为什么用-B-树做索引而不用哈希表做索引" class="headerlink" title="为什么用 B+ 树做索引而不用哈希表做索引?"></a>为什么用 B+ 树做索引而不用哈希表做索引?</h2><p>哈希表查找效率是O(1)，二叉树查找效率是O(logn)，那为什么用二叉树不用哈希表呢？</p>
<p>这和业务场景有关。如果只查询一个元素，确实hash表更快，但是数据库经常要选择多条，这时候由于B+树有序，所有value又都保存在叶子节点(操作比B树方便)，而且所有叶子节点都有链表连接，所以效率更高。</p>
<p>1、哈希表是把索引字段映射成对应的哈希码然后再存放在对应的位置，这样的话，如果我们要进行模糊查找的话，显然哈希表这种结构是不支持的，只能遍历这个表。而B+树则可以通过最左前缀原则快速找到对应的数据。</p>
<p>2、如果我们要进行范围查找，例如查找ID为100 ~ 400的人，哈希表同样不支持，只能遍历全表。</p>
<p>3、索引字段通过哈希映射成哈希码，如果很多字段都刚好映射到相同值的哈希码的话，那么形成的索引结构将会是一条很长的链表，这样的话，查找的时间就会大大增加。</p>
<p>4、考虑到磁盘操作，磁盘内存有限，很难保证用哈希表可以一口气全读进去，而B+树支持分批处理，同时树的高度比较低，可以提高查重效率。</p>
<h2 id="数据库中文件查找的过程是怎样的？-B树"><a href="#数据库中文件查找的过程是怎样的？-B树" class="headerlink" title="数据库中文件查找的过程是怎样的？(B树)"></a>数据库中文件查找的过程是怎样的？(B树)</h2><p>B树一般用于文件系统的索引，用于查找文件。</p>
<p>文件系统选择用B树而不用红黑树或有序数组，为什么呢？</p>
<p>首先，文件系统和数据库的索引都是存在硬盘上的，并且如果数据量大的话，不一定能一次性加载到内存中。但是比如用B树，每次只要加载节点上的一两个数就可以了。</p>
<p>所以，数组肯定不能存下，就算红黑树，也要存储大量节点才能找到，所以B树用于文件查找更多。实际上，在内存中，红黑树比B树效率更高。但是如果涉及到磁盘操作，比如读写有限，B树则更优。</p>
<p>B树结构如下：</p>
<p>B-树又称作”多路平衡查找树”</p>
<p><img src="https://s2.ax1x.com/2020/02/19/3VXkEF.png" alt="3VXkEF.png"></p>
<p>定义：</p>
<ul>
<li>根节点至少包括两个孩子</li>
<li>树中每个结点最多含有m个孩子(m&gt;=2)</li>
<li>除根节点和叶节点外，其他每个节点至少有ceil(m/2)个孩子(ceil为取上限，举例，1.2和1.5，都是取2)</li>
<li>所有叶子节点都位于同一层(即叶子节点高度都相同)</li>
</ul>
<h2 id="为什么用B-树做索引而不用B树"><a href="#为什么用B-树做索引而不用B树" class="headerlink" title="为什么用B+树做索引而不用B树"></a>为什么用B+树做索引而不用B树</h2><p>首先回顾一下B+树的结构：</p>
<p><img src="https://s2.ax1x.com/2020/02/19/3Vvr1s.png" alt="3Vvr1s.png"></p>
<p>B+树实际上是B树的变体，其定义和B树不同的地方为：</p>
<ul>
<li>非叶子节点的子树指针与关键字个数相同</li>
<li>非叶子节点的子树指针P[i]，指向关键字值[K[i],K[i+1])<font color=#FFF0000>(左闭右开，即可以大于等于K[i]，但必须大于K[i+1]  )</font>的子树</li>
<li>非叶子节点仅用来索引，数据都保存在叶子节点中。<font color=#FFF0000>所有的数据实际都存储在叶子节点上，所以每一次遍历都必须遍历到叶子节点上。</font>这也使得B+树的层级可以更少，树可以更矮。</li>
<li>所有叶子节点均有一个链指针指向下一个叶子节点。<font color=#FFF0000>搜索的实际是上图中粉色的块的部分。</font>这个链指针主要服务于<strong>范围统计</strong>，定位到了某个叶指针之后，可以快速横向地去做统计。比如要统计索引&gt;10的，找到了第二个Q之后，直接统计后面所有的Q内容即可。</li>
</ul>
<p>结论：B+树相比B树更适合用来做存储索引</p>
<ul>
<li>B+树的磁盘读写代价更低。B+树内部只存储索引(或者说叶子节点的指针)，如果查询多条的时候，B树需要做局部的中序遍历，可能需要不断在父节点和叶子节点之间来回移动，所以B+树的磁盘读写代价更低。</li>
<li>B+树查询效率更加稳定。因为所有实质内容都存储在根节点上，所以几乎所有数据的查询的时间都是稳定的：O(n)</li>
<li>B+树更有利于对数据库的扫描。B+树只需要遍历叶子节点就可以实现全部关键字信息的扫描。比如之前提到的，数据库中频繁使用的范围查询，使用B+树查询能够大大增加效率。</li>
</ul>
<h2 id="主键索引和非主键索引有什么区别？"><a href="#主键索引和非主键索引有什么区别？" class="headerlink" title="主键索引和非主键索引有什么区别？"></a>主键索引和非主键索引有什么区别？</h2><p>例如对于下面这个表(其实就是上面的表中增加了一个k字段),且ID是主键。</p>
<p><img src="https://i.loli.net/2020/03/19/ELdCNXhp75QSmis.png" alt="加了个非主键索引.png"></p>
<p>主键索引和非主键索引的示意图如下：</p>
<p><img src="https://i.loli.net/2020/03/19/6WRaFfuOPVtTJeE.png" alt="主键索引和非主键索引.png"></p>
<p>其中R代表一整行的值。</p>
<p>从图中不难看出，主键索引和非主键索引的区别是：非主键索引的叶子节点存放的是<strong>主键的值</strong>，而主键索引的叶子节点存放的是<strong>整行数据</strong>，其中非主键索引也被称为<strong>二级索引</strong>，而主键索引也被称为<strong>聚簇索引</strong>。</p>
<p>根据这两种结构我们来进行下查询，看看他们在查询上有什么区别。</p>
<ol>
<li><p>如果查询语句是 select * from table where ID = 100,即主键查询的方式，则只需要搜索 ID 这棵 B+树。</p>
</li>
<li><p>如果查询语句是 select * from table where k = 1，即非主键的查询方式，则先搜索k索引树，得到ID=100,再到ID索引树搜索一次，这个过程也被称为回表。</p>
</li>
</ol>
<h2 id="为什么建议使用主键自增的索引？比如自增id"><a href="#为什么建议使用主键自增的索引？比如自增id" class="headerlink" title="为什么建议使用主键自增的索引？比如自增id"></a>为什么建议使用主键自增的索引？比如自增id</h2><p><strong>聚簇索引的数据的物理存放顺序与索引顺序是一致的</strong>，即：<strong>只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的</strong>。如果主键不是自增id，那么可以想 象，它会干些什么，不断地调整数据的物理地址、分页，当然也有其他一些措施来减少这些操作，但却无法彻底避免。但，如果是自增的，那就简单了，它只需要一 页一页地写，索引结构相对紧凑，磁盘碎片少，效率也高。</p>
<p>因为<strong>MyISAM的主索引并非聚簇索引，那么他的数据的物理地址必然是凌乱的，拿到这些物理地址，按照合适的算法进行I/O读取，于是开始不停的寻道不停的旋转</strong>。<strong>聚簇索引则只需一次I/O</strong>。（强烈的对比）</p>
<p>不过，如果<strong>涉及到大数据量的排序、全表扫描、count之类的操作的话，还是MyISAM占优势些，因为索引所占空间小，这些操作是需要在内存中完成的</strong>。</p>
<p>举个例子，对于这颗主键索引的树</p>
<p><img src="https://i.loli.net/2020/03/19/4AOKQ8fG3ipCJZz.png" alt="主键的索引树.png"></p>
<p>如果我们插入 ID = 650 的一行数据，那么直接在最右边插入就可以了</p>
<p><img src="https://i.loli.net/2020/03/19/KIRLVOkxsPr58gz.png" alt="主键的索引树插入数据.png"></p>
<p>但是如果插入的是 ID = 350 的一行数据，由于 B+ 树是有序的，那么需要将下面的叶子节点进行移动，腾出位置来插入 ID = 350 的数据，这样就会比较消耗时间，如果刚好 R4 所在的数据页已经满了，需要进行页分裂操作，这样会更加糟糕。</p>
<p>但是，如果我们的主键是自增的，每次插入的 ID 都会比前面的大，那么我们每次只需要在后面插入就行， 不需要移动位置、分裂等操作，这样可以提高性能。也就是为什么建议使用主键自增的索引。</p>
<h2 id="什么是共享锁-S-和排它锁-X"><a href="#什么是共享锁-S-和排它锁-X" class="headerlink" title="什么是共享锁(S)和排它锁(X)"></a>什么是共享锁(S)和排它锁(X)</h2><p> 基本的封锁类型有两种:<strong>排它锁</strong>(X锁)和<strong>共享锁</strong>(S锁).</p>
<p><strong>排它锁</strong>又称为<font color=#FF0000>写锁</font>。若事务T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。这就保证了其它事务在T释放A上的锁之前不能再读取和修改A。 </p>
<p><strong>共享锁</strong>又称为<font color=#FF0000>读锁</font>。若事务T对数据对象A加上S锁，则其它事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这就保证了其它事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。 </p>
<p>所谓S锁,是事务T对数据A加上S锁时,其他事务只能再对数据A加S锁,而不能加X锁,直到T释放A上的S锁。</p>
<p>若事务T对数据对象A加了S锁,则T就可以对A进行读取,但不能进行更新(S锁因此又称为读锁),在T释放A上的S锁以前,其他事务可以再对A加S锁,但不能加X锁,从而可以读取A,但不能更新A.</p>
<h2 id="什么是数据库的三重加锁协议-三级加锁协议-？"><a href="#什么是数据库的三重加锁协议-三级加锁协议-？" class="headerlink" title="什么是数据库的三重加锁协议(三级加锁协议)？"></a>什么是数据库的三重加锁协议(三级加锁协议)？</h2><ul>
<li>1 级封锁协议是：<strong>事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放</strong>。事务结束包括正常结束（COMMIT）和非正常结束（ROLLBACK）。 1级封锁协议可防止丢失修改，并保证事务T是可恢复的。在1级封锁协议中，如果仅仅是读数据不对其进行修改，是不需要加锁的，所以它不能保证可重复读和不 读”脏”数据。 </li>
<li>2级封锁协议是：<strong>1级封锁协议加上事务T在读取数据R之前必须先对其加S锁，读完后即可释放S锁。</strong>2级封锁协议除防止了丢失修改，还可进一步防止读”脏”数据。 </li>
<li>3级封锁协议是：<strong>1级封锁协议加上事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放</strong>。3级封锁协议除防止了丢失修改和不读’脏’数据外，还进一步防止了不可重复读。</li>
</ul>
<p>执行了封锁协议之后，就可以克服数据库操作中的数据不一致所引起的问题。</p>
<h3 id="三段锁协议的应用"><a href="#三段锁协议的应用" class="headerlink" title="三段锁协议的应用"></a>三段锁协议的应用</h3><ul>
<li><p><strong>共享锁（S锁）</strong>：共享 (S) 用于不更改或不更新数据的操作（只读操作），如 SELECT 语句。<br>如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。获准共享锁的事务只能读数据，不能修改数据。</p>
</li>
<li><p><strong>排他锁（X锁）</strong>：用于数据修改操作，例如 INSERT、UPDATE 或 DELETE。确保不会同时同一资源进行多重更新。<br>如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获准排他锁的事务既能读数据，又能修改数据。</p>
</li>
</ul>
<h3 id="具体解释如何用三段锁协议来解决数据不一致的三种情况："><a href="#具体解释如何用三段锁协议来解决数据不一致的三种情况：" class="headerlink" title="具体解释如何用三段锁协议来解决数据不一致的三种情况："></a>具体解释如何用三段锁协议来解决数据不一致的三种情况：</h3><ol>
<li><p>一级封锁协议解决更新丢失<br><strong>当事务在更新数据的时候给数据加上排他锁</strong><br>原理：加上排他锁之后，其他事务不能对该数据加上任意锁，在当前事务没有释放锁时其他事务不能进行对该数据的读写操作，只有当前事务释放排他锁之后，才能对该数据进行操作</p>
</li>
<li><p>二级封锁协议解决读脏数据<br>在一级封锁协议的基础上，当事务在<strong>读取数据的时候加共享锁,读取完成后释放锁</strong><br>原理：加入共享锁之后，不能对该数据加排他锁，即其他事务不能进行修改数据。所以此时读取的数据一定是与数据库一致的</p>
</li>
<li><p>三级封锁线协议不可重复读<br>在一级封锁协议的基础上，<strong>当事务在读取数据的时候加共享锁，事务结束后释放</strong><br>原理：加入共享锁之后，不能对该数据加排他锁，即其他事务不能进行修改数据。如果读取完成后就释放，那么其他事务此时可以修改该数据。当延迟到事务结束后释放，其他事务就无法修改该数据了</p>
</li>
</ol>
<p>这三个协议都不能解决幻读，只有串行才能解决幻读。</p>
<p>事务的封锁级别不是越高就越好，随着封锁粒度的增加会影响执行效率。</p>
<h2 id="MyISAM与InnoDB的区别"><a href="#MyISAM与InnoDB的区别" class="headerlink" title="MyISAM与InnoDB的区别"></a>MyISAM与InnoDB的区别</h2><h3 id="1-两者对比"><a href="#1-两者对比" class="headerlink" title="1.两者对比"></a>1.两者对比</h3><ol>
<li><p><strong>count运算上的区别</strong>： 因为MyISAM缓存有表meta-data（行数等），因此在做COUNT(*)时对于一个结构很好 的查询是不需要消耗多少资源的。而对于InnoDB来说，则没有这种缓存 </p>
</li>
<li><p><strong>是否支持事务和崩溃后的安全恢复</strong>： MyISAM 强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型 更快，但是不提供事务支持。但是InnoDB 提供事务支持事务，外部键等高级数据库功能。 具有事务 (commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。 </p>
</li>
<li><p><strong>是否支持外键</strong>： MyISAM不支持，而InnoDB支持。 </p>
</li>
</ol>
<h3 id="2-两者总结"><a href="#2-两者总结" class="headerlink" title="2.两者总结"></a>2.两者总结</h3><p>MyISAM更适合读密集的表，而InnoDB更适合写密集的的表。 在数据库做主从分离的情况下，经常选择MyISAM作 为主库的存储引擎。</p>
<p>一般来说，如果需要事务支持，并且有较高的并发读取频率(MyISAM的表锁的粒度太大，所以当该表写并发量较高 时，要等待的查询就会很多了)，InnoDB是不错的选择。如果你的数据量很大（MyISAM支持压缩特性可以减少磁盘 的空间占用），而且不需要支持事务时，MyISAM是好的选择。 </p>
<h1 id="6-Java相关"><a href="#6-Java相关" class="headerlink" title="6.Java相关"></a>6.Java相关</h1><h2 id="Java的char是两个字节，是怎么存Utf-8的字符的？"><a href="#Java的char是两个字节，是怎么存Utf-8的字符的？" class="headerlink" title="Java的char是两个字节，是怎么存Utf-8的字符的？"></a>Java的char是两个字节，是怎么存Utf-8的字符的？</h2><p>这个问题看起来很简单，但是详细介绍起来是可以很上台阶的。</p>
<ul>
<li>Java char不存 UTF-8 的字节，而是UTF-16的</li>
<li>Unicode通用字符集占两个字节，例如”中”</li>
<li>Unicode扩展字符集需要用一对(两个)char来表示，例如某个emoj</li>
<li>Unicode是字符集，不是编码，作用类似于ASCII码</li>
<li>Java String的length不是字符数 (而是char数。这个主要针对emoj的情况)</li>
</ul>
<h2 id="什么是Java的泛型？泛型擦除？泛型标记规范？泛型的限定是什么？写一个简单的泛型程序？-泛型程序记住泛型的泛类标志的位置即可"><a href="#什么是Java的泛型？泛型擦除？泛型标记规范？泛型的限定是什么？写一个简单的泛型程序？-泛型程序记住泛型的泛类标志的位置即可" class="headerlink" title="什么是Java的泛型？泛型擦除？泛型标记规范？泛型的限定是什么？写一个简单的泛型程序？(泛型程序记住泛型的泛类标志的位置即可)"></a>什么是Java的泛型？泛型擦除？泛型标记规范？泛型的限定是什么？写一个简单的泛型程序？(泛型程序记住泛型的泛类标志的位置即可)</h2><p>一个一个来回答。</p>
<p><strong>什么是泛型？</strong></p>
<p>答：泛型的本质是参数化类型，泛型提供了编译时类型的安全检测机制，该机制允许程序在编译时检测非法的类型。</p>
<p><strong>什么是泛型擦除？</strong></p>
<p>答：<strong>在编译阶段采用泛型时加上的类型参数，会被编译器在编译时去掉，这个过程就被称为类型擦除，</strong>因此泛型主要用于<strong>编译阶段</strong>，在编译后生成的Java字节代码文件中不包含泛型中的类型信息。</p>
<p><strong>什么是泛型标记规范？</strong></p>
<p>答：①<code>E</code>：值Element，在集合中使用，表示在集合中存放的元素。</p>
<p>②<code>T</code>：指Type，表示Java类，包括基本的类以及自定义类。</p>
<p>③<code>K</code>：指Key，表示键，例如Map集合中的Key。</p>
<p>④<code>V</code>：指Value，表示值，例如Map集合中的Value。</p>
<p>⑤<code>N</code>：指Number，表示数值类型。</p>
<p>⑥<code>？</code>：表示不确定的Java类型。</p>
<h2 id="Java的重写-overload-和重载-override-？"><a href="#Java的重写-overload-和重载-override-？" class="headerlink" title="Java的重写(overload)和重载(override)？"></a>Java的重写(overload)和重载(override)？</h2><p><strong>重载</strong>： 发生在同一个类中，<strong>方法名必须相同</strong>，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以 不同，发生在<strong>编译时</strong>。   </p>
<p><strong>重写</strong>： 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类， 访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private 则子类就不能重写该方法。 </p>
<h2 id="String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？"><a href="#String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？" class="headerlink" title="String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？"></a>String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？</h2><h3 id="String-StringBuffer和StringBuilder的可见性"><a href="#String-StringBuffer和StringBuilder的可见性" class="headerlink" title="String, StringBuffer和StringBuilder的可见性"></a>String, StringBuffer和StringBuilder的可见性</h3><p>实际上String是通过了final关键字修饰的字符数组来保存字符串的，其写法实际上是：<code>private final char value[]</code>，所以String对象是不可变的。但是StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在这个AbstractStringBuilder类中也是使用字符数组保存字符串 <code>char[] value</code> 但是没有用 ﬁnal 关键字修饰，所以这两种对象都是可变的。</p>
<p>StringBuilder 与 StringBuﬀer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的，大家可以自 行查阅源码。</p>
<p>AbstractStringBuilder.java源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123; </span><br><span class="line">    <span class="keyword">char</span>[] value;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    AbstractStringBuilder() &#123;&#125;</span><br><span class="line">    AbstractStringBuilder(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="String-StringBuffer和StringBuilder的线程安全性"><a href="#String-StringBuffer和StringBuilder的线程安全性" class="headerlink" title="String, StringBuffer和StringBuilder的线程安全性"></a>String, StringBuffer和StringBuilder的线程安全性</h3><p>String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuﬀer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共 方法。StringBuﬀer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对 方法进行加同步锁，所以是非线程安全的。 </p>
<h3 id="String-StringBuffer和StringBuilder的性能"><a href="#String-StringBuffer和StringBuilder的性能" class="headerlink" title="String, StringBuffer和StringBuilder的性能"></a>String, StringBuffer和StringBuilder的性能</h3><p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。 StringBuﬀer 每次都会对 StringBuﬀer 对象本身进行操作，而不是生成新的对象并改变对象引用。<strong>相同情况下使用 StirngBuilder 相比使用 StringBuﬀer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险</strong>。</p>
<h3 id="String-StringBuffer和StringBuilder的使用总结"><a href="#String-StringBuffer和StringBuilder的使用总结" class="headerlink" title="String, StringBuffer和StringBuilder的使用总结"></a>String, StringBuffer和StringBuilder的使用总结</h3><ul>
<li><p>如果只需要操作少量字符串：用String</p>
</li>
<li><p>如果在单线程操作字符串缓冲区下的大量数据：用StringBuilder(<strong>性能提升10%-15%，但线程不安全</strong>)</p>
</li>
<li><p>如果多线程操作字符串缓冲区下的大量数据：用StringBuffer(<strong>线程安全</strong>)</p>
</li>
</ul>
<h2 id="与equals"><a href="#与equals" class="headerlink" title="==与equals"></a>==与equals</h2><p>==：它的作用是<strong>判断两个对象的地址是不是相等</strong>。即，判断两个对象是不是同一个对象。(基本数据类型==比较的是 值，引用数据类型==比较的是内存地址)</p>
<p>equals：它的作用也是<strong>判断两个对象是否相等。但它一般有两种使用情况</strong>： </p>
<ul>
<li>情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。</li>
<li>情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来自定义方法来判断两个对象是否内容相等；若它们的内容相 等，则返回 true (即，认为这两个对象相等)。</li>
</ul>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String a = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// a为一个引用</span></span><br><span class="line">		String b = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// b为另一个引用，对象的内容一样</span></span><br><span class="line">		String aa = <span class="string">"ab"</span>; <span class="comment">//放在常量池中</span></span><br><span class="line">		String bb = <span class="string">"ab"</span>; <span class="comment">//从常量池中查找</span></span><br><span class="line">		<span class="keyword">if</span>(aa == bb) <span class="comment">// 这里为true</span></span><br><span class="line">			System.out.println(<span class="string">"aa == bb"</span>);</span><br><span class="line">		<span class="keyword">if</span>(a == b) <span class="comment">// 这里为false,非同一对象</span></span><br><span class="line">			System.out.println(<span class="string">"aa == bb"</span>);</span><br><span class="line">		<span class="keyword">if</span>(a.equals(b)) <span class="comment">// 这里为true</span></span><br><span class="line">			System.out.println(<span class="string">"a equals to b"</span>);</span><br><span class="line">		<span class="keyword">if</span>(<span class="number">42</span> == <span class="number">42.0</span>) <span class="comment">// 这里为true</span></span><br><span class="line">			System.out.println(<span class="string">"true"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。 </li>
<li>当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有 就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。</li>
</ul>
<h2 id="equals-和hashCode-有什么联系？"><a href="#equals-和hashCode-有什么联系？" class="headerlink" title="equals()和hashCode()有什么联系？"></a>equals()和hashCode()有什么联系？</h2><h3 id="简介hashCode"><a href="#简介hashCode" class="headerlink" title="简介hashCode()"></a>简介hashCode()</h3><p>首先，hashCode()的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。</p>
<p>这个哈希码的作用是确定该对象在 哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函 数。另外需要注意的是： Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，<strong>该方法通常用来将对象的 内存地址 转换为整数之后返回</strong>。</p>
<p>方法为：<code>public native int hashCode()</code></p>
<p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！ （可以快速找到所需要的对象） </p>
<h3 id="为什么要有hashCode"><a href="#为什么要有hashCode" class="headerlink" title="为什么要有hashCode()?"></a>为什么要有hashCode()?</h3><p>我们可以举个例子，以”HashSet如何进行重复检查”为例来说明为什么要有hashCode：</p>
<p>当你把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他已经加 入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相 同hashcode值的对象，这时会调用equals（）方法来检查hashcode相等的对象是否真的相同。如果两者相同， HashSet就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自Java启蒙书《Head ﬁst java》第二版）。这样我们就大大减少了equals的次数，相应就大大提高了执行速度。</p>
<h3 id="hashCode-与equals-的相关规定"><a href="#hashCode-与equals-的相关规定" class="headerlink" title="hashCode()与equals()的相关规定"></a>hashCode()与equals()的相关规定</h3><ol>
<li>如果两个对象相等，则它们的hashcode一定相等 </li>
<li>两个对象相等,对两个对象分别调用equals方法都返回true </li>
<li>两个对象的hashcode值相等，它们不一定相等</li>
<li><font color=#FF0000>若equals()方法被覆盖过，则hashCode()方法也必须被重写覆盖</font></li>
<li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何 都不会相等（即使这两个对象指向相同的数据）</li>
</ol>
<h3 id="为什么两个对象有相同的hashCode值，它们却不一定是相等的？"><a href="#为什么两个对象有相同的hashCode值，它们却不一定是相等的？" class="headerlink" title="为什么两个对象有相同的hashCode值，它们却不一定是相等的？"></a>为什么两个对象有相同的hashCode值，它们却不一定是相等的？</h3><p>下面内容摘自《Head First Java》</p>
<p>因为hashCode() 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这 也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 hashCode）。</p>
<p>我们刚刚也提到了 HashSet,如果 HashSet 在对比的时候，同样的 hashcode 有多个对象，它会使用 equals() 来判断 是否真的相同。也就是说 hashcode 只是用来缩小查找成本。 </p>
<h2 id="简述final、finally和finalize的区别"><a href="#简述final、finally和finalize的区别" class="headerlink" title="简述final、finally和finalize的区别"></a>简述final、finally和finalize的区别</h2><p>final关键字主要用在三个地方：变量、方法、类。详细描述一下的话有三点：</p>
<ol>
<li>对于一个ﬁnal变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的 变量，则在对其初始化之后便不能再让其指向另一个对象。 </li>
<li>当用ﬁnal修饰一个类时，表明这个类不能被继承。ﬁnal类中的所有成员方法都会被隐式地指定为ﬁnal方法。 </li>
<li>使用ﬁnal方法的原因有两个。<strong>第一个原因是把方法锁定</strong>，以防任何继承类修改它的含义；<strong>第二个原因是效率</strong>。 在早期的Java实现版本中，会将ﬁnal方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的 任何性能提升（现在的Java版本已经不需要使用ﬁnal方法进行这些优化了）。类中所有的private方法都隐式地 指定为ﬁanl。 </li>
</ol>
<p>finally用于try-catch代码块中，无论是否发生异常最后都将执行，作用是释放资源。</p>
<p>finalize是Object类的方法，在对象垃圾回收之前将调用一次，一般用于资源的释放。</p>
<h2 id="Java的Object类中有哪些常见方法？分别有什么作用？"><a href="#Java的Object类中有哪些常见方法？分别有什么作用？" class="headerlink" title="Java的Object类中有哪些常见方法？分别有什么作用？"></a>Java的Object类中有哪些常见方法？分别有什么作用？</h2><p>Object类是一个特殊的类，其是所有类的父类。在类加载的双亲委派机制下，如果程序员自己定义重写了一个Object中的方法，JVM会加载Object中的类而不是加载程序员自己写的，这防止了核心API被篡改。</p>
<p>具体来说Object类有11个方法：getClass()、hasCode()、equals(Object obj)、clone()、toString()、notify()、notifyAll、wait(long timeout)、wait(long timeout, int nanos)、wait()、finalize()</p>
<p>具体内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()<span class="comment">//native方法，用于返回当前运行时对象的Class对象，使用了 final关键字修饰，故不允许子类重写。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="comment">//native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的 HashMap。 </span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span><span class="comment">//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户 比较字符串的值是否相等。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException<span class="comment">//naitive方法，用于创建并返回 当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生 CloneNotSupportedException异常。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span><span class="comment">//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方 法。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span><span class="comment">//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视 器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span><span class="comment">//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒 在此对象监视器上等待的所有线程，而不是一个线程。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//native方法，并且不能 重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//多了nanos参数， 这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//跟之前的2个wait方法一样，只不过该方法一直等 待，没有超时时间这个概念</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;<span class="comment">//实例被垃圾回收器回收的时候触发的操作</span></span><br></pre></td></tr></table></figure>

<h2 id="Java的异常处理"><a href="#Java的异常处理" class="headerlink" title="Java的异常处理"></a>Java的异常处理</h2><p>整体的思维导图概览如下：</p>
<p><img src="https://i.loli.net/2020/04/21/jzyg8Xn6Q7LtZkW.png" alt="Java异常思维导图.png"></p>
<p>在 Java 中，所有的异常都有一个共同的祖先java.lang包中的 <strong>Throwable类</strong>。Throwable： 有两个重要的子类： <strong>Exception（异常）</strong> 和 <strong>Error（错误）</strong> ，二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p>
<p><strong>Error（错误）:是程序无法处理的错误，表示运行应用程序中较严重问题</strong>。Error指Java程序运行错误，出现Error通常是因为系统的内部错误或资源耗尽，Error不能在运行过程中被动态处理，如果程序运行中出现Error，系统只能记录错误的原因和安全终止。</p>
<p>大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一 般会选择线程终止。</p>
<p>这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和 处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错 误，本质上也不应该试图去处理它所引起的异常状况。在 Java中，错误通过Error的子类描述。 </p>
<p><strong>Exception（异常）:是程序本身可以处理的异常</strong>。Exception指Java程序运行异常，即运行中发生了不期望的情况，分为RuntimeException和CheckedException(上图中的 IOException)。RuntimeException指在Java虚拟机正常运行期间抛出的异常，可以被捕获并处理，例如空指针异常，数组越界等。CheckedException指编译阶段强制要求捕获并处理的异常，例如IO异常，SQL异常等。</p>
<p>Exception 类有一个重要的子类 <strong>RuntimeException</strong>。 RuntimeException 异常由Java虚拟机抛出。<strong>NullPointerException</strong>（要访问的变量没有引用任何对象时，抛出该 异常）、<strong>ArithmeticException</strong>（算术运算异常，一个整数除以0时，抛出该异常）和 <strong>ArrayIndexOutOfBoundsException</strong> （下标越界异常）。<br>注意：异常和错误的区别：<strong>异常能被程序本身可以处理，错误是无法处理</strong>。</p>
<p>Throwable类常用方法如下：</p>
<ul>
<li>public string getMessage():返回异常发生时的详细信息 </li>
<li>public string toString():返回异常发生时的简要描述 </li>
<li>public string getLocalizedMessage():返回异常对象的本地化信息。使用Throwable的子类覆盖这个方法，可 以声称本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与getMessage（）返回的结果相同 </li>
<li>public void printStackTrace():在控制台上打印Throwable对象封装的异常信息</li>
</ul>
<h3 id="Java异常处理的-try-catch-finally"><a href="#Java异常处理的-try-catch-finally" class="headerlink" title="Java异常处理的 try-catch-finally"></a>Java异常处理的 try-catch-finally</h3><ul>
<li>try 块：用于捕获异常。其后可接零个或多个catch块，如果没有catch块，则必须跟一个ﬁnally块</li>
<li>catch 块：用于处理try捕获到的异常。 </li>
<li>ﬁnally 块：无论是否捕获或处理异常，ﬁnally块里的语句都会被执行。当在try块或catch块中遇到return语句 时，ﬁnally语句块将在方法返回之前被执行。 </li>
</ul>
<h3 id="finally块不会被执行的四种特殊情况"><a href="#finally块不会被执行的四种特殊情况" class="headerlink" title="finally块不会被执行的四种特殊情况"></a>finally块不会被执行的四种特殊情况</h3><ol>
<li>在ﬁnally语句块中发生了异常。 </li>
<li>在前面的代码中用了System.exit()退出程序。 </li>
<li>程序所在的线程死亡。 </li>
<li>关闭CPU</li>
</ol>
<h3 id="Java异常处理的方式"><a href="#Java异常处理的方式" class="headerlink" title="Java异常处理的方式"></a>Java异常处理的方式</h3><ol>
<li>抛出异常：遇到异常不进行具体处理，而是将异常抛出给调用者，由调用者根据情况处理。抛出异常有2种形式，一种是throws，作用在方法上，一种是throw，作用在方法内。</li>
<li>使用try/catch进行异常的捕获处理，try中发生的异常会被catch代码块捕获，根据情况进行处理，如果有finally代码块无论是否发生异常都会执行，一般用于释放资源，JDK1.7开始可以将资源定义在try代码块中自动释放减少代码。</li>
</ol>
<h3 id="详解-throw-和-throws的区别"><a href="#详解-throw-和-throws的区别" class="headerlink" title="详解 throw 和 throws的区别"></a>详解 throw 和 throws的区别</h3><p>throws 用在函数上，后面跟的是异常类，可以跟多个；</p>
<blockquote>
<p>语法：<a href="https://www.cnblogs.com/niceyoo/p/返回值类型" target="_blank" rel="noopener">(修饰符)</a>(方法名)([参数列表])[throws(异常类)]{……}<br>public void doA(int a) throws Exception1,Exception3{……}</p>
</blockquote>
<p>throw 用在函数内，后面跟的是异常对象。</p>
<p>throws E1,E2,E3只是告诉程序这个方法可能会抛出这些异常，方法的调用者可能要处理这些异常，而这些异常E1，E2，E3可能是该函数体产生的。<br>throw则是明确了这个地方要抛出这个异常。</p>
<p>结合来看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doA</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">throws</span> IOException,</span>&#123;</span><br><span class="line">   <span class="keyword">try</span>&#123;</span><br><span class="line">      ......</span><br><span class="line">   &#125;<span class="keyword">catch</span>(Exception1 e)&#123;</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">   &#125;<span class="keyword">catch</span>(Exception2 e)&#123;</span><br><span class="line">      System.out.println(<span class="string">"出错了！"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(a!=b)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span>  Exception3(<span class="string">"自定义异常"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>throws 用来声明异常，让调用者知道该功能可能会出现的问题（比如上方的 IO 异常），可以给出预先的处理方式；</p>
<p>throw 抛出具体的问题对象，执行到 throw，功能就已经结束了，跳转到调用者，并将具体的问题对象抛给调用者。</p>
<p>也就是说 throw 语句独立存在时，下面不要定义其他语句，因为执行不到。</p>
<blockquote>
<p>概括:<br>throws 表示出现异常的一种可能性，并不一定会发生这些异常；<br>throw 则是抛出了异常，执行 throw 则一定抛出了某种异常对象。</p>
</blockquote>
<h2 id="什么是Java的反射？简述其优缺点？"><a href="#什么是Java的反射？简述其优缺点？" class="headerlink" title="什么是Java的反射？简述其优缺点？"></a>什么是Java的反射？简述其优缺点？</h2><p>反射的基本概念：</p>
<p>答：①在运行状态中，对于任意一个<strong>类</strong>，都能够知道这个类的<strong>所有属性和方法</strong>，对于任意一个<strong>对象</strong>，都能够<strong>调用它的任意一个方法和属性</strong>；这种<strong>动态获取的信息以及动态调用对象的方法的功能称为Java的反射机制</strong>。</p>
<p>② <font color=#FF0000>优点</font>是运行时动态获取类的全部信息，<font color=#FF0000>缺点</font>是破坏了类的<strong>封装性，泛型的约束性</strong>。</p>
<p>③<font color=#FF0000>反射是框架的核心灵魂</font>，动态代理设计模式采用了反射机制，还有 Spring、Hibernate 等框架也大量使用到了反射机制。</p>
<h2 id="获得class对象有哪几种方式？能通过Class对象获取类的哪些信息？"><a href="#获得class对象有哪几种方式？能通过Class对象获取类的哪些信息？" class="headerlink" title="获得class对象有哪几种方式？能通过Class对象获取类的哪些信息？"></a>获得class对象有哪几种方式？能通过Class对象获取类的哪些信息？</h2><p>答：①通过<code>类名.class</code></p>
<p>②通过对象<code>.getClass()</code></p>
<p>③通过<code>Class.forName(类的全限名);</code></p>
<p>④可以通过Class对象获取类的成员变量，方法或构造器。带declared的获取方法可以获取到类的一个或全部成员变量，方法，构造器，不带declared的方法只能获取到类的public修饰的成员变量、方法或构造器，包括父类public修饰的成员变量、方法或构造器。</p>
<h2 id="接口和抽象类的区别是什么"><a href="#接口和抽象类的区别是什么" class="headerlink" title="接口和抽象类的区别是什么"></a>接口和抽象类的区别是什么</h2><ol>
<li><strong>接口</strong>的方法默认是public, 所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），<strong>抽象类</strong>可以有非抽象的方法</li>
<li><strong>接口</strong>中的实例变量默认是 ﬁnal 类型的，而<strong>抽象类</strong>中则不一定</li>
<li>一个类可以实现多个<strong>接口</strong>，但多只能实现一个<strong>抽象类</strong></li>
<li>一个类实现<strong>接口</strong>的话要实现接口的所有方法，而<strong>抽象类</strong>不一定 </li>
<li><strong>接口</strong>不能用 new 实例化，但可以声明，但是必须引用一个实现该接口的对象 从设计层面来说，<strong>抽象类</strong>是对类的抽 象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</li>
</ol>
<p>备注：在JDK8中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实现是不可以调用的。如果同时实现 两个接口，接口中定义了一样的默认方法，必须重写，不然会报错。(详见 issue:<a href="https://github.com/Snailclimb/JavaGuide/issues/146" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide/issues/146</a>) </p>
<h2 id="Java的线程状态有哪些？它是如何工作的？-重要"><a href="#Java的线程状态有哪些？它是如何工作的？-重要" class="headerlink" title="Java的线程状态有哪些？它是如何工作的？(重要**)"></a>Java的线程状态有哪些？它是如何工作的？(重要**)</h2><p>线程(Thread)是并发编程的基础，它是程序执行的最小单元。一个进程可以包含多个线程，多线程可以共享一块内存空间和一组系统资源，因此线程之间的切换更节省资源，也因为如此，线程常被成为轻量级的进程。</p>
<p>对线程的掌握，可以有效地提高程序整体运行效率。</p>
<h3 id="Java线程状态在JDK1-5后一共有六个"><a href="#Java线程状态在JDK1-5后一共有六个" class="headerlink" title="Java线程状态在JDK1.5后一共有六个"></a>Java线程状态在JDK1.5后一共有六个</h3><p>Java线程状态在JDK1.5后以枚举的方式定义在Thread的源码中，一共有六个状态</p>
<ul>
<li>NEW新建状态，线程被创建出来，但尚未启动时的线程状态；</li>
<li>RUNNABLE,就绪状态，表示可以运行的线程状态，它可能正在运行，或者是在排队等待操作系统给它分配 CPU 资源；</li>
<li>BLOCKED，阻塞等待锁的线程状态，表示处于阻塞状态的线程正在等待监视器锁，比如等待执行 synchronized 代码块或者使用 synchronized 标记的方法； </li>
<li>WAITING，等待状态，一个处于等待状态的线程正在等待另一个线程执行某个特定的动作，比如，一个线程调用了Object.wait()方法，那它就在等待另一个线程调用Object.notify()或Objec.botifyAll()方法;</li>
<li>TIMED_WAITING,计时等待状态，和等待状态(WAITING)类似，它只是多了超时时间，比如调用了有超时时间设置的方法 Object.wait(long timeout) 和 Thread.join(long timeout) 等这些方法时，它才会进入此状态；</li>
<li>TERMINATED,终止状态，表示线程已经执行完成</li>
</ul>
<h4 id="线程如何工作的？——线程工作模式"><a href="#线程如何工作的？——线程工作模式" class="headerlink" title="线程如何工作的？——线程工作模式"></a>线程如何工作的？——线程工作模式</h4><p>线程的工作模式是，首先先要创建线程并指定线程需要执行的业务方法，然后再调用线程的start()方法，此时线程就从NEW（新建）状态变成了RUNNABLE（就绪）状态，此时线程会判断要执行的方法中有没有 synchronized 同步代码块，如果有并且其他线程也在使用此锁，那么线程就会变为 BLOCKED（阻塞等待）状态，当其他线程使用完此锁之后，线程会继续执行剩余的方法。</p>
<p>当遇到Object.wait()或Thread.join()方法时，线程会变为WAITING（等待状态）状态，如果是带了超时时间的等待方法，那么线程会进入TIMED_WAITING（计时等待）状态，当有其他线程执行了 notify() 或 notifyAll() 方法之后，线程被唤醒继续执行剩余的业务方法，直到方法执行完成为止，此时整个线程的流程就执行完了，执行流程如下图所示：</p>
<p><img src="https://i.loli.net/2020/03/26/a7vAHYK6h23Xf5L.png" alt="Java多线程工作流程.png"></p>
<h2 id="Java创建新线程有几种方式？"><a href="#Java创建新线程有几种方式？" class="headerlink" title="Java创建新线程有几种方式？"></a>Java创建新线程有几种方式？</h2><p>一般来说有四种方式：</p>
<ol>
<li>继承Thread类(真正意义上的线程类)，这个类是Runnable接口的实现，继承之后重写run()方法，在这个方法里写出来该线程具体要完成的任务。</li>
<li>自己实现Runnable接口，重写里面的run方法，创建线程类</li>
<li>使用Executor框架创建线程池(<strong>需要注意，阿里巴巴的《Java开发手册》不允许用Executors区创建线程池，而要用ThreadPoolExecutor的方式，这样可以更加明确线程池的运行规则，规避资源耗尽的风险</strong>)。Executor框架是JUC里提供的线程池实现的。</li>
<li>通过Callable和Future创建线程</li>
</ol>
<p>虽然最常用的是四种，但是继承Thread类和实现Runnable接口是最常用的。而且更加提倡的是使用实现Runnable接口的方式。实现Runnable接口的优势：</p>
<p>①避免点继承的局限，一个类可以继承多个接口。</p>
<p>②适合于资源的共享</p>
<h2 id="BLOCKED-阻塞等待-和WAITING-等待-有什么区别？"><a href="#BLOCKED-阻塞等待-和WAITING-等待-有什么区别？" class="headerlink" title="BLOCKED(阻塞等待)和WAITING(等待)有什么区别？"></a>BLOCKED(阻塞等待)和WAITING(等待)有什么区别？</h2><p>虽然BLOCKED和WAITING都有等待的含义，但二者有着本质的区别，首先它们状态形成的调用方法不同，其次BLOCKED可以理解为当前线程还处于活跃状态，只是在阻塞等待其他线程使用完某个锁资源；而WAITING则是因为自身调用了Object.wait()或着是Thread.join()又或者是LockSupport.park()而进入等待状态，只能等待其他线程执行某个特定的动作才能被继续唤醒，比如当线程因为调用了 Object.wait() 而进入 WAITING 状态之后，则需要等待另一个线程执行Object.notify() 或 Object.notifyAll() 才能被唤醒。</p>
<h2 id="start-方法和run-方法有什么区别？"><a href="#start-方法和run-方法有什么区别？" class="headerlink" title="start()方法和run()方法有什么区别？"></a>start()方法和run()方法有什么区别？</h2><p><strong>主要区别有三点</strong>：</p>
<ol>
<li><p>首先从 Thread 源码来看，start() 方法属于 Thread 自身的方法，并且使用了 synchronized 来保证线程安全。run() 方法为 Runnable 的抽象方法，必须由调用类重写此方法，重写的 run() 方法其实就是此线程要执行的业务方法。</p>
</li>
<li><p>从执行的效果来说，start() 方法可以开启多线程，让线程从 NEW 状态转换成 RUNNABLE 状态，而 run() 方法只是一个普通的方法。</p>
</li>
<li><p>它们可调用的次数不同，start()方法不能被多次调用，否则会抛出java.lang.IllegalStateException；而run()方法可以进行多次调用，因为它只是一个普通的方法而已。</p>
</li>
</ol>
<h2 id="wait-和-sleep-有什么区别？"><a href="#wait-和-sleep-有什么区别？" class="headerlink" title="wait() 和 sleep()有什么区别？"></a>wait() 和 sleep()有什么区别？</h2><p><strong>主要区别有四点</strong>：</p>
<ol>
<li>wait()属于Object类，sleep()属于Thread类；</li>
<li>wait会释放锁对象，而sleep不会；</li>
<li>使用的位置不同，wait()需要在同步块中使用，sleep()可以在任意地方；</li>
<li>sleep()需要捕获异常，而wait()不需要</li>
</ol>
<h2 id="线程的优先级有什么用？如何设置优先级？"><a href="#线程的优先级有什么用？如何设置优先级？" class="headerlink" title="线程的优先级有什么用？如何设置优先级？"></a>线程的优先级有什么用？如何设置优先级？</h2><p>Thread源码中与线程优先级相关的属性有3个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程可以拥有的最小优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY =<span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程默认优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NORM_PNORM_PRIORITY = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程可以拥有的最大优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>线程的优先级可以理解为线程抢占 CPU 时间片的概率，优先级越高的线程优先执行的概率就越大，但并不能保证优先级高的线程一定先执行。</p>
<p>在程序中我们可以通过Thread.setPriority()来设置优先级。</p>
<h2 id="线程常用方法有哪些？"><a href="#线程常用方法有哪些？" class="headerlink" title="线程常用方法有哪些？"></a>线程常用方法有哪些？</h2><h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><p>在一个线程中调用join()，会让当前线程交出执行权给other线程，直到other线程执行完或者过了超时时间之后再继续执行当前线程。</p>
<p>在源码中可以看到，join()方法底层是通过wait()方法实现的。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               System.out.println(<span class="string">"子线程睡眠："</span> + i + <span class="string">"秒"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">"主线程睡眠："</span> + i + <span class="string">"秒"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的执行结果：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">主线程睡眠：<span class="number">1</span>秒</span><br><span class="line">子线程睡眠：<span class="number">1</span>秒</span><br><span class="line">主线程睡眠：<span class="number">2</span>秒</span><br><span class="line">子线程睡眠：<span class="number">2</span>秒</span><br><span class="line">主线程睡眠：<span class="number">3</span>秒</span><br><span class="line">子线程睡眠：<span class="number">3</span>秒</span><br><span class="line">子线程睡眠：<span class="number">4</span>秒</span><br><span class="line">子线程睡眠：<span class="number">5</span>秒</span><br><span class="line">子线程睡眠：<span class="number">6</span>秒</span><br></pre></td></tr></table></figure>

<p>可以看到，不使用join()的时候，主线程和子线程会交替执行。</p>
<p>然后加入join()方法：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">    public static <span class="literal">void</span> main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread<span class="function"><span class="params">(() -&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">try</span> &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                   Thread.sleep(<span class="number">1000</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                   e.printStackTrace();</span></span></span><br><span class="line"><span class="function"><span class="params">               &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">               System.out.println(<span class="string">"子线程睡眠："</span> + i + <span class="string">"秒"</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">           &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">        &#125;)</span>;</span></span><br><span class="line"><span class="function">        <span class="title">thread</span>.<span class="title">start</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">        <span class="title">thread</span>.<span class="title">join</span><span class="params">(<span class="number">4000</span>)</span>;</span></span><br><span class="line"><span class="function">        <span class="title">for</span> <span class="params">(int i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++)</span> &#123;</span></span><br><span class="line"><span class="function">            <span class="title">Thread</span>.<span class="title">sleep</span><span class="params">(<span class="number">1000</span>)</span>;</span></span><br><span class="line"><span class="function">            <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(<span class="string">"主线程睡眠："</span> + i + <span class="string">"秒"</span>)</span>;</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">子线程睡眠：<span class="number">1</span>秒</span><br><span class="line">子线程睡眠：<span class="number">2</span>秒</span><br><span class="line">子线程睡眠：<span class="number">3</span>秒</span><br><span class="line">子线程睡眠：<span class="number">4</span>秒</span><br><span class="line">主线程睡眠：<span class="number">1</span>秒</span><br><span class="line">子线程睡眠：<span class="number">5</span>秒</span><br><span class="line">主线程睡眠：<span class="number">2</span>秒</span><br><span class="line">子线程睡眠：<span class="number">6</span>秒</span><br><span class="line">主线程睡眠：<span class="number">3</span>秒</span><br></pre></td></tr></table></figure>

<p>可以看到用了join()方法之后，子线程会先<code>join</code>进来执行4秒，之后才会执行主线程。</p>
<h3 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h3><p>通过Thread()源码可以知道yield()为本地方法，也就是说yield()是由C/C++实现的。</p>
<p>yield() 方法表示给线程调度器一个当前线程愿意出让 CPU 使用权的暗示，但是线程调度器可能会忽略这个暗示。</p>
<p>执行一段包含yield()方法的代码之后会发现，每次执行的结果都不相同，这是因为yield()执行非常不稳定，线程调度器不一定会采纳yield()出让CPU使用权的建议，从而导致了这样的结果。</p>
<h2 id="volatile的作用"><a href="#volatile的作用" class="headerlink" title="volatile的作用"></a>volatile的作用</h2><p>在很多的开源中间件系统的源码里，大量的使用了volatile，每一个开源中间件系统，或者是大数据系统，都多线程并发。</p>
<p>volatile的作用主要是两个：<strong>保证可见性</strong>（这里指主内存与工作内存间的可见性），<strong>防止指令重排</strong>（指令重排也会导致可见性问题,防止指令重排也可以称作<strong>有序性</strong>）</p>
<h3 id="什么是可见性？"><a href="#什么是可见性？" class="headerlink" title="什么是可见性？"></a>什么是可见性？</h3><p>意思就是说，在多线程环境下，某个共享变量如果被其中一个线程给修改了，其他线程能够立即知道这个共享变量已经被修改了，当其他线程要读取这个变量的时候，最终会去内存中读取，而不是从自己的工作空间中读取.</p>
<h3 id="如何保证内存可见性？"><a href="#如何保证内存可见性？" class="headerlink" title="如何保证内存可见性？"></a>如何保证内存可见性？</h3><p>答：<strong>volatile修饰的变量保证其每个写操作后都强制更新到主内存，每个读操作都到主内存中更新，具体的话是在JVM层面，在修饰的变量前后加关键字</strong>。</p>
<blockquote>
<p>NOTE：Java内存模型规定所有的变量都是存在<strong>(主内存)主存</strong>当中（类似于前面说的物理内存），每个线程都有自己的<strong>工作内存</strong>（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的<strong>工作内存</strong>。</p>
<p>由于java中的每个线程有自己的工作空间，这种工作空间相当于上面所说的高速缓存，因此多个线程在处理一个<strong>共享变量</strong>的时候，就会出现线程安全问题。</p>
<p>所谓共享变量，是能够被多个线程访问到的变量。在java中共享变量包括实例变量，静态变量，数组元素。他们都被存放在堆内存中。</p>
</blockquote>
<h3 id="什么是指令重排？"><a href="#什么是指令重排？" class="headerlink" title="什么是指令重排？"></a>什么是指令重排？</h3><p>当我们把代码写好之后，虚拟机不一定会按照我们写的代码的顺序来执行。例如对于下面的两句代码：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">int</span> b = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>对于这两句代码，你会发现无论是先执行a = 1还是执行b = 2，都不会对a,b最终的值造成影响。所以虚拟机在编译的时候，是有可能把他们进行<strong>重排序</strong>的。</p>
<p>对于这两句代码，你会发现无论是先执行a = 1还是执行b = 2，都不会对a,b最终的值造成影响。所以虚拟机在编译的时候，是有可能把他们进行重排序的。</p>
<p>但是也有可能会有影响的例子，比如线程T2需要变量flag为true才能执行，而flag只有在T1中才会被置为true。这里如果发生指令重排，T1还没执行完的时候T2就感知到了flag为true，那么程序执行逻辑就出错了，所以不能让JVM随意重排指令。</p>
<p>指令重排是JVM做出的优化，这里Java的双check的单例模式也利用了volatile来保证不重排。</p>
<h3 id="volatile能完全保证一个变量的线程安全么？"><a href="#volatile能完全保证一个变量的线程安全么？" class="headerlink" title="volatile能完全保证一个变量的线程安全么？"></a>volatile能完全保证一个变量的线程安全么？</h3><p>volatile好像很有用，不但能够保证变量可见性，还能防止指令重排。</p>
<p>那么，它真的能够保证一个变量在多线程环境下都能被正确的使用吗？</p>
<p>答案是<strong>否定的</strong>。原因是<strong>Java里面的运算并非是原子操作，volatile也不能是原子性的</strong>。虽然说有些极端特殊的情况下有保证原子性的效果，比如，oracle，64位的long的数字进行操作，volatile可以保证原子性。但是这个很不具备普遍性，不能说volatile能够保证原子性。</p>
<h4 id="原子性-原子操作"><a href="#原子性-原子操作" class="headerlink" title="原子性\原子操作"></a>原子性\原子操作</h4><p><strong>原子操作</strong>：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p>
<p>也就是说，处理器要嘛把这组操作全部执行完，中间不允许被其他操作所打断，要嘛这组操作不要执行。</p>
<p>刚才说Java里面的运行并非是原子操作。我举个例子，例如这句代码</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> a = b + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>处理器在处理代码的时候，需要处理以下三个操作：</p>
<ol>
<li><p>从内存中读取b的值。</p>
</li>
<li><p>进行a = b + 1这个运算</p>
</li>
<li><p>把a的值写回到内存中</p>
</li>
</ol>
<p>而这三个操作处理器是不一定就会连续执行的，有可能执行了第一个操作之后，处理器就跑去执行别的操作的。</p>
<h3 id="什么情况下volatile可以保证线程安全"><a href="#什么情况下volatile可以保证线程安全" class="headerlink" title="什么情况下volatile可以保证线程安全"></a>什么情况下volatile可以保证线程安全</h3><p>刚才虽然说，volatile关键字不一定能够保证线程安全的问题，其实，在大多数情况下volatile还是可以保证变量的线程安全问题的。所以，在满足以下两个条件的情况下，volatile就能保证变量的线程安全问题：</p>
<ol>
<li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li>
<li>变量不需要与其他状态变量共同参与不变约束。</li>
</ol>
<h3 id="volatile原理-深入到内存屏障"><a href="#volatile原理-深入到内存屏障" class="headerlink" title="volatile原理(深入到内存屏障)"></a>volatile原理(深入到内存屏障)</h3><p>最后来看原理，因为最复杂(吧)。</p>
<p>volatile底层原理是怎样的？如何实现保证可见性的呢？如何实现保证有序性的呢？</p>
<p>简单来说，如果我用volatile修饰某个变量，那么这个变量在读写前后会加入一些屏障，<strong>这些屏障能够保证代码不会对volatile修饰的读写部分进行指令重排</strong>。</p>
<p>此外，还需要记住lock指令。</p>
<p>（1）lock指令：volatile保证可见性</p>
<p>对volatile修饰的变量，执行写操作的时候，JVM会发送一条<font color=#FF0000><strong>lock前缀指令</strong></font>给CPU，CPU在计算完之后会立即将这个值写回主内存，同时因为有MESI缓存一致性协议，所以各个CPU都会对总线进行<strong>嗅探</strong>，随时check自己本地缓存中的数据是否被别人修改。</p>
<p>如果发现别人修改了某个缓存的数据，那么CPU就会将自己本地缓存的数据过期掉，然后这个CPU上执行的线程在读取那个变量的时候，就会从主内存重新加载最新的数据了。</p>
<p><strong>lock前缀指令 + MESI缓存一致性协议</strong>。</p>
<p>（2）内存屏障：volatile禁止指令重排序</p>
<p>volatille是如何保证有序性的？加了volatile的变量，可以保证前后的一些代码不会被指令重排，这个是如何做到的呢？指令重排是怎么回事，volatile就不会指令重排，简单介绍一下，实际内存屏障机制是非常非常复杂的：</p>
<p>这里介绍三种屏障：Load屏障、Store屏障、LoadStore屏障</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Load1：</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> localVar = <span class="keyword">this</span>.variable</span><br><span class="line"></span><br><span class="line">Load2：</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> localVar = <span class="keyword">this</span>.variable2</span><br></pre></td></tr></table></figure>

<p>LoadLoad屏障：Load1；LoadLoad；Load2，确保Load1数据的装载先于Load2后所有装载指令，他的意思，Load1对应的代码和Load2对应的代码，是不能指令重排的</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Store1：</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.variable = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>StoreStore屏障</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Store2：</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.variable2 = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>StoreStore屏障：Store1；StoreStore；Store2，确保Store1的数据一定刷回主存，对其他cpu可见，先于Store2以及后续指令</p>
<p>LoadStore屏障：Load1；LoadStore；Store2，确保Load1指令的数据装载，先于Store2以及后续指令</p>
<p>StoreLoad屏障：Store1；StoreLoad；Load2，确保Store1指令的数据一定刷回主存，对其他cpu可见，先于Load2以及后续指令的数据装载</p>
<p>volatile的作用是什么呢？</p>
<p>volatile variable = 1</p>
<p>this.variable = 2 =&gt; store操作</p>
<p>int localVariable = this.variable =&gt; load操作</p>
<p>对于volatile修改变量的读写操作，都会加入内存屏障</p>
<p>每个volatile写操作前面，加StoreStore屏障，禁止上面的普通写和他重排；每个volatile写操作后面，加StoreLoad屏障，禁止跟下面的volatile读/写重排</p>
<p>每个volatile读操作后面，加LoadLoad屏障，禁止下面的普通读和voaltile读重排；每个volatile读操作后面，加LoadStore屏障，禁止下面的普通写和volatile读重排</p>
<h2 id="线程池原理介绍"><a href="#线程池原理介绍" class="headerlink" title="线程池原理介绍"></a>线程池原理介绍</h2><p>线程池刚创建时是没有线程的，并且里面包含了一个任务队列。</p>
<p>可以举一个例子，如果用基于ThreadPoolExecutor创建的<code>newFixedThreadPool()</code>线程池，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">3</span>) -&gt; <span class="number">3</span>: corePoolSize</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">threadPool.submit(<span class="keyword">new</span> Callable() &#123;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;)；</span><br></pre></td></tr></table></figure>

<p>其阻塞队列是无界阻塞队列，即<strong>队列的大小是无穷大</strong>的。</p>
<p>其实，这个<code>newFixedThreadPool()</code>线程池是很常用的，其构造函数其实就是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads,</span><br><span class="line">                             nThreads,</span><br><span class="line">                             <span class="number">0L</span>,</span><br><span class="line">                             TimeUnit.MILLISECONDS,</span><br><span class="line">                             <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br></pre></td></tr></table></figure>

<p>其默认设置的是<code>corePoolSize</code>和<code>maximumPoolSize</code>大小相同。</p>
<p>当有任务过来时，会去判断线程池中的线程数量是否小于<code>corePoolSize</code>，如果是，就去创建一个线程去执行这个任务，任务执行完成以后，这个线程就会阻塞在队列头部，继续等待下一个任务，只要下一个任务能被当前线程池里的线程执行，那么就会直接被使用；如果线程池中的线程数量已经等于corePoolSize时，就将当前任务放入任务队列，阻塞在任务队列的线程就会去执行这个任务。</p>
<p>如下图所示(注意此时线程池大小为3)：</p>
<p><img src="https://i.loli.net/2020/04/06/7YSWbPZBz4jCa2L.png" alt="线程池原理图.png"></p>
<h2 id="ThreadPoolExecutor介绍"><a href="#ThreadPoolExecutor介绍" class="headerlink" title="ThreadPoolExecutor介绍"></a>ThreadPoolExecutor介绍</h2><p><strong>线程池的使用必须要通过ThreadPoolExecutor的方式来创建，这样才可以更加明确线程池的运行规则，规避资源耗尽的风险</strong>。</p>
<p>ThreadPoolExecutor有七大核心参数,包括核心线程数和最大线程数之间的区别，当线程池的任务队列没有可用空间且线程池的线程数量已经达到了最大线程数时，则会执行拒绝策略，Java 自动的拒绝策略有 4 种，用户也可以通过重写rejectedExecution()来自定义拒绝策略，我们还可以通过重写beforeExecute()和afterExecute()来实现ThreadPoolExecutor的扩展功能。</p>
<h2 id="线程池——ThreadPoolExecutor参数含义及源码执行流程？"><a href="#线程池——ThreadPoolExecutor参数含义及源码执行流程？" class="headerlink" title="线程池——ThreadPoolExecutor参数含义及源码执行流程？"></a>线程池——ThreadPoolExecutor参数含义及源码执行流程？</h2><p><font color=#FF0000>线程池是为了避免线程频繁的创建和销毁带来的性能消耗，而建立的一种池化技术，它是把已创建的线程放入“池”中，而不是在线程执行完任务后将其销毁。这样当再有任务来临时就可以重用已有的线程，无需等待创建的过程，这样就可以有效提高程序的响应速度</font>。</p>
<p>而说到线程池，现在一定离不开<code>ThreadPoolExecutor</code>，现在不推荐用<code>Executors</code>去创建线程池了。阿里巴巴的《Java开发手册》中这样规定创建线程池的方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的读者更加明确线程池的运行规则，规避资源耗尽的风险。</span><br></pre></td></tr></table></figure>

<h3 id="ThreadPoolExecutor一共有七个核心参数"><a href="#ThreadPoolExecutor一共有七个核心参数" class="headerlink" title="ThreadPoolExecutor一共有七个核心参数"></a>ThreadPoolExecutor一共有七个核心参数</h3><p><strong>第1个参数</strong>：<code>corePoolSize</code>表示线程池的<strong>常驻核心线程数</strong>(<strong>即在没有任务需要执行的时候线程池的大小，并且只有在工作队列满了的情况下才会创建超出这个数量的线程</strong>)。如果设置为0，则表示在没有任何任务时，销毁线程池；如果大于0，即使没有任务时也会保证线程池的线程数量等于此值。但需要注意，此值如果设置的比较小，则会频繁的创建和销毁线程；如果设置的比较大，则会浪费系统资源，所以开发者需要根据自己的实际业务来调整此值。</p>
<p><strong>第2个参数</strong>：<code>maximumPoolSize</code>表示线程池在任务最多时，最大可以创建的线程数(<strong>线程池中的当前线程数数目不会超过该值，如果队列中任务已满，而且当前线程数小于<code>maximumPoolSize</code>，那么会创建新的线程来执行任务</strong>)。官方规定此值必须大于0，也必须大于等于corePoolSize，此值只有在任务比较多，且不能存放在任务队列时，才会用到。</p>
<p>也就是说，<font color=#FF0000>线程池的线程数量最小不小于<code>corePoolSize</code>,但是最大不大于<code>maximumPoolSize</code></font></p>
<p><strong>第3个参数</strong>：<code>keepAliveTime</code>表示线程的存活时间，当线程池空闲时并且超过了此时间，多余的线程就会销毁，直到线程池中的线程数量销毁的等于corePoolSize为止，如果 maximumPoolSize 等于 corePoolSize，那么线程池在空闲的时候也不会销毁任何线程。</p>
<p><strong>第 4 个参数</strong>：<code>unit</code> 表示存活时间的单位，它是配合 keepAliveTime 参数共同使用的。</p>
<p><strong>第 5 个参数</strong>：<code>workQueue</code> 表示线程池执行的任务队列，当线程池的所有线程都在处理任务时，如果来了新任务就会缓存到此任务队列中排队等待执行。</p>
<p><strong>第 6 个参数</strong>：<code>threadFactory</code> 表示线程的创建工厂，此参数一般用的比较少，我们通常在创建线程池时不指定此参数，它会使用默认的线程创建工厂的方法来创建线程。</p>
<p><strong>第 7 个参数</strong>：<code>RejectedExecutionHandler</code>表示指定线程池的拒绝策略。很可能发生的一种情况是，我的任务队列里有特别多的队列，然后线程池现在已经装满了<code>maximumPoolSize</code>的数量，那么此时我们已经达到了承受的上限，再来任务就需要拒绝了。即：当<strong>线程池的任务已经在缓存队列workQueue中存储满了之后，并且不能创建新的线程来执行此任务时，就会用到此拒绝策略</strong>，它属于一种<strong>限流保护的机制</strong>。</p>
<h3 id="线程池-ThreadPoolExecutor-执行流程"><a href="#线程池-ThreadPoolExecutor-执行流程" class="headerlink" title="线程池(ThreadPoolExecutor)执行流程"></a>线程池(ThreadPoolExecutor)执行流程</h3><p>通过<code>executor()</code>方法开始执行，如果当前工作线程数(workerCount)小于核心线程数，会创建新的线程执行这个任务。</p>
<p>然后检查线程池是否处于运行状态，是的话把任务添加到队列。如果线程池处于非运行状态，而且处于爆满，并且尝试新启动一个线程失败了，那么执行拒绝策略。</p>
<p>重点方法：<code>addWorker(Runnable firstTask, boolean core)</code>两个方法参数如下：</p>
<ul>
<li><p>firstTask，线程应首先运行的任务，如果没有则可以设置为 null；</p>
</li>
<li><p>core，判断是否可以创建线程的阀值（最大值），如果等于 true 则表示使用 corePoolSize 作为阀值，false 则表示使用 maximumPoolSize 作为阀值。</p>
</li>
</ul>
<p>具体流程可以参考这张图：</p>
<p><img src="https://i.loli.net/2020/03/27/z48VkDrqOcN9Yug.png" alt="ThreadPoolExecutor执行流程.png"></p>
<h3 id="使用Executors返回线程池对象的弊端"><a href="#使用Executors返回线程池对象的弊端" class="headerlink" title="使用Executors返回线程池对象的弊端"></a>使用Executors返回线程池对象的弊端</h3><p><strong>主要两点</strong>：</p>
<ol>
<li><p>FixedThreadPool 和 SingleThreadPool：<strong>允许的请求队列长度为 Integer.MAX_VALUE</strong>，可能会堆积大量的请求，从而导致 OOM。</p>
</li>
<li><p>CachedThreadPool 和 ScheduledThreadPool：<strong>允许的创建线程数量为 Integer.MAX_VALUE</strong>，可能会创建大量的线程，从而导致 OOM。</p>
</li>
</ol>
<h2 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h2><p>当线程池中的任务队列已经被存满，再有任务添加时会先判断当前线程池中的线程数是否大于等于线程池的最大值，如果是，则会触发线程池的拒绝策略，即之前七个参数中的<code>RejectedExcecutionHandler</code>。</p>
<p>Java 自带的拒绝策略有 4 种：</p>
<ul>
<li><strong>Abort</strong> (Policy)，终止策略，线程池会抛出异常并终止执行，它是默认的拒绝策略；</li>
<li><strong>CallerRuns</strong> (Policy)，把任务交给当前线程来执行</li>
<li><strong>Discard</strong> (Policy)，忽略此任务（最新的任务）；</li>
<li><strong>DiscardOldest</strong> (Policy)，忽略最早的任务（最先加入队列的任务）。</li>
</ul>
<h3 id="自定义拒绝策略"><a href="#自定义拒绝策略" class="headerlink" title="自定义拒绝策略"></a>自定义拒绝策略</h3><p>自定义拒绝策略只需要新建一个 <strong>RejectedExecutionHandler</strong> 对象，然后重写它的 <strong>rejectedExecution()</strong> 方法即可。</p>
<h3 id="ThreadPoolExecutor扩展"><a href="#ThreadPoolExecutor扩展" class="headerlink" title="ThreadPoolExecutor扩展"></a>ThreadPoolExecutor扩展</h3><p>ThreadPoolExecutor的扩展主要是通过重写它的<strong>beforeExecute()</strong>和<strong>afterExecute()</strong>方法实现的，我们可以在扩展方法中添加日志或者实现数据统计，比如统计线程的执行时间。</p>
<p>展示代码暂时略。</p>
<h2 id="如果在线程池中使用无界阻塞队列会发生什么问题？"><a href="#如果在线程池中使用无界阻塞队列会发生什么问题？" class="headerlink" title="如果在线程池中使用无界阻塞队列会发生什么问题？"></a>如果在线程池中使用无界阻塞队列会发生什么问题？</h2><p>这个问题的另外一个问法：<strong>在远程服务异常的情况下，使用无界阻塞队列，是否会导致内存异常飙升</strong>？</p>
<p>考察你对线程池工作原理是否理解，线程处理任务、队列长度等。</p>
<p>实际上，每个线程在执行任务的时候都会调用远程服务。如果某个服务总是异常，那么会导致你这个线程总是调用失败，调用时间会超时，导致整个系统卡住，然后挤压的任务越来越多，最后会导致内存飙升，甚至可能导致OOM，<font color=#FF0000>内存泄漏</font>。</p>
<h2 id="如果线程池的队列满了，会发生什么？"><a href="#如果线程池的队列满了，会发生什么？" class="headerlink" title="如果线程池的队列满了，会发生什么？"></a>如果线程池的队列满了，会发生什么？</h2><p>这道题还是考察你对线程池原理是否理解。</p>
<p>如果你使用有界队列，那么可以避免上述说的内存溢出问题。</p>
<p>但是如果我们还是使用无阻塞队列，设置<code>maximumPoolSize</code>为<code>Integer.MAX_VALUE</code>了，那么如果某个时刻来的请求太多太多了，虽然无限制的不停的创建额外的线程出来，最后一台机器上，有几千个线程，甚至是几万个线程，但是每个线程都有自己的栈内存，占用一定的内存资源，会导致内存资源耗尽，系统也会崩溃掉。</p>
<p>即使内存没有崩溃，会导致你的机器cpu load，负载特别高。</p>
<p><font color=#FF0000>建议</font>：<strong>自定义一个reject策略，如果线程池无法执行更多的任务了，此时你可以把这个任务信息持久化写入磁盘里去，后台专门启动一个线程，后续等待你的线程池的工作负载降低了，他可以慢慢地从磁盘里读取之前持久化的任务，重新提交到线程池里去执行</strong>。</p>
<h2 id="如果线上机器突然宕机，线程池的阻塞队列中的请求怎么办？"><a href="#如果线上机器突然宕机，线程池的阻塞队列中的请求怎么办？" class="headerlink" title="如果线上机器突然宕机，线程池的阻塞队列中的请求怎么办？"></a>如果线上机器突然宕机，线程池的阻塞队列中的请求怎么办？</h2><p>首先，<strong>必然会导致线程池里的积压的任务都会丢失</strong>。</p>
<p>如果你提交一个任务到线程池里去，在提交之前，你需要先在数据库里插入这个任务的信息，更新他的状态：<strong>未提交</strong>、<strong>已提交</strong>、<strong>已完成</strong>。提交成功之后，更新他的状态是 <strong>已提交</strong> 状态。</p>
<p>系统重启，你可以自己定义一个后台线程，这个后台线程需要去扫描数据库里的<strong>未提交</strong>和<strong>已提交</strong>状态的任务，可以把任务的信息读取出来，重新提交到线程池里去，继续进行执行。</p>
<h2 id="搞懂synchronized-从偏量锁到重量级锁"><a href="#搞懂synchronized-从偏量锁到重量级锁" class="headerlink" title="搞懂synchronized(从偏量锁到重量级锁)"></a>搞懂synchronized(从偏量锁到重量级锁)</h2><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&mid=2247485257&idx=1&sn=0ab85e4cd8b575fe5c01b269dda007f5&source=41&scene=21#wechat_redirect" target="_blank" rel="noopener">本部分参考这篇文章</a></p>
<h3 id="从一个例子展开基础用法"><a href="#从一个例子展开基础用法" class="headerlink" title="从一个例子展开基础用法"></a>从一个例子展开基础用法</h3><p>接触过线程安全的同学想必都使用过synchronized这个关键字，在java同步代码快中，synchronized的使用方式无非有两个:</p>
<ol>
<li>通过对一个对象进行加锁来实现同步，如下面代码。</li>
</ol>
<p><code>synchronized(lockObject){    //代码}</code></p>
<ol start="2">
<li>对一个方法进行synchronized声明，进而对一个方法进行加锁来实现同步。如下面代码</li>
</ol>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> synchornized <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//一大堆的代码</span></span><br><span class="line">    synchornized(myObject) &#123;</span><br><span class="line">    	<span class="comment">//一大堆的代码</span></span><br><span class="line">    	<span class="keyword">synchronized</span>(myObject) &#123;</span><br><span class="line">    		<span class="comment">// 一大堆的代码</span></span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面会讲到，实际上在JVM层面来看，用到了monitor对象，字节码会用到<code>monitorenter</code>和<code>monitorexit</code> 指令。</p>
<p><font color=#FF0000><strong>首先加锁，使用<code>monitorenter</code>指令</strong></font>。即刚进入到synchronized关键字的范围内的时候，会使用<code>monitorenter</code>指令。</p>
<p>每个对象都有一个关联的monitor，比如一个对象实例就有一个monitor，一个类的Class对象也有一个monitor，如果要对这个对象加锁，那么必须获取这个对象关联的monitor的lock锁</p>
<p>他里面的原理和思路大概是这样的，monitor里面有一个计数器，从0开始的。如果一个线程要获取monitor的锁，就看看他的计数器是不是0，如果是0的话，那么说明没人获取锁，他就可以获取锁了，然后对计数器加1。</p>
<p>如果一个线程第一次从synchronized那里获取到了myObject对象的monitor的锁，计数器会加1，然后二次到synchronized那里，会再次获取myObject对象的monitor锁，这个就是重入加锁了，然后计数器会再次加1，变成2。这个时候，其他的线程在第一次synchronized那里，会发现说myObject对象的monitor锁的计数器是大于0的，意味着被别人加锁了，然后此时线程就会进入block阻塞状态，什么都干不了，就是等着获取锁。</p>
<p><font color=#FF0000><strong>释放锁，使用<code>monitorexit</code>指令</strong></font>，即如果出了synchronized修饰的代码片段的范围，就会有一个<code>monitorexit</code>指令，在底层。此时获取锁的线程就会对那个对象的monitor的计数器减1，如果有多次重入加锁就会对应多次减1，直到最后，计数器是0。</p>
<p>如下图所示：</p>
<p><img src="https://i.loli.net/2020/04/06/5fD496r1YZMkWuL.png" alt="加锁释放锁.png"></p>
<p>但这里需要指出的是，无论是对一个对象进行加锁还是对一个方法进行加锁，实际上，都是对<strong>对象进行加锁</strong>。</p>
<p>也就是说，对于方式2，实际上虚拟机会根据synchronized修饰的是实例方法还是类方法，去取对应的实例对象或者Class对象来进行加锁。</p>
<blockquote>
<p>synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者 代码块在任意时刻只能有一个线程执行。</p>
</blockquote>
<p>另外，在 Java 早期版本(JDK1.6之前)中，synchronized属于重量级锁，效率低下，因为监视器锁（<strong>monitor,在Java中每个对象都隐式包含一个monitor（监视器）对象，加锁的过程其实就是竞争monitor的过程，当线程进入字节码monitorenter指令之后，线程将持有monitor对象，执行 monitorexit 时释放 monitor 对象，当其他线程没有拿到 monitor 对象时，则需要阻塞等待获取该对象。</strong> ）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程， 都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要 相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对 锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p>
<h2 id="synchronized和ReentrantLock-两者的实现原理？两者的区别？"><a href="#synchronized和ReentrantLock-两者的实现原理？两者的区别？" class="headerlink" title="synchronized和ReentrantLock,两者的实现原理？两者的区别？"></a>synchronized和ReentrantLock,两者的实现原理？两者的区别？</h2><p>在JDK1.5之前共享对象的协调机制只有synchronized和volatile，在JDK1.5中增加了新的机制ReentrantLock，该机制的诞生并不是为了替代synchronized而是在 synchronized 不适用的情况下，提供一种可以选择的高级功能。</p>
<p>注意synchronized：synchronized关键字加到非 static 静态 方法上是给对象实例上锁。另外需要注意的是：尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓冲功能！</p>
<h3 id="synchronized和ReentrantLock原理"><a href="#synchronized和ReentrantLock原理" class="headerlink" title="synchronized和ReentrantLock原理"></a>synchronized和ReentrantLock原理</h3><p>synchronized 属于独占式<strong>悲观锁</strong>，是通过 JVM 隐式实现的.</p>
<p>synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者 代码块在任意时刻只能有一个线程执行。</p>
<p>synchronized的一个例子就是单例模式的双检查模式中对类加锁的操作。</p>
<p>ReentrantLock是Lock的默认实现方式之一，它是基于AQS（AbstractQueuedSynchronizer，队列同步器）实现的，它默认是通过非公平锁实现的，在它的内部有一个 state 的状态字段用于表示锁是否被占用，如果是 0 则表示锁未被占用，此时线程就可以把 state 改为 1，并成功获得锁，而其他未获得锁的线程只能去排队等待获取锁资源。</p>
<h3 id="synchronized和ReentrantLock共同点与区别"><a href="#synchronized和ReentrantLock共同点与区别" class="headerlink" title="synchronized和ReentrantLock共同点与区别"></a>synchronized和ReentrantLock共同点与区别</h3><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><p><strong>两者都是可重入锁</strong></p>
<p>两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时 这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p>
<p><strong>两者都是悲观锁，都属于独占锁的实现</strong></p>
<p>Lock 只是一个顶层抽象接口，并没有实现，也没有规定是乐观锁还是悲观锁实现规则。而 ReentrantLock 作为 Lock 的一种实现，是<strong>悲观锁</strong>。(注：ReentrantReadWriteLock 的提供了一种乐观锁的实现，但是<strong>这个不太熟的话建议面试别说</strong>)</p>
<p><a href="https://blog.csdn.net/qq_35688140/article/details/101223701" target="_blank" rel="noopener">参考文章1</a></p>
<p><a href="https://ask.csdn.net/questions/774015" target="_blank" rel="noopener">参考文章2</a></p>
<h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><p>① synchronized 依赖于 JVM 而 ReenTrantLock 依赖于 API</p>
<p>synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多 优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReenTrantLock 是 JDK 层面实现的（也就 是 API 层面，需要 lock() 和 unlock 方法配合 try/ﬁnally 语句块来完成），所以我们可以通过查看它的源代码，来看 它是如何实现的。</p>
<p><strong>说白了，Synchronized是依赖于JVM实现的，而ReenTrantLock是JDK实现的，前者的实现是比较难见到的，后者有直接的源码可供阅读</strong>。</p>
<p>②  ReenTrantLock 比 synchronized 增加了一些高级功能 </p>
<p>相比synchronized，ReenTrantLock增加了一些高级功能。主要来说主要有三点：</p>
<ol>
<li>等待可中断；</li>
<li>可实现公平锁； </li>
<li>可实现选择性通知（锁可以绑定多个条件）</li>
</ol>
<ul>
<li><p><strong>ReenTrantLock提供了一种能够中断等待锁的线程的机制</strong>，通过lock.lockInterruptibly()来实现这个机制。也 就是说正在等待的线程可以选择放弃等待，改为处理其他事情。 </p>
</li>
<li><p><strong>ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁</strong>(<font color=#FF0000>但是两者默认都是非公平锁，因为性能更好</font>)。所谓的公平锁就是先等待的线程先获得锁。 ReenTrantLock默认情况是非公平的，可以通过 ReenTrantLock类的 <code>ReentrantLock(boolean fair)</code> 构造方法来制定是否是公平的。 </p>
</li>
<li><p>synchronized关键字与wait()和notify/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也 可以实现，但是需要借助于Condition接口与newCondition() 方法。Condition是JDK1.5之后才有的，它具有很 好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视 器），<strong>线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合 Condition实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是Condition接口默认提供的。而 synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的 signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。 </p>
</li>
</ul>
<h2 id="“synchronized和ReentrantLock共同点与区别”的典型回答-重要"><a href="#“synchronized和ReentrantLock共同点与区别”的典型回答-重要" class="headerlink" title="“synchronized和ReentrantLock共同点与区别”的典型回答(重要)"></a>“synchronized和ReentrantLock共同点与区别”的典型回答(重要)</h2><p>synchronized 属于独占式悲观锁，是通过 JVM 隐式实现的，synchronized 只允许同一时刻只有一个线程操作资源。</p>
<p>在Java中每个对象都隐式包含一个monitor（监视器）对象，加锁的过程其实就是竞争monitor的过程，当线程进入字节码monitorenter指令之后，线程将持有monitor对象，执行 monitorexit 时释放 monitor 对象，当其他线程没有拿到 monitor 对象时，则需要阻塞等待获取该对象。  </p>
<p>ReentrantLock 是 Lock 的默认实现方式之一，<font color=#FF0000>注意ReentrantLock也是独占式悲观锁</font>，它是基于 AQS（Abstract Queued Synchronizer，队列同步器）实现的，它默认是通过非公平锁实现的，在它的内部有一个 state 的状态字段用于表示锁是否被占用，如果是 0 则表示锁未被占用，此时线程就可以把 state 改为 1，并成功获得锁，而其他未获得锁的线程只能去排队等待获取锁资源。</p>
<p>synchronized和ReentrantLock都提供了锁的功能，具备互斥性和不可见性。在JDK1.5中synchronized的性能远远低于ReentrantLock，但在 JDK 1.6 之后  synchronized 的性能略低于  ReentrantLock，它的区别如下(四点)：</p>
<ul>
<li>synchronized是JVM隐式实现的，而ReentrantLock是Java语言提供的API；ReentrantLock可设置为公平锁，而synchronized却不行；</li>
<li>ReentrantLock只能修饰代码块，而synchronized可以用于修饰方法、修饰代码块等；</li>
<li>ReentrantLock需要手动加锁和释放锁，如果忘记释放锁，则会造成资源被永久占用，而 synchronized 无需手动释放锁——即<strong>Synchronized的使用比较方便简洁，并且由编译器去保证锁的加锁和释放，而ReenTrantLock需要手工声明来加锁和释放锁，为了避免忘记手工释放锁造成死锁，所以最好在finally中声明释放锁</strong>。</li>
<li>ReentrantLock 可以知道是否成功获得了锁，而 synchronized  却不行。</li>
<li>synchronized只有一个等待队列，而lock调用newCondition()可以产生多个等待队列</li>
</ul>
<h2 id="公平锁-VS-非公平锁"><a href="#公平锁-VS-非公平锁" class="headerlink" title="公平锁 VS 非公平锁"></a>公平锁 VS 非公平锁</h2><p>先介绍一下什么是公平锁和非公平锁。</p>
<p>公平锁的含义是线程需要按照请求的顺序来获得锁；而非公平锁则允许“插队”的情况存在，所谓的“插队”指的是，线程在发送请求的同时该锁的状态恰好变成了可用，那么此线程就可以跳过队列中所有排队的线程直接拥有该锁。</p>
<p>而公平锁由于有挂起和恢复所以存在一定的开销，因此性能不如非公平锁，所以 <strong>ReentrantLock 和 synchronized 默认都是非公平锁的实现方式</strong>。</p>
<h2 id="ReentrantLock详细介绍-源码分析，主要针对加锁和解锁的流程"><a href="#ReentrantLock详细介绍-源码分析，主要针对加锁和解锁的流程" class="headerlink" title="ReentrantLock详细介绍(源码分析，主要针对加锁和解锁的流程)"></a>ReentrantLock详细介绍(源码分析，主要针对加锁和解锁的流程)</h2><p>本课时从源码出发来解密 ReentrantLock 的具体实现细节，首先来看 ReentrantLock 的两个构造函数：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="constructor">ReentrantLock()</span> &#123;</span><br><span class="line">	sync = <span class="keyword">new</span> <span class="constructor">NonfairSync()</span>; <span class="comment">// 非公平锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="constructor">ReentrantLock()</span> &#123;</span><br><span class="line">	sync = fair ? <span class="keyword">new</span> <span class="constructor">FairSync()</span> : <span class="keyword">new</span> <span class="constructor">NonfairSync()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无参的构造函数创建了一个<em>非公平锁</em>，用户也可以根据第二个构造函数，设置一个 boolean 类型的值，来决定是否使用公平锁来实现线程的调度。</p>
<p>ReentrantLock默认使用lock()来获取锁的，并通过unlock()释放锁，样例代码如下：</p>
<figure class="highlight cos"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Lock</span> <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock()<span class="comment">;</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">// 加锁</span></span><br><span class="line">	<span class="keyword">lock</span>.<span class="keyword">lock</span>()<span class="comment">;</span></span><br><span class="line">	<span class="comment">// .....业务处理</span></span><br><span class="line">&#125; finally &#123;</span><br><span class="line">	<span class="comment">// 释放锁，这里别忘了，否则会造成资源被永久占用</span></span><br><span class="line">	<span class="keyword">lock</span>.unlock()<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color=#FF0000>先来重点看一下lock()的过程</font>：</p>
<p>ReentrantLock中的lock()是通过sync.lock()实现的，但Sync类中的lock()是一个抽象方法，需要子类NonfairSync或FairSync去实现，NonfairSync中的lock()源码如下：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="built_in">void</span> lock() &#123;</span><br><span class="line">	<span class="keyword">if</span>(compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">		<span class="comment">// 将当前线程设置为此锁的持有者</span></span><br><span class="line">		setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FairSync中的lock()源码如下：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="built_in">void</span> lock() &#123;</span><br><span class="line">	acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出非公平锁比公平锁只是多了一行 compareAndSetState 方法，该方法是尝试将 state 值由 0 置换为 1，如果设置成功的话，则说明当前没有其他线程持有该锁，不用再去排队了，可直接占用该锁，否则，则需要通过 acquire() 方法去排队。</p>
<p><code>acquire()</code>源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!tryAcquire(arg) &amp;&amp;</span><br><span class="line">		acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">		selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tryAcquire 方法尝试获取锁，如果获取锁失败，则把它加入到阻塞队列中，来看 tryAcquire 的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">	<span class="keyword">int</span> c = getState();</span><br><span class="line">	<span class="keyword">if</span>(c == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// 公平锁比非公平锁多了一行代码： !hasQueuedPredecessors()</span></span><br><span class="line">		<span class="keyword">if</span>(!hasQueuePredecessors() &amp;&amp;</span><br><span class="line">			compareAndSetState(<span class="number">0</span>, acquires)) &#123; <span class="comment">//尝试获取锁</span></span><br><span class="line">			setExclusiveOwnerThread(current); <span class="comment">//获取成功，标记被抢占</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">		<span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">		<span class="keyword">if</span>(nextc &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">		setState(nextc); <span class="comment">// set state = state + 1</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里公平锁比非公平锁多了一行代码<code>!hasQueuePredecessors()</code>，它的作用是查看队列中是否有比它等待时间更长的线程，如果没有，尝试一下是否能获取到锁。如果能获取成功，则把当前锁标记为已经被占用。</p>
<p>如果获取失败，则调用addWaiter方法(在<code>acquire()</code>方法中，见更上面的<code>acquire()</code>源码)把线程包装成Node对象，同时放入到队列中，但addWaiter方法并不会尝试获取锁，<code>acquireQueued()</code>方法才会尝试获取锁，如果获取失败，则此节点会被挂起。</p>
<p><code>acquireQueued()</code>的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 队列中的线程尝试获取锁，失败则会被挂起</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">boolean</span> faild = <span class="keyword">true</span>; <span class="comment">// 获取锁是否成功的状态标识</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">boolean</span> interrrupted = <span class="keyword">false</span>; <span class="comment">// 线程是否被中断</span></span><br><span class="line">		<span class="keyword">for</span>(;;) &#123;</span><br><span class="line">			<span class="comment">// 获取当前一个节点(前驱节点)</span></span><br><span class="line">			<span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">			<span class="comment">// 当前节点为头结点的下一个节点时，有权尝试获取锁</span></span><br><span class="line">			<span class="keyword">if</span>(p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">				setHead(node); <span class="comment">//获取成功，将当前节点设置为head节点</span></span><br><span class="line">				p.next = <span class="keyword">null</span>; <span class="comment">//原head节点出队，等待被GC</span></span><br><span class="line">				faild = <span class="keyword">false</span>; <span class="comment">// 获取成功</span></span><br><span class="line">				<span class="keyword">return</span> interrupted;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 判断获取锁失败后是否可以将其挂起</span></span><br><span class="line">			<span class="keyword">if</span>(shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">				parkAndCheckInterrupt())</span><br><span class="line">				<span class="comment">// 如果线程被中断，则返回true</span></span><br><span class="line">				interrupted = <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(faild)</span><br><span class="line">			canceAcquire(node);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法有个很有意思的地方，就是用了<code>for(;;)</code>这个死循环来尝试获取锁，如果获取失败了，会调用<code>shouldParkAfterFailedAcquire()</code>来尝试挂起当前线程。<code>shouldParkAfterFailedAcquire()</code>方法的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断是否可以被挂起</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 获得当前节点的前驱节点的状态</span></span><br><span class="line">	<span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">	<span class="comment">// 只在前驱节点状态为Node.SIGNAL的时候，当前线程可以被挂起(阻塞)</span></span><br><span class="line">	<span class="keyword">if</span>(ws == Node.SIGNAL)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">if</span>(ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			<span class="comment">// 若前驱节点状态为CANCELLED,那就一直往前找，直到找到一个正常等待的状态</span></span><br><span class="line">				node.prev = pred = pred.prev;</span><br><span class="line">		&#125; <span class="keyword">while</span>(pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">		<span class="comment">// 并将当前节点排在它后边</span></span><br><span class="line">		pred.next = node;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 把前驱节点的状态修改为 SIGNAL</span></span><br><span class="line">		compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前驱节点状态为SIGNAL(SIGNAL状态的含义是后继节点处于等待状态，当前节点释放锁后将会唤醒后继节点),线程才会在入队列的时候被挂起。</p>
<p>在上述代码中，先获取前驱节点pred.waitStatus(即ws)，然后判断这个节点的状态是否为SIGNAL，如果是SIGNAL，则当前线程可以被挂起并返回true；如果前驱节点状态&gt;0,则表示前驱节点已经被干掉了，它已经失效了，所以要继续往前找更前面的节点，直到找到最近一个正常等待的前驱节点，然后把它当前的前驱节点，然后将其状态设置为SIGNAL.</p>
<p>整个加锁过程到这里就完成了，最后需要注意，没有拿到锁的线程会在队列中被挂起，直到拥有锁的线程释放掉锁之后，才会去唤醒其他的线程去获取锁资源，整个运行流程如下图所示：</p>
<p><img src="https://i.loli.net/2020/03/29/uXlKdG83SJTmHCp.png" alt="整个加锁流程.png"></p>
<p><font color=#FF0000>再来看一下unlock()的过程</font>：</p>
<p>这个过程相比加锁简单很多。unlock()只涉及到release()和tryRelease()方法。</p>
<p>unlock源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简单，我们再深入进去看一下release()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 尝试释放锁</span></span><br><span class="line">	<span class="keyword">if</span>(tryRelease(arg)) &#123;</span><br><span class="line">		<span class="comment">// 释放成功</span></span><br><span class="line">		Node h = head;</span><br><span class="line">		<span class="keyword">if</span>(h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">			unparkSuccessor(h);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，锁释放的流程为，先调用tryRelease()方法尝试释放锁，如果释放成功，则查看头结点的状态是否为SIGNAL，是则唤醒头结点的下一个关联的线程；如果释放失败，则直接返回false</p>
<p>tryRelease()源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 释放当前线程占有的锁</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> c = getState() - releases; <span class="comment">// 释放锁后的状态，0表示释放成功</span></span><br><span class="line">	<span class="comment">// 如果拥有锁的线程不是当前线程的话抛出异常</span></span><br><span class="line">	<span class="keyword">if</span>(Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">	<span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">if</span>(c == <span class="number">0</span>) &#123; <span class="comment">//锁被成功释放</span></span><br><span class="line">		free = <span class="keyword">true</span>;</span><br><span class="line">		setExclusiveOwnerThread(<span class="keyword">null</span>); <span class="comment">//清空独占线程</span></span><br><span class="line">	&#125;</span><br><span class="line">	setState(c); <span class="comment">//更新state的值，0表示释放锁成功</span></span><br><span class="line">	<span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在tryRelease()方法中，会先判断当前的线程是不是占用锁的线程，如果不是的话，会抛出异常；如果是的话，会先计算锁的状态值:<code>getState()-releases</code>是否为0，如果是0，则表示可以正常地释放锁，然后清空独占线程，最后会更新锁的状态并返回执行结果。</p>
<h2 id="JDK1-6之后synchronized关键字底层做了哪些优化？详细介绍一下这些优化？"><a href="#JDK1-6之后synchronized关键字底层做了哪些优化？详细介绍一下这些优化？" class="headerlink" title="JDK1.6之后synchronized关键字底层做了哪些优化？详细介绍一下这些优化？"></a>JDK1.6之后synchronized关键字底层做了哪些优化？详细介绍一下这些优化？</h2><p>JDK 1.5 在升级为 JDK 1.6 时，HotSpot 虚拟机团队在锁的优化上下了很大功夫，比如实现了自适应式自旋锁、锁升级等。</p>
<p>JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减 少锁操作的开销。</p>
<p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐 渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p>
<p>下面详细讲一下<strong>自适应自旋锁</strong>和<strong>锁升级</strong>两个部分。</p>
<h3 id="自适应自旋锁-1"><a href="#自适应自旋锁-1" class="headerlink" title="自适应自旋锁"></a>自适应自旋锁</h3><p>JDK1.6引入了自适应式自旋锁意味着自旋的时间不再是固定的时间了，比如在同一个锁对象上，如果通过自旋等待成功获取了锁，那么虚拟机就会认为，它下一次很有可能也会成功(通过自旋获取到锁)，因此允许自旋等待的时间会相对的比较长，而当某个锁通过自旋很少成功获得过锁，那么以后在获取该锁时，可能会直接忽略掉自旋的过程，以避免浪费 CPU 的资源，这就是<strong>自适应自旋锁</strong>的功能。</p>
<h3 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h3><p>锁升级其实就是从偏向锁到轻量级锁再到重量级锁升级的过程，这是 JDK 1.6 提供的优化功能，也称之为<strong>锁膨胀</strong>。</p>
<ul>
<li><p><strong>偏向锁</strong>是指在无竞争的情况下设置的一种锁状态。偏向锁的意思是它会偏向于第一个获取它的线程，当锁对象第一次被获取到之后，会在此对象头中设置标示为“01”，表示偏向锁的模式，并且在对象头中记录此线程的ID，这种情况下，如果是持有偏向锁的线程每次在进入的话，不再进行任何同步操作，如Locking、Unlocking等，直到另一个线程尝试获取此锁的时候，偏向锁模式才会结束，偏向锁可以提高带有同步但无竞争的程序性能。但如果在多数锁总会被不同的线程访问时，偏向锁模式就比较多余了，此时可以通过 -XX:-UseBiasedLocking 来禁用偏向锁以提高性能。</p>
</li>
<li><p><strong>重量锁</strong>：在JDK1.6之前，synchronized是通过操作系统的互斥量（mutexlock）来实现的，这种实现方式需要在用户态和核心态之间做转换，有很大的性能消耗，这种传统实现锁的方式被称之为<strong>重量锁</strong>。</p>
</li>
<li><p><strong>轻量锁</strong>：轻量锁是相对于重量锁而言的，轻量锁是通过比较并交换（CAS，CompareandSwap）来实现的，它对比的是线程和对象的MarkWord（对象头中的一个区域），如果更新成功则表示当前线程成功拥有此锁；如果失败，虚拟机会先检查对象的MarkWord是否指向当前线程的栈帧，如果是，则说明当前线程已经拥有此锁，否则，则说明此锁已经被其他线程占用了。当两个以上的线程争抢此锁时，轻量级锁就膨胀为重量级锁，这就是锁升级的过程，也是JDK1.6锁优化的内容。</p>
</li>
</ul>
<h2 id="synchronized关键字底层原理详解"><a href="#synchronized关键字底层原理详解" class="headerlink" title="synchronized关键字底层原理详解"></a>synchronized关键字底层原理详解</h2><p>synchronized 关键字底层原理属于 JVM 层面，我们一般不会直接接触其源代码。与之对比的是ReenTrantLock， ReenTrantLock是 JDK 层面实现的（也就 是 API 层面，需要 lock() 和 unlock 方法配合 try/ﬁnally 语句块来完成），所以我们可以通过查看它的源代码，来看 它是如何实现的。</p>
<p>对于synchronized我们主要看两种情况：</p>
<h3 id="synchronized-同步语句块的情况"><a href="#synchronized-同步语句块的情况" class="headerlink" title="synchronized 同步语句块的情况"></a>synchronized 同步语句块的情况</h3><p>这里我们自己做实验，首先写一段简单的代码，用synchronized关键字使得代码块上锁：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"synchronized Code block"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后想要看synchronized的工作原理，我们可以看它执行的过程，比如可以看相关字节码文件。我们可以用JDK自带的javap命令查看SynchronizedDemo类的相关字节码信息。先用javac生成其编译后的.class文件，然后执行<code>javap -c -s -v -l SynchronizedDemo.class</code></p>
<p>结果如下图：</p>
<p><img src="https://i.loli.net/2020/03/28/RkuhOC931cYBSsw.png" alt="synchronized修饰代码块.png"></p>
<p>从上图可以看出：</p>
<p><strong>synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同 步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。</strong> 当执行 monitorenter 指令时，线程试图 获取锁也就是获取 monitor(monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取 锁的，也是为什么Java中任意对象可以作为锁的原因) 的持有权.当计数器为0则可以成功获取，获取后将锁计数器设 为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当 前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p>
<h3 id="synchronized修饰方法"><a href="#synchronized修饰方法" class="headerlink" title="synchronized修饰方法"></a>synchronized修饰方法</h3><p>代码如下：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo2</span> &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> synchronized <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"synchronized method"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码用javap查看字节码文件：</p>
<p><img src="https://i.loli.net/2020/03/28/MhosgzRn3EPIxtp.png" alt="synchronized修饰方法.png"></p>
<p>synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来 辨别一个方法是否声明为同步方法，从而执行相应的同步调用。 </p>
<h2 id="ReentrantLock的使用和原理"><a href="#ReentrantLock的使用和原理" class="headerlink" title="ReentrantLock的使用和原理"></a>ReentrantLock的使用和原理</h2><p>ReentrantLock基于AQS，使用CAS进行加锁，同一时间只能有一个线程成功用CAS加锁。当之前线程执行完之后，会自动唤醒等待队列中队头的线程，然后这个被唤醒的线程会继续用CAS加锁。</p>
<p><strong>需要注意</strong>，<font color=#FF0000>如果构造ReentrantLock的时候用了无参构造，那么默认是非公平锁</font>。代码如下：</p>
<p><code>ReentrantLock lock = new ReentrantLock();//非公平锁</code></p>
<p>即当线程1执行结束之后，如果线程3此时恰好过来请求，那么系统会无视等待队列，直接让线程3使用资源。</p>
<p><font color=#FF0000>如果要定义成公平锁，要传入一个构造参数true</font>，即：</p>
<p><code>ReentrantLock lock = new ReentrantLock(true);//非公平锁</code></p>
<p>此时线程3会按照顺序进入等待队列，线程2执行之后线程3才会执行。</p>
<p>如下图所示：</p>
<p><img src="https://i.loli.net/2020/04/06/L4ifbJ639r85sMy.png" alt="AQS工作原理.png"></p>
<h2 id="说说Java多线程的互斥锁和同步锁？"><a href="#说说Java多线程的互斥锁和同步锁？" class="headerlink" title="说说Java多线程的互斥锁和同步锁？"></a>说说Java多线程的互斥锁和同步锁？</h2><h3 id="通俗解释"><a href="#通俗解释" class="headerlink" title="通俗解释"></a>通俗解释</h3><p>首先，所谓互斥锁，有互斥锁，其实就有同步锁。不论是在java语法层面包装成了sycnchronized或者明确的XXXLock，但是底层都是一样的。无非就是哪种写起来方便而已。</p>
<p>所谓锁，就是锁而已，<strong>避免多个线程对同一个共享的数据并发修改带来的数据混乱</strong>。</p>
<p>锁其实要解决的是这四大问题：</p>
<ul>
<li><strong>“谁拿到了锁“这个信息存哪里</strong>（可以是当前class，当前instance的markword，还可以是某个具体的Lock的实例）</li>
<li><strong>谁能抢到锁的规则</strong>（只能一个人抢到 - Mutex；能抢有限多个数量 - Semphore；自己可以反复抢 - 重入锁；读可以反复抢到但是写独占 - 读写锁……）</li>
<li><strong>抢不到时怎么办</strong>（抢不到玩命抢；抢不到暂时睡着，等一段时间再试/等通知再试；或者二者的结合，先玩命抢几次，还没抢到就睡着）</li>
<li><strong>如果锁被释放了还有其他等待锁的怎么办</strong>（不管，让等的线程通过超时机制自己抢；按照一定规则通知某一个等待的线程；通知所有线程唤醒他们，让他们一起抢……）</li>
</ul>
<p>有了这些选择，你就可以按照业务需求组装出你需要的锁。</p>
<p><font color=#FF0000>关于“互斥”和“同步”的概念</font>：</p>
<ul>
<li><strong>互斥</strong>就是线程A访问了一组数据，线程BCD就不能同时访问这些数据，直到A停止访问了</li>
<li><strong>同步</strong>就是ABCD这些线程要约定一个执行的协调顺序，比如D要执行，B和C必须都得做完，而B和C要开始，A必须先得做完。</li>
</ul>
<p>这是两种典型的并发问题。恰当的使用锁，可以解决同步或者互斥的问题。</p>
<p>你可以说Mutex是专门被设计来解决互斥的；Barrier，Semphore是专门来解决同步的。但是这些都离不开上述对上述4个问题的处理。同时，如果遇到了其他的具体的并发问题，你也可以定制一个锁来满足需要。</p>
<h3 id="更正式的学术解释"><a href="#更正式的学术解释" class="headerlink" title="更正式的学术解释"></a>更正式的学术解释</h3><p>所谓互斥，就是不同线程通过竞争进入临界区（共享的数据和硬件资源），为了防止访问冲突，在有限的时间内只允许其中之一独占性的使用共享资源。如不允许同时写</p>
<p>同步关系则是多个线程彼此合作，通过一定的逻辑关系来共同完成一个任务。一般来说，同步关系中往往包含互斥，同时对临界区的资源会按照某种逻辑顺序进行访问。如先生产后使用</p>
<p>总的来说，两者的区别就是：</p>
<ul>
<li><p><strong>互斥</strong>是通过竞争对资源的独占使用，彼此之间不需要知道对方的存在，执行顺序是一个乱序。</p>
</li>
<li><p><strong>同步</strong>是协调多个相互关联线程合作完成任务，彼此之间知道对方存在，执行顺序往往是有序的。</p>
</li>
</ul>
<p><a href="https://www.cnblogs.com/yuxiang1/p/9183671.html" target="_blank" rel="noopener">有关同步锁和互斥锁可以参考这篇文章</a></p>
<p><a href="https://www.oschina.net/code/piece_full?code=11175" target="_blank" rel="noopener">有关互斥锁的样例可以参考这篇文章</a></p>
<h2 id="Java-内存模型详解-JVM-JMM-包含类加载器"><a href="#Java-内存模型详解-JVM-JMM-包含类加载器" class="headerlink" title="Java 内存模型详解(JVM+JMM)(包含类加载器)"></a>Java 内存模型详解(JVM+JMM)(包含类加载器)</h2><p>java内存模型(Java Memory Model，JMM)是java虚拟机规范定义的，用来屏蔽掉java程序在各种不同的硬件和操作系统对内存的访问的差异，这样就可以实现java程序在各种不同的平台上都能达到内存访问的一致性。可以避免像c++等直接使用物理硬件和操作系统的内存模型在不同操作系统和硬件平台下表现不同，比如有些c/c++程序可能在windows平台运行正常，而在linux平台却运行有问题。</p>
<h3 id="1-说一下JVM的内存模型？-由浅入深"><a href="#1-说一下JVM的内存模型？-由浅入深" class="headerlink" title="1.说一下JVM的内存模型？(由浅入深)"></a>1.说一下JVM的内存模型？(由浅入深)</h3><p>先简单回答这个问题，要答出两个要点：一个是各部分的功能，另一个是哪些线程共享，哪些线程独占。</p>
<p><strong>JVM内存模型主要指<font color=#FF0000>运行时的数据区</font></strong>，包括5个部分。如下图：</p>
<p><img src="https://i.loli.net/2020/03/16/CcQiorLdHl4w9EK.png" alt="Java内存模型.png"></p>
<ul>
<li><strong>栈</strong>，也叫方法栈，是线程私有的，线程在执行每个方法时都会同时创建一个栈帧，用来存储局部变量表、操作栈、动态链接、方法出口等信息。调用方法时执行入栈，方法返回时执行出栈。</li>
<li><strong>本地方法栈</strong>与栈类似，也是用来保存线程执行方法时的信息，不同的是，执行 Java 方法使用栈，而执行 native 方法使用本地方法栈。</li>
</ul>
<blockquote>
<p>注：什么是Java的本地方法(native method)？——一个Native Method是这样一个java的方法：该方法的实现由非java语言实现，比如C。这个特征并非java所特有，很多其它的编程语言都有这一机制，比如在C＋＋中，你可以用extern “C”告知C＋＋编译器去调用一个C的函数。</p>
<p>“A native method is a Java method whose implementation is provided by non-java code.”在定义一个native method时，并不提供实现体（有些像定义一个java interface），因为其实现体是由非java语言在外面实现的。</p>
</blockquote>
<ul>
<li><strong>程序计数器</strong>保存着当前线程所执行的字节码位置，每个线程工作时都有一个独立的计数器。程序计数器为执行 Java 方法服务，执行 native 方法时，程序计数器为空。</li>
</ul>
<p>以上三个部分：栈、本地方法栈、程序计数器，都是线程独占的。</p>
<ul>
<li><strong>堆</strong>是JVM管理的内存中最大的一块，堆被所有线程共享，目的是为了存放对象实例，几乎所有的对象实例都在这里分配。当堆内存没有可用的空间时，会抛出OOM异常。根据对象存活的周期不同，<strong>JVM把堆内存进行分代管理，由垃圾回收器来进行对象的回收管理</strong>。</li>
<li><strong>方法区</strong>也是各个线程共享的内存区域，又叫<strong>非堆区</strong>。用于<strong>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</strong>，JDK1.7中的永久代和JDK1.8中的Metaspace都是方法区的一种实现。</li>
</ul>
<p>简单回答之后，可以深入地剖析线程独占和线程共享的每个部分的内容：</p>
<h4 id="线程独占部分"><a href="#线程独占部分" class="headerlink" title="线程独占部分"></a>线程独占部分</h4><h5 id="程序计数器-Program-Counter-Register-即PC"><a href="#程序计数器-Program-Counter-Register-即PC" class="headerlink" title="程序计数器(Program Counter Register,即PC)"></a>程序计数器(Program Counter Register,即PC)</h5><ol>
<li><p>它是一块较小的内存空间，它可以看做是<strong>当前线程所执行的字节码行号指示器(逻辑)</strong>。</p>
</li>
<li><p>在虚拟机的概念模型里，字节码解释器工作时，通过改变计数器的值来选取下一条需要执行的字节码指令。包括分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成。</p>
</li>
<li><p>由于JVM的多线程是通过线程之间的来回切换，并且分配处理器执行时间的方式来实现的，所以在任何一个确定的时刻，一个处理器只会执行一条线程中的指令。因此，为了确保线程在切换后能回到正确的位置，每条线程都需要有一个独立的程序计数器，并且各条线程之间的计数器互不影响，独立存储。我们称这样的内存为”线程私有”的内存，这个计数器的值也和线程之间是一对一的关系。</p>
</li>
<li><p>如果一个线程正在执行Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址，那么如果正在执行的是Native方法，则计数器值会为<code>&quot;Undefined&quot;</code></p>
</li>
<li><p>此外，由于只是记录行号，程序计数器不会存暴掉，即程序计数器不会存在内存泄漏的问题。</p>
</li>
</ol>
<p>小总结：<strong>程序计数器是逻辑计数器，而不是物理计数器。为了线程切换后都能回到正确的执行位置，每个线程都有一个独立的程序计数器，它是线程独立的，并且只为Java方法计数。Native方法对应的程序计数器则是Undefined。使用程序计数器，不用担心会发生内存泄漏的问题。</strong></p>
<ul>
<li>当前线程所执行的字节码行号指示器</li>
<li>改变计数器的值来选取下一条需要执行的字节码指令</li>
<li>和线程一一对应</li>
<li>只对Java方法计数，如果是Native方法则计数器值为Undefined</li>
<li>不会发生内存泄漏</li>
</ul>
<h5 id="Java虚拟机栈-Stack"><a href="#Java虚拟机栈-Stack" class="headerlink" title="Java虚拟机栈(Stack)"></a>Java虚拟机栈(Stack)</h5><p>Java虚拟机栈也是线程私有的，是Java方法执行的内存模型。每个方法被执行的时候都会创建一个栈帧，结构如下图：</p>
<p><img src="https://s2.ax1x.com/2020/03/04/3IqmNR.png" alt="3IqmNR.png"></p>
<p>图中的局部变量表和操作数栈有什么区别？</p>
<ul>
<li>局部变量表：包含方法执行过程中的所有变量，包含this引用、所有方法参数，其他局部变量(包括布尔值、Byte、char、long、short、int、float、double等等类型)</li>
<li>操作数栈：在执行字节码指令过程中被用到，这种方式类似原生CPU寄存器。大部分JVM字节码把时间花费在操作数栈的操作上，包括入栈、出栈、复制、交换、产生消费变量</li>
</ul>
<p>栈本身是一个后进先出的数据结构。因此当前执行的方法在栈的顶部，每次方法调用时一个新的栈帧创建，并压入栈顶。当方法正常返回或抛出未捕获的异常时，栈帧就会出栈。除了栈帧的压栈和出栈，栈不能被直接操作。</p>
<p>解读Java可能出现的异常</p>
<p><strong>java.lang.StackOverflowError</strong></p>
<p>递归为什么会引发java.lang.StackOverflowError异常？</p>
<p>递归执行次数过多，栈帧过高。每次调用递归，都会创建一个对应的栈帧，并把建立的栈帧压入虚拟机栈中。</p>
<ol>
<li>如果递归层数过高，不断调用自身，每新调用一次方法，就会生成一个栈帧。</li>
<li>它会保存当前方法的栈帧状态</li>
<li>栈帧上下文切换的时候会切换到最新的方法栈帧当中</li>
</ol>
<p>如果递归调用过多，则会产生过多的栈帧，栈帧超过虚拟栈深度限制，就会报错。</p>
<p>解决的方法主要是限制递归的次数，或者可以直接用循环替换递归。</p>
<p><strong>java.lang.OutOfMemoryError</strong></p>
<p>虚拟机栈过多会引发java.lang.OutOfMemoryError异常。当虚拟机栈可以动态扩展时，如果无法申请足够多的内存，就会抛出这个异常。</p>
<p>如果虚拟机栈可以动态扩展，并超出内存，就会报这个错误。</p>
<h5 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h5><ul>
<li>与虚拟机栈类似，主要作用于标注了native的方法</li>
</ul>
<p>带有native关键字的方法，比如之前的forName0()之类的方法，用的是本地方法栈。</p>
<p><strong>小总结</strong></p>
<p>虚拟机栈是Java虚拟机自动管理的。栈类似一个集合，但是有容量限制，由多个栈帧组合而成。编写代码的时候，每调用一个方法，Java虚拟机就为其分配一块空间，就增加一层栈帧。<font color=#FF0000>而当方法调用结束后，对应的栈帧就会被自动释放掉。这就是为什么栈不需要GC，但是堆需要</font>。</p>
<h4 id="线程共享部分"><a href="#线程共享部分" class="headerlink" title="线程共享部分"></a>线程共享部分</h4><p>从之前”JDK8内存模型”这张图中可以看到，JVM里线程共享的主要是两个部分：MataSpace和Java堆</p>
<h5 id="元空间-MetaSpace-与永久代-PermGen-的区别"><a href="#元空间-MetaSpace-与永久代-PermGen-的区别" class="headerlink" title="元空间(MetaSpace)与永久代(PermGen)的区别"></a>元空间(MetaSpace)与永久代(PermGen)的区别</h5><p>JDK8之后，MetaSpace开始把类的元数据放在本地堆内存中，这段区域在JDK7以及以前，都是属于永久代的。</p>
<p>元空间和永久代都用来存储class的相关信息，包括class对象的方法和filed等。</p>
<p>元空间永久代都是方法区的实现，实现方法不同。方法区只是一种JVM的规范。</p>
<p>Java7之后，把原先位于方法区的字符串常量池移动到了Java堆中，并且在JDK8之后，使用元空间替代了永久代。</p>
<p>这一替代不仅是名字上的替代，两者最大的区别是：<strong>元空间使用本地内存，而永久代使用的是JVM的内存</strong>。这样设置的一个好处就是解决了内存不足的问题，<code>java.lang.OutOfMemoryError:PemGen space</code>这个错误将不复存在。因为此时MetaSpace的大小取决于本地内存的大小。本地内存有多大，MetaSpace就有多大。当然，实际运行的时候不可能放任MetaSpace的壮大，JVM在运行的时候会根据需要动态地设置其大小。</p>
<p><strong>MetaSpace相比PermGen的优势</strong></p>
<ul>
<li>字符串常量池存在永久代中，容易出现性能问题和内存溢出</li>
<li>永久代类和方法的信息大小难以确定，给永久代的大小指定带来困难</li>
<li>永久代会为GC带来不必要的复杂性，而且回收效率可能较低</li>
<li>用元空间方便HotSpot与其他JVM如Jrockit的集成</li>
</ul>
<p><font color=#FF0000>重点记住：元空间和永久代的主要区别，是前者内存空间主要使用的是本机内存。</font>MetaSpace没有了字符串常量池，它在JDK7中已经被移动到了堆中。MetaSpace其他存储的东西，包括类文件，在JVM运行时候的数据结构，以及class相关的内容，如method,filed，大体上都与永久代一样，只是划分上更加合理。比如类元素的生命周期与类加载器一致，每个类加载器(classLoader)都会分配一个单独的存储空间。</p>
<h5 id="Java堆-Heap"><a href="#Java堆-Heap" class="headerlink" title="Java堆(Heap)"></a>Java堆(Heap)</h5><p>对于大多数应用来说，Java堆是Java虚拟机所管理的内存中最大的一块。Java堆是被所有内存共享的一块内存区域。在虚拟机启动时创建此内存区域的唯一目的，就是存放对象实例，几乎所有的对象实例都在这里分配内存。</p>
<p>以一个32位处理器的Java内存布局为例：</p>
<p><img src="https://s2.ax1x.com/2020/03/05/3TNVFx.png" alt="32位处理器的Java内存布局"></p>
<p>可以看到，Java堆会占用非常大的一块内存。</p>
<p>此外，Java堆是垃圾收集器管理的主要区域，因此很多时候也被称为GC堆。</p>
<p>如果从内存回收的角度看，由于现在的收集器基本都采用分代收集的算法，所以Java堆中还可以细分为新生代和老年代。</p>
<p>可以参见下图：</p>
<p><img src="https://s2.ax1x.com/2020/03/05/3TNefK.png" alt="GC堆"></p>
<h4 id="JVM的运行模式-server和client"><a href="#JVM的运行模式-server和client" class="headerlink" title="JVM的运行模式(server和client)"></a>JVM的运行模式(server和client)</h4><p>JVM有两种运行模式：Server和Client。</p>
<p>这两种运行模式的区别在于：Server启动较慢，Client启动较快。但是启动后运行进入稳定期之后，Server模式的程序运行速度比Client更快。</p>
<p>因为Server模式启动的是重量级的虚拟机，对程序采用了更多优化，对比之下Client模式启用的是轻量级的虚拟机。</p>
<p>如果想要查看当前Java是Server模式还是Client模式，可以直接用<code>java -version</code>查看即可.</p>
<h3 id="2-JMM如何保证原子性、可见性、有序性？"><a href="#2-JMM如何保证原子性、可见性、有序性？" class="headerlink" title="2.JMM如何保证原子性、可见性、有序性？"></a>2.JMM如何保证原子性、可见性、有序性？</h3><p>首先应当搞清楚，JMM和JVM内存模型是完全不同的两个概念。JVM内存模型主要针对<strong>运行时数据区</strong>而言，而JMM是指Java程序中<strong>变量的访问规则</strong>，两者是完全不同的两个概念。</p>
<p>JMM如下图所示：</p>
<p><img src="https://i.loli.net/2020/04/06/pDqjgrUoiXQGRnL.png" alt="JMM与内存可见性.png"></p>
<p>所有<strong>共享变量</strong>都存储在<strong>主内存</strong>中，共享。每个线程都有自己的<strong>工作内存</strong>，而工作内存中保存的是主内存中<strong>变量的副本</strong>，线程对变量的读写等操作必须在自己的工作内存中进行，而不能直接读写主内存中的变量。</p>
<p>综合1和2两个部分，我们要注意，<font color=#FF0000>在回答”说一下JVM的内存模型？”这个问题的时候，要和面试官确认是希望回答JVM的内存模型，还是Java对内存数据访问的模型</font>，不要答跑偏。</p>
<p>在多线程进行数据交互时，例如线程A给一个共享变量赋值后，由线程B来读取这个值，A修改完变量是修改在自己的工作区内存中，B是不可见的，只有从A的工作区写回主内存，B再从主内存读取自己的工作区才能进行进一步的操作。由于指令重排序的存在，这个写—读的顺序有可能被打乱。因此 JMM 需要提供<strong>原子性、可见性、有序性</strong>的保证。</p>
<p>下面来详细分析一下如何保证这三个特性的。</p>
<p>首先，还是来看一张图：</p>
<p><img src="https://i.loli.net/2020/04/06/aCUTyDSk4qKvxN5.png" alt="JMM保证.png"></p>
<p>从图中已经可以看到，为了保证<strong>原子性、可见性、有序性</strong>，我们有不同的方法。</p>
<p><strong>原子性</strong>：</p>
<p><u>原子性即线程T1在对变量a操作的时候，线程T2不能对变量a有任何操作，即T2必须等到T1的所有操作结束之后才能对变量a操作</u>。</p>
<p><strong>JMM保证对除long和double外的基础数据类型的读写操作是原子性的</strong>。另外<strong>关键字synchronized也可以提供原子性保证</strong>。synchronized的原子性是通过Java的两个高级的字节码指令 monitorenter 和 monitorexit 来保证的。</p>
<p><strong>可见性：</strong></p>
<p><u>可见性即T1线程对一个变量修改之后，T2线程能够马上看到自己操作的变量值被修改了</u>。</p>
<p>JMM可见性的保证，<strong>一个是通过synchronized，另外一个就是volatile</strong>。volatile强制变量的赋值会同步刷新回主内存，强制变量的读取会从主内存重新加载，保证不同的线程总是能够看到该变量的最新值。</p>
<p><strong>有序性：</strong></p>
<p><u>有序性即要保证不出现指令重排</u>(JVM优化的时候会有指令重排的情况)。举个例子，T2需要变量flag为true才能执行，而flag只有在T1中才会被置为true。这里如果发生指令重排，T1还没执行完的时候T2就感知到了flag为true，那么程序执行逻辑就出错了。</p>
<p>对有序性的保证，主要通过 volatile 和一系列 happens-before 原则。volatile 的另一个作用就是阻止指令重排序，这样就可以保证变量读写的有序性。</p>
<p>happens-before 原则包括一系列规则。</p>
<p>编译器、指令器可以为了优化性能而对代码重排序，乱排，但是要遵守这些happens-before原则，只要符合happens-before的原则，那么就不能胡乱重排，如果不符合这些规则的话，那就可以自己排序。一些happens-before原则为：</p>
<ol>
<li><p><strong>程序顺序原则</strong>，即一个线程内必须保证<strong>语义串行性</strong>。通俗来说，就是一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作。</p>
</li>
<li><p><strong>锁规则</strong>，即对同一个锁的解锁一定发生在再次加锁之前。通俗来说，就是<strong>一个unLock操作先行发生于后面对同一个锁的lock操作</strong>。比如说在代码里；先有lock.unlock()，再有lock.lock()，那么这个前unlock()后lock.lock()的顺序不能重排。</p>
</li>
<li><p><strong>volatile变量规则</strong>：即对一个volatile变量的写操作要在读操作前面。即对<strong>这个volatile变量必须保证先写，再读</strong>。</p>
</li>
<li><p><strong>传递规则</strong>：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C。</p>
</li>
<li><p><strong>线程启动规则</strong>：Thread对象的start()方法先行发生于此线程的每个一个动作，thread.start()，thread.interrupt()。</p>
</li>
<li><p><strong>线程中断规则</strong>：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生。</p>
</li>
<li><p><strong>线程终结规则</strong>：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行。</p>
</li>
<li><p><strong>对象终结规则</strong>：一个对象的初始化完成先行发生于他的finalize()方法的开始。</p>
</li>
</ol>
<p>这8条原则是避免说出现乱七八糟扰乱秩序的指令重排，要求是这几个重要的场景下，比如是按照顺序来，但是8条规则之外，可以随意重排指令。</p>
<p>对于有序性的happens-before，面试的时候如果问到，不是要求你把上面8条全部背出来！</p>
<p>你可以说个大概，happens-before规则制定了在一些特殊情况下，不允许编译器、指令器对你写的代码进行指令重排，必须保证你的代码的有序性，但是如果没满足上面的规则，那么就可能会出现指令重排，就这个意思。</p>
<h3 id="3-哪些情况下类会进行初始化？"><a href="#3-哪些情况下类会进行初始化？" class="headerlink" title="3.哪些情况下类会进行初始化？"></a>3.哪些情况下类会进行初始化？</h3><p>主要有<strong>六种</strong>情况下类会进行初始化：</p>
<ol>
<li>创建类的实例</li>
<li>访问某个类或接口的静态变量，或对该静态变量赋值。</li>
<li>调用类的静态方法。</li>
<li>初始化一个类的子类时（初始化子类，父类必须先初始化）。</li>
<li>JVM启动时被标为启动类的类。</li>
<li>使用反射进行方法调用时会生成该类，比如class.forName(“类名”)。</li>
</ol>
<h3 id="4-类加载过程是怎样的？JVM是如何运行起来的？我们的对象是如何分配的？"><a href="#4-类加载过程是怎样的？JVM是如何运行起来的？我们的对象是如何分配的？" class="headerlink" title="4.类加载过程是怎样的？JVM是如何运行起来的？我们的对象是如何分配的？"></a>4.类加载过程是怎样的？JVM是如何运行起来的？我们的对象是如何分配的？</h3><p>类的加载指将编译好的 Class 类文件中的字节码读入内存中，将其放在方法区内并创建对应的 Class 对象。类的加载分为<strong>加载、链接、初始化</strong>，如下图：</p>
<p><img src="https://i.loli.net/2020/04/10/uiE7nAk2wGSxVhm.png" alt="类的加载和卸载01.png"></p>
<p>其中链接又包括<strong>验证、准备、解析</strong>三步。展开之后如下图所示。</p>
<p><img src="https://i.loli.net/2020/04/10/faSQnUpKlIh2vWw.png" alt="类的加载和卸载02.png"></p>
<p>整个加载过程描述如下：</p>
<ol>
<li>首先进行<strong>加载</strong>操作，首先查找到这个类的字节码文件，然后使用这个字节码文件创建一个<strong>class对象</strong>，这样就实现了从文件到内存的过程。</li>
<li><strong>验证</strong>是对<strong>类文件内容</strong>的验证。主要是为了虚拟机自身安全考虑，保证当前class文件符合要求。验证主要包括四种：文件格式、元数据、字节码、符号引用的验证。</li>
<li><strong>准备阶段</strong>是进行<strong>内存分配</strong>。为类中用<strong>static修饰的变量分配</strong>内存并设置初始值。需要注意这里只会赋值0或者null，程序中指定赋的初始值是在初始化阶段赋值的，不是在这一阶段赋值的。此外，这里也不包含用final修饰的静态变量，因为<strong>final的变量会在编译的时候分配</strong>。</li>
<li><strong>解析</strong>主要是解析<strong>字段、接口、方法</strong>。主要是将常量池中的<u>符号引用</u>替换为<u>直接引用</u>的过程。（啥是直接引用？就是直接指向目标的指针、相对偏移量等）</li>
<li><strong>初始化</strong>，主要完成静态代码块执行与静态变量的赋值(注意，用static修饰的变量在这一步才进行赋值)。这是类加载的最后阶段，若被加载的类的父类没有初始化，则先对父类进行初始化。——注意，只有对类主动使用时才会进行初始化。初始化的触发条件包括在创建类的实例时、访问类的静态方法或者静态变量时、Class.forName() 反射类时、或者某个子类被初始化时。</li>
</ol>
<p>需要注意一点，<font color=#FF0000>由Java虚拟机自带的三种类加载器(BootStrap启动类加载器、ExtClassLoader扩展类加载器、AppClassLoader应用加载器(也称系统加载器))加载的类在虚拟机的整个生命周期中是不会被卸载的，只有用户自定义的类加载器所加载的类才可以被卸载</font>。</p>
<p>实际上我们平时写的代码一定会有很多线程去执行，比如程序有一个类里面包含了一个main方法，你去执行这个main方法，此时会启动一个jvm进程，程序会默认有一个main线程，这个main线程就负责执行这个main方法的代码，进而创建各种对象，然后执行业务逻辑等等。</p>
<p>对于服务器也是类似。比如基于JDK的Tomcat，类会加载到JVM中；Spring 容器会把所有管理的类实例化成Bean，然后有线程使用Bean，等等。</p>
<p><strong>栈里面放局部变量</strong>，先入后出，每次有新的对象被访问时都会新定义一个栈帧然后入栈、<strong>堆中放的是对象和对象和实例</strong>。方法执行完毕后，会把栈里面的栈帧弹出，并且对堆进行垃圾回收。</p>
<h3 id="5-Java类加载器有几种？关系是怎样的？"><a href="#5-Java类加载器有几种？关系是怎样的？" class="headerlink" title="5.Java类加载器有几种？关系是怎样的？"></a>5.Java类加载器有几种？关系是怎样的？</h3><p>上面标红的内容已经提到了， 类加载器一共有四种，其中<strong>三种是JVM自带的</strong>：</p>
<ul>
<li>BootStrap启动类加载器</li>
<li>ExtClassLoader扩展类加载器</li>
<li>AppClassLoader应用加载器(也称系统加载器)</li>
</ul>
<p>还有一种是使用者可以自定义的类加载器：Custom ClassLoader(自定义类加载器)。</p>
<p>这四种类加载器有上下层级关系，而且JVM自带的类加载器有默认的加载目录。如下图所示：</p>
<p><img src="https://i.loli.net/2020/04/10/zVTRHPiSYKGM56g.png" alt="类加载器_双亲委派机制.png"></p>
<p>启动类加载器会加载<code>JAVA_HOME</code>中lib目录下的类，扩展加载器会负责加载ext目录下的类。而应用加载起会加载classpath指定目录下的类，自定义加载器是最下层的子类加载器，即Custom ClassLoader。</p>
<h3 id="6-双亲委派机制的加载流程是怎样的，有什么好处？"><a href="#6-双亲委派机制的加载流程是怎样的，有什么好处？" class="headerlink" title="6.双亲委派机制的加载流程是怎样的，有什么好处？"></a>6.双亲委派机制的加载流程是怎样的，有什么好处？</h3><p>双亲委派的加载流程就如下图所示(再展现一次)：</p>
<p><img src="https://i.loli.net/2020/04/10/zVTRHPiSYKGM56g.png" alt="类加载器_双亲委派机制.png"></p>
<p>这四个类加载器详解：</p>
<ul>
<li>BootStrap ClassLoader：<strong>引导类加载器</strong>。最顶层的类加载器，负责加载JDK中的核心类库，比如rt.jar, resources.jar, charsets.jar等。其位置都在”JAVA_HOME/jre/lib”下</li>
<li>ExtClassLoader：<strong>扩展类加载器</strong>。主要负责加载Java的扩展类库，默认加载”JAVA_HOME/jre/lib/ext/“目录下的所有jar包或者由java.ext.dirs系统属性指定的jar包。放入这个目录下的jar包对AppClassLoader加载器都是可见的。(因为ExtClassLoader是AppClassLoader的父加载器，并且Java类的类加载器采用双亲委派机制)。</li>
<li>AppClassLoader：<strong>应用类加载器</strong>，又称为系统类加载器。负责在JVM启动时，加载来自命令中的classpath或者java.class.path系统属性或者CLASSPATH操作系统属性所指定的jar类包和类路径。</li>
</ul>
<p>其中在上面的是父类加载器，在下面的是子类加载器。Java在整个类加载过程都是通过双亲委派机制来实现的，即<strong>一个类加载器在加载类时，先把这个请求委托给自己的父类加载器去执行，如果父类加载器还存在父类加载器，就继续向上委托，直到顶层的启动类加载器，如上图中黑色向上的箭头。如果父类加载器能够完成类加载，就成功返回；如果父类加载器无法完成加载，则子类加载器才会尝试自己去加载</strong>，即图中的蓝色向下的箭头。</p>
<p>双亲委派机制的好处主要是<strong>两个</strong>：</p>
<ol>
<li>避免类的重复加载，节省资源</li>
<li>避免了Java核心API被篡改，因为一个类只会被加载一次。如果用户重写了Object类，那么不能用用户写的。</li>
</ol>
<p>一个经常被补充问到的问题：<font color=#FF0000>如何保证双亲委派的类是同一个？</font></p>
<p>方法是根据<strong>全类名</strong>和<strong>类加载器</strong>是否都一样来判断。</p>
<h3 id="7-双亲委派机制被破坏的情况"><a href="#7-双亲委派机制被破坏的情况" class="headerlink" title="7.双亲委派机制被破坏的情况"></a>7.双亲委派机制被破坏的情况</h3><p>实际上，双亲委派这种加载流程只是Java设计者推荐给开发者的类加载器的实现方式。虽然Java世界中大部分类加载器都遵循这个规则，但当然有而且允许有例外，这就是破坏了双亲委派的机制了。</p>
<p>简单来说，双亲委派一般有两种破坏方法：</p>
<ol>
<li>自定义类加载器，重写loadClass方法；</li>
<li>使用线程上下文类加载器；</li>
</ol>
<p>JDK在历史上对双亲委派机制有三次破坏：</p>
<ol>
<li><strong>第一次破坏</strong></li>
</ol>
<p>由于双亲委派模型是在JDK1.2之后才被引入的，而类加载器和抽象类java.lang.ClassLoader则在JDK1.0时代就已经存在，面对已经存在的用户自定义类加载器的实现代码，Java设计者引入双亲委派模型时不得不做出一些妥协。在此之前，用户去继承java.lang.ClassLoader的唯一目的就是为了<strong>重写loadClass()</strong>方法，因为虚拟机在进行类加载的时候会调用加载器的私有方法loadClassInternal()，而这个方法唯一逻辑就是去调用自己的loadClass()。</p>
<ol start="2">
<li><strong>第二次破坏</strong></li>
</ol>
<p>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷所导致的，双亲委派很好地解决了各个类加载器的基础类的同一问题（越基础的类由越上层的加载器进行加载），基础类之所以称为“基础”，是因为它们总是作为被用户代码调用的API，但世事往往没有绝对的完美。</p>
<p>如果<strong>基础类又要调用回用户的代码</strong>，那该么办？</p>
<p>一个典型的例子就是<strong>JNDI服务</strong>，JNDI现在已经是Java的标准服务，<br>它的代码由启动类加载器去加载（在JDK1.3时放进去的rt.jar），但JNDI的目的就是对资源进行集中管理和查找，它需要调用由独立厂商实现并部署在应用程序的ClassPath下的JNDI接口提供者的代码，但启动类加载器不可能“认识”这些代码。</p>
<p>为了解决这个问题，Java设计团队只好引入了一个不太优雅的设计：<strong>线程上下文类加载器(Thread Context ClassLoader)</strong>。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，他将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</p>
<p>有了线程上下文加载器，JNDI服务就可以使用它去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则，但这也是无可奈何的事情。Java中所有涉及SPI的加载动作基本上都采用这种方式，例如JNDI、JDBC、JCE、JAXB和JBI等。</p>
<ol start="3">
<li><strong>第三次破坏</strong></li>
</ol>
<p>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求导致的，这里所说的“动态性”指的是当前一些非常“热门”的名词：代码热替换、模块热部署等，简答的说就是机器不用重启，只要部署上就能用。</p>
<p><strong>OSGi实现模块化热部署的关键则是它自定义的类加载器机制的实现</strong>。每一个程序模块(Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。在OSGi幻境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构，当受到类加载请求时，OSGi将按照下面的顺序进行类搜索：</p>
<p>1）将java.＊开头的类委派给父类加载器加载。</p>
<p>2）否则，将委派列表名单内的类委派给父类加载器加载。</p>
<p>3）否则，将Import列表中的类委派给Export这个类的Bundle的类加载器加载。</p>
<p>4）否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。</p>
<p>5）否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。</p>
<p>6）否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。</p>
<p>7）否则，类加载器失败。</p>
<p>实际上，双亲委派机制”被破坏”并不是贬义词，只要有足够的意义和理由，其实突破原有的双亲委派机制也是一种创新。比如OSGi对类加载器的使用时很值得学习的。弄懂了OSGi的实现，就可以算是掌握了类加载器的精髓。</p>
<h3 id="8-JDK8之后对内存分代做了什么改进？为什么用Metaspace替换掉PermGen-Metaspace保存在哪里？"><a href="#8-JDK8之后对内存分代做了什么改进？为什么用Metaspace替换掉PermGen-Metaspace保存在哪里？" class="headerlink" title="8.JDK8之后对内存分代做了什么改进？为什么用Metaspace替换掉PermGen?Metaspace保存在哪里？"></a>8.JDK8之后对内存分代做了什么改进？为什么用Metaspace替换掉PermGen?Metaspace保存在哪里？</h3><p>JDK8之前，永久代里放了一些<strong>常量池+类信息</strong>。java 8以后进行了<strong>内存分代</strong>的改进，变成了：<strong>常量池放到堆里面，类信息放到了 metaspace（元区域）</strong>。</p>
<p>实际上，JDK1.8版本中对方法区进行了调整，使用Metaspace替换掉了PermGen的永久代。<strong>Metaspace与PermGen之间最大的区别在于</strong>：<font color=#FF0000>Metaspace并不在虚拟机中，而是使用本地内存</font>。替换的目的主要有两个：</p>
<ol>
<li>可以提升对元数据的管理同时提升GC效率</li>
<li>方便后序HotSpot与JRockit合并。</li>
</ol>
<h3 id="9-编译器会对指令做哪些优化？-简单描述编译器的指令重排"><a href="#9-编译器会对指令做哪些优化？-简单描述编译器的指令重排" class="headerlink" title="9.编译器会对指令做哪些优化？(简单描述编译器的指令重排)"></a>9.编译器会对指令做哪些优化？(简单描述编译器的指令重排)</h3><p>为了性能考虑，编译器和CPU可能会在执行过程中对指令重新排序。</p>
<p>简而言之，就是程序在CPU执行的时候会细分为不同的指令，这些指令互相之间可能有依存关系，即某个操作需要等待另一个变量的计算结果，如果都是类似串行的执行，那么CPU的多核用不上，浪费了。我们可以通过指令重排让计算结果不相关的指令交替执行，这样哪怕是有的语句要等待别的语句的计算结果，也可以让整体执行效率比较高。</p>
<p>当然，这样的重排在多线程的时候有出错风险，所以有类似volatile的指令来禁止或者限制指令重排。</p>
<p>具体细节<a href="https://www.cnblogs.com/xdecode/p/8948277.html" target="_blank" rel="noopener">可以参考这篇文章</a></p>
<h3 id="10-对象引用有哪几种方式，有什么特点？"><a href="#10-对象引用有哪几种方式，有什么特点？" class="headerlink" title="10.对象引用有哪几种方式，有什么特点？"></a>10.对象引用有哪几种方式，有什么特点？</h3><p>重点介绍Java的四种引用：<strong>强、弱、软、虚</strong>，以及<strong>在GC中的处理方式</strong>。</p>
<h4 id="强引用-Strong-Reference"><a href="#强引用-Strong-Reference" class="headerlink" title="强引用(Strong Reference)"></a>强引用(Strong Reference)</h4><ul>
<li>最普遍的引用：Object obj = new Object()，这里obj就是强引用</li>
<li>抛出OutOfMemoryError终止程序也不会回收具有强引用的对象</li>
<li>通过将对象设置为null来弱化引用，使其被回收</li>
</ul>
<h4 id="弱引用-Weak-Reference"><a href="#弱引用-Weak-Reference" class="headerlink" title="弱引用(Weak Reference)"></a>弱引用(Weak Reference)</h4><ul>
<li>非必须的对象，比软引用更弱一些</li>
<li>生命周期更短，在GC时会被回收——无论当前内存是否紧缺，GC都会回收被弱引用关联的对象</li>
<li>被回收的概率也不大，因为GC线程优先级比较低</li>
<li>弱引用适用于偶尔使用且不影响垃圾收集的对象</li>
</ul>
<p>弱引用案例：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3qyBqI.png" alt="弱引用例子"></p>
<p>弱引用同样可以配合引用队列去使用。</p>
<h4 id="软引用-Soft-Reference"><a href="#软引用-Soft-Reference" class="headerlink" title="软引用(Soft Reference)"></a>软引用(Soft Reference)</h4><ul>
<li>对象处在有用但非必须的状态</li>
<li>只有当内存空间不足时，GC会回收该引用的对象的内存</li>
<li>可以用来实现高速缓存——这样我们就可以避免OutOfMemory的问题。因为软引用的内存会在内存不足的情况下回收。</li>
</ul>
<p>强引用和软引用例子如下图：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3qsJ3Q.png" alt="强引用和软引用例子"></p>
<h4 id="虚引用-Phantom-Reference"><a href="#虚引用-Phantom-Reference" class="headerlink" title="虚引用(Phantom Reference)"></a>虚引用(Phantom Reference)</h4><p>“虚无缥缈”，其生命周期比较不固定</p>
<ul>
<li>不会决定对象的生命周期</li>
<li>任何时候都可能被垃圾收集器回收</li>
<li>跟踪对象被垃圾收集器回收的活动，起哨兵作用</li>
<li>比较特殊，必须和引用队列ReferenceQueue联合使用</li>
</ul>
<p><img src="https://s2.ax1x.com/2020/03/06/3q63lQ.png" alt="虚引用例子"></p>
<p>GC在回收一个对象时，若发现这个对象有虚引用，那么回收前会先将这个引用加入到与之关联的引用队列当中。</p>
<h4 id="四种引用之间的关系"><a href="#四种引用之间的关系" class="headerlink" title="四种引用之间的关系"></a>四种引用之间的关系</h4><p><img src="https://s2.ax1x.com/2020/03/06/3q64pD.png" alt="四种引用之间的关系"></p>
<h4 id="引用类结构层次"><a href="#引用类结构层次" class="headerlink" title="引用类结构层次"></a>引用类结构层次</h4><p><img src="https://s2.ax1x.com/2020/03/06/3qcmjJ.png" alt="引用类结构层次"></p>
<h4 id="引用队列-ReferenceQueue"><a href="#引用队列-ReferenceQueue" class="headerlink" title="引用队列(ReferenceQueue)"></a>引用队列(ReferenceQueue)</h4><p>引用队列名义上是一个队列，但其内部没有实际存储结构。</p>
<ul>
<li>无实际存储结构，存储逻辑依赖于内部节点之间的关系来表达的——类似链表，节点是Reference本身，它自己只存储链表的头结点，而后面的节点都通过Reference指向下一个的next来保持。</li>
<li>存储关联的且被GC的软引用，弱引用以及虚引用</li>
</ul>
<h3 id="11-使用过哪些JVM调优工具，主要分析哪些内容？举一个JVM抗住并发的实例？"><a href="#11-使用过哪些JVM调优工具，主要分析哪些内容？举一个JVM抗住并发的实例？" class="headerlink" title="11.使用过哪些JVM调优工具，主要分析哪些内容？举一个JVM抗住并发的实例？"></a>11.使用过哪些JVM调优工具，主要分析哪些内容？举一个JVM抗住并发的实例？</h3><h4 id="一个JVM调优实例"><a href="#一个JVM调优实例" class="headerlink" title="一个JVM调优实例"></a>一个JVM调优实例</h4><p>如果我们要设置Spring Boot和Tomcat部署的系统的JVM参数，比较方便：Spring Boot其实就是启动的时候可以加上JVM参数，Tomcat就是在bin目录下的catalina.sh中可以加入JVM参数。</p>
<p>实际上，如果只是普通的系统，比如普通的电商系统，每日上亿请求量，按照每个用户平均每日访问20次来算，那么上亿的请求量大概需要500万日活用户。而按照10%的交易转换率来算，差不多每天只有50万用户下单，就算这50万单集中在高峰期的四个小时，平均下来每秒也就几十个订单。几十个订单的压力下，根本不需要对JVM过多关注，基本就是每秒占用一些新生代内存，隔很久新生代才会满，然后用Minor GC之后内存又空了，没啥压力。</p>
<p>但是很需要考虑的就是一些特殊的比如电商大促的场景，双11场景，就很不同了。大家都在凌晨时分等待剁手，可能在短短10分钟内，就有50万订单，折算下来每秒1000下单请求！</p>
<p><strong>这样大的并发，如何能抗住呢？需要几台机器呢？</strong>我们可以用内存模型分析，如果我们把这每秒1000的请求用三台机器去抗，那么每台机器每秒抗300并发量即可。假设订单部署在的系统是最普通的标配4核8G的机器上，那么理论上，可以抗住，但是需要对JVM有限的内存资源进行合理的分配和优化，包括对垃圾回收进行合理的优化，让JVM的GC次数尽可能最少，而且尽量避免Full GC，这样可以尽可能减少JVM的GC对高峰期的系统更新的影响。</p>
<p>具体来说，可以按照每秒300个下单量来估算(这样的值和生产其实也比较接近了)，因为下单操作涉及很多接口调用，基本上每秒处理100<del>300个下单请求差不多。我们每个订单按照1kb来估算，300个订单会有300kb内存开销，然后算上订单对象连带的订单条目对象、库存、促销、优惠券等等一系列的其他业务对象，一般需要对单个对象开销放大10倍</del>20倍。</p>
<p>此外，除了下单之外，这个订单系统还会有很多订单相关的其他操作，比如订单查询之类的，所以连带算起来，可以往大了估算，再扩大10倍的量。</p>
<p>那么每秒钟会有大概300kb * 20 * 10 = 60mb的内存开销。但是一秒过后，可以认为这60mb的对象就是垃圾了，因为300个订单处理完了，所有相关对象都失去了引用，可以回收的状态。当然，这60mb的对象都会保存在新生代区域。</p>
<p><strong>那么内存应该如何分配呢？</strong></p>
<p>假设我们有4核8G的机器，那么给JVM的内存一般会到4G，剩下几个G会留点空余给操作系统之类的来使用，不要想着把机器内存一下子都耗尽，其中堆内存我们可以给3G，新生代我们可以给到1.5G，老年代也是1.5G。然后每个线程的Java虚拟机栈有1M，那么JVM里如果有几百个线程大概会有几百M，然后再给永久代256M内存，基本上这4G内存就差不多了。</p>
<p>在JDK1.6之后，“-XX:HandlePromotionFailure”参数就被废弃了，所以现在一般都不会在生产环境里设置这个参数了。在JDK 1.6以后，只要判断“<strong>老年代可用空间”&gt; “新生代对象总和</strong>”，或者“<strong>老年代可用空间”&gt; “历次Minor GC升入老年代对象的平均大小</strong>”，两个条件满足一个，就可以直接提前进行Minor GC，不需要提前触发Full GC了。</p>
<blockquote>
<p>注：<code>XX:HandlePromotionFailure</code>用于空间分配担保。在发生Minor GC（Yong GC）之前，JVM会计算Survivor区移至老年区的对象的平均大小，虚拟机会检查老年代<strong>最大可用的连续空间</strong>是否大于需要转移的对象大小。<br>      如果大于，则此次Minor GC（Yong GC）是安全的。<br>      如果小于，<em>jdk1.6之前：则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。</em><br>         <em>如果大于，则尝试进行一次Minor GC（Yong GC），但这次Minor GC（Yong GC）依然是有风险的，失败后会重新发起一次Major GC（Full GC）；<br>         如果小于或者HandlePromotionFailure=false，则改为直接进行一次Major GC（Full GC）。</em></p>
</blockquote>
<blockquote>
<p>但是在jdk1.6 update 24之后-XX:-HandlePromotionFailure 不起作用了，只要老年代的连续空间大于新生代对象的总大小或者历次晋升到老年代的对象的平均大小就进行MonitorGC，否则FullGC</p>
</blockquote>
<p>但是这里会存在一个问题，就是每秒处理300个订单，都会占据新生代60MB的内存空间。但是1秒过后这60MB对象都变成了垃圾，那么新生代1.5GB的内存空间大概需要25秒就会被占满，然后进行回收，第一次肯定能正常Minor GC，然后一下子回收掉了99%的新生代对象，因为大部分订单都处理完了，除了最近一秒的订单请求还在处理，这个剩余的订单大小可能就100MB左右。</p>
<p>但是这里问题来了，如果“-XX:SurvivorRatio”参数默认值为8(此参数为Eden区和S1与S2区的比，默认为8)，那么此时新生代里Eden区大概占据了1.2GB内存，每个Survivor区是150MB的内存。即Eden满了1.2GB就要进行Minor GC，因此大概只需要20秒，就会把Eden区塞满，然后就必须进行Minor GC了。</p>
<p>就像上面所说，GC后只剩上一秒的订单，大小就100MB左右。这100MB会放入到S1区中。然后再运行20秒，Eden又满了，再次垃圾回收Eden和S1中的对象，这次可能存活的对象还是100MB左右，这些对象会进入S2区。</p>
<p>此时JVM的参数会大致如下：</p>
<p><code>-Xms3072M -Xmx3072M -Xmn1536M -Xss1M -XX:PermSize=256M -XX:MaxPermSize=256M -XX:SurvivorRatio=8</code></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">参数解释：常见参数种类（配置内存）</span><br><span class="line">配置堆区：-Xms 、-Xmx、-XX:newSize、-XX:MaxnewSize、-Xmn</span><br><span class="line">配置非堆区：-XX:PermSize、-XX:MaxPermSize</span><br><span class="line"></span><br><span class="line">堆区参数配置</span><br><span class="line"><span class="number">1</span>、-Xms ：表示java虚拟机堆区内存初始内存分配的大小，通常为操作系统可用内存的<span class="number">1</span>/<span class="number">64</span>大小即可，但仍需按照实际情况进行分配。有可能真的按照这样的一个规则分配时，设计出的软件还没有能够运行得起来就挂了。</span><br><span class="line"><span class="number">2</span>、-Xmx： 表示java虚拟机堆区内存可被分配的最大上限，通常为操作系统可用内存的<span class="number">1</span>/<span class="number">4</span>大小。但是开发过程中，通常会将 -Xms 与 -Xmx两个参数的配置相同的值，其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小而浪费资源。</span><br><span class="line">    一般来讲对于堆区的内存分配只需要对上述两个参数进行合理配置即可。</span><br><span class="line">    </span><br><span class="line">非堆区参数配置</span><br><span class="line"><span class="number">1</span>、-XX:PermSize：表示非堆区初始内存分配大小，其缩写为permanent size（持久化内存）</span><br><span class="line"><span class="number">2</span>、-XX:MaxPermSize：表示对非堆区分配的内存的最大上限</span><br></pre></td></tr></table></figure>

<p><strong>优化的时候到了</strong>。</p>
<p><strong>首先，新生代垃圾回收器需要优化。我们的Survivor(S区)区空间够不够用</strong>？</p>
<p>按照上述逻辑，首先每次新生代垃圾回收在100MB左右，有可能会突破150MB，那么岂不是经常会出现Minor GC过后的对象无法放入Survivor中？然后岂不是频繁会让对象进入老年代？(年轻代垃圾回收器放不下时就会放入老年代)</p>
<p>所以按照上面的参数设置，S区明显不够用。</p>
<p>所以这里的建议是：<font color=#FF0000>调整新生代和老年代的大小</font>，因为这种普通业务系统，明显大部分对象都是短生存周期的，根本不应该频繁进入老年代，也没必要给老年代维持过大的内存空间，首先得先让对象尽量留在新生代里。</p>
<p>具体做法是增加新生代的容量，从1.25GB增加到1.5GB，这样Eden为1.6GB，每个Survivor为200MB。</p>
<p>此时，S区域变大，大大降低了新生代GC过后存活对象在S里放不下的问题，或者是同龄对象超过S区 50%的问题，从而大大降低新生代对象进入老年代的概率。</p>
<p>此时JVM的参数如下：</p>
<p><code>-Xms3072M -Xmx3072M -Xmn2048M -Xss1M -XX:PermSize=256M -XX:MaxPermSize=256M -XX:SurvivorRatio=8</code></p>
<p>其实对任何系统，首先类似上文的内存使用模型预估以及合理的分配内存，<strong>尽量让每次Minor GC后的对象都留在Survivor里，不要进入老年代，这是你首先要进行优化的一个地方</strong>。</p>
<p><strong>其次，设置参数，新生对象经过多少次垃圾回收后进入老年代</strong>？</p>
<p>默认是15，即一个对象经过15次Minor GC后还在S区，就将其转移到老年代。但是这里实际上可以考虑把15调小，比如调到5。</p>
<p>为什么呢？<strong>这个必须结合系统的运行模型来说</strong>。来说，如果躲过15次GC都几分钟了，一个对象几分钟都不能被回收，说明肯定是系统里类似用@Service、@Controller之类的注解标注的那种需要长期存活的核心业务逻辑组件。</p>
<p>所以我们这里应该减小<code>-XX:MaxTenuringThreshold</code>的参数值，让对象尽快离开新生代S区。</p>
<p>比如调小到5，则此时JVM参数为：</p>
<p><code>-Xms3072M -Xmx3072M -Xmn2048M -Xss1M -XX:PermSize=256M -XX:MaxPermSize=256M -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=5</code></p>
<p><strong>接下来，可以设置多大的对象可以进入老年代</strong>。</p>
<p>一般来说，设置1MB够用了，因为一般很少有超过1MB的大对象。如果有，可能是你提前分配了一个大数组、大List之类的东西来存放缓存的数据。</p>
<p>设置之后的参数为：</p>
<p><code>-Xms3072M -Xmx3072M -Xmn2048M -Xss1M -XX:PermSize=256M -XX:MaxPermSize=256M -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=5 XX:PretenureSizeThreshold=1M</code></p>
<p><strong>最后，如果不用G1这种比较新的垃圾收集器，我们需要设置新生代和老年代的垃圾回收器</strong>。如下：</p>
<p><code>-Xms3072M -Xmx3072M -Xmn2048M -Xss1M -XX:PermSize=256M -XX:MaxPermSize=256M -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=5 XX:PretenureSizeThreshold=1M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC</code></p>
<p>ParNew垃圾回收器的核心参数，其实就是配套的新生代内存大小、Eden和Survivor的比例，只要你设置合理，避免Minor GC后对象放不下Survivor进入老年代，或者是动态年龄判定之后进入老年代，给新生代里的Survivor充足的空间，那么Minor GC一般就没什么问题。</p>
<h4 id="JVM调优工具"><a href="#JVM调优工具" class="headerlink" title="JVM调优工具"></a>JVM调优工具</h4><p>有关JVM调优工具可以参考这篇博客：<a href="https://www.cnblogs.com/ityouknow/p/6437037.html" target="_blank" rel="noopener">jvm系列(七)：jvm调优-工具篇</a></p>
<p>可以了解一下 Java 自带的几种工具的功能，例如 JMC 中的飞行记录器，堆分析工具 MAT，线程分析工具 jstack 和获取堆信息的 jmap 等。</p>
<h3 id="12-什么是垃圾回收的stop-the-world和-Safepoint"><a href="#12-什么是垃圾回收的stop-the-world和-Safepoint" class="headerlink" title="12.什么是垃圾回收的stop the world和 Safepoint?"></a>12.什么是垃圾回收的stop the world和 Safepoint?</h3><h4 id="Stop-the-World"><a href="#Stop-the-World" class="headerlink" title="Stop-the-World"></a>Stop-the-World</h4><ul>
<li>JVM由于要执行GC而停止了应用程序的执行</li>
<li>会在任何一种GC算法中发生</li>
<li>多数GC优化通过减少Stop-the-World发生的时间来提高程序性能，从而让系统有高吞吐，低停顿的特点</li>
</ul>
<p>如果执行的垃圾回收比较慢，比如要回收100mb，那么可能stop the world需要100ms，这段期间不能处理任何请求，要尽可能地让垃圾回收和工作线程的运行并发执行。</p>
<h4 id="Safepoint"><a href="#Safepoint" class="headerlink" title="Safepoint"></a>Safepoint</h4><p>JVM垃圾回收就好比是保洁阿姨在打扫卫生，如果一边打扫一遍有人扔垃圾，那很难能打扫完。怎么办呢？可以在开始打扫之前和所有人说好:”我要开始打扫了！你们不准扔垃圾了！”，这样就可以了。</p>
<p><strong>安全点，即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停</strong>。所以SafePoint的选定不能太长以至于让GC等待时间太长，也不能过于频繁导致过分增大运行时的负荷。由于JVM系统运行期间的复杂性，不可能做到随时暂停，因此引入了安全点的概念。</p>
<p>安全点的初始目的并不是让其他线程停下，而是找到一个稳定的执行状态。在这个执行状态下，Java虚拟机的堆栈不会发生变化。这么一来，垃圾回收器便能够“安全”地执行可达性分析。只要不离开这个安全点，Java虚拟机便能够在垃圾回收的同时，继续运行这段本地代码。</p>
<ul>
<li>分析过程中对象引用关系不会发生变化的点——这是程序运行过程中的一个特殊点的，在这个点所有线程都被冻结了，不能出现分析过程中对象引用关系还在不断变化的情况。类似函数的可导，我们分析的结果需要在某个节点具备确定性，这个节点就叫做安全点。</li>
<li>产生Safepoint的地方一般是：方法调用；循环跳转；异常跳转等</li>
<li>安全点数量得适中——安全点选择不能太多也不能太少</li>
</ul>
<p>两种安全点的解决方案：</p>
<ul>
<li>抢先式中断(Preemptive Suspension)</li>
</ul>
<p>抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机采用这种方式来暂停线程从而响应GC事件。</p>
<ul>
<li>主动式中断(Voluntary Suspension)</li>
</ul>
<p>主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。</p>
<h3 id="13-简单描述一下GC的分代回收"><a href="#13-简单描述一下GC的分代回收" class="headerlink" title="13.简单描述一下GC的分代回收"></a>13.简单描述一下GC的分代回收</h3><p>首先我们可以比较容易地理解为什么需要GC。我们的资源不可能是无限的，而且资源很多时候也是昂贵的，2核4G的机器，堆内存也就2GB左右，4核8G的机器，堆内存可能也就4G左右，栈内存也需要空间，metaspace区域放类信息也需要空间。所以，在jvm里必然是有一个内存分代模型，年轻代和老年代，年轻代中是经常要被清理的，而常用的放到老年代，清理的频次更低一些。</p>
<p>实际上，Java堆中可以分为年轻代(新生代)和老年代，如下图所示：</p>
<p><img src="https://s2.ax1x.com/2020/03/05/3TNefK.png" alt="GC堆"></p>
<p>比如内存一共是4G，可以给年轻代一共2GB内存，给老年代是2GB内存。对于年轻代，默认情况下Eden和2个s区(s1和s2区)的比例：8:1:1，即此时Eden是1.6GB，S是0.2GB。</p>
<p>如果说eden区域满了，此时必然触发垃圾回收，young gc，ygc，如何判断某个对象是否是可回收的对象呢？——没有其他对象引用的对象就是垃圾对象。有关如何定义没有被其他对象引用，可以有两种标记算法：引用计数算法和可达性分析算法。下面介绍。</p>
<p>需要注意，<strong>年轻代有两种对象不能回收</strong>：</p>
<ol>
<li>一个方法正在执行，这个正在执行的方法中的<strong>局部变量</strong>引用了某个对象，那被引用的这个对象不能被回收。</li>
<li>一个类是存活着的，这个类里面的<strong>静态变量</strong>引用了某个对象，那这个对象也不能回收。</li>
</ol>
<p>除此之外，所有没被引用的对象，都可以是GC的目标对象。</p>
<p>Java的堆内存被分类管理的，这主要是为了方便垃圾回收，<font color=#FF0000>分代管理这样的做法基于两个原因</font>：</p>
<ol>
<li>大部分对象很快就不再被系统需要和使用</li>
<li>有一部分对象不会立即无用，但也不会持续很长时间</li>
</ol>
<h3 id="14-介绍一下常用的两种对象标记算法？"><a href="#14-介绍一下常用的两种对象标记算法？" class="headerlink" title="14.介绍一下常用的两种对象标记算法？"></a>14.介绍一下常用的两种对象标记算法？</h3><h4 id="怎样的对象会被判定为垃圾？"><a href="#怎样的对象会被判定为垃圾？" class="headerlink" title="怎样的对象会被判定为垃圾？"></a>怎样的对象会被判定为垃圾？</h4><ul>
<li>没有被其他对象引用</li>
</ul>
<p>此时这个对象占据的内存会被释放，此对象也会被销毁。</p>
<h4 id="用什么方法判定对象不被引用了呢？"><a href="#用什么方法判定对象不被引用了呢？" class="headerlink" title="用什么方法判定对象不被引用了呢？"></a>用什么方法判定对象不被引用了呢？</h4><ul>
<li>引用计数算法</li>
<li>可达性分析算法</li>
</ul>
<h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p><strong>通过判断对象的引用数量来决定对象是否可以被回收。</strong></p>
<p>具体执行方法：</p>
<ul>
<li>每个对象实例都有一个引用计数器，被引用则+1，完成引用则-1</li>
<li>任何引用计数为0的对象实例可以被当做垃圾收集</li>
</ul>
<p>引用计数算法的优劣：</p>
<ul>
<li>优点：执行效率高，程序执行受影响较小。因为我们只需要过滤掉引用计数为0的对象，然后将其回收即可，可以交织在程序运行中。由于垃圾回收的过程中可以做到几乎不打断程序的执行，所以这种方法适用于程序需要不被长时间打断的实时环境。</li>
<li>缺点：无法检测出循环引用的情况，导致内存泄漏。这个缺点是很致命的，如果存在父对象与子对象互相引用的情况，那么它们的引用计数永远不可能为零，那么永远都不会被检测到为0，永远不会被释放。</li>
</ul>
<p>由于这种比较致命的缺点，主流JDK没有使用引用计数算法进行垃圾判定，而是用了下面的可达性分析算法。</p>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p><strong>通过判断对象的引用链是否可达来决定对象是否可以被回收</strong>。</p>
<p>这种方法从图论中引入。程序把所有的引用关系看作是一张图，通过一系列的名为GC Root的对象作为起始点，从这些节点开始向下搜索，搜索经过的路径会被称为”引用链”，即”reference chain”，当某个对象到其他图中的节点都不能相连的时候，也就是说从这个对象到其他部分的GC Root是不可达的，那么就判定这个对象为垃圾。</p>
<p>如图：</p>
<p><img src="https://s2.ax1x.com/2020/03/05/37rfUg.png" alt="可达性分析算法"></p>
<p>蓝色为存活对象，即可达对象，灰色的部分不可达了，为垃圾对象。</p>
<p>什么对象可以作为GC Root的对象呢？</p>
<ul>
<li>虚拟机栈中引用的对象(栈帧中的本地变量表)。比如在方法中new了一个Object，并赋值给了一个局部变量，那么在该局部变量没有被销毁之前，new出来的对象就会是GC Root。</li>
<li>方法区中的常量引用的对象。比如在类中定义了一个常量，而该常量保存的是某个对象的地址，那么被保存的对象也会成为GC的根对象。</li>
<li>方法区中的类静态属性引用的对象。这个和上面常量的情况如出一辙。</li>
<li>本地方法栈中JNI(Native方法)的引用对象</li>
<li>活跃线程的引用对象</li>
</ul>
<h3 id="15-介绍一下垃圾回收算法？"><a href="#15-介绍一下垃圾回收算法？" class="headerlink" title="15.介绍一下垃圾回收算法？"></a>15.介绍一下垃圾回收算法？</h3><p>判断了哪些对象是垃圾只是第一步，我们还需要解决一个很重要的问题：如何处理这些垃圾？或者说，如果回收这些垃圾？</p>
<p>垃圾回收算法有以下这几种：</p>
<h4 id="标记-清除算法-Mark-and-Sweep"><a href="#标记-清除算法-Mark-and-Sweep" class="headerlink" title="标记-清除算法(Mark and Sweep)"></a>标记-清除算法(Mark and Sweep)</h4><ul>
<li>标记：从根集合进行扫描，对存活的对象进行标记</li>
<li>清除：对堆内存从头到尾进行线性遍历，回收不可达对象内存</li>
</ul>
<p>如图：</p>
<p><img src="https://s2.ax1x.com/2020/03/05/37y678.jpg" alt="标记-清除算法"></p>
<p>如上图所示，经过了Mark阶段到达Sweep阶段的时候，所有不可达的对象都会被当做垃圾回收掉。</p>
<p>但是这种方法会存在一些问题，在标记-清除之后，可能会产生大量不连续的碎片，空间碎片多，可能导致之后开辟大对象空间的时候出现内存不够用的情况。</p>
<h4 id="复制算法-Copying"><a href="#复制算法-Copying" class="headerlink" title="复制算法(Copying)"></a>复制算法(Copying)</h4><p>复制算法将可用的内存按照容量和一定比例划分为两块或多块，并选择其中一块两块作为对象面，其他的作为空闲面。</p>
<ul>
<li>分为对象面和空闲面</li>
<li>对象在对象面上创建 </li>
<li>存活的对象被从对象面复制到空闲面。当被定义为对象面的块的内存用完了，就将还存活着的对象复制到其中一块空闲面上</li>
<li>将对象面所有对象清除</li>
</ul>
<p><font color=#FF0000><strong>这种算法适用于对象存活率低的场景，比如年轻代</strong></font>。这样每次都对内存块进行回收，这样就解决了内存碎片的问题。</p>
<p>推倒重建的过程只需要移动堆顶指针，按顺序分配内容即可。</p>
<p><img src="https://s2.ax1x.com/2020/03/05/37r2b8.png" alt="复制算法"></p>
<p>优势：</p>
<ul>
<li>解决碎片化问题</li>
<li>顺序分配内存，简单高效</li>
<li>适用于对象存活率低的场景(现在很多虚拟机都采用这种方法回收年轻代，因为年轻代每次都只存活10%左右，用复制算法效果不错)</li>
</ul>
<p>但是在老年代不能轻易选用这种算法，因为可能出现存活率特别高的情况。</p>
<h4 id="标记-整理算法-Compacting"><a href="#标记-整理算法-Compacting" class="headerlink" title="标记-整理算法(Compacting)"></a>标记-整理算法(Compacting)</h4><p><font color=#FF0000><strong>这种算法比较适合用于老年代的对象回收</strong></font>。它使用类似”标记-清除”算法的方式进行对象的标记，但是在清除的时候不同。</p>
<ul>
<li>标记：从根集合进行扫描，对存活的对象进行标记</li>
<li>清除：移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收</li>
</ul>
<p>“标记-整理”算法是在”标记-清除”的基础上又进行了对象的移动，因此成本更高，但是能够解决内存碎片的问题。</p>
<p><img src="https://s2.ax1x.com/2020/03/05/37RmRg.png" alt="标记整理算法"></p>
<p>也可以参考这张图：</p>
<p><img src="https://s2.ax1x.com/2020/03/05/37rWVS.png" alt="标记整理算法2"></p>
<p>执行这个算法的时候会把存活的对象压缩到一端，然后将所有可回收的对象清除掉。</p>
<p>这样做的好处：</p>
<ul>
<li>避免内存的不连续性</li>
<li>不用设置两块内存互换</li>
<li>适用于存活率高的场景(比如涉及分代收集算法中老年代的回收)</li>
</ul>
<h4 id="GC-最主流-分代收集算法-Generational-Collector"><a href="#GC-最主流-分代收集算法-Generational-Collector" class="headerlink" title="(GC,最主流)分代收集算法(Generational Collector)"></a>(GC,最主流)分代收集算法(Generational Collector)</h4><p>这是一种比较主流的垃圾回收算法。</p>
<p>可以理解是一套”组合拳”</p>
<ul>
<li>垃圾回收算法的组合拳</li>
<li>按照对象生命周期的不同划分区域以采用不同的垃圾回收算法</li>
<li>目的：提高JVM的回收效率</li>
</ul>
<p>前面已经提过，JDK8之前，比如JDK6和JDK7，里面有年轻代、老年代和永久代，如下图：</p>
<p><img src="https://s2.ax1x.com/2020/03/05/37r5Cj.png" alt="JDK6+7"></p>
<p>但是JDK8之后(包括JDK8)就去掉了永久代：</p>
<p><img src="https://s2.ax1x.com/2020/03/05/37rI8s.png" alt="JDK8后去掉永久代"></p>
<p>可以看到，JDK6、JDK7和JDK8中都有年轻代和老年代。其中年轻代的对象存活率低，采用复制算法。而老年代存活率高，一般使用”标记-清除算法”或者”标记-整理算法”。</p>
<h5 id="GC的分类"><a href="#GC的分类" class="headerlink" title="GC的分类"></a>GC的分类</h5><p>分代收集的GC分为两种：</p>
<ul>
<li>Minor GC。发生在年轻代中的垃圾收集工作，采用复制算法。</li>
<li>Full GC。与老年代的垃圾回收相关。</li>
</ul>
<p>年轻代是所有Java对象出生的地方，即Java对象申请的内存和存放对象，都是在年轻代进行的。</p>
<p>实际上，Java大部分对象都不会长久存活，”朝生夕灭”。新生代是GC发生的频繁区域。</p>
<p>老年代的回收一般伴随着年轻代的垃圾收集，因此第二种垃圾回收方式被命名为”Full GC”</p>
<h5 id="年轻代：尽可能快速地收集掉那些生命周期短的对象"><a href="#年轻代：尽可能快速地收集掉那些生命周期短的对象" class="headerlink" title="年轻代：尽可能快速地收集掉那些生命周期短的对象"></a>年轻代：尽可能快速地收集掉那些生命周期短的对象</h5><ul>
<li>Eden区</li>
<li>两个Survivor区</li>
</ul>
<p><font color=#FF0000>年轻代用到的算法基本都是复制算法</font>。</p>
<p>年轻代主要用来存放新建的对象，分为Eden和两个Survivor区(又被称为S1和S2或者from区和to区)。大部分对象在Eden区生成，当Eden区满时，还存活的对象会在两个Survivor区交替保存，达到一定存活时间(比如15)之后会晋升到老年代。</p>
<p>对象刚被创建出来的时候，其内存空间首先被分配在Eden区。如果Eden区放不下新创建的对象的话，对象也有可能被直接放在Survivor甚至是老年代中。</p>
<p>而两个Survivor则分别被定义在from区和to区，并且哪个是from区，哪个是to区，也不是固定的，会随着垃圾回收的进行而相互转换。</p>
<p><img src="https://s2.ax1x.com/2020/03/05/37qRlq.png" alt="年轻代"></p>
<h5 id="年轻代垃圾回收的过程演示"><a href="#年轻代垃圾回收的过程演示" class="headerlink" title="年轻代垃圾回收的过程演示"></a>年轻代垃圾回收的过程演示</h5><p>通过一个实例演示年轻代的垃圾回收过程：</p>
<p>演示过程暂时忽略Eden区和Survivor区的大小比例，并且假设每个对象的大小都是一样的。Eden区最多能保存四个对象，Survivor区最多能保存三个对象。</p>
<p>一开始，如果对象在Eden出生，并且Eden被挤满，如下图：</p>
<p><img src="https://s2.ax1x.com/2020/03/05/3H1hJU.png" alt="3H1hJU.png"></p>
<p>此时会触发一次Minor GC。此时如果对象还存活(绿色的为存活对象)，它就会被复制到一个Survivor区里面，假设是复制到了S0里面，此时我们称S0为from区。复制之后会增加1个年龄。比如图中复制过去之后年龄为1.</p>
<p>然后清理所有使用过的Eden区域，如下图： </p>
<p><img src="https://s2.ax1x.com/2020/03/05/3H1fiT.png" alt="3H1fiT.png"></p>
<p>之后会清空Eden</p>
<p><img src="https://s2.ax1x.com/2020/03/05/3H1RoV.png" alt="3H1RoV.png"></p>
<p>然后过了一段时间，发现Eden区又被填满了，如图：</p>
<p><img src="https://s2.ax1x.com/2020/03/05/3H12d0.png" alt="3H12d0.png"></p>
<p>此时又会触发一次Minor GC，然后将Eden和S0里面的存活的对象都拷贝到S1里面，同时会把存活的对象的年龄都加1。</p>
<p>此时S1从to区变成了from区，而S0从from区变成了to区。</p>
<p><img src="https://s2.ax1x.com/2020/03/05/3H1gZq.png" alt="3H1gZq.png"></p>
<p>拷贝完成后，Eden和S0都会被清空，以此完成了第二次Minor GC。</p>
<p><img src="https://s2.ax1x.com/2020/03/05/3H14WF.png" alt="3H14WF.png"></p>
<p>之后我们假设Eden区又满了：</p>
<p><img src="https://s2.ax1x.com/2020/03/05/3H15z4.png" alt="3H15z4.png"></p>
<p>此时会出发第三次Minor GC，操作行为也和之前一样，年龄加1。同时S1里面如果有一个对象没有被用到，那么也要把它清除。</p>
<p>每次拷贝，存活对象的年龄都要加1.</p>
<p><img src="https://s2.ax1x.com/2020/03/05/3H1oQJ.png" alt="3H1oQJ.png"></p>
<p>拷贝完成后，S1和Eden又会被再次清空：</p>
<p><img src="https://s2.ax1x.com/2020/03/05/3H1Ty9.png" alt="3H1Ty9.png"></p>
<p>周而复始。对象在Survivor区每熬过一次Minor GC，其年龄就会被加1，当对象的年龄达到某个值之后(默认是15岁)，这些对象会成为老年代。</p>
<p>NOTE：这个默认年龄可以通过<code>-XX:MaxTenuringThreshold</code>调整</p>
<p>但这也不是一定的，如果存储的对象过大，Eden区和Survivor区都存不下，可能会需要用到老年代的空间协助存储。</p>
<h5 id="年轻代对象如何晋升到老年代"><a href="#年轻代对象如何晋升到老年代" class="headerlink" title="年轻代对象如何晋升到老年代"></a>年轻代对象如何晋升到老年代</h5><p>在分代算法当中，年轻代对象如何晋升到老年代？<strong>简单来说有3种场景</strong>：</p>
<ul>
<li>经历一定Minor GC次数(比如是15次)依然存活的对象</li>
<li>Survivor区中存放不下的对象</li>
<li>新生成的大对象(可以用:<code>-XX:+PretenuerSizeThreshold</code>来控制大对象的大小，只要大于这个大小，对象生成之后直接放入老年代)</li>
</ul>
<h5 id="常用的调优参数"><a href="#常用的调优参数" class="headerlink" title="常用的调优参数"></a>常用的调优参数</h5><p>介绍几个常用的用来做性能调优的参数。</p>
<ul>
<li>-XX:SurvivorRatio：Eden和Survivor的比值，默认8:1</li>
<li>-XX:NewRatio：老年代和年轻代内存大小的比例(比如若值为2，则老年代是年轻代大小的两倍，即young generation占据内存的三分之一)。</li>
<li>-XX:MaxTenuringThreshold:对象从年轻代晋升到老生代经历过GC次数的最大阈值</li>
</ul>
<p>新生代和老年代的总内存大小是通过”-Xms”和”-Xmx”来决定的。</p>
<h5 id="老年代：存放生命周期较长的对象"><a href="#老年代：存放生命周期较长的对象" class="headerlink" title="老年代：存放生命周期较长的对象"></a>老年代：存放生命周期较长的对象</h5><p>首先应该明确，<font color=#FF0000>老年代不适合用类似年轻代的复制算法</font>，因为老年代的对象很多都是被长期引用的，spring容器管理各种的bean。老年代中长期存活的对象是比较多的，可能甚至有几百MB，这么大的对象复制来复制去，效率很低。而且老年代中垃圾没有那么多。</p>
<p>回顾这副图：</p>
<p><img src="https://s2.ax1x.com/2020/03/05/37qRlq.png" alt="年轻代"></p>
<p>可以看到，老年代占的内存比新生代大，而且大致的比例为2:1</p>
<p><strong>老年代的对象存活率较高，而且没有额外空间做担保</strong>，所以老年代主要用的算法为：</p>
<ul>
<li>标记-清理算法（<strong>致命缺点是会产生内存碎片</strong>）</li>
<li>标记-整理算法（把老年代里的存活对象标记出来，移动到一起，存活对象压缩到一片内存空间里去，剩余的空间都是垃圾对象，把它们全部清理掉，剩余的都是连续的可用的内存空间，解决了内存碎片的问题）</li>
</ul>
<p>其中，老年代用到的更多的是<font color=#FF0000><strong>标记-整理算法</strong></font></p>
<p>之前已经详细介绍过这两种算法，这里就不再介绍了。</p>
<h3 id="16-常见的垃圾回收器有哪些？"><a href="#16-常见的垃圾回收器有哪些？" class="headerlink" title="16.常见的垃圾回收器有哪些？"></a>16.常见的垃圾回收器有哪些？</h3><h4 id="垃圾收集器之间的联系"><a href="#垃圾收集器之间的联系" class="headerlink" title="垃圾收集器之间的联系"></a>垃圾收集器之间的联系</h4><p>垃圾收集器不存在哪个好那个坏的问题，而是涉及到适合哪个具体的JVM。不同的厂商，不同版本的JVM，提供的选择也不同，这也是HotSpot实现这么多收集器的原因。</p>
<p>一些常见的垃圾收集器、它们之间的关系和它们的适用范围，如图所示：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3b1jC8.png" alt="垃圾收集器之间的联系"></p>
<p>如果两个收集器之间有连线，说明它们可以搭配使用。</p>
<p>我们只需要大致熟悉每一个垃圾收集器的作用即可。</p>
<p>下面分别介绍：</p>
<hr>
<h4 id="年轻代收集器"><a href="#年轻代收集器" class="headerlink" title="年轻代收集器"></a>年轻代收集器</h4><h5 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h5><p>可以在程序启动的时候通过<code>-XX:+UseSerialGC</code>设置使用此收集器。使用<strong>复制算法</strong>。</p>
<p>在JDK1.3之前，是Java虚拟机年轻代收集器的唯一选择。</p>
<p>Java中历史最悠久的收集器。</p>
<ul>
<li>单线程收集，GC时必须暂停所有工作线程</li>
<li>简单高效，Client默认用这个作为年轻代收集器</li>
</ul>
<p>工作过程如下图所示：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3b8lLj.png" alt="Serial收集器工作模拟图"></p>
<p>实际中系统分配给虚拟机管理的内存不会很大，一般就几十兆到一百兆，收集这么多的年轻代的停顿时间也就几十毫秒，一百毫秒左右。只要不是太频繁，这样的停顿是可以接受的。</p>
<h5 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h5><p>可以在程序启动的时候通过<code>-XX:+UseParNewGC</code>设置使用此收集器。使用复制算法。</p>
<ul>
<li>除了是多线程收集，其余的行为、特点和Serial收集器一样</li>
<li>单核执行效率不如Serial，在多核下执行才有优势</li>
</ul>
<p>在单核执行的环境中，表现不会比Serial更好，因为存在键程交互开销。但是随着CPU增加，它的表现会更好。它默认开启的收集线程数和CPU数相同。在CPU数量非常多的情况下，可以使用ParGCThreds的参数来限制垃圾收集的线程数</p>
<p><strong>ParNew是Server模式下虚拟机首选的年轻代收集器</strong>。因为除了Serial之外，目前只有它可以和CMS收集器配合工作。</p>
<p>ParNew工作过程如下图：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3bG5gU.png" alt="ParNew"></p>
<h5 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h5><p>可以在程序启动的时候通过<code>-XX:+UseParallelGC</code>设置使用此收集器。使用复制算法。</p>
<p>这个收集器和系统吞吐量有关。</p>
<p>什么是系统的吞吐量？</p>
<blockquote>
<p>吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)</p>
</blockquote>
<p>也就是运行用户代码时间/CPU消耗总时间。比如虚拟机一共运行了100分钟，垃圾收集用了2分钟，吞吐量就是98%</p>
<p>Parallel Scavenge收集器有些类似ParaNew收集器，也是多线程，但是与ParNew相比也有不同：</p>
<ul>
<li>相比ParNew，Parallel Scavenge对系统吞吐量的重视程度大于对用户线程停顿的时间的重视程度。虽然停顿时间短比较适合与用户相互的程序，因为响应速度更快可以提升用户体验；但高吞吐量可以高效率利用CPU时间，尽可能快地完成运算任务，比较适合在后台运算而不用和用户交互的任务。</li>
<li>在多核下执行才有优势，Server模式下默认的年轻代收集器</li>
</ul>
<p>Parallel Scavenge和ParNew工作过程基本相同，如下图：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3bG5gU.png" alt="ParNew"></p>
<p>值得一提的是，如果程序员本身对垃圾收集器不太了解，在程序优化过程中遇到了困难的时候，可以这样解决：在启动的时候加上参数<code>-XX:+UseAdaptiveSizePolicy</code>，使用Parallel Scavenge的自适应调节策略，这样就可以把内存管理的调优任务交给虚拟机自己去完成。</p>
<hr>
<h4 id="老年代收集器"><a href="#老年代收集器" class="headerlink" title="老年代收集器"></a>老年代收集器</h4><h5 id="Serial-Old收集器-MSC"><a href="#Serial-Old收集器-MSC" class="headerlink" title="Serial Old收集器(MSC)"></a>Serial Old收集器(MSC)</h5><p>可以在程序启动的时候通过<code>-XX:+UseSerialOldGC</code>设置使用此收集器。使用标记-整理算法。</p>
<p>Serial模式的老年版</p>
<ul>
<li>单线程收集，进行垃圾收集时，必须暂停所有工作线程</li>
<li>简单高效，Client模式下默认的老年代收集器</li>
</ul>
<p>工作流程如图：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3bYz0H.png" alt="Serial Old"></p>
<h5 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h5><p>可以在程序启动的时候通过<code>-XX:+UseParallelOldGC</code>设置使用此收集器。使用标记-整理算法。</p>
<p>这个收集器在JDK6之后才开始提供的。在此之前新生代的Parallel Scavenge收集器一直处在一个比较尴尬的位置，因为如果新生代选了它，老年代就只能选Serial Old收集器了。</p>
<p>Parallel Old收集器的出现就是为了解决这个问题。</p>
<p>直到Parallel Old出现之后，吞吐量优先收集器才有了名副其实的组合。</p>
<ul>
<li>多线程，吞吐量优先</li>
</ul>
<p>在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge + Parallel Old收集器的组合。</p>
<p>工作流程如图：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3bczkV.png" alt="Parallel Old收集器"></p>
<h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p>CMS在JDK1.7之前可以说是最主流的垃圾回收算法。CMS使用<strong>标记-清除算法</strong>，<font color=#FF0000>优点是并发收集，停顿小</font>。</p>
<p>可以在程序启动的时候通过<code>-XX:+UseConcMarkSweepGC</code>设置使用此收集器。使用标记-清除算法。</p>
<p>实际上，CMS收集器几乎占据着JVM老年代收集器的半壁江山。它的划时代的意义就是垃圾回收线程几乎能与用户线程做到同时工作——说是”几乎”，是因为它不能完全做到不”Stop-the-World”，它只是能尽可能地缩短停顿时间。需要注意如果你的程序对停顿比较敏感，并且在应用程序运行的时候可以提供更大的内存和更多的CPU，那么用CMS是好的选择。</p>
<p>此外，如果在JVM中有相对较多而且存活时间较长的对象，也更适合使用CMS。</p>
<p>CMS的算法在整个垃圾回收过程可以分为下面六步：</p>
<ol>
<li><font color=#FF0000>初始标记</font>：这个过程会stop-the-world(简称STW)，JVM停顿正在执行的任务，从垃圾回收的根对象开始，只扫描和根对象直接关联的对象，时间短。最后标记的对象只是从root集最直接可达的对象；</li>
<li>并发标记：并发追溯标记，程序不停顿。这个阶段中GC线程和应用线程并发执行，主要标记可达的对象。用户不会感受到停顿；</li>
<li>并发预清理：查找执行并发标记时晋升老年代的对象。可能有一些对象从新生代晋升到老年代，或者有些对象直接被分配到老年代，通过重新扫描，减少下一个阶段重新标记的工作(因为下一阶段会重新stop-the-world)。这个过程不停顿</li>
<li><font color=#FF0000>重新标记</font>：过程会STW，暂停虚拟机，扫描CMS堆中剩余对象，扫描从根对象开始向下追溯，并处理对象单元。这一步相对较慢</li>
<li>并发清理：清理垃圾对象，程序不停顿</li>
<li>并发重置：重置CMS收集器的数据结构，等待下一次垃圾回收</li>
</ol>
<p>上述过程中，<strong>初始标记和重新标记需要短暂的stop-the-world</strong></p>
<p>工作流程如下图：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3bvBJU.png" alt="CMS垃圾收集器"></p>
<p>并发标记的过程实际上是和用户线程同时工作的，也就是一边丢垃圾，一边打扫。但这也可能产生一个问题，就是某个垃圾如果在打扫之后产生的，那么这个垃圾就只能等到下次垃圾回收才能被收掉，也就是说垃圾打扫完一次后没有完全打扫干净。</p>
<p>但是CMS收集器因为用的是”标记-清除算法”而不是”标记-整理算法”，就不可避免导致了垃圾碎片化的问题。如果此时需要分配较大的对象，那就只能触发一次GC了。</p>
<p><font color=#FF0000>优点</font>：并发，停顿低</p>
<h4 id="年轻代和老年代都可：G1收集器"><a href="#年轻代和老年代都可：G1收集器" class="headerlink" title="年轻代和老年代都可：G1收集器"></a>年轻代和老年代都可：G1收集器</h4><p>G1在JDK1.9之后是JVM默认的垃圾回收算法，G1的<strong>特点是保持高回收率的同时，减少停顿</strong>。</p>
<p>G1算法对JVM中堆结构进行了改变，取消了年轻代和老年代的物理划分，<strong>但它仍然属于分代收集器</strong>。G1算法将堆划分为若干个区域，称作 Region，如下图中的小方格所示：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3qSkGT.png" alt="G1堆内存分配"></p>
<p><font color=#FF0000>一部分区域用作年轻代，一部分用作老年代，另外还有一种专门用来存储巨型对象的分区</font>。</p>
<p>G1 也和 CMS 一样会遍历全部的对象，然后标记对象引用情况，在清除对象后会对区域进行复制移动整合碎片空间。</p>
<p>G1的回收过程如下：</p>
<ol>
<li><p>G1的年轻代回收，采用<strong>复制算法</strong>，并行收集，过程会SWT</p>
</li>
<li><p>G1的老年代回收时会对年轻代进行回收。主要分为四个阶段：</p>
<p>a. 依然是<strong>初始标记</strong>阶段完成对象的标记，这个过程是STW的；</p>
<p>b. <strong>并发标记</strong>阶段，这个阶段是和用户线程并行执行的；</p>
<p>c. <strong>最终标记</strong>阶段，完成三色标记周期；</p>
<p>d. <strong>复制/清除</strong>阶段，这个阶段会优先对可回收空间较大的Region进行回收，即garbage first，这也是G1名称的由来。</p>
</li>
</ol>
<p>G1采用每次只清理一部分而不是全部Region的增量式清理，由此来包保证每次GC停顿时间不会过长。</p>
<p>可以在程序启动的时候通过<code>-XX:+UseG1GC</code>设置使用此收集器。使用多种算法，即”<strong>复制算法 + 标记-整理算法</strong>“。</p>
<p>G1收集器既用于年轻代，也用于老年代。全称：<font color=#FF0000>Garbage First收集器</font>。</p>
<p>实际上，<strong>HotSpot最终的目的是让G1收集器最后能替换掉JDK5发布的CMS收集器</strong>。</p>
<p>Garbage First收集器的特点：</p>
<ol>
<li>并行和并发——使用多个CPU来缩短stop-the-world的停顿时间，与用户线程并发执行</li>
<li>分代收集——独立管理整个堆，但是能够采用不同的方式去处理新创建的对象和已经熬过多次GC的旧对象以获得更好的收集效果</li>
<li>空间整合——基于”标记-整理算法”，解决了内存碎片的问题</li>
<li>可预测停顿——能建立可预测的停顿时间模型，设置用户在某个地方的停顿时长不能超过m毫秒，类似这样</li>
</ol>
<p>在Garbage First垃圾收集器之前的收集器，都是只针对年轻代或者老年代的。而Garbage First可以同时针对年轻代和老年代。</p>
<p>在使用Garbage First收集器的时候，Java堆的布局和使用其他垃圾收集器时有很大不同：</p>
<ul>
<li>将整个Java堆内存划分成多个大小相等的Region——虽然还保留新生代和老年代的概念，但是新生代和老年代不再是物理隔离的了。<strong>这个Region大小可以通过JVM参数设置，范围是1~32MB</strong></li>
<li>年轻代和老年代不再物理隔离——它们可以是不连续的Region的集合。这也使得分配内存空间的时候可以不是连续的</li>
</ul>
<p>也就是说此时在JVM启动的时候不需要决定哪些Region属于老年代，哪些Region属于年轻代。因为随着时间推移，年轻代的Region被回收以后，就会变为可用状态，此时也可以把它分配成老年代。</p>
<p>和其他的HotSpot一样，当一个年轻代GC发生时，整个年轻代会被回收，G1的老年代收集器有所不同，它在老年代不需要整个老年代进行回收，只有一部分Region被调用。</p>
<p>G1的年轻代由Eden Region和Survivor Region组成。当一个JVM分配Eden Region失败后，会触发一个年轻代回收，意味着Eden区满了。之后GC开始释放空间，第一个年轻代收集器会移动所有的存储对象，从Eden Region到Survivor Region,这就是copy to survivor的过程。</p>
<p>JDK11还有研发Epsilon GC和ZGC，这里暂时先不介绍。</p>
<h4 id="回顾一个问题"><a href="#回顾一个问题" class="headerlink" title="回顾一个问题"></a>回顾一个问题</h4><p><img src="https://s2.ax1x.com/2020/03/06/3b1jC8.png" alt="垃圾收集器之间的联系"></p>
<p>如上图，为什么CMS不能和Parallel Scavenge一起工作呢？两者为什么不兼容呢？</p>
<p>CMS是HotSpot在JDK5的时候推出的第一款整整意义上的并发收集器，第一次实现了让垃圾收集线程与用户线程同时工作。</p>
<p>CMS作为老年代收集器不能和Parallel Scavenge一起工作主要是因为Parallel Scavenge和CMS代码框架不同。</p>
<h4 id="常用的垃圾回收器组合"><a href="#常用的垃圾回收器组合" class="headerlink" title="常用的垃圾回收器组合"></a>常用的垃圾回收器组合</h4><ul>
<li>ParNew + CMS组合（以后会被淘汰）</li>
</ul>
<p>这个是JDK8以及JDK8之前非常常用的组合。</p>
<p>ParNew回收的过程是多线程进行回收，过程是先把存活的对象标记出来，把这些存活对象复制到一块S区，然后清除。</p>
<p>CMS执行的过程就比ParNew复杂多了，而且老年代的回收很多时候会比年轻代慢10倍以上。具体内容参考上面的介绍。</p>
<ul>
<li>G1直接回收（JDK1.9及之后的11默认，最后其实希望G1代替ParNew与CMS组合）</li>
</ul>
<h3 id="17-G1垃圾回收器与CMS的区别有哪些？"><a href="#17-G1垃圾回收器与CMS的区别有哪些？" class="headerlink" title="17.G1垃圾回收器与CMS的区别有哪些？"></a>17.G1垃圾回收器与CMS的区别有哪些？</h3><p>参考文章：</p>
<p><a href="https://www.cnblogs.com/heyonggang/p/11718170.html" target="_blank" rel="noopener">弄明白CMS和G1，就靠这一篇了</a></p>
<p><a href="https://www.cnblogs.com/rgever/p/9534857.html" target="_blank" rel="noopener">CMS和G1的区别</a></p>
<p>正如上面所说，1.9之后已经将G1设置为默认的垃圾回收器。两者区别整理如下：</p>
<table>
<thead>
<tr>
<th align="center">特征</th>
<th align="center">G1</th>
<th align="center">CMS</th>
</tr>
</thead>
<tbody><tr>
<td align="center">并发和分代</td>
<td align="center">是</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">最大化释放堆内存</td>
<td align="center">是</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">低延时</td>
<td align="center">是</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">吞吐量</td>
<td align="center">高</td>
<td align="center">低</td>
</tr>
<tr>
<td align="center">压实</td>
<td align="center">是</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">可预测性</td>
<td align="center">强</td>
<td align="center">弱</td>
</tr>
<tr>
<td align="center">新生代和老年代的物理隔离</td>
<td align="center">否</td>
<td align="center">是</td>
</tr>
</tbody></table>
<hr>
<p><strong>CMS收集器特点汇总</strong>：</p>
<p>CMS收集器<strong>优点</strong>：并发收集、低停顿。</p>
<p>CMS收集器缺点：</p>
<ul>
<li>CMS收集器对CPU资源非常敏感</li>
<li>CMS收集器无法处理浮动垃圾(Floating Garbage)</li>
<li>CMS收集器是基于标记-清除算法，该算法的缺点都有</li>
</ul>
<p>CMS收集器之所以能够做到并发，根本原因在于<strong>采用基于“标记-清除”的算法并对算法过程进行了细粒度的分解</strong>。</p>
<hr>
<p><strong>G1收集器特点汇总</strong>：</p>
<ul>
<li><strong>并行与并发</strong>：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短Stop-the-world停顿的时间，部分其他收集器原来需要停顿Java线程执行的GC操作，G1收集器仍然可以通过<strong>并发</strong>的方式让Java程序继续运行。</li>
<li>分代收集</li>
<li>空间整合：与CMS的标记-清除算法不同，G1从整体来看是基于<strong>标记-整理算法</strong>实现的收集器，从局部（两个Region之间）上来看是基于“<strong>复制</strong>”算法实现的。但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。<strong>这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC</strong>。</li>
<li>可预测的停顿：这是G1相对于CMS的一个优势，降低停顿时间是G1和CMS共同的关注点。</li>
</ul>
<h3 id="18-什么情况下会触发FullGC"><a href="#18-什么情况下会触发FullGC" class="headerlink" title="18.什么情况下会触发FullGC?"></a>18.什么情况下会触发FullGC?</h3><p>当触发老年代的垃圾回收的时候，往往也会伴随对新生代堆内存的回收，即对整个堆进行垃圾回收，也就是所谓的Full GC，或者叫做Major GC。Major GC和Full GC是等价的，即收集所有的GC堆。</p>
<p>主要是因为HotSpot VM发展了很多年，外界对很多名词的解读都已经混乱了，当有人说到了”Major GC”的时候，一定要问清楚，他说的到底是针对所有代的Full GC，还是只是针对老年代的GC。</p>
<p>Full GC比Minor GC慢(慢十倍)，但因为老年代里面元素本身就不容易被淘汰，所以执行频率也会更低。</p>
<h4 id="触发Full-GC的条件"><a href="#触发Full-GC的条件" class="headerlink" title="触发Full GC的条件"></a>触发Full GC的条件</h4><ul>
<li>老年代空间不足——如果创建的对象很大，Eden区域放不下这个对象，会放入到老年代中。如果老年代空间也不足，就会触发Full GC。为了避免这种情况，最好就是不要创建太大的对象。</li>
<li>永久代空间不足——这主要是针对JDK7以及以前的版本。当系统中需要加载和调用的类很多，而同时持久代当中没有足够的空间去存放类的信息和方法信息的时候，就会触发出一次Full GC。而JDK8以后由于取消了永久代，就不存在”永久代空间不足”这种情况了。(这也是JDK8后面用元空间替代永久代的原因之一，为了降低Full GC的频率，减少GC的负担，提升其效率)</li>
<li>CMS GC时出现promotion failed, concurrent mode failure。对于采用CMS 进行老年代GC的程序而言，如果GC日志中出现了这两个字段。如果出现了，可能会触发Full GC。</li>
<li>Minor GC晋升到老年代的平均大小大于老年代的剩余空间</li>
<li>调用System.gc()——这个是我们在程序里面手动调用的，触发Full GC。需要注意这个方法只是提醒虚拟机，程序员希望你在这里回收一下对象。但是具体怎么做还是要看虚拟机自己，程序员没有控制权</li>
<li>使用RMI来进行RPC或管理的JDK应用，每小时执行1次Full GC</li>
</ul>
<p>这些点很多，面试的时候只要能够提到3点，基本可以点到为止了，可以答到老年代空间不足，程序手动调用System.gc()，然后如果用的JDK版本比较老，在JDK8之前的版本，会有永久代空间不足的情况。当然其他的能说出来更好。</p>
<p>需要注意：</p>
<p>1.promotion failed是在进行Minor GC的时候Survivor放不下了，对象只能放入老年代，而此时恰好老年代也放不下，这时候就会造成promotion failed。</p>
<p>2.concurrent mode failure是在执行CMS GC的过程中同时有对象要放入老年代中，而此时老年代空间不足，就会造成这个failure。</p>
<p>而对于Minor GC晋升的这第四点，是比较复杂的触发情况。HotSpot为了避免由于新生代对象晋升到老年代而导致老年代空间不足的现象，在进行Minor GC的时候做了一个判断：如果之前统计所得到的Minor GC晋升到老年代的平均大小大于老年代的剩余空间，就直接触发Full GC。例如，程序第一次触发GC后有6M的对象晋升到老年代，当下一次Minor GC发生的时候，首先先检查老年代的剩余空间是否大于6M，如果小于6M，则执行Full GC。</p>
<h3 id="19-介绍一下JDK11新推出的ZGC算法？"><a href="#19-介绍一下JDK11新推出的ZGC算法？" class="headerlink" title="19.介绍一下JDK11新推出的ZGC算法？"></a>19.介绍一下JDK11新推出的ZGC算法？</h3><p>JDK11提供的最激动人心的就是ZGC这个新的垃圾回收器，ZGC专门为大内存堆设计，有很强悍的性能，能够实现10ms一下的GC暂停时间。</p>
<h2 id="Java内存模型与synchronized和volatile的面试二连击"><a href="#Java内存模型与synchronized和volatile的面试二连击" class="headerlink" title="Java内存模型与synchronized和volatile的面试二连击"></a>Java内存模型与synchronized和volatile的面试二连击</h2><h3 id="1-Java内存模型-JMM"><a href="#1-Java内存模型-JMM" class="headerlink" title="1.Java内存模型(JMM)"></a>1.Java内存模型(JMM)</h3><p>这里简要概括上面写过的Java内存模型的内容。</p>
<p>Java内存模型JMM和JVM是两回事，JVM内存模型主要针对<strong>运行时数据区</strong>而言，而JMM是指Java程序中<strong>变量的访问规则</strong>，两者是完全不同的两个概念。</p>
<p>在 JDK1.2 之前，Java的内存模型(JMM)实现总是从<font color=#FF0000><strong>主存</strong>（即共享内存）读取变量</font>，是不需要进行特别的注意的。而在当前 的 Java 内存模型下，线程可以把变量保存<font color=#FF0000><strong>本地内存</strong></font>（比如机器的寄存器）中，而不是直接在主存中进行读写。这就 可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成<font color=#FF0000><strong>数据的不一致</strong></font>。</p>
<p>新的Java内存模型如下图：</p>
<p><img src="https://i.loli.net/2020/03/28/kWu9vcZ5AILjNQm.png" alt="现代版Java内存模型.png"></p>
<p>要解决这个问题，就需要把变量声明为 <font color=#FF0000><strong>volatile</strong></font>，这就指示 JVM，这个变量是不稳定的，每次使用它都到主存中进行 读取。</p>
<p>说白了， volatile 关键字的主要作用就是保证变量的可见性然后还有一个作用是防止指令重排序。</p>
<p><img src="https://i.loli.net/2020/03/28/fUSMYGbVAux1LH7.png" alt="volatile作用.png"></p>
<h3 id="2-synchronized关键字和volatile关键字的区别"><a href="#2-synchronized关键字和volatile关键字的区别" class="headerlink" title="2.synchronized关键字和volatile关键字的区别"></a>2.synchronized关键字和volatile关键字的区别</h3><p>synchronized关键字和volatile关键字比较 </p>
<ul>
<li><p><strong>volatile关键字</strong>是线程同步的<strong>轻量级实现</strong>，所以<strong>volatile性能肯定比synchronized关键字要好</strong>。但是<strong>volatile关键字只能用于变量</strong>而<strong>synchronized关键字可以修饰方法以及代码块</strong>。synchronized关键字在JavaSE1.6之后进 行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行 效率有了显著提升，<strong>实际开发中使用 synchronized 关键字的场景还是更多一些</strong>。 </p>
</li>
<li><p><strong>多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞</strong></p>
</li>
<li><p><strong>volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。</strong> </p>
</li>
<li><p><strong>volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访 问资源的同步性。</strong> </p>
</li>
</ul>
<h2 id="Java线程池的面试四连击"><a href="#Java线程池的面试四连击" class="headerlink" title="Java线程池的面试四连击"></a>Java线程池的面试四连击</h2><h3 id="1-为什么要用线程池？"><a href="#1-为什么要用线程池？" class="headerlink" title="1.为什么要用线程池？"></a>1.为什么要用线程池？</h3><p>线程池是为了避免线程频繁的创建和销毁带来的性能消耗，而建立的一种池化技术，它是把已创建的线程放入“池”中，当有任务来临时就可以重用已有的线程，无需等待创建的过程，这样就可以有效提高程序的响应速度。</p>
<p>这里借用《Java并发编程的艺术》提到的来说一下使用线程池的好处： </p>
<ul>
<li><strong>降低资源消耗</strong>。 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 </li>
<li><strong>提高响应速度</strong>。 当任务到达时，任务可以不需要的等到线程创建就能立即执行。 </li>
<li><strong>提高线程的可管理性</strong>。 线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性， 使用线程池可以进行统一的分配，调优和监控。 </li>
</ul>
<h3 id="2-实现Runnable接口和Callable接口的区别？"><a href="#2-实现Runnable接口和Callable接口的区别？" class="headerlink" title="2.实现Runnable接口和Callable接口的区别？"></a>2.实现Runnable接口和Callable接口的区别？</h3><p>如果想让线程池执行任务的话需要实现的Runnable接口或Callable接口。 Runnable接口或Callable接口实现类都可 以被ThreadPoolExecutor或ScheduledThreadPoolExecutor执行。两者的区别在于 Runnable 接口不会返回结果但 是 Callable 接口可以返回结果。</p>
<p><strong>备注</strong>：工具类 <code>Executors</code> 可以实现 <code>Runnable</code> 对象和 <code>Callable</code> 对象之间的相互转换。 （ <code>Executors.callable（Runnable task）</code>或 <code>Executors.callable（Runnable task，Object resule）</code>）。 </p>
<h3 id="3-执行execute-方法和submit-方法的区别是什么呢？"><a href="#3-执行execute-方法和submit-方法的区别是什么呢？" class="headerlink" title="3.执行execute()方法和submit()方法的区别是什么呢？"></a>3.执行execute()方法和submit()方法的区别是什么呢？</h3><ol>
<li><strong>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否。</strong>；</li>
<li><strong>submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断 任务是否执行成功</strong>，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用 get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行 完。 </li>
</ol>
<p>此外它们俩之间另一个区别是，execute()方法属于Executor接口的方法，而submit()方法则是属于ExecutorService接口的方法，它们之间的继承关系如下图所示：</p>
<p><img src="https://i.loli.net/2020/03/29/lX7uBNwA6s2gUeQ.png" alt="execute__方法和submit__方法另一个区别.png"></p>
<h3 id="4-如何创建线程池"><a href="#4-如何创建线程池" class="headerlink" title="4.如何创建线程池"></a>4.如何创建线程池</h3><p>《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这 样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p>
<blockquote>
<p>Executors 返回线程池对象的弊端如下：</p>
<ul>
<li>FixedThreadPool 和 SingleThreadExecutor ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积 大量的请求，从而导致OOM。 </li>
<li>CachedThreadPool 和 ScheduledThreadPool ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能 会创建大量线程，从而导致OOM。</li>
</ul>
</blockquote>
<p>而且参考之前写过的《ThreadPoolExecutor的核心参数》，那部分已经度过了源代码(能把参数和其作用都具体说出来，效果已经不错了)。其实当我们去看Executors的源码会发现，Executors.newFixedThreadPool()、Executors.newSingleThreadExecutor()和Executors.newCachedThreadPool() 等方法的底层都是通过 ThreadPoolExecutor 实现的。</p>
<p><img src="https://i.loli.net/2020/03/28/WQbFa9Iy8kgzjDi.png" alt="线程池创建方法_THreadPoolExecutor_.png"></p>
<p>顺带提一下上面三种基于Executor框架的工具类Executors实现的三种类型的ThreadPoolExecutor：</p>
<h2 id="CAS-比较后替换-Compare-and-Set"><a href="#CAS-比较后替换-Compare-and-Set" class="headerlink" title="CAS(比较后替换,Compare and Set)"></a>CAS(比较后替换,Compare and Set)</h2><h3 id="从synchronized引入"><a href="#从synchronized引入" class="headerlink" title="从synchronized引入"></a>从synchronized引入</h3><p>大家可能都听说说 Java 中的并发包，如果想要读懂 Java 中的并发包，其核心就是要先读懂 CAS 机制，因为 CAS 可以说是并发包的底层实现原理。</p>
<p>CAS能够保证操作的原子性，JDK8也对CAS进行了一些优化。</p>
<p>首先来看synchronized，它很多时候有些大材小用了。</p>
<p>先看几行代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CASTest</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如有100个线程同时调用 increment() 方法对 i 进行自增操作，i 的结果会是 100 吗？</p>
<p>但凡对多线程有一点了解的同学应该都知道，这个方法是线程不安全的，由于 i++ <strong>不是一个原子操作</strong>，所以是很难得到 100 的。</p>
<blockquote>
<p>这里稍微解释下为啥会得不到 100(知道的可直接跳过)， i++ 这个操作，计算机需要分成三步来执行。</p>
<p>1、读取 i 的值。</p>
<p>2、把 i 加 1.</p>
<p>3、把 最终 i 的结果写入内存之中。</p>
<p>所以，（1）、假如线程 A 读取了 i 的值为 i = 0，（2）、这个时候线程 B 也读取了 i 的值 i = 0。（3）、接着 A把 i 加 1，然后写入内存，此时 i = 1。（4）、紧接着，B也把 i 加 1，此时线程B中的 i = 1，然后线程 B 把 i 写入内存，此时内存中的 i = 1。也就是说，线程 A, B 都对 i 进行了自增，但最终的结果却是 1，不是 2.</p>
</blockquote>
<p>解决方法：加锁。比如可以加synchronized锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CASTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 在对象方法实例上加synchronized</span></span><br><span class="line">	<span class="comment">//同一时间，只能有一个线程可以进入这个increment()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个线程都同时基于myObject这个对象，来执行increment()方法</span></span><br><span class="line">MyObject myObject  = <span class="keyword">new</span> MyObject();</span><br><span class="line">myObject.increment();</span><br></pre></td></tr></table></figure>

<p>加了 synchronized 之后，就最多只能有一个线程能够进入这个 increment() 方法了，保证了线程安全。</p>
<p>然而，一个简简单单的自增操作，就加了 synchronized 进行同步，加了 synchronized 关键词之后，当有很多线程去竞争 increment 这个方法的时候，拿不到锁的方法是会被阻塞在方法外面的，最后再来唤醒他们，而阻塞/唤醒这些操作，是非常消耗时间的。因为只有一个线程可以成功的对myObject加锁，可以对它关联的monitor的计数器去加1，加锁，一旦多个线程并发的去进行synchronized加锁，相当于<strong>串行化执行</strong>了，效率并不是太高，其他线程都需要排队去执行</p>
<p><strong>更合适的解决方法：CAS</strong></p>
<h3 id="CAS介绍"><a href="#CAS介绍" class="headerlink" title="CAS介绍"></a>CAS介绍</h3><p>大家看一下，如果我采用下面这种方式，能否保证 increment 是线程安全的呢？步骤如下：</p>
<p>1、线程从内存中读取 i 的值，假如此时 i 的值为 0，我们把这个值称为 k 吧，即此时 k = 0。</p>
<p>2、令 j = k + 1。</p>
<p>3、用 k 的值与内存中i的值相比，如果相等，这意味着没有其他线程修改过 i 的值，我们就把 j（此时为1） 的值写入内存；如果不相等（意味着i的值被其他线程修改过），我们就不把j的值写入内存，而是重新跳回步骤 1，继续这三个操作。</p>
<p>翻译成代码的话就是这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = i;</span><br><span class="line">        <span class="keyword">int</span> j = k + <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">while</span> (compareAndSet(i, k, j))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你去模拟一下，就会发现，这样写是线程安全的。</p>
<p><strong>这里可能有人会说，第三步的 compareAndSet 这个操作不仅要读取内存，还干了比较、写入内存等操作，这一步本身就是线程不安全的啊？</strong></p>
<p>如果你能想到这个，说明你是真的有去思考、模拟这个过程，不过我想要告诉你的是，这个 <font color=#FF0000>compareAndSet 操作，是由硬件提供的原语来保证其操作的原子性</font>。CAS在底层的硬件级别给你保证一定是原子的，同一时间只有一个线程可以执行CAS，先比较再设置，其他的线程的CAS同时间去执行此时会失败。 即他其实只对应操作系统的一条硬件操作指令，尽管看似有很多操作在里面，但操作系统能够保证他是原子执行的。</p>
<p>对于一条英文单词很长的指令，我们都喜欢用它的简称来称呼他，所以，我们就把 compareAndSet 称为 CAS 吧。</p>
<p><strong>所以，采用 CAS 这种机制的写法也是线程安全的</strong>，通过这种方式，可以说是不存在锁的竞争，也不存在阻塞等事情的发生，可以让程序执行的更好。</p>
<p>在 Java 中，也是提供了这种 CAS 的原子类，例如：</p>
<p>AtomicBoolean</p>
<p>AtomicInteger</p>
<p>AtomicLong</p>
<p>AtomicReference</p>
<p>具体如何使用呢？我就以上面那个例子进行改版吧，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CASTest</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> AtomicInteger i = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>); <span class="comment">// AtomicInteger底层基于CAS实现</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 自增 1并返回之后的结果</span></span><br><span class="line">        i.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用<code>AtomicInteger</code>实现的CAS的实现原理如下图所示，首先是单线程访问的情况：</p>
<p><img src="https://i.loli.net/2020/04/06/lbD7dBxYjiIFkzH.png" alt="AtomicInteger单线程.png"></p>
<p>在incrementAndGet()底层会使用CAS方法。</p>
<p>然后是多线程都要使用这个用<code>AtomicInteger</code>修饰的对象的时候：</p>
<p><img src="https://i.loli.net/2020/04/06/sShQDWq7pitkFfy.png" alt="AtomicInteger多线程.png"></p>
<p>可以看到，这样解决了数据修改的问题，又不需要加synchronized这种比较重的锁，CAS相比之下很轻量。</p>
<p>但是又会有一个问题，就是如果函数的操作返回的就是和原来传入的值相同的值，那线程A可能认为B还没执行完。</p>
<p>举个例子：当线程A即将要执行第三步的时候，线程 B 把 i 的值加1，之后又马上把 i 的值减 1，然后，线程 A 执行第三步，这个时候线程 A 是认为并没有人修改过 i 的值，因为 i 的值并没有发生改变。而这，就是我们平常说的<strong>ABA问题</strong>。</p>
<p><strong>CAS只能保障一个变量的原子性，但不能保证整个代码块的原子性</strong>。</p>
<p>CAS可能会造成ABA问题，即：<strong>线程一拿到了某个变量最初的预期原值A，在将要进行CAS的时候被其他线程抢占了执行权，把值从A变成了B，然后其他线程又把这个值从B变回了A。虽然这个时候此变量实际上已经不是原先的A了，但线程一并不知道这个情况，它在执行CAS的时候，对比了A的值没有改变，就按照这个预期工作了，这就造成了ABA问题。</strong></p>
<p>以警匪剧为例，假如某人把装了100W现金的箱子放在了家里，几分钟之后要拿它去赎人，然而在趁他不注意的时候，进来了一个小偷，用空箱子换走了装满钱的箱子，当某人进来之后看到箱子还是一模一样的，他会以为这就是原来的箱子，就拿着它去赎人了，这种情况肯定有问题，因为箱子已经是空的了，这就是 ABA 的问题。</p>
<p>对于基本类型的值来说，这种把数字改变了在改回原来的值是没有太大影响的，但如果是对于<strong>引用类型</strong>的话，就会产生很大的影响了。</p>
<p>解决方法：版本控制，或者说<strong>添加版本号</strong>。每次修改之后都更新版本号，拿上面的例子来说，假如每次移动箱子之后，箱子的位置就会发生变化，而这个变化的位置就相当于“版本号”，当某人进来之后发现箱子的位置发生了变化就知道有人动了手脚，就会放弃原有的计划，这样就解决了ABA问题。</p>
<p>相似的，每次有线程修改了引用的值，就会进行版本的更新，虽然两个线程持有相同的引用，但他们的版本不同，这样，我们就可以预防 ABA 问题了。</p>
<p>JDK在1.5时提供了 <code>AtomicStampedReference</code> 这个类，维护了”版本号” <code>Stamp</code>,每次，值和版本号，都会比较，这样就解决了ABA的问题。</p>
<h3 id="CAS会遇到的问题及如何解决"><a href="#CAS会遇到的问题及如何解决" class="headerlink" title="CAS会遇到的问题及如何解决"></a>CAS会遇到的问题及如何解决</h3><p>CAS虽然高效的解决了原子操作问题，但仍然存在三大问题： </p>
<ol>
<li><font color=#FF0000><strong>ABA问题</strong></font>：如果变量V初次读取的时候值是A，后来变成了B，然后又变成了A，你本来期望的值是第一个A才会设置新值，第二个A跟期望不符合，但却也能设置新值。针对这种情况，java并发包中提供了一个带有标记的原子引用类AtomicStampedReference，它可以通过控制变量值的版本号来保证CAS的正确性，比较两个值的引用是否一致，如果一致，才会设置新值。 打一个比方，如果有一家蛋糕店，为了挽留客户，绝对为贵宾卡里余额小于20元的客户一次性赠送20元，刺激消费者充值和消费。但条件是，每一位客户只能被赠送一次。此时，如果很不幸的，用户正好正在进行消费，就在赠予金额到账的同时，他进行了一次消费，使得总金额又小于20元，并且正好累计消费了20元。使得消费、赠予后的金额等于消费前、赠予前的金额。这时，后台的赠予进程就会误以为这个账户还没有赠予，所以，存在被多次赠予的可能，但使用AtomicStampedReference就可以很好的解决这个问题。 </li>
<li><font color=#FF0000><strong>无限循环问题（自旋）</strong></font>：看源码可知，Atomic类设置值的时候会进入一个无限循环，只要不成功，就会不停的循环再次尝试。在高并发时，如果大量线程频繁修改同一个值，可能会导致大量线程执行compareAndSet()方法时需要循环N次才能设置成功，即大量线程执行一个重复的空循环（自旋），造成大量开销。解决无线循环问题可以使用java8中的LongAdder，分段CAS和自动分段迁移。 </li>
<li><font color=#FF0000><strong>多变量原子问题</strong></font>：只能保证一个共享变量的原子操作。一般的Atomic类，只能保证一个变量的原子性，但如果是多个变量呢？可以用AtomicReference，这个是封装自定义对象的，多个变量可以放一个自定义对象里，然后他会检查这个对象的引用是不是同一个。如果多个线程同时对一个对象变量的引用进行赋值，用AtomicReference的CAS操作可以解决并发冲突问题。 但是如果遇到ABA问题，AtomicReference就无能为力了，需要使用AtomicStampedReference来解决。</li>
</ol>
<h3 id="JDK8对CAS的优化"><a href="#JDK8对CAS的优化" class="headerlink" title="JDK8对CAS的优化"></a>JDK8对CAS的优化</h3><p>由于采用这种 CAS 机制是没有对方法进行加锁的，所以，所有的线程都可以进入 increment() 这个方法，假如进入这个方法的线程太多，就会出现一个问题：每次有线程要执行第三个步骤的时候，i 的值老是被修改了，所以线程又到回到第一步继续重头再来。</p>
<p>而这就会导致一个问题：<strong>由于线程太密集了，太多线程想要修改 i 的值了，进而大部分线程都会修改不成功，白白着在那里循环消耗资源</strong>。</p>
<p>为了解决这个问题，<strong>Java8 引入了一个 cell[] 数组，它的工作机制是这样的：假如有 5 个线程要对 i  进行自增操作，由于 5 个线程的话，不是很多，起冲突的几率较小，那就让他们按照以往正常的那样，采用 CAS 来自增吧</strong>。</p>
<p>但是，如果有 100 个线程要对 i 进行自增操作的话，这个时候，冲突就会大大增加，系统就会把这些线程分配到不同的 cell 数组元素去，假如 cell[10] 有 10 个元素吧，且元素的初始化值为 0，那么系统就会把 100 个线程分成 10 组，每一组对 cell 数组其中的一个元素做自增操作，这样到最后，cell 数组 10 个元素的值都为 10，系统在把这 10 个元素的值进行汇总，进而得到 100，二这，就等价于 100 个线程对 i 进行了 100 次自增操作。</p>
<h3 id="CAS和synchronized各自适用场景"><a href="#CAS和synchronized各自适用场景" class="headerlink" title="CAS和synchronized各自适用场景"></a>CAS和synchronized各自适用场景</h3><p>简单的来说<strong>CAS适用于写比较少的情况下</strong>（多读场景，冲突一般较少），<strong>synchronized适用于写比较多的情况下</strong>（多写场景，冲突一般较多）。</p>
<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p><strong>AQS的原理就是提供了一个volatile修饰的状态变量和一个双向的同步队列。提供模板方法对于独占锁和共享锁的获取和释放</strong>.</p>
<p>AQS的全称为（AbstractQueuedSynchronizer），这个类在java.util.concurrent.locks包下面。<font color=#FF0000>AQS本质是几个变量加上一个等待队列</font>。</p>
<h3 id="正式介绍AQS"><a href="#正式介绍AQS" class="headerlink" title="正式介绍AQS"></a>正式介绍AQS</h3><p><a href="https://www.cnblogs.com/yszzu/p/10198904.html" target="_blank" rel="noopener">CAS、AQS和lock之间的关系</a></p>
<p><a href="https://www.jianshu.com/p/2a48778871a9" target="_blank" rel="noopener">CAS和AQS</a></p>
<p>AQS的全称为（AbstractQueuedSynchronizer），这个类在java.util.concurrent.locks包下面，AQS是各种各样锁的基础，比如说 ReentrantLock、CountDownLatch 等等，这些我们经常用的锁底层实现都是AQS。</p>
<p><font color=#FF0000><strong>AQS是基于CAS的锁同步框架</strong></font>，是一个抽象类，其中有一个状态统计变量stateOffset是使用CAS来操作的。</p>
<p><img src="https://i.loli.net/2020/03/29/FdK93NT78n5U2lb.png" alt="AQS的位置.png"></p>
<p>AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask(一些具体作用见下段)等等皆是 基于AQS的。当然，我们自己也能利用AQS非常轻松容易地构造出符合我们自己需求的同步器。</p>
<p>参考《Java并发编程实战》的内容：</p>
<blockquote>
<p>AQS管理一个关于状态信息的单一整数，状态信息可以通过protected类型的getState()、setState()和compareAndSetState()等方法操作，这可以用于表现任何状态。</p>
<p>例如，ReentrantLock用它来表现<strong>拥有它的线程已经请求了多少次锁</strong>；Semaphore用它来表现<strong>剩余的许可次数</strong>；FutureTask用它来表现<strong>任务的状态(尚未开始、运行、完成和取消)</strong>。</p>
</blockquote>
<h3 id="AQS核心思想"><a href="#AQS核心思想" class="headerlink" title="AQS核心思想"></a>AQS核心思想</h3><p>AQS核心思想是，<strong>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制</strong>，这个机制 AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</p>
<blockquote>
<p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结 点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）来实现锁的分配。</p>
</blockquote>
<p>AQS原理图如下：</p>
<p><img src="https://i.loli.net/2020/03/30/PnzieOJcNX8mB24.png" alt="CLH队列.png"></p>
<p>AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该 同步状态进行原子操作实现对其值的修改。</p>
<h3 id="AQS两种资源共享方式"><a href="#AQS两种资源共享方式" class="headerlink" title="AQS两种资源共享方式"></a>AQS两种资源共享方式</h3><ul>
<li><strong>Exclusive</strong>(独占)：只有一个线程能执行，比如ReentrantLock。又可以分为公平锁和非公平锁。<ul>
<li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li>
<li>非公平锁：当线程要获取锁的时候，无视队列顺序直接去抢锁，谁先抢到就是谁的。</li>
</ul>
</li>
<li><strong>Share</strong>(共享)：：多个线程可同时执行，如Semaphore/CountDownLatch。</li>
</ul>
<p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方 式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。</p>
<h3 id="AQS组件总结"><a href="#AQS组件总结" class="headerlink" title="AQS组件总结"></a>AQS组件总结</h3><ul>
<li><strong>Semaphore(信号量)-允许多个线程同时访问</strong>： synchronized 和 ReentrantLock 都是一次只允许一个线程访问 某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。 </li>
<li><strong>CountDownLatch （倒计时器）</strong>： CountDownLatch是一个同步工具类，用来协调多个线程之间的同步。这 个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。 </li>
<li><strong>CyclicBarrier(循环栅栏)</strong>： CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待， 但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫 同步点）时被阻塞，直到后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。 CyclicBarrier默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用 await方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</li>
</ul>
<h2 id="谈谈对多线程的锁的理解？如何手动模拟一个死锁？"><a href="#谈谈对多线程的锁的理解？如何手动模拟一个死锁？" class="headerlink" title="谈谈对多线程的锁的理解？如何手动模拟一个死锁？"></a>谈谈对多线程的锁的理解？如何手动模拟一个死锁？</h2><p>多线程并发编程有两个重要概念：<strong>线程和锁</strong>。虽然多线程可以提高程序性能，但是带来了编码的复杂性，尤其是要解决多线程操作同一组资源的时候保证数据的一致性的问题。引入了锁之后，我们会给某个资源上锁，只有拥有这个资源的锁的线程才能操作此资源，而其他线程只能排队等待使用锁，也就是要等待这个锁被释放才行。</p>
<p>在并发编程中，当有多个线程同时操作一个资源时，为了保证数据操作的正确性，需要让多线程排队，一个一个地操作资源，而这个过程就是给资源加锁和释放锁的过程，就好像去公共厕所一样，一次只能有一个人占用，剩下的必须排队，而且一个人用的时候为了防止后面人进来，要给门上锁一样。</p>
<h3 id="什么是死锁？如何手动模拟一个死锁？"><a href="#什么是死锁？如何手动模拟一个死锁？" class="headerlink" title="什么是死锁？如何手动模拟一个死锁？"></a>什么是死锁？如何手动模拟一个死锁？</h3><p>首先，死锁是指两个线程都各自拥有一个资源的锁，但是又都在等待对方释放对方锁拥有的资源的锁。如下图所示：</p>
<p><img src="https://i.loli.net/2020/03/30/LeThwqHWSBGvtzX.png" alt="死锁.png"></p>
<p>代码例子如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockExample</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arg)</span> </span>&#123;</span><br><span class="line">		deadLock(); <span class="comment">// 死锁</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 死锁</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deadLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Object lock1 = <span class="keyword">new</span> Object();</span><br><span class="line">		Object lock2 = <span class="keyword">new</span> Object();</span><br><span class="line">		<span class="comment">// 线程1拥有 lock1 试图获取lock2</span></span><br><span class="line">		<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">			<span class="keyword">synchronized</span>(lock1) &#123;</span><br><span class="line">				System.out.println(<span class="string">"获取lock1成功"</span>);</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 试图获取lock2</span></span><br><span class="line">				<span class="keyword">synchronized</span>(lock2) &#123;</span><br><span class="line">					System.out.println(Thread.currentThread().getName());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">		<span class="comment">// 线程二拥有 lock2 试图获取lock1</span></span><br><span class="line">		<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">			<span class="keyword">synchronized</span>(lock2) &#123;</span><br><span class="line">				System.out.println(<span class="string">"获取lock2成功"</span>);</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 试图获取lock2</span></span><br><span class="line">				<span class="keyword">synchronized</span>(lock1) &#123;</span><br><span class="line">					System.out.println(Thread.currentThread().getName());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">获取lock1成功</span><br><span class="line">获取lock2成功</span><br></pre></td></tr></table></figure>

<p>在分别获得lock1和lock2成功之后，这两个线程还会试图获得对方的锁，也就是线程一拥有锁lock1之后试图获取lock2，而线程二在拥有lock2之后试图获取lock1,这样就造成了彼此都在等待对方释放资源，于是造成了<strong>死锁</strong>。</p>
<h2 id="Java的悲观锁和乐观锁、共享锁和独占锁"><a href="#Java的悲观锁和乐观锁、共享锁和独占锁" class="headerlink" title="Java的悲观锁和乐观锁、共享锁和独占锁"></a>Java的悲观锁和乐观锁、共享锁和独占锁</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>悲观锁是指<strong>数据对外界的修改采取保守策略，它认为线程很容易会把数据修改掉，因此在整个数据被修改的过程中都会采取锁定状态，直到一个线程使用完，其他线程才可以继续使用。</strong>通俗理解，就是在用数据之前要先加上锁，用完之后才能释放锁。</p>
<p>拿synchronized来说，每次执行被synchronized修饰的代码块在执行之前会先用<code>monitorenter</code>指令加上锁，在执行结束之后再使用<code>monitorexit</code>指令释放锁资源，在整个执行期间这个代码都是锁定的状态，这就是<strong>典型悲观锁的实现流程</strong>。</p>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁肯定与悲观锁相反啦，<strong>乐观锁认为数据之间一般不会发生冲突，所以在数据访问之前不会加锁，只有在提交的时候，才会对数据进行检测和上锁。</strong></p>
<p>乐观锁大部分都是通过<strong>CAS(Compare And Swap，比较并交换)</strong>操作实现的。CAS之前有过介绍，它是一个多线程同步的原子指令。CAS操作包含三个重要信息：内存位置、预期原值和新值。如果内存位置的值和预期原值相等的话，可以把该位置的值更新为新值，否则不做任何修改。之前讲过的ReentrantLock就是通过CAS实现的，Lock就是乐观锁的典型例子。</p>
<p>然而，CAS可能造成ABA问题(前面有介绍过，解决方法是用版本号)。</p>
<h3 id="共享锁和独占锁-排它锁"><a href="#共享锁和独占锁-排它锁" class="headerlink" title="共享锁和独占锁(排它锁)"></a>共享锁和独占锁(排它锁)</h3><ul>
<li><p>可以被多线程持有的称作<strong>共享锁</strong></p>
</li>
<li><p>只能被单线程持有的锁称作<strong>独占锁</strong>。独占锁指的是在任何时候最多只能有一个线程持有该锁，比如 ReentrantLock 就是独占锁，而 ReadWriteLock 读写锁允许同一时间内有多个线程进行读操作，它就属于共享锁。</p>
</li>
</ul>
<p><strong>独占锁可以理解为悲观锁</strong>，当每次访问资源时都要加上互斥锁，<strong>而共享锁可以理解为乐观锁</strong>，它放宽了加锁的条件，允许多线程同时访问该资源。</p>
<p><strong>排它锁</strong>的意思是同一时刻，只能有一个线程可以获得锁，也只能有一个线程可以释放锁。<strong>共享锁</strong>可以允许多个线程获得同一个锁，并且可以设置获取锁的线程数量。</p>
<h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>可重入锁也叫<strong>递归锁</strong>，指的是同一个线程，如果外层的函数拥有这个锁，内层的函数可以继续获取该锁。</p>
<p>在Java语言中，ReentrantLock和synchronized都是可重入锁。</p>
<p>用代码举一个可重入锁的例子，用synchronized来演示：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockExample</span> &#123;</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] arg)</span> </span>&#123;</span><br><span class="line">		reentrantA(); <span class="comment">// 可重入锁</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	*	可重入锁A方法</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> synchronized <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reentrantA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.<span class="built_in">println</span>(Thread.currentThread.getName() + <span class="string">":执行 reentrantA"</span>);</span><br><span class="line">		reentrantB();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	*	可重入锁B方法</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> synchronized <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reentrantB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.<span class="built_in">println</span>(Thread.currentThread.getName() + <span class="string">":执行 reentrantB"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main：执行 reentrantA</span><br><span class="line">main：执行 reentrantB</span><br></pre></td></tr></table></figure>

<p>从结果可以看出reentrantA方法和reentrantB方法的执行线程都是“main”，我们调用了reentrantA方法，它的方法中嵌套了reentrantB，如果synchronized是不可重入的话，那么线程会一直堵塞。</p>
<p>可重入锁的实现原理，是在锁内部存储了一个线程标识，用于判断当前的锁属于哪个线程，并且锁的内部维护了一个计数器，当锁空闲时此计数器的值为0，当被线程占用和重入时分别加1，当锁被释放时计数器减1，直到减到 0 时表示此锁为空闲状态。</p>
<h1 id="7-Spring"><a href="#7-Spring" class="headerlink" title="7.Spring"></a>7.Spring</h1><h2 id="注解是什么？元注解是什么？有什么用？"><a href="#注解是什么？元注解是什么？有什么用？" class="headerlink" title="注解是什么？元注解是什么？有什么用？"></a>注解是什么？元注解是什么？有什么用？</h2><p>答：①注解是一种标记，可以使类或接口附加额外的信息，是帮助编译器和JVM完成一些特定功能的。</p>
<p>②元注解就是自定义注解的注解，包括<code>@Target</code>：用来约束注解的位置，值是<code>ElementType</code>枚举类，包括<code>METHOD</code>方法、<code>VARIABLE</code>变量、<code>TYPE</code>类/接口、<code>PARAMETER</code>方法参数、<code>CONSTRUCTORS</code>构造器和<code>LOACL_VARIABLE</code>局部变量；<code>@Rentention</code>：用来约束注解的生命周期，值是<code>RetentionPolicy</code>枚举类，包括：<code>SOURCE</code>源码、<code>CLASS</code>字节码和<code>RUNTIME</code>运行时；<code>@Documented</code>：表明这个注解应该被javadoc工具记录；<code>@Inherited</code>：表面某个被标注的类型是被继承的。</p>
<h2 id="说说你对Spring-IOC机制的理解"><a href="#说说你对Spring-IOC机制的理解" class="headerlink" title="说说你对Spring IOC机制的理解"></a>说说你对Spring IOC机制的理解</h2><h3 id="Spring-IOC的演进由来"><a href="#Spring-IOC的演进由来" class="headerlink" title="Spring IOC的演进由来"></a>Spring IOC的演进由来</h3><p>首先，我们可以对比，没有IOC的常规情况：</p>
<p><strong>没有IOC的项目模式</strong>：tomcat最初的流程是接受http请求，然后封装后转发给我们自己写的servlet，最后由我们手动创建实现类的对象去执行业务逻辑。<strong>但是这样存在很大弊端：耦合性太高</strong>。比如我要修改这个方法，那么所有调用了这个方法的类全都要改代码！改动过程复杂不说，后序测试也会非常复杂！出了一点点问题，都会要改动很多代码！很不合理。</p>
<p>上面这个过程如图所示：</p>
<p><img src="https://i.loli.net/2020/04/07/6xaodPEkOAKIHc3.png" alt="原始项目流程.png"></p>
<p>紧接着，<strong>整个体系进行演化</strong>，演化出了Spring IOC框架，即控制反转，依赖注入(DI)。在以前，我们都会用xml文件来进行配置我们的系统，现在都是用<strong>注解</strong>来完成。具体做法：把原先完成业务逻辑的Servlet修改成Controller，在最上面加上注解”@Controller”，然后实现这个Controller的类加上注解”@Resource”，后面我们只要在这个工程里通过maven引入一些spring框架的依赖比如ioc功能，那么<strong>tomcat在启动的时候，直接会启动spring容器</strong>。</p>
<p>spring容器启动后会扫描所有代码，之后的过程是，spring容器会理解你的注解或者xml配置，只要你加了”<strong>@Controller</strong>“注解，spring容器就会知道现在需要它来创建你这个类的对象实例；你加了”<strong>@Service</strong>“，spring容器就会管理和创建这个类；如果加了”<strong>@Resource</strong>“，就知道这个是一个引用变量，没有对象实例，这个对象实例的bean是不是在spring容器的管理之下，如果在，就把之前创建的带有”<strong>@Service</strong>“的类赋值给”<strong>@Resource</strong>“的变量，也就是让”<strong>@Controller</strong>“去引用”<strong>@Service</strong>“。</p>
<p><strong>然后引入spring mvc其实就是由它实现了之前servlet的一些功能，处理包装请求，然后一些filter，最终转发到我们的controller，最终调用实现类完成业务逻辑</strong>。 整个IOC容器就像是一个map，key是对应的名称，value是通过反射创建的bean。比较明显的作用就是解耦。</p>
<p>样例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MyService myService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRequest</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对请求统一处理</span></span><br><span class="line">        <span class="comment">// 调用自己的业务逻辑组件，去执行一些业务逻辑</span></span><br><span class="line">        myService.doService(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServiceImpl</span> <span class="keyword">implements</span> <span class="title">MyService</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewServiceManagerImpl</span> <span class="keyword">implements</span> <span class="title">MyService</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码中，MyServiceImpl 和 NewServiceManagerImpl 是一前一后实现MyService这个接口的实现类。可以假设原本项目中的实现方法是MyServiceImpl，但是后面改成了NewServiceManagerImpl ，但是此时修改代码非常简单，只需要改一下”@Service”的位置即可，就会改变实例化的方法。但项目要修改的时候，不用改代码，只要改之前的”@Service”注解即可。</p>
<p>上述代码的执行过程如图：</p>
<p><img src="https://i.loli.net/2020/04/07/DBStkXIYlCNd97G.png" alt="新的使用IOC的系统.png"></p>
<p><font color=#FF0000>IOC底层核心技术是反射</font>，直接根据你的类去自己构建对应的对象出来。</p>
<p>spring容器会根据xml配置或者注解，去实例化对应的bean对象，再然后根据xml配置或者注解，去对bean对象之间的引用关系，去进行依赖注入，某个bean依赖了另外一个bean。最后spring ioc实现了系统的类与类之间彻底的解耦合。现在这套比较高大上的一点系统里，有几十个类都使用了@Resource这个注解去标注MyService myService，几十个地方都依赖了这个类，如果要修改实现类为NewServiceManagerImpl</p>
<p>Tomcat启动后会去启动一个spring容器，由spring将对应的bean进行创建于初始化，并且管理对应的依赖关系，这里的就是控制反转了，将类的调用关系由主动变成了被动，交给了spring去管理。 3、有了这个机制以后，就可以轻松的完成解耦，然后引入spring mvc其实就是由它实现了之前servlet的一些功能，处理包装请求，然后一些filter，最终转发到我们的controller，最终调用实现类完成业务逻辑。 4、整个IOC容器就像是一个map，key是对应的名称，value是通过反射创建的bean。比较明显的作用就是解耦。</p>
<h3 id="Spring-IOC的优点？"><a href="#Spring-IOC的优点？" class="headerlink" title="Spring IOC的优点？"></a>Spring IOC的优点？</h3><p>IOC 或 依赖注入把应用的代码量降到最低。它使应用容易测试，单元测试不再需要单例和JNDI查找机制。最小的代价和最小的侵入性使松散耦合得以实现。IOC容器支持加载服务时的饿汉式初始化和懒加载。</p>
<h3 id="SpringIOC初始化过程-重要"><a href="#SpringIOC初始化过程-重要" class="headerlink" title="SpringIOC初始化过程(重要)"></a>SpringIOC初始化过程(重要)</h3><p>详细来说，其实Spring IOC初始化过程就是容器的初始化过程。</p>
<p>之前介绍Spring Bean的时候已经提到了，Spring Bean都是由Spring容器去管理的，而Spring主要有两个容器系列：</p>
<ol>
<li>实现BeanFactory接口的简单容器；</li>
<li>实现ApplicationContext接口的高级容器。</li>
</ol>
<p>ApplicationContext比较复杂，它不但继承了BeanFactory的大部分属性，还继承其它可扩展接口，扩展的了许多高级的属性，其接口定义如下：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">ApplicationContext</span> <span class="symbol">extends</span> <span class="symbol">EnvironmentCapable</span>, </span><br><span class="line">　　　　　　　　　　　　　　　　　　<span class="symbol">ListableBeanFactory</span>,    //继承于<span class="symbol">BeanFactory</span></span><br><span class="line">　　　　　　　　　　　　　　　　　　<span class="symbol">HierarchicalBeanFactory</span>,//继承于<span class="symbol">BeanFactory</span></span><br><span class="line">　　　　　　　　　　　　　　　　　　<span class="symbol">MessageSource</span>,            //</span><br><span class="line">　　　　　　　　　　　　　　　　　　<span class="symbol">ApplicationEventPublisher</span>,//</span><br><span class="line">　　　　　　　　　　　　　　　　　　<span class="symbol">ResourcePatternResolver</span>   //继承<span class="symbol">ResourceLoader</span>，用于获取<span class="symbol">resource</span>对象</span><br></pre></td></tr></table></figure>

<p>在BeanFactory子类中有一个DefaultListableBeanFactory类，它包含了基本Spirng IoC容器所具有的重要功能，开发时不论是使用BeanFactory系列还是ApplicationContext系列来创建容器基本都会使用到DefaultListableBeanFactory类，可以这么说，在spring中实际上把它当成默认的IoC容器来使用。</p>
<p>关于Spirng IoC容器的初始化过程在《Spirng技术内幕：深入解析Spring架构与设计原理》一书中有明确的指出，IoC容器的初始化过程可以分为三步：</p>
<ol>
<li><font color=#FF0000>Resource定位（Bean的定义文件定位）</font></li>
<li><font color=#FF0000>将Resource定位好的资源载入到BeanDefinition </font></li>
<li><font color=#FF0000>将BeanDefiniton注册到容器中 </font></li>
</ol>
<p>如下图：</p>
<p><img src="https://i.loli.net/2020/03/25/YNAar5mMChU2Dzc.png" alt="SpringIOC初始化过程.png"></p>
<h2 id="Spring实现IOC的三种方式"><a href="#Spring实现IOC的三种方式" class="headerlink" title="Spring实现IOC的三种方式"></a>Spring实现IOC的三种方式</h2><h3 id="属性注入"><a href="#属性注入" class="headerlink" title="属性注入"></a>属性注入</h3><p>通过setXXX()方法注入Bean的属性值或者依赖对象，最常用。</p>
<ul>
<li>Spring首先会调用bean的默认构造函数实例化bean对象，然后再通过<strong>反射</strong>的方法来调用set方法来注入属性值。</li>
<li>属性注入要求bean提供一个默认的构造函数,并且得为需要注入的属性提供set方法</li>
</ul>
<h3 id="构造函数注入-构造器依赖注入"><a href="#构造函数注入-构造器依赖注入" class="headerlink" title="构造函数注入(构造器依赖注入)"></a>构造函数注入(构造器依赖注入)</h3><p>使用构造函数注入的前提是：bean必须提供带参的构造函数。</p>
<p>构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。</p>
<h3 id="工厂方法注入"><a href="#工厂方法注入" class="headerlink" title="工厂方法注入"></a>工厂方法注入</h3><p>注解的方式注入 @Autowired,@Resource,@Required。</p>
<h4 id="Autowired和-Resource的区别-重要"><a href="#Autowired和-Resource的区别-重要" class="headerlink" title="@Autowired和@Resource的区别(重要)"></a>@Autowired和@Resource的区别(重要)</h4><p>简而言之：<strong>@Autowired按<code>byType</code>(类型)自动注入</strong>，而<strong>@Resource则默认按<code>byName</code>(名字)自动注入</strong>，当然@Resource可以指定按照什么方式注入。</p>
<p>@Autowired是在Spring2.5后引入的，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。 可以通过 @Autowired的使用来消除 set ，get方法。</p>
<p>@Resource有两个属性是比较重要的，分别是<code>name</code>和<code>type</code>，Spring 将@Resource注解的<code>name</code>属性解析为bean的名字，而<code>type</code>属性则解析为bean的类型。因此，如果使用<code>name</code>属性，则使用<code>byName</code>的自动注入策略，而使用<code>type</code>属性时则使用byType自动注入策略。如果既不指定<code>name</code>也不指定<code>type</code>属性，这时将通过反射机制使用<code>byName</code>自动注入策略。</p>
<h2 id="说说你对Spring-AOP机制的理解"><a href="#说说你对Spring-AOP机制的理解" class="headerlink" title="说说你对Spring AOP机制的理解"></a>说说你对Spring AOP机制的理解</h2><p>spring核心框架里面，最关键的两个机制，就是ioc和aop，spring IOC可以根据xml配置或者注解，去实例化我们所有的bean，管理bean之间的依赖注入，让类与类之间解耦，维护代码的时候可以更加的轻松便利。</p>
<p>下面介绍Spring AOP。</p>
<p>AOP是一个编程目标，”面向切面编程”的目标。实现这个目标，有哪些手段？——其中一个手段是Spring AOP,还有一个手段是AspectJ。Spring在2.5之后借用了AspectJ的语法，借鉴了其编程风格</p>
<h3 id="为什么需要AOP？"><a href="#为什么需要AOP？" class="headerlink" title="为什么需要AOP？"></a>为什么需要AOP？</h3><p>AOP可以说是对OOP的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们<strong>需要为分散的对象引入公共行为的时候，OOP则显得无能为力</strong>。也就是说，<font color=#FF0000><strong>OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系</strong></font>。</p>
<p>例如<strong>日志功能</strong>。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</p>
<blockquote>
<p>将程序中的交叉业务逻辑（比如安全检查，日志，事务管理、缓存、对象池等），封装成一个切面，然后注入到目标对象（具体业务逻辑）中去。</p>
</blockquote>
<h3 id="代理模式-AOP实现原理"><a href="#代理模式-AOP实现原理" class="headerlink" title="代理模式(AOP实现原理)"></a>代理模式(AOP实现原理)</h3><p>之所以这里单独列出来代理模式，主要因为<font color=#FF0000>AOP就是通过代理模式实现的(静态代理、动态代理)</font></p>
<p>代理模式是23种设计模式的一种，他是指<strong>一个对象A通过持有另一个对象B，可以具有B同样的行为的模式</strong>。为了对外开放协议，B往往实现了一个接口，A也会去实现接口。但是B是“真正”实现类，A则比较“虚”，他借用了B的方法去实现接口的方法。A虽然是“伪军”，但它可以增强B，在调用B的方法前后都做些其他的事情。Spring AOP就是使用了动态代理完成了代码的动态“织入”。</p>
<p>使用代理好处还不止这些，一个工程如果依赖另一个工程给的接口，但是另一个工程的接口不稳定，经常变更协议，就可以使用一个代理，接口变更时，只需要修改代理，不需要一一修改业务代码。从这个意义上说，所有调外界的接口，我们都可以这么做，不让外界的代码对我们的代码有侵入，这叫防御式编程。代理其他的应用可能还有很多。</p>
<p><strong>上述例子中，类A写死持有B，就是B的静态代理。如果A代理的对象是不确定的，就是动态代理。</strong></p>
<blockquote>
<p>动态代理目前有两种常见的实现，jdk动态代理和cglib动态代理。</p>
<p>静态代理的实现有两种——组合和继承。一种通过组合的方式获取目标函数，一个通过继承目标类通过父类调用函数。(如果用面向对象的思路来看，能用组合就尽量用组合，因为继承出了情况的话修改代码太麻烦)。</p>
</blockquote>
<h3 id="AOP实现原理"><a href="#AOP实现原理" class="headerlink" title="AOP实现原理"></a>AOP实现原理</h3><blockquote>
<p>AOP 实现的关键就在于 AOP 框架自动创建的 AOP 代理，AOP 代理则可分为静态代理和动态代理两大类，其中静态代理是指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强；而动态代理则在运行时借助于 JDK 动态代理、CGLIB 等在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。</p>
</blockquote>
<p>实现AOP(不是Spring AOP，而是AOP技术，即Spring AOP和AspectJ)的技术，主要分为两大类：</p>
<ul>
<li>一是采用<strong>动态代理技术</strong>(Spring AOP)，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；</li>
<li>二是采用<strong>静态织入(静态代理)</strong>的方式(AspectJ)，引入特定的语法创建“切面”，从而使得编译器可以在编译期间织入有关“切面”的代码.</li>
</ul>
<h2 id="JDK和CGLib动态代理性能对比"><a href="#JDK和CGLib动态代理性能对比" class="headerlink" title="JDK和CGLib动态代理性能对比"></a>JDK和CGLib动态代理性能对比</h2><p><strong>JDK动态代理基于接口、CGLib基于子类</strong>。</p>
<p>关于两者之间的性能的话，JDK动态代理所创建的代理对象，在以前的JDK版本中，性能并不是很高，虽然在高版本中JDK动态代理对象的性能得到了很大的提升，但是他也并不是适用于所有的场景。主要体现在<strong>创建的实例对象的性能</strong>和<strong>创建对象需要花费的时间</strong>这两个指标中：</p>
<p>1、CGLib所创建的动态代理对象在实际运行时候的<strong>性能要比JDK动态代理高不少</strong>，有研究表明，<strong>大概要高10倍</strong>；</p>
<p>2、但是CGLib在创建对象的时候所<strong>花费的时间却比JDK动态代理要多很多</strong>，有研究表明，大概有<strong>8倍的差距</strong>；</p>
<p>因此，<strong>对于singleton的代理对象或者具有实例池的代理，因为无需频繁的创建代理对象，所以比较适合采用CGLib动态代理，反之，则比较适用JDK动态代理</strong>。</p>
<p>除了创建对象的性能和花费的时间之外，其他差别：</p>
<ul>
<li>JDK动态代理需要实现接口，而CGlib没有这个限制。但是CGlib不能代理final类或者final方法</li>
</ul>
<p><a href="https://blog.csdn.net/xlgen157387/article/details/82497594" target="_blank" rel="noopener">Spring AOP中的JDK和CGLib动态代理哪个效率更高？</a></p>
<p><a href="https://blog.csdn.net/flyfeifei66/article/details/81481222" target="_blank" rel="noopener">Java两种动态代理JDK动态代理和CGLIB动态代理</a></p>
<h2 id="画一张图说说Spring的核心架构？"><a href="#画一张图说说Spring的核心架构？" class="headerlink" title="画一张图说说Spring的核心架构？"></a>画一张图说说Spring的核心架构？</h2><p>spring容器的执行的核心原理实际上可以用bean的流程来表述。</p>
<p>spring和新架构比较简单，但是实现细节很复杂。你在系统里用xml或者注解，定义一大堆的bean，然后整个过程就是对bean进行操作。</p>
<p>比如你要用AOP进行一些增强，可能用到<strong>动态代理</strong>，或者IOC的<strong>反射</strong>，得到bean的对象实例。</p>
<p><img src="https://i.loli.net/2020/04/08/PQgf5M7T1RIax49.png" alt="spring容器的核心流程.png"></p>
<h2 id="Spring-Bean是什么"><a href="#Spring-Bean是什么" class="headerlink" title="Spring Bean是什么"></a>Spring Bean是什么</h2><p>被称作 bean 的对象是构成应用程序的支柱也是由 Spring IoC 容器管理的。<strong>bean 是一个被实例化，组装，并通过 Spring IoC 容器所管理的对象</strong>。这些 bean 是由用容器提供的配置元数据创建。</p>
<h2 id="一个Spring-Bean定义包含什么"><a href="#一个Spring-Bean定义包含什么" class="headerlink" title="一个Spring Bean定义包含什么"></a>一个Spring Bean定义包含什么</h2><p>bean 定义包含称为<strong>配置元数据</strong>的信息。</p>
<p>Spring IOC容器管理Bean时，需要了解Bean的类名、名称、依赖项、属性、生命周期及作用域等信息。为此，Spring IOC提供了一系列配置项，用于Bean在IOC容器中的定义。已创建的Bean类需要在Spring配置文件中进行定义，Spring IOC容器才能对Bean进行组配和管理。</p>
<p>一些配置项如下表所示：</p>
<p><img src="https://i.loli.net/2020/03/25/PWQAFcpv4hqM9Ze.png" alt="bean的一些配置项.png"></p>
<h2 id="Spring的两种IOC容器——BeanFactory和ApplicationContext"><a href="#Spring的两种IOC容器——BeanFactory和ApplicationContext" class="headerlink" title="Spring的两种IOC容器——BeanFactory和ApplicationContext"></a>Spring的两种IOC容器——BeanFactory和ApplicationContext</h2><p>Spring 容器是 Spring 框架的核心。容器将创建对象，把它们连接在一起，配置它们，并管理他们的整个生命周期从创建到销毁。Spring 容器使用依赖注入（DI）来管理组成一个应用程序的组件。这些对象被称为 Spring Beans.</p>
<p>通过阅读配置元数据提供的指令，容器知道对哪些对象进行实例化，配置和组装。配置元数据可以通过 XML，Java 注释或 Java 代码来表示。下图是 Spring 如何工作的高级视图。 </p>
<p><img src="https://i.loli.net/2020/03/25/nEIgC9TfwFkYr1s.png" alt="Spring如何工作的高级视图.png"></p>
<p>Spring IoC 容器利用 Java 的 POJO 类和配置元数据来生成完全配置和可执行的系统或应用程序。</p>
<p>Spring提供了两种不同类型的容器：</p>
<ul>
<li><strong>BeanFactory容器</strong>，最简单的容器(太简单了，功能实现比较少，不推荐了)，给DI提供了基本支持。</li>
<li><strong>ApplicationContext容器</strong>，该容器添加了更多的企业特定的功能，例如从一个属性文件中解析文本信息的能力，发布应用程序事件给感兴趣的事件监听器的能力。该容器是由 org.springframework.context.ApplicationContext 接口定义。</li>
</ul>
<p>两者区别：<strong>ApplicationContext 容器包括 BeanFactory 容器的所有功能，所以通常建议使用 ApplicationContext。BeanFactory 仍然可以用于轻量级的应用程序，如移动设备或基于 applet 的应用程序，其中它的数据量和速度是显著。</strong></p>
<h3 id="Spring的基本模块——BeanFactory-BeanFactory容器"><a href="#Spring的基本模块——BeanFactory-BeanFactory容器" class="headerlink" title="Spring的基本模块——BeanFactory(BeanFactory容器)"></a>Spring的基本模块——BeanFactory(BeanFactory容器)</h3><p>BeanFactory是基本的Spring模块，提供spring 框架的基础功能，BeanFactory 是 任何以spring为基础的应用的核心。Spring 框架建立在此模块之上，它使Spring成为一个容器。</p>
<p>Bean 工厂是工厂模式的一个实现，提供了控制反转功能，用来把应用的配置和依赖从真正的应用代码中分离。</p>
<p>最常用的BeanFactory 实现是<strong>XmlBeanFactory</strong> 类。即org.springframework.beans.factory.xml.XmlBeanFactory ，它根据XML文件中的定义加载beans。这个容器从一个 XML 文件中读取配置元数据，由这些元数据来生成一个被配置化的系统或者应用。</p>
<p>需要注意，在资源宝贵的移动设备或者基于 applet 的应用当中， BeanFactory 会被优先选择。否则，一般使用的是 ApplicationContext，除非你有更好的理由选择 BeanFactory。</p>
<h3 id="ApplicationContext是什么？通常的实现是什么"><a href="#ApplicationContext是什么？通常的实现是什么" class="headerlink" title="ApplicationContext是什么？通常的实现是什么?"></a>ApplicationContext是什么？通常的实现是什么?</h3><p><em>Application Context</em> 是 spring 中较高级的容器。和 BeanFactory 类似，它可以加载配置文件中定义的 bean，将所有的 bean 集中在一起，当有请求的时候分配 bean。 另外，它增加了企业所需要的功能，比如，从属性文件从解析文本信息和将事件传递给所指定的监听器。这个容器在 <em>org.springframework.context.ApplicationContext interface</em> 接口中定义。</p>
<ul>
<li><strong>FileSystemXmlApplicationContext</strong> ：此容器从一个<strong>XML文件</strong>中加载已被定义的bean。在这里，你<font color=#FF0000>需要提供给构造器 XML 文件的完整路径</font></li>
<li><strong>ClassPathXmlApplicationContext</strong>：该容器从 XML 文件中加载已被定义的 bean。在这里，你<font color=#FF0000>不需要提供 XML 文件的完整路径</font>，只需正确配置 CLASSPATH 环境变量即可，因为，容器会从 CLASSPATH 中搜索 bean 配置文件。</li>
<li><strong>WebXmlApplicationContext</strong>：此容器加载一个XML文件，此文件定义了一个WEB应用的所有bean。</li>
</ul>
<h3 id="BeanFactory和ApplicationContext有什么区别？"><a href="#BeanFactory和ApplicationContext有什么区别？" class="headerlink" title="BeanFactory和ApplicationContext有什么区别？"></a>BeanFactory和ApplicationContext有什么区别？</h3><p>ApplicationContext 包含 BeanFactory 所有的功能，一般情况下，相对于 BeanFactory，ApplicationContext 会被推荐使用。BeanFactory 仍然可以在轻量级应用中使用，比如移动设备或者基于 applet 的应用程序。</p>
<p><code>ApplicationContext</code>在<code>BeanFactory</code>的基础上实现的额外功能：</p>
<ul>
<li><p>默认初始化所有的Singleton，也可以通过配置取消预初始化。</p>
</li>
<li><p>继承MessageSource，因此<strong>支持国际化</strong>。</p>
</li>
<li><p>继承ResourceLoader，可以资源访问，比如访问URL和文件。</p>
</li>
<li><p>事件机制，比如发送消息、相应机制(ApplicationEventPublisher)。</p>
</li>
<li><p>可以载入多个(有继承关系)的上下文，使得每一个上下文都专注于一个特定的层次，比如应用的web层。</p>
</li>
<li><p>支持Spring的AOP(最常用的是拦截器，一般实现<code>HandlerInterceptor</code>，其中有三个方法：preHandle、postHandle、afterCompletion)。</p>
</li>
</ul>
<blockquote>
<p>注：由于ApplicationContext会预先初始化所有的Singleton Bean，于是在系统创建前期会有较大的系统开销，但一旦ApplicationContext初始化完成，程序后面获取Singleton Bean实例时候将有较好的性能。也可以为bean设置lazy-init属性为true，即Spring容器将不会预先初始化该bean。</p>
</blockquote>
<p>参考文章：<a href="https://blog.csdn.net/pythias_/article/details/82752881" target="_blank" rel="noopener">BeanFactory和ApplicationContext的区别</a></p>
<h2 id="Spring-Bean加载机制"><a href="#Spring-Bean加载机制" class="headerlink" title="Spring Bean加载机制"></a>Spring Bean加载机制</h2><p>将Bean类添加到Spring IOC容器有三种方式</p>
<ul>
<li>一种方式是基于XML的配置文件；(现在很不推荐用，太久远了)</li>
<li>一种方式是基于注解的配置(Annotation-based configuration，从Spring2.5开始)；</li>
<li>一种方式是基于Java的配置(java-based configuration, 从Spring3.0开始)</li>
</ul>
<h2 id="Spring-Bean的生命周期-重要"><a href="#Spring-Bean的生命周期-重要" class="headerlink" title="Spring Bean的生命周期(重要)"></a>Spring Bean的生命周期(重要)</h2><p>理解 Spring bean 的生命周期很容易。当一个 bean 被实例化时，它可能需要执行一些初始化使它转换成可用状态。同样，当 bean 不再需要，并且从容器中移除时，可能需要做一些清除工作。</p>
<p>尽管还有一些在 Bean 实例化和销毁之间发生的活动，但是本章将只讨论两个重要的生命周期回调方法，它们在 bean 的初始化和销毁的时候是必需的。</p>
<p>为了定义安装和拆卸一个 bean，我们只要声明带有 init-method 和/或 destroy-method 参数的 。init-method 属性指定一个方法，在实例化 bean 时，立即调用该方法。同样，destroy-method 指定一个方法，只有从容器中移除 bean 之后，才能调用该方法。</p>
<p>首先<strong>大体看一下</strong>，Spring Bean的生命周期可以分为八步：</p>
<p>（1）<strong>实例化Bean</strong>：如果要使用一个bean的话会实例化这个Bean</p>
<p>（2）<strong>设置对象属性（依赖注入）</strong>：spring容器需要去看看，你的这个bean依赖了谁，把你依赖的bean也创建出来，给你进行一个注入，比如说通过构造函数，setter</p>
<p>举个例子，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyDao myDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">(MyDao myDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myDao = myDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyDao</span><span class="params">(MyDao myDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myDao = myDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）<strong>处理并调用Aware接口</strong>：如果这个Bean已经实现了<code>ApplicationContextAware</code>接口，spring容器就会调用我们的bean的setApplicationContext(ApplicationContext)方法，传入Spring上下文，把spring容器给传递给这个bean</p>
<p>（4）调用<strong>BeanPostProcessor</strong>方法：如果我们想在bean实例构建好了之后，此时在这个时间点，我们想要对Bean进行一些自定义的处理，那么可以让Bean实现了<code>BeanPostProcessor</code>接口，那将会调用<code>postProcessBeforeInitialization(Object obj, String s)</code>方法。</p>
<p>（5）<strong>InitializingBean 与 init-method</strong>：如果Bean在Spring配置文件中配置了 init-method 属性，则会自动调用其配置的初始化方法。</p>
<p>（6）如果这个Bean实现了BeanPostProcessor接口，将会调用postProcessAfterInitialization(Object obj, String s)方法。这步完成之后，整个Bean就已经初始化好了，后面开始使用。</p>
<p>（7）<strong>DisposableBean</strong>：当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，会调用其实现的destroy()方法；</p>
<p>（8）<strong>destory-method</strong>：最后，如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法。</p>
<p>整个过程大体描述：创建+初始化一个bean -&gt; spring容器管理的bean长期存活 -&gt; 销毁bean（两个回调函数）</p>
<p><strong>更详细地来看</strong>，Spring Bean的生命周期可以分得更细：</p>
<p><a href="https://blog.csdn.net/w_linux/article/details/80086950?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">参考文章：Spring了解Bean的一生(生命周期)</a></p>
<p><a href="https://www.jianshu.com/p/3944792a5fff" target="_blank" rel="noopener">Spring Bean的生命周期</a> ,这篇文章也包含案例</p>
<h3 id="ApplicationContext-Bean的生命周期"><a href="#ApplicationContext-Bean的生命周期" class="headerlink" title="ApplicationContext Bean的生命周期"></a>ApplicationContext Bean的生命周期</h3><p><img src="https://i.loli.net/2020/03/25/HypdfUSJNYqAEzG.png" alt="ApplicationContextBean的生命周期.png"></p>
<p>ApplicationContext容器中，Bean的生命周期流程如上图所示，流程大致如下：</p>
<p>1.首先容器启动后，会对scope为singleton且非懒加载的bean进行实例化，</p>
<p>2.按照Bean定义信息配置信息，注入所有的属性，</p>
<p>3.如果Bean实现了BeanNameAware接口，会回调该接口的setBeanName()方法，传入该Bean的id，此时该Bean就获得了自己在配置文件中的id，</p>
<p>4.如果Bean实现了BeanFactoryAware接口,会回调该接口的setBeanFactory()方法，传入该Bean的BeanFactory，这样该Bean就获得了自己所在的BeanFactory，</p>
<p>5.如果Bean实现了ApplicationContextAware接口,会回调该接口的setApplicationContext()方法，传入该Bean的ApplicationContext，这样该Bean就获得了自己所在的ApplicationContext，</p>
<p>6.如果有Bean实现了BeanPostProcessor接口，则会回调该接口的postProcessBeforeInitialzation()方法，</p>
<p>7.如果Bean实现了InitializingBean接口，则会回调该接口的afterPropertiesSet()方法，</p>
<p>8.如果Bean配置了init-method方法，则会执行init-method配置的方法，</p>
<p>9.如果有Bean实现了BeanPostProcessor接口，则会回调该接口的postProcessAfterInitialization()方法，</p>
<p>10.经过流程9之后，就可以正式使用该Bean了,对于scope为singleton的Bean,Spring的ioc容器中会缓存一份该bean的实例，而对于scope为prototype的Bean,每次被调用都会new一个新的对象，期生命周期就交给调用方管理了，不再是Spring容器进行管理了</p>
<p>11.容器关闭后，如果Bean实现了DisposableBean接口，则会回调该接口的destroy()方法，</p>
<p>12.如果Bean配置了destroy-method方法，则会执行destroy-method配置的方法，至此，整个Bean的生命周期结束</p>
<h3 id="BeanFactory-Bean的生命周期"><a href="#BeanFactory-Bean的生命周期" class="headerlink" title="BeanFactory Bean的生命周期"></a>BeanFactory Bean的生命周期</h3><p><img src="https://i.loli.net/2020/03/25/NU6EPjKc7n2To1L.png" alt="BeanFactory Bean生命周期.png"></p>
<p>BeanFactoty容器中, Bean的生命周期如上图所示，与ApplicationContext相比，有如下几点不同:</p>
<p>1.BeanFactory容器中，不会调用ApplicationContextAware接口的setApplicationContext()方法，</p>
<p>2.BeanPostProcessor接口的postProcessBeforeInitialzation()方法和postProcessAfterInitialization()方法不会自动调用，必须自己通过代码手动注册</p>
<p>3.BeanFactory容器启动的时候，不会去实例化所有Bean,包括所有scope为singleton且非懒加载的Bean也是一样，而是在调用的时候去实例化。</p>
<h2 id="哪些是重要的bean生命周期方法？-你能重载它们吗？-setup和teardown"><a href="#哪些是重要的bean生命周期方法？-你能重载它们吗？-setup和teardown" class="headerlink" title="哪些是重要的bean生命周期方法？ 你能重载它们吗？(setup和teardown)"></a>哪些是重要的bean生命周期方法？ 你能重载它们吗？(setup和teardown)</h2><p>有两个重要的bean 生命周期方法，第一个是setup ， 它是在容器加载bean的时候被调用。第二个方法是 teardown  它是在容器卸载类的时候被调用。</p>
<p>bean 标签有两个重要的属性（init-method和destroy-method）。用它们你可以自己定制初始化和注销方法。它们也有相应的注解（@PostConstruct和@PreDestroy）。</p>
<p>换句话说：为了定义安装和拆卸一个 bean，我们只要声明带有 init-method 和/或 destroy-method 参数的 。init-method 属性指定一个方法(setup)，在实例化 bean 时，立即调用该方法。同样，destroy-method 指定一个方法(teardown)，只有从容器中移除 bean 之后，才能调用该方法。</p>
<h2 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h2><p>在IoC容器启动之后，并不会马上就实例化相应的bean，此时容器仅仅拥有所有对象的BeanDefinition(BeanDefinition：是容器依赖某些工具加载的XML配置信息进行解析和分析，并将分析后的信息编组为相应的BeanDefinition)。只有当getBean()调用时才是有可能触发Bean实例化阶段的活动。</p>
<p>当在 Spring 中定义一个 时，你必须声明该 bean 的作用域的选项。例如，为了强制 Spring 在每次需要时都产生一个新的 bean 实例，你应该声明 bean 的作用域的属性为 prototype。同理，如果你想让 Spring 在每次需要时都返回同一个bean实例，你应该声明 bean 的作用域的属性为 singleton。</p>
<p>Spring 框架支持以下五个作用域，如果你使用 web-aware ApplicationContext 时，其中三个是可用的。</p>
<p>如下表：</p>
<p><img src="https://i.loli.net/2020/03/25/iJZPArWfomIY9M6.png" alt="Bean的作用域.png"></p>
<p><strong>在实际开发中，用得最多的是singleton，prototype偶尔也会用。也就是说，大部分情况每个bean都只有一个实例</strong>。99.99%的时候用得都是singleton。</p>
<h2 id="Spring中的bean是线程安全的么？-重要"><a href="#Spring中的bean是线程安全的么？-重要" class="headerlink" title="Spring中的bean是线程安全的么？(重要)"></a>Spring中的bean是线程安全的么？(重要)</h2><p>首先，这个答案是<strong>不一定</strong>，<font color=#FF0000>Spring框架中的单例bean不一定是线程安全的</font>。如果针对的是在Bean中放入的线程不安全的状态变量，比如int data，然后执行线程不安全的操作，比如data++，那么就是线程不安全的(这个可以结合Bean的作用域默认为singleton)。但是，如果在Bean里面放入线程安全的状态变量，比如<code>ConcurrentHashMap</code>，那么系统是线程安全的。</p>
<p>要讲清楚spring bean是不是线程安全的，要先讲一下Bean的作用域(上一节已经讲了)。bean默认的作用域是singleton，即单例，也是99.99%的情况下使用。</p>
<p>虽然一般情况下@Controller类不会有自己的变量，但是如果定义了，比如定义了一个<code>data</code>，那么每次执行<code>data++</code>的时候，是线程不安全的。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServiceImpl</span> <span class="keyword">implements</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> data;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为MyServiceImpl只有一个对象实例(Spring Bean的singleton)，而data是这个实例中的一个比量，所以在面对多线程执行的时候，是有可能出现多线程访问造成的data值出错的情况的。</p>
<p>需要注意Tomcat本身是会开多线程的，可能同时有多个请求发送，多个线程可能会同时调用同一个bean的对象实例，就是这里的data，而且都执行data++，则可能会出错。</p>
<p>但是，<strong>对于java web系统来说，一般来说很少在spring bean里放一些实例变量，一般来说他们都是多个组件互相调用，最终去访问数据库的</strong>。也就是说一般不会在Spring 的Service和Controller组件里面定义变量，所以大部分变量没有所谓的状态。因此虽然Spring Bean单例下是线程不安全的，但是多个线程不会访问内存中的共享数据，而大部分情况是会造成多个线程并发通过实例访问数据库，<strong>并不会对实例的状态变量有什么影响</strong>。</p>
<h2 id="Spring-Bean小结"><a href="#Spring-Bean小结" class="headerlink" title="Spring Bean小结"></a>Spring Bean小结</h2><p>项目中的<strong>事务处理组件</strong>和<strong>实体类</strong>（POJO）可以作为Bean类，Bean类需要在Spring配置文件中进行定义，才能被IOC容器管理和组配。Spring IOC容器管理Bean时，需要了解Bean的<strong>类名、名称、依赖项、属性、生命周期及作用域等</strong>信息。为此，Spring IOC提供了一系列配置项，用于Bean在IOC容器中的定义。</p>
<h2 id="Spring事务机制"><a href="#Spring事务机制" class="headerlink" title="Spring事务机制"></a>Spring事务机制</h2><p>首先，<strong>加上了一个@Transactional注解，就会开启事务</strong>。此时就spring会使用AOP思想，对你的这个方法在执行之前，先去开启事务，执行完毕之后，根据你方法是否报错，来决定回滚还是提交事务。</p>
<p>这是<strong>Spring针对JDBC来设计的，事务和数据库的事务定义相同</strong>。</p>
<p>关于事务，老生常谈的就是ACID，然后三种事务并发可能的问题：<strong>脏读、不可重复读、幻读</strong>。针对这三种问题，设计了四种解决的隔离级别：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。</p>
<h2 id="Spring-事务中的隔离级别"><a href="#Spring-事务中的隔离级别" class="headerlink" title="Spring 事务中的隔离级别"></a>Spring 事务中的隔离级别</h2><p>而Spring的事务隔离级别就是根据上面四种隔离级别而设置的。加上”默认”的级别，一共有五种级别。具体说，TransactionDeﬁnition 接口中定义了五个表示隔离级别的常量： </p>
<ul>
<li><p><strong>TransactionDeﬁnition.ISOLATION_DEFAULT</strong>: 使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别. </p>
<ul>
<li><strong>TransactionDeﬁnition.ISOLATION_READ_UNCOMMITTED</strong>: 低的隔离级别，允许读取尚未提交的数据变 更，可能会导致脏读、幻读或不可重复读</li>
</ul>
</li>
<li><p><strong>TransactionDeﬁnition.ISOLATION_READ_COMMITTED</strong>: 允许读取并发事务已经提交的数据，可以阻止脏 读，但是幻读或不可重复读仍有可能发生</p>
</li>
<li><p><strong>TransactionDeﬁnition.ISOLATION_REPEATABLE_READ</strong>: 对同一字段的多次读取结果都是一致的，除非数据 是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。 </p>
</li>
<li><p><strong>TransactionDeﬁnition.ISOLATION_SERIALIZABLE</strong>: 高的隔离级别，完全服从ACID的隔离级别。所有的事 务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻 读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。 </p>
</li>
</ul>
<h2 id="Spring事务中的事务传播行为"><a href="#Spring事务中的事务传播行为" class="headerlink" title="Spring事务中的事务传播行为"></a>Spring事务中的事务传播行为</h2><p>Spring事务的传播机制是比较关键的一个内容。</p>
<p>举例，我现在有两个方法，方法A和方法B：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(propagation = Propagation.REQUIRED)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    doSomethingPre();</span><br><span class="line">    methodB();</span><br><span class="line">    doSomethingPost();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span>(propagation = Propagation.NESTED)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个方法都带有<code>@Transactional</code>注解，他们之间调用的时候，事务是怎样传播的呢？</p>
<p>下面讲解某个事务类型的时候，实际上所有类型的变量都是属于<code>TransactionDeﬁnition</code>中的，比如PROPAGATION_REQUIRED，实质上应该是<code>TransactionDeﬁnition.PROPAGATION_REQUIRED</code>，但是为了方便阅读，统一省略掉前面的<code>TransactionDeﬁnition</code></p>
<p>Spring中一共有<strong>七种事务</strong>。</p>
<p><strong>支持当前事务的情况</strong>：</p>
<ul>
<li><font color=#FF0000>PROPAGATION_REQUIRED</font>： 如果当前存在事务，则加入该事务；如果当前没有事 务，则创建一个新的事务。 如果什么都不设置，只写上一个<code>@Transactional</code>，那么默认就是这个事务，实际上<strong>这个也是最常用的</strong>。</li>
</ul>
<p>举例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(propagation = Propagation.REQUIRED)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    methodB();</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span>(propagation = Propagation.REQUIRED)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果直接执行了methodB，因为没有执行A，所以B会自己开启一个事务。</p>
<p>但是如果先执行了methodA,则此时执行的流程会是：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开启一个事务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行方法A的代码，接着执行方法B的代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交或者回滚事务</span></span><br></pre></td></tr></table></figure>

<ul>
<li><font color=#FF0000>PROPAGATION_SUPPORTS</font>： 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。 (<strong>比较少用</strong>)</li>
</ul>
<p>举例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(propagation = Propagation.REQUIRED)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    methodB();</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span>(propagation = Propagation.SUPPORTS)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和上面类似，但是如果此时直接先执行了methodB，那么<strong>因为当前没有事务，所以methodB会直接以非事务的方式继续运行</strong>。</p>
<p>如果先执行了methodA，那么过程和上面的PROPAGATION_REQUIRED一样，<strong>B会加入A的事务</strong>。</p>
<ul>
<li><font color=#FF0000>PROPAGATION_MANDATORY</font>： 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性），这个解释很清楚了，B加入A，或者B抛出异常。</li>
</ul>
<p><strong>不支持当前事务的情况：</strong></p>
<ul>
<li><font color=#FF0000>PROPAGATION_REQUIRES_NEW</font>： 创建一个新的事务，如果当前存在事务，则把当前事务挂起。字面解释的也很清楚，先执行了methodA，再执行methodB的时候，会挂起A，直接执行B的代码。</li>
</ul>
<p>举例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(propagation = Propagation.REQUIRED)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    doSomethingPre();</span><br><span class="line">    methodB();</span><br><span class="line">    doSomethingPost();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span>(propagation = Propagation.REQUIRES_NEW)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么执行的流程会是：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开启一个事务1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行方法A里的一些代码，doSomethingPre()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启一个事务2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行方法B里的一些代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交或者回滚事务2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行方法A里的一些代码，doSomethingPost()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交或者回滚事务1</span></span><br></pre></td></tr></table></figure>

<p>如果方法B的代码出错了，那么只会回滚B的程序，A还是能够继续执行。如果A出错了，也只会回滚A，不会回滚B，因为A和B是两个事务，互不相关。</p>
<ul>
<li><font color=#FF0000>PROPAGATION_NOT_SUPPORTED</font>： 以非事务方式运行，如果当前存在事务，则把当前事务挂起。 (<strong>很少用</strong>)</li>
<li><font color=#FF0000>PROPAGATION_NEVER</font>： 以非事务方式运行，如果当前存在事务，则抛出异常。</li>
</ul>
<p>举例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(propagation = Propagation.REQUIRED)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    doSomethingPre();</span><br><span class="line">    methodB();</span><br><span class="line">    doSomethingPost();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span>(propagation = Propagation.NEVER)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时只能以非事务方式调用methodB，也就是直接执行B。如果你先执行A，那么在执行B的时候，因为当前存在了事务A，所以程序会抛出异常！</p>
<p><strong>其他情况：</strong></p>
<ul>
<li><font color=#FF0000>PROPAGATION_NESTED</font>： 如果当前存在事务，则创建一个事务作为当前事务的<strong>嵌套事务</strong>来运行；如果当前没有事务，则该取值等价于TransactionDeﬁnition.PROPAGATION_REQUIRED。 </li>
</ul>
<p>举例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(propagation = Propagation.REQUIRED)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    doSomethingPre();</span><br><span class="line">    methodB();</span><br><span class="line">    doSomethingPost();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span>(propagation = Propagation.NESTED)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么执行流程会是：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开启一个事务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行方法A里的一些代码，doSomethingPre()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置一个回滚点，savepoint</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行方法B里的一些代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果方法B里抛出了异常，此时进行回滚，回滚到之前的savepoint</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行方法A里的一些代码，doSomethingPost()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交或者回滚事务</span></span><br></pre></td></tr></table></figure>

<p>需要注意，如果执行到了A的<code>doSomethingPost()</code>的时候出了异常，那么会把A和B全部回滚。而B如果出了异常，那么只会回滚B。</p>
<p>也就是说：嵌套事务，外层的事务如果回滚，会导致内层的事务也回滚；但是内层的事务如果回滚，仅仅是回滚自己的代码。</p>
<p><strong>需要注意</strong>，面试的时候，问事务传播机制不会直接傻乎乎地问你知不知道啥啥的，而是会营造一个场景，比如：</p>
<ol>
<li><p>我们现在有一段业务逻辑，方法A调用方法B，我希望的是如果说方法A出错了，此时仅仅回滚方法A，不能回滚方法B，必须得用<strong>REQUIRES_NEW</strong>，传播机制，让他们俩的事务是不同的。</p>
</li>
<li><p>方法A调用方法B，如果出错，方法B只能回滚他自己，方法A可以带着方法B一起回滚，<strong>NESTED</strong>嵌套事务。</p>
</li>
</ol>
<h2 id="Spring-Boot如何演化得来"><a href="#Spring-Boot如何演化得来" class="headerlink" title="Spring Boot如何演化得来"></a>Spring Boot如何演化得来</h2><p>spring boot本身是spring这个项目发展到一定阶段之后的一个产物，</p>
<p>在传统中，我们使用spring框架，mybatis，spring mvc，去做一些开发，打包部署到线上的tomcat里去，tomcat启动了，他就会接收http请求，转发给spring mvc框架，在架构中的调用顺序为：controller -&gt; service -&gt; dao -&gt; mybatis（sql语句）。</p>
<p>带了后面，在进行java web开发的时候，经常需要整合进来redis、elasticsearch、还有很多其他的一些东西，rabbitmq、zookeeper，等等，诸如此类的一些东西，会很繁杂，但是又是使用的常态。而如果没有spring boot，我们需要自己手动做很多的配置，自己去定义一些bean，流程比较繁琐。</p>
<p>为了解决这个问题，国外的spring开源社区，就发起了一个项目即spring boot，我们基于spring boot直接进行开发，里面还是使用spring + spring mvc + mybatis一些框架，我们可以一定程度上来简化我们之前的开发流程。</p>
<p>spring boot内嵌一个tomcat去直接让我们一下子就可以把写好的java web系统给启动起来，直接运行一个main方法，spring boot就直接把tomcat服务器给跑起来，把我们的代码运行起来了。</p>
<p>spring boot的另一个核心功能是<strong>自动装配</strong>，比如说我们可以引入mybatis，我其实主要引入一个starter依赖，他会一定程度上个自动完成mybatis的一些配置和定义，不需要我们手工去做大量的配置了，一定程度上简化我们搭建一个工程的成本。</p>
<p>也就是说，如果没有spring boot，如果要使用mybatis，我们要引入一些mybatis的jar包，还有mybatis依赖的一些其他的jar包，然后动手编写一些xml配置文件，然后定义一些bean，写一些sql语句，写一些dao代码，之后才可以使用mybatis去执行sql语句。</p>
<p>但是用了spring boot之后，只要引入一个starter，他会自动给你引入需要的一些jar包，做非常简单的、必须的一些配置，比如数据库的地址，几乎就不用你做太多的其他额外的配置了，他会自动帮你去进行一些配置，定义和生成对应的bean。生成的bean会自动注入比如你的dao里去，让你免去一些手工配置+定义bean的一些工作。</p>
<p>很多人意识到了spring开发的复杂性，想到了<font color=#FF0000>约定大于配置</font>的思路，spring boot + spring + spirng mvc + mybatis + XXX之类的技术去进行开发，后续很多配置和定义的一些繁琐的重复性的工作就免去了，自动装配的一些功能，自动给你把一些事情干完了，不需要你去做了。</p>
<h2 id="Spring-Boot启动流程"><a href="#Spring-Boot启动流程" class="headerlink" title="Spring Boot启动流程"></a>Spring Boot启动流程</h2><ol>
<li>配置Environment</li>
<li>准备Context上下文，包括执行 ApplicationContext 的后置处理、初始化 Initializer、通知Listener 处理 ContextPrepared 和 ContextLoaded 事件。</li>
<li>执行 refreshContext，也就是前面介绍过的 AbstractApplicationContext 类的 refresh 方法。</li>
</ol>
<p>在SpringBoot中有两种上下文，一种是bootstrap,另外一种是application：</p>
<ul>
<li>bootstrap是应用程序的父上下文，会先于applicaton加载。bootstrap 主要用于从额外的资源来加载配置信息，还可以在本地外部配置文件中解密属性。</li>
<li>bootstrap 里面的属性会优先加载，默认也不能被本地相同配置覆盖。</li>
</ul>
<h2 id="能画一张图说说Spring-Boot的核心架构吗？"><a href="#能画一张图说说Spring-Boot的核心架构吗？" class="headerlink" title="能画一张图说说Spring Boot的核心架构吗？"></a>能画一张图说说Spring Boot的核心架构吗？</h2><p>假定一个场景，就是我们已经有了一个spring的传统模式开发的系统，如图：</p>
<p><img src="https://i.loli.net/2020/04/08/Es9wfnRFGDugQkV.png" alt="初始项目.png"></p>
<p>在使用了spring boot之后，会调用spring boot的main方法，自动启动一个内嵌的tomcat。</p>
<p>启动spring boot之后，你肯定会使用很多框架来完成任务，所以Tomcat运行起来之后，必然会把spring mvc核心的Servlet、Filter注册到Tomcat中。</p>
<p>然后spring boot会自动完成bean的装配和定义，一些Mybatis的bean会注入到mybatis的核心组件等等，最后程序访问的很多bean都是spring boot自动装配的。</p>
<p>使用spring boot之后的框架图如下：</p>
<p><img src="https://i.loli.net/2020/04/08/nq23vyUlmeP9cGd.png" alt="引入spring boot之后.png"></p>
<h2 id="Spring-中都用了哪些设计模式？"><a href="#Spring-中都用了哪些设计模式？" class="headerlink" title="Spring 中都用了哪些设计模式？"></a>Spring 中都用了哪些设计模式？</h2><p>实际上Spring中用到很多设计模式，简单举三个例子：工厂模式，单例模式，代理模式。下面一个一个简单地介绍：</p>
<p><strong>工厂模式</strong>：</p>
<p>工厂模式主要用在IOC，一个例子如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyService myService = MyServiceFactory.getMyService();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServiceFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyService <span class="title">getMyService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是一个典型的工厂模式，我把MyService对象的创建封装在了MyServiceFactory工厂里面(一般创建的时候使用静态的方法)。之后每次我想使用它的时候，直接通过工厂把它拿出来即可。</p>
<p>spring ioc核心的设计模式的思想就是工厂模式，他自己就是一个大的工厂，把所有的bean实例都给放在了spring容器里（大工厂），如果你要使用bean，就找spring容器就可以了，你自己不用创建对象了。</p>
<p><strong>单例模式</strong>：</p>
<p>spring默认对每个bean走的都是一个单例模式，确保说你的一个类在系统运行期间只有一个实例对象，只有一个bean，用到了一个单例模式的思想，保证了每个bean都是单例的。</p>
<p>单例模式的经典写法：双check+volatile+synchronized基本耳熟能详，这里用MyService类再次写出来一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> MyService myService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyService</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyService <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(myService == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(MyService<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(myService == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    myService = <span class="keyword">new</span> MyService();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> myService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代理模式</strong>：</p>
<p>相比理解门槛更低的工厂模式和单例模式，代理模式算是稍微更有含金量的。</p>
<p>一般出现在你要对一些类的方法切入一些增强的代码，此时会创建一些动态代理的对象(比如称作B)，让你对那些目标对象(比如称作A)的访问，A先经过动态代理对象B，让动态代理的对象B先做一些增强的代码，然后再调用你的目标对象A，这样A的行为就在原有基础上有了变化或者叫增强。</p>
<p>在设计模式里，就是一个代理模式的体现和运用，让动态代理的对象，去代理了你的目标对象，在这个过程中做一些增强的访问，你可以把面试突击的内容作为一个抛砖引玉的作用，去更加深入的学习一些技术</p>
<h2 id="用一张图说说Spring-Web-MVC的核心架构"><a href="#用一张图说说Spring-Web-MVC的核心架构" class="headerlink" title="用一张图说说Spring Web MVC的核心架构"></a>用一张图说说Spring Web MVC的核心架构</h2><p>首先，这张图可以很生动地展现整个过程：</p>
<p><img src="https://i.loli.net/2020/04/12/IEZxvXmzLVPCgBT.png" alt="SpringWebMVC架构.png"></p>
<p>客户端发送请求-&gt; 前端控制器 DispatcherServlet 接受客户端请求 -&gt; 找到处理器映射 HandlerMapping 解析请求对应的 Handler-&gt; HandlerAdapter 会根据 Handler 来调用真正的处理器开处理请求，并处理相应的业务逻辑 -&gt; 处理器返回一个模型视图 ModelAndView -&gt; 视图解析器进行解析 -&gt; 返回一个视图对象-&gt;前端控制器 DispatcherServlet 渲染数据（Model）-&gt;将得到视图对象返回给用户 。</p>
<p>另外一种流程解析：</p>
<p>（1）tomcat的工作线程将请求转交给spring mvc框架的DispatcherServlet</p>
<p>（2）发送查找请求给处理器映射器HandlerMapping，如果能查找到内容，则返回执行链给前端控制器。</p>
<p>（3）前端控制器拿到返回的执行链之后，发送请求给处理适配器去执行Handler</p>
<p>（4）DispatcherServlet查找@Controller注解的controller，我们一般会给controller加上一个@RequestMapping的注解，标注说哪些controller用来处理哪些请求，之后处理器适配器会根据请求的uri，去定位到哪个controller来进行处理。</p>
<p>（5）根据@RequestMapping去查找，使用这个controller内的哪个方法来进行请求的处理，对每个方法一般也会加@RequestMapping的注解</p>
<p>（6）处理器(Handler，或者会被叫做controller)会直接调用对应的某个方法来进行请求处理，处理结束后返回一个ModelAndView视图给处理器适配器。</p>
<p>注意！我们的controller的方法会有一个返回值，以前的时候，一般来说还是走jsp、模板技术，我们会把前端页面放在后端的工程里面，返回一个页面模板的名字，spring mvc的框架使用模板技术，对html页面做一个渲染；返回一个json串，前后端分离，可能前端发送一个请求过来，我们只要返回json数据。即：<strong>处理完毕后，分为两种方式返回。一是前端页面放在后端工程时，可以返回对应的页面模板名字，然后springmcv使用模板技术进行渲染后返回。二是前后端分离以后，直接返回前端所需JSON串即可。</strong></p>
<p>（8）再把渲染以后的html页面返回给浏览器去进行显示；前端负责把html页面渲染给浏览器就可以了</p>
<h2 id="一张图说说Spring-Cloud的核心架构"><a href="#一张图说说Spring-Cloud的核心架构" class="headerlink" title="一张图说说Spring Cloud的核心架构"></a>一张图说说Spring Cloud的核心架构</h2><p>如下图所示：</p>
<p><img src="https://i.loli.net/2020/04/08/RnUL7NdKGpWYM1o.png" alt="Spring Cloud核心架构整体图.png"></p>
<p>Spring Cloud的部分主要在图的左边和上边。</p>
<p>这里只是简单说说Spring Cloud的架构，传统方法的spring boot、spring、spring mvc是让你开发那种单体架构的系统，而spring cloud是让你去开发分布式系统，让你把系统拆分为很多的子系统，子系统互相之间进行请求和调用，也可以比较方便地迁移微服务。</p>
<p>比较常用的组件：</p>
<ul>
<li><p>zuul：网关，前面部署一个网关，所有请求发送到网关上，然后从网关往外去请求Tomcat来得到服务内容。</p>
</li>
<li><p>eureka 服务注册中心，服务可以通过Spring Boot内嵌的Tomcat启动，启动之后，会进行服务注册。这样之后再调用服务的时候会进行服务发现，发现其他服务的地址。</p>
</li>
<li><p>ribbon、feign：先通过ribbon由负载均衡随机地挑选一台机器，然后通过feign构造HTTP请求，再把这个请求发送到其他服务上。过程使用远程RPC调用。</p>
</li>
<li><p>hystrix主要用于服务之间调用的熔断、隔离、降级。</p>
</li>
<li><p>链路追踪等等其他组件，这些组件都是服务于分布式系统的</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Interview Note</category>
      </categories>
      <tags>
        <tag>Interview</tag>
        <tag>Intergrated</tag>
      </tags>
  </entry>
  <entry>
    <title>List-Map-Analysis</title>
    <url>/2020/03/20/List-Map-Analysis/</url>
    <content><![CDATA[<blockquote>
<p>世上无难事，只要肯攀登——毛泽东</p>
</blockquote>
<a id="more"></a>

<p>推荐参考文章：<a href="https://blog.csdn.net/weixin_41796401/article/details/104321419?utm_source=app" target="_blank" rel="noopener">java集合之HashMap源码分析(常用函数，扩容，哈希冲突，线程不安全问题，HashSet)</a></p>
<h1 id="ArrayList源码解析及设计思路"><a href="#ArrayList源码解析及设计思路" class="headerlink" title="ArrayList源码解析及设计思路"></a>ArrayList源码解析及设计思路</h1><p>提纲挈领地说，主要从ArrayList整体架构出发，考虑到新增、扩容、删除、迭代等内容。</p>
<p>ArrayList其实就是围绕底层数组，各个API都是对数组的操作进行封装，使用者使用的时候对底层无需感知，只要关注如何使用即可。</p>
<p><strong>ArrayList是线程不安全的</strong>，多线程情况下更推荐使用线程安全的类：Collections#synchronizedList。</p>
<p>如果我们不指定位置直接添加元素时(add(E element))，元素会默认会添加在最后，不会触发底层数组的复制，不考虑底层数组自动扩容的话，时间复杂度为O(1) ，在指定位置添加元素(add(int index, E element))，需要复制底层数组，根据最坏打算，时间复杂度是O(n)。</p>
<h2 id="ArrayList整体架构"><a href="#ArrayList整体架构" class="headerlink" title="ArrayList整体架构"></a>ArrayList整体架构</h2><p>ArrayList底层就是一个数组，如图：</p>
<p><img src="https://i.loli.net/2020/03/16/6qckhNGguBS95KQ.png" alt="ArrayList底层结构.png"></p>
<p>和数组一样，index下标从0开始，然后上图数组的名字是<code>elementData</code>。</p>
<p>除了上面这两个概念，源码中还有下面三个基础概念：</p>
<ul>
<li>DEFAULT_CAPACITY 表示数组的初始大小，默认是 10，这个数字要记住；</li>
<li>size 表示当前数组的大小，类型 int，因为没有使用 volatile 修饰，所以是非线程安全的；</li>
<li>modCount 统计当前数组被修改的版本次数，每当这个结构发生结构变动的时候，会 +1。</li>
</ul>
<p>然后，在ArrayList的类注释中有下面比较重要的四点：</p>
<ol>
<li>ArrayList允许put null值，而且会自动扩容;</li>
<li>size()、isEmpty()、get()、set()、add()等方法的时间复杂度都是O(1);</li>
<li>ArrayList不是线程安全的，多线程情况下更推荐使用线程安全的类：Collections#synchronizedList;</li>
<li>增强 for 循环，或者使用迭代器迭代过程中，如果数组大小被改变，会快速失败，抛出异常。</li>
</ol>
<h2 id="源码解析-未完成"><a href="#源码解析-未完成" class="headerlink" title="源码解析(未完成)"></a>源码解析(未完成)</h2><p>源码解析主要集中在ArrayList的初始化、新增与扩容、删除元素、迭代器等方面</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化有三种方法：无参数直接初始化、指定大小初始化、指定初始数据初始化</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> static final Object<span class="literal">[]</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无参数直接初始化，数组大小为空</span></span><br><span class="line">public <span class="constructor">ArrayList()</span> &#123;</span><br><span class="line">    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定初始数据初始化</span></span><br><span class="line">public <span class="constructor">ArrayList(Collection&lt;? <span class="params">extends</span> E&gt; <span class="params">c</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//elementData 是保存数组的容器，默认为 null</span></span><br><span class="line">    elementData = c.<span class="keyword">to</span><span class="constructor">Array()</span>;</span><br><span class="line">    <span class="comment">//如果给定的集合（c）数据有值</span></span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="comment">//如果集合元素类型不是 Object 类型，我们会转成 Object</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.get<span class="constructor">Class()</span> != Object<span class="literal">[]</span>.<span class="keyword">class</span>) &#123;</span><br><span class="line">            elementData = <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span>copy<span class="constructor">Of(<span class="params">elementData</span>, <span class="params">size</span>, Object[].<span class="params">class</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 给定集合（c）无值，则默认空数组</span></span><br><span class="line">        this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要补充：</p>
<ol>
<li>ArrayList无参构造器初始化的时候，默认大小是空数组，并不是大家常说的 10，10 是在第一次 add 的时候扩容的数组值。</li>
<li>指定初始数据初始化时，我们发现一个这样子的注释 see 6260652，这是 Java 的一个 bug，意思是当给定集合内的元素不是 Object 类型时，我们会转化成 Object 的类型。这个BUG在JDK9中被解决。</li>
</ol>
<h3 id="新增和扩容实现"><a href="#新增和扩容实现" class="headerlink" title="新增和扩容实现"></a>新增和扩容实现</h3><p>新增就是往数组中添加元素，主要分成两步：</p>
<ol>
<li>判断是否需要扩容，如果需要执行扩容操作；</li>
<li>直接赋值。</li>
</ol>
<p>两步的源码如下：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//确保数组大小是否足够，不够执行扩容，size 为当前数组的大小</span></span><br><span class="line">  ensureCapacityInternal(<span class="built_in">size</span> + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">  <span class="comment">//直接赋值，线程不安全的</span></span><br><span class="line">  elementData[<span class="built_in">size</span>++] = e;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩容(ensureCapacityInternal)的源码：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> void ensure<span class="constructor">CapacityInternal(<span class="params">int</span> <span class="params">minCapacity</span>)</span> &#123;</span><br><span class="line">  <span class="comment">//如果初始化数组大小时，有给定初始值，以给定的大小为准，不走 if 逻辑</span></span><br><span class="line">  <span class="keyword">if</span> (elementData<span class="operator"> == </span>DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">    minCapacity = <span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//确保容积足够</span></span><br><span class="line">  ensure<span class="constructor">ExplicitCapacity(<span class="params">minCapacity</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> void ensure<span class="constructor">ExplicitCapacity(<span class="params">int</span> <span class="params">minCapacity</span>)</span> &#123;</span><br><span class="line">  <span class="comment">//记录数组被修改</span></span><br><span class="line">  modCount++;</span><br><span class="line">  <span class="comment">// 如果我们期望的最小容量大于目前数组的长度，那么就扩容</span></span><br><span class="line">  <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">    grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//扩容，并把现有数据拷贝到新的数组里面去</span></span><br><span class="line"><span class="keyword">private</span> void grow(<span class="built_in">int</span> minCapacity) &#123;</span><br><span class="line">  <span class="built_in">int</span> oldCapacity = elementData.length;</span><br><span class="line">  <span class="comment">// oldCapacity &gt;&gt; 1 是把 oldCapacity 除以 2 的意思</span></span><br><span class="line">  <span class="built_in">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果扩容后的值 &lt; 我们的期望值，扩容后的值就等于我们的期望值</span></span><br><span class="line">  <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = minCapacity;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果扩容后的值 &gt; jvm 所能分配的数组的最大值，那么就用 Integer 的最大值</span></span><br><span class="line">  <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = huge<span class="constructor">Capacity(<span class="params">minCapacity</span>)</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 通过复制进行扩容</span></span><br><span class="line">  elementData = <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span>copy<span class="constructor">Of(<span class="params">elementData</span>, <span class="params">newCapacity</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了注释内容，需要额外注意四点：</p>
<ul>
<li><p>扩容的规则并不是翻倍，是原来容量大小 + 容量大小的一半，直白来说，扩容后的大小是原来容量的 1.5 倍；</p>
</li>
<li><p>ArrayList 中的数组的最大值是 Integer.MAX_VALUE，超过这个值，JVM 就不会给数组分配内存空间了。</p>
</li>
<li><p>新增时，并没有对值进行严格的校验，所以 ArrayList 是允许 null 值的。</p>
</li>
<li><p>源码在扩容的时候，有数组大小溢出意识，就是说扩容后数组的大小下界不能小于 0，上界不能大于 Integer 的最大值，这种意识我们可以学习。</p>
</li>
</ul>
<p>扩容完成之后，赋值是非常简单的，直接往数组上添加元素即可：elementData [size++] = e。也正是通过这种简单赋值，没有任何锁控制，所以这里的操作是线程不安全的。</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>对ArrayList的新增或者删除操作本质都是对数组元素的操作，只需要根据数组索引，直接新增和删除数据，所以时间复杂度是O(1)</p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>需要强调的是，<font color=#FF0000>只有当 ArrayList 作为共享变量时，才会有线程安全问题，当 ArrayList 是方法内的局部变量时，是没有线程安全的问题的</font>。</p>
<p>ArrayList 有线程安全问题的本质，是因为 ArrayList 自身的 elementData、size、modConut 在进行各种操作时，都没有加锁，而且这些变量的类型并非是可见（volatile）的，所以如果多个线程对这些变量进行操作时，可能会有值被覆盖的情况。</p>
<p>类注释中推荐我们使用 Collections#synchronizedList 来保证线程安全，SynchronizedList 是通过在每个方法上面加上锁来实现，虽然实现了线程安全，但是性能大大降低，具体实现源码：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;<span class="comment">// synchronized 是一种轻量锁，mutex 表示一个当前 SynchronizedList</span></span><br><span class="line">        <span class="function"><span class="keyword">return</span> c.<span class="title">add</span><span class="params">(e)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="LinkedList源码解析及设计思路"><a href="#LinkedList源码解析及设计思路" class="headerlink" title="LinkedList源码解析及设计思路"></a>LinkedList源码解析及设计思路</h1><p>LinkedList可以用于先入先出，也可以用于先入后出，因为它本质是一个链表，而且是双向链表。</p>
<h2 id="LinkedList整体架构"><a href="#LinkedList整体架构" class="headerlink" title="LinkedList整体架构"></a>LinkedList整体架构</h2><p>LinkedList本质是双向链表，整体结构如下图：</p>
<p><img src="https://i.loli.net/2020/03/16/oIRDHnTqAy2dcsB.png" alt="LinkedList底层架构.png"></p>
<h2 id="源码解析-未完"><a href="#源码解析-未完" class="headerlink" title="源码解析(未完)"></a>源码解析(未完)</h2><h3 id="新增元素"><a href="#新增元素" class="headerlink" title="新增元素"></a>新增元素</h3><p>追加节点时，我们可以选择追加到链表头部，还是追加到链表尾部，add 方法默认是从尾部开始追加，addFirst 方法是从头部开始追加。</p>
<h4 id="从尾部追加-add"><a href="#从尾部追加-add" class="headerlink" title="从尾部追加(add)"></a>从尾部追加(add)</h4><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从尾部开始追加节点</span></span><br><span class="line">void linkLast(E e) &#123;</span><br><span class="line">    <span class="comment">// 把尾节点数据暂存</span></span><br><span class="line">    final Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">// 新建新的节点，初始化入参含义：</span></span><br><span class="line">    <span class="comment">// l 是新节点的前一个节点，当前值是尾节点值</span></span><br><span class="line">    <span class="comment">// e 表示当前新增节点，当前新增节点后一个节点是 null</span></span><br><span class="line">    final Node&lt;E&gt; <span class="keyword">new</span><span class="type">Node</span> = <span class="keyword">new</span> <span class="type">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 新建节点追加到尾部</span></span><br><span class="line">    last = <span class="keyword">new</span><span class="type">Node</span>;</span><br><span class="line">    <span class="comment">//如果链表为空（l 是尾节点，尾节点为空，链表即空），头部和尾部是同一个节点，都是新建的节点</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        first = <span class="keyword">new</span><span class="type">Node</span>;![图片描述](<span class="comment">//img1.sycdn.imooc.com/5d5fc69600013e4803600240.gif)</span></span><br><span class="line">    <span class="comment">//否则把前尾节点的下一个节点，指向当前尾节点。</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = <span class="keyword">new</span><span class="type">Node</span>;</span><br><span class="line">    <span class="comment">//大小和版本更改</span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码上来看，尾部追加节点比较简单，只需要简单地把指向位置修改下即可</p>
<h4 id="从头部追加-addFirst"><a href="#从头部追加-addFirst" class="headerlink" title="从头部追加(addFirst)"></a>从头部追加(addFirst)</h4><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从头部追加</span></span><br><span class="line"><span class="keyword">private</span> void linkFirst(E e) &#123;</span><br><span class="line">    <span class="comment">// 头节点赋值给临时变量</span></span><br><span class="line">    final Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="comment">// 新建节点，前一个节点指向null，e 是新建节点，f 是新建节点的下一个节点，目前值是头节点的值</span></span><br><span class="line">    final Node&lt;E&gt; <span class="keyword">new</span><span class="type">Node</span> = <span class="keyword">new</span> <span class="type">Node</span>&lt;&gt;(<span class="literal">null</span>, e, f);</span><br><span class="line">    <span class="comment">// 新建节点成为头节点</span></span><br><span class="line">    first = <span class="keyword">new</span><span class="type">Node</span>;</span><br><span class="line">    <span class="comment">// 头节点为空，就是链表为空，头尾节点是一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span>)</span><br><span class="line">        last = <span class="keyword">new</span><span class="type">Node</span>;</span><br><span class="line">    <span class="comment">//上一个头节点的前一个节点指向当前节点</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        f.prev = <span class="keyword">new</span><span class="type">Node</span>;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>头部追加节点和尾部追加节点非常类似，只是前者是移动头节点的 prev 指向，后者是移动尾节点的 next 指向。</p>
<h3 id="节点删除"><a href="#节点删除" class="headerlink" title="节点删除"></a>节点删除</h3><p>节点删除的方式和追加类似，我们可以选择从头部删除，也可以选择从尾部删除，删除操作会把节点的值，前后指向节点都置为 null，帮助 GC 进行回收。</p>
<p>从头部删除：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从头删除节点 f 是链表头节点</span></span><br><span class="line"><span class="keyword">private</span> E unlinkFirst(Node&lt;E&gt; f) &#123;</span><br><span class="line">    <span class="comment">// 拿出头节点的值，作为方法的返回值</span></span><br><span class="line">    <span class="keyword">final</span> E element = f.item;</span><br><span class="line">    <span class="comment">// 拿出头节点的下一个节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; <span class="keyword">next</span> = f.<span class="keyword">next</span>;</span><br><span class="line">    <span class="comment">//帮助 GC 回收头节点</span></span><br><span class="line">    f.item = <span class="keyword">null</span>;</span><br><span class="line">    f.<span class="keyword">next</span> = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 头节点的下一个节点成为头节点</span></span><br><span class="line">    first = <span class="keyword">next</span>;</span><br><span class="line">    <span class="comment">//如果 next 为空，表明链表为空</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">next</span> == <span class="keyword">null</span>)</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//链表不为空，头节点的前一个节点指向 null</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">next</span>.prev = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//修改链表大小和版本</span></span><br><span class="line">    <span class="keyword">size</span>--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从尾部删除差不多，不重复贴了。</p>
<p>链表结构的节点新增、删除都非常简单，仅仅把前后节点的指向修改下就好了，所以 LinkedList 新增和删除速度很快。</p>
<h3 id="访问元素-节点"><a href="#访问元素-节点" class="headerlink" title="访问元素(节点)"></a>访问元素(节点)</h3><p>这是LinkedList的缺陷了，需要循环挨个查找才行。但是LinkedList其实也是用了二分法来加快查找的。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">// 根据链表索引位置查询节点</span><br><span class="line"><span class="keyword">Node</span><span class="title">&lt;E</span>&gt; <span class="keyword">node</span><span class="title">(int</span> index) &#123;</span><br><span class="line">    // 如果 index 处于队列的前半部分，从头开始找，size &gt;&gt; <span class="number">1</span> 是 size 除以 <span class="number">2</span> 的意思。</span><br><span class="line">    if (index <span class="tag">&lt; (size &gt;</span>&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">Node</span><span class="title">&lt;E</span>&gt; x = first;</span><br><span class="line">        // 直到 for 循环到 index 的前一个 <span class="keyword">node</span> <span class="title">停止</span></span><br><span class="line"><span class="title">        for</span> (int i = <span class="number">0</span>; i <span class="tag">&lt; index; i++)</span></span><br><span class="line"><span class="tag">            x = x.next;</span></span><br><span class="line"><span class="tag">        return x;</span></span><br><span class="line"><span class="tag">    &#125; else &#123;// 如果 index 处于队列的后半部分，从尾开始找</span></span><br><span class="line"><span class="tag">        Node&lt;E&gt;</span> x = last;</span><br><span class="line">        // 直到 for 循环到 index 的后一个 <span class="keyword">node</span> <span class="title">停止</span></span><br><span class="line"><span class="title">        for</span> (int i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LinkedList 并没有采用从头循环到尾的做法，而是采取了简单二分法，首先看看 index 是在链表的前半部分，还是后半部分。如果是前半部分，就从头开始寻找，反之亦然。通过这种方式，使循环的次数至少降低了一半，提高了查找的性能，这种思想值得我们借鉴。</p>
<h3 id="LinkedList和其他结构对比"><a href="#LinkedList和其他结构对比" class="headerlink" title="LinkedList和其他结构对比"></a>LinkedList和其他结构对比</h3><p>首先，LinkedList实现了Queue接口，也就是实例化Queue的时候，需要这么写：<code>Queue&lt;E&gt; queue = new LinkedList&lt;&gt;()</code>，在新增、删除、查询等方面增加了很多新的方法，这些方法在平时特别容易混淆，在链表为空的情况下，返回值也不太一样</p>
<p><img src="https://i.loli.net/2020/03/16/RykLXdcBrnDTUJl.png" alt="LinkedList方法对比表格.png"></p>
<h1 id="List接口常见问题"><a href="#List接口常见问题" class="headerlink" title="List接口常见问题"></a>List接口常见问题</h1><h2 id="1-说说对ArrayList的理解？"><a href="#1-说说对ArrayList的理解？" class="headerlink" title="1.说说对ArrayList的理解？"></a>1.说说对ArrayList的理解？</h2><p>建议先回答总体架构，再从某个细节出发作为突破口，比如这样：</p>
<p>ArrayList 底层数据结构是个数组，其 API 都做了一层对数组底层访问的封装，比如说 add 方法的过程是……（这里可以引用我们在 ArrayList 源码解析中 add 的过程）。</p>
<p>谈谈对LinkedList的理解？——一样的套路。</p>
<h2 id="2-扩容类问题"><a href="#2-扩容类问题" class="headerlink" title="2.扩容类问题"></a>2.扩容类问题</h2><h3 id="2-1-ArrayList-无参数构造器构造，现在-add-一个值进去，此时数组的大小是多少，下一次扩容前最大可用大小是多少？"><a href="#2-1-ArrayList-无参数构造器构造，现在-add-一个值进去，此时数组的大小是多少，下一次扩容前最大可用大小是多少？" class="headerlink" title="2.1 ArrayList 无参数构造器构造，现在 add 一个值进去，此时数组的大小是多少，下一次扩容前最大可用大小是多少？"></a>2.1 ArrayList 无参数构造器构造，现在 add 一个值进去，此时数组的大小是多少，下一次扩容前最大可用大小是多少？</h3><p>答：此处数组的大小是 1，下一次扩容前最大可用大小是 10，因为 ArrayList 第一次扩容时，是有默认值的，默认值是 10，在第一次 add 一个值进去时，数组的可用大小被扩容到 10 了。</p>
<h3 id="2-2-如果我连续往-list-里面新增值，增加到第-11-个的时候，数组的大小是多少？"><a href="#2-2-如果我连续往-list-里面新增值，增加到第-11-个的时候，数组的大小是多少？" class="headerlink" title="2.2 如果我连续往 list 里面新增值，增加到第 11 个的时候，数组的大小是多少？"></a>2.2 如果我连续往 list 里面新增值，增加到第 11 个的时候，数组的大小是多少？</h3><p>扩容一次，从10扩容1.5倍，到15</p>
<h3 id="2-3-数组初始化，被加入一个值后，如果我使用-addAll-方法，一下子加入-15-个值，那么最终数组的大小是多少？"><a href="#2-3-数组初始化，被加入一个值后，如果我使用-addAll-方法，一下子加入-15-个值，那么最终数组的大小是多少？" class="headerlink" title="2.3 数组初始化，被加入一个值后，如果我使用 addAll 方法，一下子加入 15 个值，那么最终数组的大小是多少？"></a>2.3 数组初始化，被加入一个值后，如果我使用 addAll 方法，一下子加入 15 个值，那么最终数组的大小是多少？</h3><p>扩容一次不够，根据ArrayList源码的扩容原则，当期望值(这里是16)大于一次扩容之后的量，那么我们这次扩容的值为期望值，即扩容之后容量为16</p>
<h3 id="2-4-现在我有一个很大的数组需要拷贝，原数组大小是-5k，请问如何快速拷贝？"><a href="#2-4-现在我有一个很大的数组需要拷贝，原数组大小是-5k，请问如何快速拷贝？" class="headerlink" title="2.4 现在我有一个很大的数组需要拷贝，原数组大小是 5k，请问如何快速拷贝？"></a>2.4 现在我有一个很大的数组需要拷贝，原数组大小是 5k，请问如何快速拷贝？</h3><p>答：因为原数组比较大，不能频繁扩容，否则有大量拷贝的工作，造成拷贝的性能低下，所以回答说新建数组时，指定新数组的大小为 5k 即可。</p>
<h3 id="2-5-为什么说扩容会消耗性能？"><a href="#2-5-为什么说扩容会消耗性能？" class="headerlink" title="2.5 为什么说扩容会消耗性能？"></a>2.5 为什么说扩容会消耗性能？</h3><p>答：扩容底层使用的是 System.arraycopy 方法，会把原数组的数据全部拷贝到新数组上，所以性能消耗比较严重。</p>
<h3 id="2-6-源码扩容过程有什么值得借鉴的地方？"><a href="#2-6-源码扩容过程有什么值得借鉴的地方？" class="headerlink" title="2.6 源码扩容过程有什么值得借鉴的地方？"></a>2.6 源码扩容过程有什么值得借鉴的地方？</h3><p>主要两点：</p>
<ol>
<li>扩容的思想。每次扩容1.5倍，也是比较合理的设置，前期慢慢增加，后期增加速度更快</li>
<li>扩容过程中，有数组大小溢出的意识，比如要求扩容后的数组大小，不能小于 0，不能大于 Integer 的最大值。</li>
</ol>
<h2 id="3-对比问题"><a href="#3-对比问题" class="headerlink" title="3.对比问题"></a>3.对比问题</h2><h3 id="3-1-ArrayList和LinkedList有何不同？"><a href="#3-1-ArrayList和LinkedList有何不同？" class="headerlink" title="3.1 ArrayList和LinkedList有何不同？"></a>3.1 ArrayList和LinkedList有何不同？</h3><p>最大的不同是两者底层的数据结构不同，ArrayList 底层是数组，LinkedList 底层是双向链表，两者的数据结构不同也导致了操作的 API 实现有所差异，拿新增实现来说，ArrayList 会先计算并决定是否扩容，然后把新增的数据直接赋值到数组上，而 LinkedList 仅仅只需要改变插入节点和其前后节点的指向位置关系即可。</p>
<h3 id="3-2-ArrayList-和-LinkedList-应用场景有何不同"><a href="#3-2-ArrayList-和-LinkedList-应用场景有何不同" class="headerlink" title="3.2 ArrayList 和 LinkedList 应用场景有何不同"></a>3.2 ArrayList 和 LinkedList 应用场景有何不同</h3><p>答：ArrayList 更适合于快速的查找匹配，不适合频繁新增删除，像工作中经常会对元素进行匹配查询的场景比较合适，LinkedList 更适合于经常新增和删除，对查询反而很少的场景。</p>
<h3 id="3-3-ArrayList-和-LinkedList-两者有没有最大容量"><a href="#3-3-ArrayList-和-LinkedList-两者有没有最大容量" class="headerlink" title="3.3 ArrayList 和 LinkedList 两者有没有最大容量"></a>3.3 ArrayList 和 LinkedList 两者有没有最大容量</h3><p>答：ArrayList 有最大容量的，为 Integer 的最大值，大于这个值 JVM 是不会为数组分配内存空间的，LinkedList 底层是双向链表，理论上可以无限大。但源码中，LinkedList 实际大小用的是 int 类型，这也说明了 LinkedList 不能超过 Integer 的最大值，不然会溢出。</p>
<h3 id="3-4-ArrayList-和-LinkedList-是如何对-null-值进行处理的"><a href="#3-4-ArrayList-和-LinkedList-是如何对-null-值进行处理的" class="headerlink" title="3.4 ArrayList 和 LinkedList 是如何对 null 值进行处理的"></a>3.4 ArrayList 和 LinkedList 是如何对 null 值进行处理的</h3><p>答：ArrayList 允许 null 值新增，也允许 null 值删除。删除 null 值时，是从头开始，找到第一值是 null 的元素删除；LinkedList 新增删除时对 null 值没有特殊校验，是允许新增和删除的。</p>
<h3 id="3-5-ArrayList-和-LinedList-是线程安全的么，为什么？"><a href="#3-5-ArrayList-和-LinedList-是线程安全的么，为什么？" class="headerlink" title="3.5 ArrayList 和 LinedList 是线程安全的么，为什么？"></a>3.5 ArrayList 和 LinedList 是线程安全的么，为什么？</h3><p>答：当两者作为非共享变量时，比如说仅仅是在方法里面的局部变量时，是没有线程安全问题的，只有当两者是共享变量时，才会有线程安全问题。主要的问题点在于多线程环境下，所有线程任何时刻都可对数组和链表进行操作，这会导致值被覆盖，甚至混乱的情况。</p>
<p>如果有线程安全问题，在迭代的过程中，会频繁报 ConcurrentModificationException 的错误，意思是在我当前循环的过程中，数组或链表的结构被其它线程修改了。</p>
<h3 id="3-6-如何解决线程安全问题？"><a href="#3-6-如何解决线程安全问题？" class="headerlink" title="3.6 如何解决线程安全问题？"></a>3.6 如何解决线程安全问题？</h3><p>Java 源码中推荐使用 Collections#synchronizedList 进行解决，Collections#synchronizedList 的返回值是 List 的每个方法都加了 synchronized 锁，保证了在同一时刻，数组和链表只会被一个线程所修改，或者采用CopyOnWriteArrayList 并发 List 来解决。</p>
<h2 id="4-其他"><a href="#4-其他" class="headerlink" title="4.其他"></a>4.其他</h2><h3 id="4-1-描述下双向链表的新增和删除"><a href="#4-1-描述下双向链表的新增和删除" class="headerlink" title="4.1 描述下双向链表的新增和删除"></a>4.1 描述下双向链表的新增和删除</h3><p>如果条件允许，可以画图说明，参考前面LinkedList的图。</p>
<p>如果远程电话面试，可以这样描述：双向链表中双向的意思是说前后节点之间互相有引用，链表的节点我们称为 Node。Node 有三个属性组成：其前一个节点，本身节点的值，其下一个节点，假设 A、B 节点相邻，A 节点的下一个节点就是 B，B 节点的上一个节点就是 A，两者互相引用，在链表的头部节点，我们称为头节点。头节点的前一个节点是 null，尾部称为尾节点，尾节点的后一个节点是 null，如果链表数据为空的话，头尾节点是同一个节点，本身是 null，指向前后节点的值也是 null。</p>
<h3 id="4-2-描述下双向链表的新增和删除"><a href="#4-2-描述下双向链表的新增和删除" class="headerlink" title="4.2 描述下双向链表的新增和删除"></a>4.2 描述下双向链表的新增和删除</h3><p>答：如果是面对面沟通，最好可以直接画图，如果是电话面试，可以这么描述：</p>
<p>新增：我们可以选择从链表头新增，也可以选择从链表尾新增，如果是从链表尾新增的话，直接把当前节点追加到尾节点之后，本身节点自动变为尾节点。</p>
<p>删除：把删除节点的后一个节点的 prev 指向其前一个节点，把删除节点的前一个节点的 next 指向其后一个节点，最后把删除的节点置为 null 即可。</p>
<h1 id="Hashmap源码解析与架构-未完"><a href="#Hashmap源码解析与架构-未完" class="headerlink" title="Hashmap源码解析与架构(未完)"></a>Hashmap源码解析与架构(未完)</h1><p>首先HashMap的源码很长，面试题也很多，最好能弄清楚底层。</p>
<h2 id="1-整体架构"><a href="#1-整体架构" class="headerlink" title="1.整体架构"></a>1.整体架构</h2><p>HashMap 底层的数据结构主要是：<strong>数组 + 链表 + 红黑树</strong>。其中当链表的长度大于等于 8 时，链表会转化成红黑树，当红黑树的大小小于等于 6 时，红黑树会转化成链表。</p>
<p><img src="https://i.loli.net/2020/03/16/aguyM8eO4cqZ9Qt.png" alt="HashMap整体架构.png"></p>
<p>图中左边竖着的是 HashMap 的数组结构，数组的元素可能是单个 Node，也可能是个链表，也可能是个红黑树，比如数组下标索引为 2 的位置就是一个链表，下标索引为 9 的位置对应的就是红黑树</p>
<h3 id="1-1类注释中的信息"><a href="#1-1类注释中的信息" class="headerlink" title="1.1类注释中的信息"></a>1.1类注释中的信息</h3><p>从下面这些信息可以大体把握HashMap的重点。</p>
<ul>
<li>允许 null 值，不同于 HashTable ，是线程不安全的；</li>
<li>load factor（影响因子） 默认值是 0.75， 是均衡了时间和空间损耗算出来的值，较高的值会减少空间开销（扩容减少，数组大小增长速度变慢），但增加了查找成本（hash 冲突增加，链表长度变长），不扩容的条件：数组容量 &gt; 需要的数组大小 /load factor；</li>
<li>如果有很多数据需要储存到 HashMap 中，建议 HashMap 的容量一开始就设置成足够的大小，这样可以防止在其过程中不断的扩容，影响性能；</li>
<li>HashMap 是非线程安全的，我们可以自己在外部加锁，或者通过 Collections#synchronizedMap 来实现线程安全，Collections#synchronizedMap 的实现是在每个方法上加上了 synchronized 锁；</li>
<li>在迭代过程中，如果 HashMap 的结构被修改，会快速失败。</li>
</ul>
<h3 id="1-2-常见的属性"><a href="#1-2-常见的属性" class="headerlink" title="1.2 常见的属性"></a>1.2 常见的属性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始容量为 16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//负载因子默认值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//桶上的链表长度大于等于8时，链表转化成红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//桶上的红黑树大小小于等于6时，红黑树转化成链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当数组容量大于 64 时，链表才会转化成红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录迭代过程中 HashMap 结构是否发生变化，如果有变化，迭代时会 fail-fast</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//HashMap 的实际大小，可能不准(因为当你拿到这个值的时候，可能又发生了变化)</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存放数据的数组</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容的门槛，有两种情况</span></span><br><span class="line"><span class="comment">// 如果初始化时，给定数组大小的话，通过 tableSizeFor 方法计算，数组大小永远接近于 2 的幂次方，比如你给定初始化大小 19，实际上初始化大小为 32，为 2 的 5 次方。</span></span><br><span class="line"><span class="comment">// 如果是通过 resize 方法进行扩容，大小 = 数组容量 * 0.75</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表的节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//红黑树的节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br></pre></td></tr></table></figure>

<h2 id="2-新增节点"><a href="#2-新增节点" class="headerlink" title="2.新增节点"></a>2.新增节点</h2><p>新增 key，value 大概的步骤如下：</p>
<ol>
<li>空数组有无初始化，没有的话初始化；</li>
<li>如果通过 key 的 hash 能够直接找到值，跳转到 6，否则到 3；</li>
<li>如果 hash 冲突，两种解决方案：链表 or 红黑树；</li>
<li>如果是链表，递归循环，把新元素追加到队尾；</li>
<li>如果是红黑树，调用红黑树新增的方法；</li>
<li>通过 2、4、5 将新元素追加成功，再根据 onlyIfAbsent 判断是否需要覆盖；</li>
<li>判断是否需要扩容，需要扩容进行扩容，结束。</li>
</ol>
<h3 id="2-1链表的新增"><a href="#2-1链表的新增" class="headerlink" title="2.1链表的新增"></a>2.1链表的新增</h3><p>链表的新增比较简单，就是把当前节点追加到链表的尾部，和 LinkedList 的追加实现一样的。</p>
<p>当链表长度大于等于 8 时，此时的链表就会转化成红黑树，转化的方法是：treeifyBin，此方法有一个判断，当链表长度大于等于 8，并且整个数组大小大于 64 时，才会转成红黑树，当数组大小小于 64 时，只会触发扩容，不会转化成红黑树。</p>
<p>可能面试的时候，有人问你为什么是 8，这个答案在源码中注释有说，中文翻译过来大概的意思是：</p>
<p>链表查询的时间复杂度是 O (n)，红黑树的查询复杂度是 O (log (n))。在链表数据不多的时候，使用链表进行遍历也比较快，只有当链表数据比较多的时候，才会转化成红黑树，但红黑树需要的占用空间是链表的 2 倍，考虑到转化时间和空间损耗，所以我们需要定义出转化的边界值。</p>
<p>在考虑设计 8 这个值的时候，我们参考了泊松分布概率函数，由泊松分布中得出结论，链表各个长度的命中概率为：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">* <span class="number">0</span>:    <span class="number">0.60653066</span></span><br><span class="line">* <span class="number">1</span>:    <span class="number">0.30326533</span></span><br><span class="line">* <span class="number">2</span>:    <span class="number">0.07581633</span></span><br><span class="line">* <span class="number">3</span>:    <span class="number">0.01263606</span></span><br><span class="line">* <span class="number">4</span>:    <span class="number">0.00157952</span></span><br><span class="line">* <span class="number">5</span>:    <span class="number">0.00015795</span></span><br><span class="line">* <span class="number">6</span>:    <span class="number">0.00001316</span></span><br><span class="line">* <span class="number">7</span>:    <span class="number">0.00000094</span></span><br><span class="line">* <span class="number">8</span>:    <span class="number">0.00000006</span></span><br></pre></td></tr></table></figure>

<p>意思是，当链表的长度是 8 的时候，出现的概率是 0.00000006，不到千万分之一，所以说正常情况下，链表的长度不可能到达 8 ，而一旦到达 8 时，肯定是 hash 算法出了问题，所以在这种情况下，为了让 HashMap 仍然有较高的查询性能，所以让链表转化成红黑树，我们正常写代码，使用 HashMap 时，几乎不会碰到链表转化成红黑树的情况，毕竟概念只有千万分之一。</p>
<h3 id="2-2红黑树新增节点过程"><a href="#2-2红黑树新增节点过程" class="headerlink" title="2.2红黑树新增节点过程"></a>2.2红黑树新增节点过程</h3><ol start="2">
<li><p>首先判断新增的节点在红黑树上是不是已经存在，判断手段有如下两种：</p>
<p> 1.1. 如果节点没有实现 Comparable 接口，使用 equals 进行判断；</p>
<p> 1.2. 如果节点自己实现了 Comparable 接口，使用 compareTo 进行判断。</p>
</li>
<li><p>新增的节点如果已经在红黑树上，直接返回；不在的话，判断新增节点是在当前节点的左边还是右边，左边值小，右边值大；</p>
</li>
<li><p>自旋递归 1 和 2 步，直到当前节点的左边或者右边的节点为空时，停止自旋，当前节点即为我们新增节点的父节点；</p>
</li>
<li><p>把新增节点放到当前节点的左边或右边为空的地方，并于当前节点建立父子节点关系；</p>
</li>
<li><p>进行着色和旋转，结束。</p>
</li>
</ol>
<p>红黑树的新增，要求大家对红黑树的数据结构有一定的了解。面试的时候，一般只会问到新增节点到红黑树上大概是什么样的一个过程，着色和旋转的细节不会问，因为很难说清楚，但我们要清楚着色指的是给红黑树的节点着上红色或黑色，旋转是为了让红黑树更加平衡，提高查询的效率，总的来说都是为了满足红黑树的 5 个原则：</p>
<ol>
<li>节点是红色或黑色</li>
<li>根是黑色</li>
<li>所有叶子都是黑色</li>
<li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点</li>
<li>从每个叶子到根的所有路径上不能有两个连续的红色节点</li>
</ol>
<h2 id="3-查找"><a href="#3-查找" class="headerlink" title="3.查找"></a>3.查找</h2><p>HashMap 的查找主要分为以下三步：</p>
<ol>
<li>根据 hash 算法定位数组的索引位置，equals 判断当前节点是否是我们需要寻找的 key，是的话直接返回，不是的话往下。</li>
<li>判断当前节点有无 next 节点，有的话判断是链表类型，还是红黑树类型。</li>
<li>分别走链表和红黑树不同类型的查找方法。</li>
</ol>
<h1 id="Treemap和LinkedHashMap源码解析与架构-未完"><a href="#Treemap和LinkedHashMap源码解析与架构-未完" class="headerlink" title="Treemap和LinkedHashMap源码解析与架构(未完)"></a>Treemap和LinkedHashMap源码解析与架构(未完)</h1><p>首先可以明确分析源码的目的：TreeMap 是如何根据 key 进行排序的 和 LinkedHashMap 是如何用两种策略进行访问的。</p>
<h2 id="1-Treemap解析"><a href="#1-Treemap解析" class="headerlink" title="1. Treemap解析"></a>1. Treemap解析</h2><h3 id="1-1-Treemap排序方式解析"><a href="#1-1-Treemap排序方式解析" class="headerlink" title="1.1 Treemap排序方式解析"></a>1.1 Treemap排序方式解析</h3><p>了解 TreeMap 之前，我们来看下日常工作中排序的两种方式，作为我们学习的基础储备，两种方式的代码如下：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> TreeMapDemo &#123;</span><br><span class="line"></span><br><span class="line">  @Data</span><br><span class="line">  <span class="comment">// DTO 为我们排序的对象</span></span><br><span class="line">  <span class="keyword">class</span> DTO implements Comparable&lt;DTO&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    public <span class="constructor">DTO(Integer <span class="params">id</span>)</span> &#123;</span><br><span class="line">      this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public <span class="built_in">int</span> compare<span class="constructor">To(DTO <span class="params">o</span>)</span> &#123;</span><br><span class="line">      <span class="comment">//默认从小到大排序</span></span><br><span class="line">      return id - o.get<span class="constructor">Id()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Test</span><br><span class="line">  public void test<span class="constructor">TwoComparable()</span> &#123;</span><br><span class="line">    <span class="comment">// 第一种排序，从小到大排序，实现 Comparable 的 compareTo 方法进行排序</span></span><br><span class="line">    List&lt;DTO&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">    for (<span class="built_in">int</span> i = <span class="number">5</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="built_in">list</span>.add(<span class="keyword">new</span> <span class="constructor">DTO(<span class="params">i</span>)</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">Collections</span>.</span></span>sort(<span class="built_in">list</span>);</span><br><span class="line">    log.info(<span class="module-access"><span class="module"><span class="identifier">JSON</span>.</span></span><span class="keyword">to</span><span class="constructor">JSONString(<span class="params">list</span>)</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种排序，从大到小排序，利用外部排序器 Comparator 进行排序</span></span><br><span class="line">    Comparator comparator = (Comparator&lt;DTO&gt;) (o1, o2) -&gt; o2.get<span class="constructor">Id()</span> - o1.get<span class="constructor">Id()</span>;</span><br><span class="line">    List&lt;DTO&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">    for (<span class="built_in">int</span> i = <span class="number">5</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">      list2.add(<span class="keyword">new</span> <span class="constructor">DTO(<span class="params">i</span>)</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">Collections</span>.</span></span>sort(<span class="built_in">list</span>,comparator);</span><br><span class="line">    log.info(<span class="module-access"><span class="module"><span class="identifier">JSON</span>.</span></span><span class="keyword">to</span><span class="constructor">JSONString(<span class="params">list2</span>)</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一种排序输出的结果从小到大，结果是：[{“id”:1},{“id”:2},{“id”:3},{“id”:4},{“id”:5}]；</p>
<p>第二种输出的结果恰好相反，结果是：[{“id”:5},{“id”:4},{“id”:3},{“id”:2},{“id”:1}]。</p>
<p>以上两种就是分别通过 Comparable 和 Comparator 两者进行排序的方式，而 TreeMap 利用的也是此原理，从而实现了对 key 的排序，我们一起来看下。</p>
<h3 id="1-2-TreeMap整体架构"><a href="#1-2-TreeMap整体架构" class="headerlink" title="1.2 TreeMap整体架构"></a>1.2 TreeMap整体架构</h3><p>TreeMap 底层的数据结构就是红黑树，和 HashMap 的红黑树结构一样。</p>
<p>不同的是，TreeMap 利用了红黑树左节点小，右节点大的性质，根据 key 进行排序，使每个元素能够插入到红黑树大小适当的位置，维护了 key 的大小关系，适用于 key 需要排序的场景。</p>
<p>因为底层使用的是平衡红黑树的结构，所以 containsKey、get、put、remove 等方法的时间复杂度都是 log(n)。</p>
<h3 id="1-3-TreeMap常见属性"><a href="#1-3-TreeMap常见属性" class="headerlink" title="1.3 TreeMap常见属性"></a>1.3 TreeMap常见属性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//比较器，如果外部有传进来 Comparator 比较器，首先用外部的</span></span><br><span class="line"><span class="comment">//如果外部比较器为空，则使用 key 自己实现的 Comparable#compareTo 方法</span></span><br><span class="line"><span class="comment">//比较手段和上面日常工作中的比较 demo 是一致的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> K&gt; comparator;</span><br><span class="line"></span><br><span class="line"><span class="comment">//红黑树的根节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root;</span><br><span class="line"></span><br><span class="line"><span class="comment">//红黑树的已有元素大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树结构变化的版本号，用于迭代过程中的快速失败场景</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//红黑树的节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4新增节点过程"><a href="#1-4新增节点过程" class="headerlink" title="1.4新增节点过程"></a>1.4新增节点过程</h3><p>看下 TreeMap 新增节点的步骤：</p>
<ol>
<li>判断红黑树的节点是否为空，为空的话，新增的节点直接作为根节点</li>
<li>根据红黑树左小右大的特性，进行判断，找到应该新增节点的父节点</li>
<li>在父节点的左边或右边插入新增节点</li>
<li>着色旋转，达到平衡，结束。</li>
</ol>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name">这里省略掉了这四步的代码</span>)</span><br></pre></td></tr></table></figure>

<p>从源码中，我们可以看到：</p>
<ol>
<li>新增节点时，就是利用了红黑树左小右大的特性，从根节点不断往下查找，直到找到节点是 null 为止，节点为 null 说明到达了叶子结点；</li>
<li>查找过程中，发现 key 值已经存在，直接覆盖；</li>
<li>TreeMap 是禁止 key 是 null 值的。</li>
</ol>
<h3 id="1-5-TreeMap小结"><a href="#1-5-TreeMap小结" class="headerlink" title="1.5 TreeMap小结"></a>1.5 TreeMap小结</h3><p>TreeMap 相对来说比较简单，红黑树和 HashMap 比较类似，比较关键的是通过 compare 来比较 key 的大小，然后利用红黑树左小右大的特性，为每个 key 找到自己的位置，从而维护了 key 的大小排序顺序。</p>
<h2 id="2-LinkedHashMap整体结构解析-未完"><a href="#2-LinkedHashMap整体结构解析-未完" class="headerlink" title="2. LinkedHashMap整体结构解析(未完)"></a>2. LinkedHashMap整体结构解析(未完)</h2><p>LinkedHashMap最主要的就是维护了插入的顺序。其本身继承了HashMap,再此基础上，还提供了两大特性：</p>
<ol>
<li>按照插入顺序进行访问；</li>
<li>实现了访问最少最先删除功能，其目的是把很久都没有访问的 key 自动删除。</li>
</ol>
<h3 id="2-1-LinkedHashMap按照插入顺序访问"><a href="#2-1-LinkedHashMap按照插入顺序访问" class="headerlink" title="2.1 LinkedHashMap按照插入顺序访问"></a>2.1 LinkedHashMap按照插入顺序访问</h3><h4 id="2-1-1-LinkedHashMap的链表结构"><a href="#2-1-1-LinkedHashMap的链表结构" class="headerlink" title="2.1.1 LinkedHashMap的链表结构"></a>2.1.1 LinkedHashMap的链表结构</h4><p>LinkedHashMap 的数据结构很像是把 LinkedList 的每个元素换成了 HashMap 的 Node，像是两者的结合体，也正是因为增加了这些结构，从而能把 Map 的元素都串联起来，形成一个链表，而链表就可以保证顺序了，就可以维护元素插入进来的顺序。</p>
<h4 id="2-1-2-LinkedHashMap如何按照顺序新增"><a href="#2-1-2-LinkedHashMap如何按照顺序新增" class="headerlink" title="2.1.2 LinkedHashMap如何按照顺序新增"></a>2.1.2 LinkedHashMap如何按照顺序新增</h4><p>LinkedHashMap 初始化时，默认 accessOrder 为 false，就是会按照插入顺序提供访问，插入方法使用的是父类 HashMap 的 put 方法，不过覆写了 put 方法执行中调用的 newNode/newTreeNode 和 afterNodeAccess 方法。</p>
<p>newNode/newTreeNode 方法，控制新增节点追加到链表的尾部，这样每次新节点都追加到尾部，即可保证插入顺序了。</p>
<p>(略去源码)</p>
<p>LinkedHashMap 通过新增头节点、尾节点，给每个节点增加 before、after 属性，每次新增时，都把节点追加到尾节点等手段，在新增的时候，就已经维护了按照插入顺序的链表结构了。</p>
<p>换句话说，LinkedHashMap底层其实是双向链表+哈希Map的组合。</p>
<h4 id="2-1-3-LinkedHashMap如何按照顺序访问"><a href="#2-1-3-LinkedHashMap如何按照顺序访问" class="headerlink" title="2.1.3 LinkedHashMap如何按照顺序访问"></a>2.1.3 LinkedHashMap如何按照顺序访问</h4><p>LinkedHashMap 只提供了单向访问，即按照插入的顺序从头到尾进行访问，不能像 LinkedList 那样可以从头和从尾两个方向双向访问。</p>
<p>我们主要通过迭代器进行访问，迭代器初始化的时候，默认从头节点开始访问，在迭代的过程中，不断访问当前节点的 after 节点即可。</p>
<p>Map 对 key、value 和 entity（节点） 都提供出了迭代的方法，假设我们需要迭代 entity，就可使用 <code>LinkedHashMap.entrySet().iterator()</code> 这种写法直接返回 LinkedHashIterator ，LinkedHashIterator 是迭代器，我们调用迭代器的 nextNode 方法就可以得到下一个节点。</p>
<p>(源码略)</p>
<p>在新增节点时，我们就已经维护了元素之间的插入顺序了，所以迭代访问时非常简单，只需要不断的访问当前节点的下一个节点即可。</p>
<h3 id="2-2-访问最少删除策略-LRU-cahce"><a href="#2-2-访问最少删除策略-LRU-cahce" class="headerlink" title="2.2 访问最少删除策略(LRU cahce)"></a>2.2 访问最少删除策略(LRU cahce)</h3><p>非常经典的LRU（Least recently used,最近最少使用）了，大概的意思就是经常访问的元素会被追加到队尾，这样不经常访问的数据自然就靠近队头，然后每次删除都会把最尾部，也就是最不常用的元素，删除掉。(注意源码这里想表示的是删除队头的元素，所以常用的元素其实是会被追加到队尾的，这和我们自己实现的LRU cache是相反的，但是原理是相同的。我们自己写的LRU可以命名为moveToHead,但是我们写的就是head了，不是队尾)</p>
<p>删除策略的方法：<code>removeEldestEntry</code></p>
<p>比如我们设定节点个数大于3个开始删除：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> boolean removeEldestEntry(Map.<span class="built_in">Entry</span>&lt;<span class="keyword">Integer</span>, <span class="keyword">Integer</span>&gt; eldest) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">size</span>() &gt; <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次强调，LinkedHashMap的源码中经常使用的元素会被移动到队尾。</p>
<p>把元素移动到队尾的方法：<code>afterNodeAccess</code>。其实不仅仅是 get 方法，执行 getOrDefault、compute、computeIfAbsent、computeIfPresent、merge 方法时，也会这么做，通过不断的把经常访问的节点移动到队尾，那么靠近队头的节点，自然就是很少被访问的元素了。</p>
<h4 id="2-2-1具体删除策略"><a href="#2-2-1具体删除策略" class="headerlink" title="2.2.1具体删除策略"></a>2.2.1具体删除策略</h4><p>我们在执行 put 方法时，发现队头元素被删除了，LinkedHashMap 本身是没有 put 方法实现的，调用的是 HashMap 的 put 方法，但 LinkedHashMap 实现了 put 方法中的调用 <code>afterNodeInsertion</code> 方法，这个方式实现了删除。</p>
<h3 id="2-3-LinkedHashMap小结"><a href="#2-3-LinkedHashMap小结" class="headerlink" title="2.3 LinkedHashMap小结"></a>2.3 LinkedHashMap小结</h3><p>LinkedHashMap 提供了两个很有意思的功能：<strong>按照插入顺序访问和删除最少访问元素策略(LRU cache)</strong>，简单地通过链表的结构就实现了，设计得非常巧妙。</p>
<h1 id="Map接口常问问题"><a href="#Map接口常问问题" class="headerlink" title="Map接口常问问题"></a>Map接口常问问题</h1><h2 id="1-Map整体数据结构问题"><a href="#1-Map整体数据结构问题" class="headerlink" title="1. Map整体数据结构问题"></a>1. Map整体数据结构问题</h2><h3 id="1-1-HashMap的底层数据结构"><a href="#1-1-HashMap的底层数据结构" class="headerlink" title="1.1 HashMap的底层数据结构"></a>1.1 HashMap的底层数据结构</h3><p>答：HashMap 底层是数组 + 链表 + 红黑树的数据结构，数组的主要作用是方便快速查找，时间复杂度是 O(1)，默认大小是 16，数组的下标索引是通过 key 的 hashcode 计算出来的，数组元素叫做 Node，当多个 key 的 hashcode 一致，但 key 值不同时，单个 Node 就会转化成链表，链表的查询复杂度是 O(n)，当链表的长度大于等于 8 并且数组的大小超过 64 时，链表就会转化成红黑树，红黑树的查询复杂度是 O(log(n))，简单来说，最坏的查询次数相当于红黑树的最大深度。</p>
<p>具体来说，数组中的每个元素都是一个<strong><font color=#FF000>哈希桶</font></strong>，每个哈希桶里面包含四个字段：hash、key、value、next。其中next表示链表的下一个节点。</p>
<p>JDK 1.8 之所以添加红黑树是因为一旦链表过长，会严重影响 HashMap 的性能，而红黑树具有快速增删改查的特点，这样就可以有效的解决链表过长时操作比较慢的问题。</p>
<p><font color=#FF000>数据结构总结</font>：jdk1.6 1.7 采用 数组+链表，把key 进行取模获取 小标，到对应的链表 进行put/get操作 jdk1.8 采用 数组+链表+红黑树（当链表超过8 而且总长度大于64时，转红黑树【1.符合二叉树结果 2.不是黑色 就红色 3.叶子节点都是黑色 或者nil 4.左右子树 高度差小于 1 】）</p>
<h3 id="1-2-HashMap、TreeMap、LinkedHashMap-三者有啥相同点，有啥不同点？"><a href="#1-2-HashMap、TreeMap、LinkedHashMap-三者有啥相同点，有啥不同点？" class="headerlink" title="1.2 HashMap、TreeMap、LinkedHashMap 三者有啥相同点，有啥不同点？"></a>1.2 HashMap、TreeMap、LinkedHashMap 三者有啥相同点，有啥不同点？</h3><p>答：相同点：</p>
<ol>
<li>三者在特定的情况下，都会使用红黑树；</li>
<li>底层的 hash 算法相同；</li>
<li>在迭代的过程中，如果 Map 的数据结构被改动，都会报 ConcurrentModificationException 的错误。</li>
</ol>
<p>不同点：</p>
<ol>
<li>Map 数据结构以数组为主，查询非常快，TreeMap 数据结构以红黑树为主，利用了红黑树左小右大的特点，可以实现 key 的排序，LinkedHashMap 在 HashMap 的基础上增加了链表的结构，实现了插入顺序访问和最少访问删除两种策略;</li>
<li>由于三种 Map 底层数据结构的差别，导致了三者的使用场景的不同，TreeMap 适合需要根据 key 进行排序的场景，LinkedHashMap 适合按照插入顺序访问，或需要删除最少访问元素的场景，剩余场景我们使用 HashMap 即可，我们工作中大部分场景基本都在使用 HashMap；</li>
<li>由于三种 map 的底层数据结构的不同，导致上层包装的 api 略有差别。</li>
</ol>
<h3 id="1-3-说一下-HashMap-的对hash-算法和寻址算法的优化"><a href="#1-3-说一下-HashMap-的对hash-算法和寻址算法的优化" class="headerlink" title="1.3 说一下 HashMap 的对hash 算法和寻址算法的优化"></a>1.3 说一下 HashMap 的对hash 算法和寻址算法的优化</h3><p><strong>对hash算法的优化</strong>：</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> hash(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">    <span class="built_in">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">key</span> == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = <span class="built_in">key</span>.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">key</span> 在数组中的位置公式：tab[(n - <span class="number">1</span>) &amp; hash]</span><br></pre></td></tr></table></figure>

<p>这段代码是HashMap的hash算法。</p>
<p>这其实是一个数学问题，源码中就是通过以上代码来计算 hash 值的，首先计算出 key 的 hashcode，因为 key 是 Object，所以会根据 key 的不同类型进行 hashcode 的计算，接着计算 h ^ (h &gt;&gt;&gt; 16) ，<strong>这么做的好处是使大多数场景下，算出来的 hash 值比较分散，因为此时hash计算之后的结果的低16位融合了高16位的特征，可以让每个计算出来的hash的值的低16位更大概率不同</strong>。</p>
<p>举个例子，如果一个key经过hashCode()计算后值为：1111 1111 1111 1111 1111 1010 0111 1100(没有经过优化的hash值)，那么右移16位之后会得到：0000 0000 0000 0000 1111 1111 1111 1111，然后将两者异或运算，得到：1111 1111 1111 1111 0000 0101 1000 0011 (经过优化和二进制位运算的新的hash值)（int值，32位） </p>
<p>这些计算我能看懂，但是为啥这么做？<strong>目的是让key的高16位和低16位做异或运算，其本身高16位在结果中还是不变的</strong>。<font color=#FF0000><strong>这个过程就是对hash算法的优化，从而减少冲突</strong></font>。</p>
<p><strong>对寻址算法的优化</strong>：</p>
<p>一般来说，hash 值算出来之后，要计算当前 key 在数组中的索引下标位置时，可以采用取模的方式，就是索引下标位置 = hash 值 % 数组大小，这样做的好处，就是可以保证计算出来的索引下标值可以均匀的分布在数组的各个索引位置上，<strong>但取模操作对于处理器的计算是比较慢的，我们可以考虑将取模运算转换成效果相同的与运算</strong>，数学上有个公式，当 b 是 2 的幂次方时，a % b = a &amp;（b-1），所以此处索引位置的计算公式我们可以更换为： (n-1) &amp; hash。</p>
<p><font color=#FF0000>所以原本是取模的运算，在这里变成了和(长度-1)的与运算，这个是对寻址算法的优化，但是这个与运算和取模运算等价的前提是数组长度为2的倍数，所以哈希表元素数量要是2的倍数</font>。</p>
<p><strong>对hash和寻址算法的优化的总结</strong>：</p>
<ul>
<li><p><strong>hash算法的优化</strong>：对每个hash值，在他的低16位中，让高低16位进行了异或，让他的低16位同时保持了高低16位的特征，尽量避免一些hash值后续出现冲突，大家可能会进入数组的同一个位置</p>
</li>
<li><p><strong>寻址算法的优化</strong>：用与运算替代取模，提升性能</p>
</li>
</ul>
<p>此问题可以延伸出三个小问题：</p>
<ol>
<li>为什么不用 key % 数组大小，而是需要用 key 的 hash 值 % 数组大小。</li>
</ol>
<p>答：如果 key 是数字，直接用 key % 数组大小是完全没有问题的，但我们的 key 还有可能是字符串，是复杂对象，这时候用 字符串或复杂对象 % 数组大小是不行的，所以需要先计算出 key 的 hash 值。</p>
<ol start="2">
<li>计算 hash 值时，为什么需要右移 16 位？</li>
</ol>
<p>答：hash 算法是 h ^ (h &gt;&gt;&gt; 16)，为了使计算出的 hash 值更分散，所以选择先将 h 无符号右移 16 位，然后再于 h 异或时，就能达到 h 的高 16 位和低 16 位都能参与计算，减少了碰撞的可能性。</p>
<ol start="3">
<li>为什么把取模操作换成了 &amp; 操作？</li>
</ol>
<p>答：key.hashCode() 算出来的 hash 值还不是数组的索引下标，为了随机的计算出索引的下表位置，我们还会用 hash 值和数组大小进行取模，这样子计算出来的索引下标比较均匀分布。</p>
<p>取模操作处理器计算比较慢，处理器对 &amp; 操作就比较擅长，换成了 &amp; 操作，是有数学上证明的支撑，为了提高了处理器处理的速度。</p>
<ol start="4">
<li>为什么提倡数组大小是 2 的幂次方？</li>
</ol>
<p>答：因为只有大小是 2 的幂次方时，才能使 hash 值 % n(数组大小) == (n-1) &amp; hash 公式成立。</p>
<h3 id="1-4-为解决-hash-冲突，大概有哪些办法。"><a href="#1-4-为解决-hash-冲突，大概有哪些办法。" class="headerlink" title="1.4 为解决 hash 冲突，大概有哪些办法。"></a>1.4 为解决 hash 冲突，大概有哪些办法。</h3><p>答：1：好的 hash 算法，细问的话复述一下上题的 hash 算法;</p>
<p>2：自动扩容，当数组大小快满的时候，采取自动扩容，可以减少 hash 冲突;</p>
<p>3：hash 冲突发生时，采用链表来解决;</p>
<p>4：hash 冲突严重时，链表会自动转化成红黑树，提高遍历速度。</p>
<p>其他不熟悉的方法不要说了。</p>
<h2 id="2-HashMap源码细节类问题"><a href="#2-HashMap源码细节类问题" class="headerlink" title="2. HashMap源码细节类问题"></a>2. HashMap源码细节类问题</h2><h3 id="2-1-HashMap-是如何扩容的？"><a href="#2-1-HashMap-是如何扩容的？" class="headerlink" title="2.1 HashMap 是如何扩容的？"></a>2.1 HashMap 是如何扩容的？</h3><p>答：扩容的时机：</p>
<ol>
<li>put 时，发现数组为空，进行初始化扩容，默认扩容大小为 16;</li>
<li>put 成功后，发现现有数组大小大于扩容的门阀值时，进行扩容，扩容为老数组大小的 2 倍;</li>
</ol>
<p>扩容的门阀是 threshold，每次扩容时 threshold 都会被重新计算，门阀值等于数组的大小 * 影响因子（0.75）。</p>
<p>新数组初始化之后，需要将老数组的值拷贝到新数组上，链表和红黑树都有自己拷贝的方法。</p>
<p><strong>延伸问题：为什么数组容量会是2的倍数，以及扩容为什么是扩成两倍</strong>？</p>
<p>答：<font color=#FF0000>可以减少碰撞几率，2的倍数 -1 得到值所有位都是1，和计算值相与后能保证结果单一，如果位上的0越多，碰撞概率越大</font>。举个例子， 比如容量是2的4次方 减1就是 1111。那么计算值1110过来和他相与， 结果是1110，另一个计算值1111和他相与结果仍是1111 各自结果不一样 不会碰撞 如果容量不是2的4次方 比如15 减1就是1110. 那么计算值1110过来和他相与， 结果是1110，另一个计算值1111和他相与结果是1110 跟前一个一样 发生碰撞了。</p>
<h3 id="2-2-HashMap-是如何解决哈希冲突的？"><a href="#2-2-HashMap-是如何解决哈希冲突的？" class="headerlink" title="2.2 HashMap 是如何解决哈希冲突的？"></a>2.2 HashMap 是如何解决哈希冲突的？</h3><p>答：hash 冲突指的是 key 值的 hashcode 计算相同，但 key 值不同的情况。</p>
<p>如果桶中元素原本只有一个或已经是链表了，新增元素直接追加到链表尾部；</p>
<p>如果桶中元素已经是链表，并且链表个数大于等于 8 时，此时有两种情况：</p>
<ol>
<li>如果此时数组大小小于 64，数组再次扩容，链表不会转化成红黑树;</li>
<li>如果数组大小大于 64 时，链表就会转化成红黑树。</li>
</ol>
<p>这里不仅仅判断链表个数大于等于 8，还判断了数组大小，数组容量小于 64 没有立即转化的原因，猜测主要是因为红黑树占用的空间比链表大很多，转化也比较耗时，所以数组容量小的情况下冲突严重，我们可以先尝试扩容，看看能否通过扩容来解决冲突的问题。</p>
<ul>
<li>在 JDK 1.7 时 HashMap 是由数组和链表组成的，而 JDK 1.8 则新增了红黑树结构，当链表的长度大于 8 并且容量大于 64 时会转换为红黑树存储，以提升元素的操作性能。结合源码来具体说：当链表长度到8需要转化红黑树是还有一个判断table的length大于MIN_TREEIFY_CAPACITY，也就是64才会转化红黑树</li>
</ul>
<h3 id="2-3-为什么链表个数大于等于-8-时，链表要转化成红黑树了？"><a href="#2-3-为什么链表个数大于等于-8-时，链表要转化成红黑树了？" class="headerlink" title="2.3 为什么链表个数大于等于 8 时，链表要转化成红黑树了？"></a>2.3 为什么链表个数大于等于 8 时，链表要转化成红黑树了？</h3><p>答：当链表个数太多了，遍历可能比较耗时(O(N))，转化成红黑树，可以使遍历的时间复杂度降低，但转化成红黑树，有空间和转化耗时的成本(O(logN))，我们通过泊松分布公式计算，正常情况下，链表个数出现 8 的概念不到千万分之一(源码中有写)，所以说正常情况下，链表都不会转化成红黑树，这样设计的目的，是为了防止非正常情况下，比如 hash 算法出了问题时，导致链表个数轻易大于等于 8 时，仍然能够快速遍历。</p>
<p>延伸问题：<strong>红黑树什么时候转变成链表</strong>。</p>
<p>答：<font color=#FF0000>当节点的个数小于等于 6 时，红黑树会自动转化成链表</font>，主要还是考虑红黑树的<strong>空间成本问题</strong>，当节点个数小于等于 6 时，遍历链表也很快，所以红黑树会重新变成链表。</p>
<h3 id="2-4-HashMap-在-put-时，如果数组中已经有了这个-key，我不想把-value-覆盖怎么办？取值时，如果得到的-value-是空时，想返回默认值怎么办？"><a href="#2-4-HashMap-在-put-时，如果数组中已经有了这个-key，我不想把-value-覆盖怎么办？取值时，如果得到的-value-是空时，想返回默认值怎么办？" class="headerlink" title="2.4 HashMap 在 put 时，如果数组中已经有了这个 key，我不想把 value 覆盖怎么办？取值时，如果得到的 value 是空时，想返回默认值怎么办？"></a>2.4 HashMap 在 put 时，如果数组中已经有了这个 key，我不想把 value 覆盖怎么办？取值时，如果得到的 value 是空时，想返回默认值怎么办？</h3><p>答：如果数组有了 key，但不想覆盖 value ，可以选择 putIfAbsent 方法，这个方法有个内置变量 onlyIfAbsent，内置是 true ，就不会覆盖，我们平时使用的 put 方法，内置 onlyIfAbsent 为 false，是允许覆盖的。</p>
<p>取值时，如果为空，想返回默认值，可以使用 getOrDefault 方法，方法第一参数为 key，第二个参数为你想返回的默认值，如 map.getOrDefault(“2”,“0”)，当 map 中没有 key 为 2 的值时，会默认返回 0，而不是空。</p>
<h3 id="2-5-通过以下代码进行删除，是否可行？"><a href="#2-5-通过以下代码进行删除，是否可行？" class="headerlink" title="2.5 通过以下代码进行删除，是否可行？"></a>2.5 通过以下代码进行删除，是否可行？</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">HashMap&lt;<span class="keyword">String</span>,<span class="keyword">String</span> &gt; <span class="built_in">map</span> = Maps.newHashMap();</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">put</span>(<span class="string">"1"</span>,<span class="string">"1"</span>);</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">put</span>(<span class="string">"2"</span>,<span class="string">"2"</span>);</span><br><span class="line"><span class="built_in">map</span>.forEach((s, s2) -&gt; <span class="built_in">map</span>.<span class="built_in">remove</span>(<span class="string">"1"</span>));</span><br></pre></td></tr></table></figure>

<p>答：不行，会报错误 ConcurrentModificationException</p>
<h3 id="2-6-描述一下-HashMap-get-查询-、put-新增-、resize-数据扩容-的过程"><a href="#2-6-描述一下-HashMap-get-查询-、put-新增-、resize-数据扩容-的过程" class="headerlink" title="2.6 描述一下 HashMap get(查询)、put(新增)、resize(数据扩容) 的过程"></a>2.6 描述一下 HashMap get(查询)、put(新增)、resize(数据扩容) 的过程</h3><h4 id="get-查询"><a href="#get-查询" class="headerlink" title="get(查询)"></a>get(查询)</h4><p>通过源码分析：如果没有哈希冲突，可以直接查询到。如果有哈希冲突，需要判断key的值是否相等，才能确认此元素是不是我们想要的元素。</p>
<h4 id="add-新增"><a href="#add-新增" class="headerlink" title="add(新增)"></a>add(新增)</h4><p>直接来看流程图：</p>
<p><img src="https://i.loli.net/2020/03/26/LCVBDpeqgGdQJa7.png" alt="哈希表新增方法.png"></p>
<p>注意，如果根据key计算的哈希值冲突了，会比较复杂。首先如果之前key已经存在了，会直接覆盖value</p>
<h4 id="resize-扩容-重点"><a href="#resize-扩容-重点" class="headerlink" title="resize(扩容)(重点)"></a>resize(扩容)(重点)</h4><p>当原本数组存不下的时候，需要考虑扩容。比如原先16位的数组，经过扩容之后会变成32位，那么原先的元素在的位置就会变化了。</p>
<p>举个例子，如果用16位存储，我们现在有两个数，经过hash之后结果是一样的，都是5，会冲突。</p>
<p>第一个数：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">n - <span class="number">1</span>      <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1111</span></span><br><span class="line"></span><br><span class="line">hash1     <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0000</span> <span class="number">1111</span> <span class="number">0000</span> <span class="number">0101</span></span><br><span class="line"></span><br><span class="line">&amp;结果    <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0101</span>    = <span class="number">5</span>（index = <span class="number">5</span>的位置）</span><br></pre></td></tr></table></figure>

<p>第二个数：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">n - <span class="number">1</span>      <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1111</span></span><br><span class="line"></span><br><span class="line">hash2     <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0000</span> <span class="number">1111</span> <span class="number">0001</span> <span class="number">0101</span></span><br><span class="line"></span><br><span class="line">&amp;结果    <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0101</span> = <span class="number">5</span>（index = <span class="number">5</span>的位置）</span><br></pre></td></tr></table></figure>

<p>会发现，这两个数hash之后结果都是5，也就是说在数组长度为16的时候，他们两个hash值的位置是一样的，用链表来处理，出现一个hash冲突的问题。</p>
<p>所以我们可以进行扩容，扩容到32位去保存。扩容之后：</p>
<p>第一个数：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">n<span class="number">-1</span>        <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1111</span></span><br><span class="line"></span><br><span class="line">hash1     <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0000</span> <span class="number">1111</span> <span class="number">0000</span> <span class="number">0101</span></span><br><span class="line"></span><br><span class="line">&amp;结果    <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0101</span> = <span class="number">5</span>（index = <span class="number">5</span>的位置）</span><br></pre></td></tr></table></figure>

<p>第二个数：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">n<span class="number">-1</span>        <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1111</span></span><br><span class="line"></span><br><span class="line">hash2     <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0000</span> <span class="number">1111</span> <span class="number">0001</span> <span class="number">0101</span></span><br><span class="line"></span><br><span class="line">&amp;结果    <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">0101</span> = <span class="number">21</span>（index = <span class="number">21</span>的位置）</span><br></pre></td></tr></table></figure>

<p>由此一来，计算之后index就不冲突了，扩容的数组得到了利用。</p>
<p>判断二进制结果中是否多出一个bit的1，如果没多，那么就是原来的index，如果多了出来，那么就是index + oldCap(对于这个例子，就是5+16，新位置是21)，通过这个方式，就避免了rehash的时候，用每个hash对新数组.length取模，取模性能不高，位运算的性能比较高。</p>
<p>也就是说，如果扩容之后高位发生了变化，那么新的位置是<font color=#FF0000>原数组下标+原数组长度</font></p>
<p>上面只是一个大概的印象，<strong>下面结合源码进行详细分析</strong>：</p>
<p>从源码可以看出，JDK 1.8 在扩容时并没有像 JDK 1.7 那样，重新计算每个元素的哈希值，而是通过高位运算（e.hash &amp; oldCap）来确定元素是否需要移动，比如 key1 的信息如下：</p>
<ul>
<li><p>key1.hash = 10 (0000 1010)</p>
</li>
<li><p>oldCap = 16 (0001 0000)</p>
</li>
</ul>
<p>使用 e.hash &amp; oldCap 得到的结果，高一位为 0，当结果为 0 时表示元素在扩容时位置不会发生任何变化.</p>
<p>再举个例子，key2:</p>
<ul>
<li><p>key2.hash = 10 0001 0001</p>
</li>
<li><p>oldCap = 16 0001 0000</p>
</li>
</ul>
<p>这时候得到的结果，高一位为 1，当结果为 1 时，表示元素在扩容时位置发生了变化，新的下标位置等于原下标位置 + 原数组长度，如下图所示：</p>
<p><img src="https://i.loli.net/2020/03/26/zbRju1JL4oZArNh.png" alt="哈希表扩容.png"></p>
<p>其中红色的虚线图代表了扩容时元素移动的位置。</p>
<h3 id="2-7-什么是加载因子？加载因子为什么是0-75？"><a href="#2-7-什么是加载因子？加载因子为什么是0-75？" class="headerlink" title="2.7 什么是加载因子？加载因子为什么是0.75？"></a>2.7 什么是加载因子？加载因子为什么是0.75？</h3><p>加载因子也叫扩容因子或负载因子，用来判断什么时候进行扩容的，假如加载因子是0.5，HashMap的初始化容量是16，那么当HashMap中有16*0.5=8个元素时，HashMap就会进行扩容。</p>
<p>那加载因子为什么是 0.75 而不是 0.5 或者 1.0 呢？</p>
<p>这其实是出于容量和性能之间平衡的结果：</p>
<ul>
<li>当加载因子设置比较大的时候，扩容的门槛就被提高了，扩容发生的频率比较低，占用的空间会比较小，但此时发生Hash冲突的几率就会提升，因此需要更复杂的数据结构来存储元素，这样对元素的操作时间就会增加，运行效率也会因此降低；而当加载因子值比较小的时候，扩容的门槛会比较低，因此会占用更多的空间，此时元素的存储就比较稀疏，发生哈希冲突的可能性就比较小，因此操作性能会比较高。</li>
<li><strong>为了提升扩容效果，HashMap的容量(capacity)有一个固定的要求，那就是一定要是2的幂。所以，如果负载因子是3/4的话，那么和capacity的乘积结果就可以是一个整数。</strong></li>
</ul>
<p>所以综合了以上情况就取了一个 0.5 到 1.0 的平均数 0.75 作为加载因子。</p>
<h3 id="2-8-HashMap死循环分析"><a href="#2-8-HashMap死循环分析" class="headerlink" title="2.8 HashMap死循环分析"></a>2.8 HashMap死循环分析</h3><p>以JDK1.7为例，假设HashMap默认大小为2，原本HashMap中有一个元素key(5)，我们再使用两个线程：t1添加元素key(3)，t2添加元素key(7)，当元素key(3) 和 key(7) 都添加到 HashMap 中之后，线程 t1 在执行到 Entry&lt;K,V&gt; next = e.next; 时，交出了 CPU 的使用权，源码如下：</p>
<p><img src="https://i.loli.net/2020/03/26/dyLhi4eBJU3I1Cp.png" alt="哈希死循环代码.png"></p>
<p>那么此时线程t1中的e指向了key(3)，而next指向了key(7)；之后线程t2重新rehash之后链表的顺序被反转，链表的位置变成了key(5)→key(7)→key(3)，其中 “→” 用来表示下一个元素。</p>
<p>当t1重新获得执行权之后，先执行newTalbe[i]=e把key(3)的next设置为key(7)，而下次循环时查询到key(7)的next元素为key(3)，于是就形成了 key(3) 和 key(7) 的循环引用，因此就导致了死循环的发生，如下图所示：</p>
<p><img src="https://i.loli.net/2020/03/26/BeLuptASOiDR5PW.png" alt="哈希表死循环.png"></p>
<p>当然发生死循环的原因是 JDK 1.7 链表插入方式为首部倒序插入，这个问题在 JDK 1.8 得到了改善，变成了尾部正序插入。</p>
<p>有人曾经把这个问题反馈给了Sun公司，但Sun公司认为这不是一个问题，<font color=#FF0000>因为HashMap本身就是非线程安全的，如果要在多线程下，建议使用ConcurrentHashMap替代</font>，但这个问题在面试中被问到的几率依然很大，所以在这里需要特别说明一下。</p>
<h2 id="3-其他Map面试题"><a href="#3-其他Map面试题" class="headerlink" title="3.其他Map面试题"></a>3.其他Map面试题</h2><h3 id="3-1-DTO-作为-Map-的-key-时，有无需要注意的点？"><a href="#3-1-DTO-作为-Map-的-key-时，有无需要注意的点？" class="headerlink" title="3.1 DTO 作为 Map 的 key 时，有无需要注意的点？"></a>3.1 DTO 作为 Map 的 key 时，有无需要注意的点？</h3><p>答：DTO 就是一个数据载体，可以看做拥有很多属性的 Java 类，我们可以对这些属性进行 get、set 操作。</p>
<p>看是什么类型的 Map，如果是 HashMap 的话，一定需要覆写 equals 和 hashCode 方法，因为在 get 和 put 的时候，需要通过 equals 方法进行相等的判断；如果是 TreeMap 的话，DTO 需要实现 Comparable 接口，因为 TreeMap 会使用 Comparable 接口进行判断 key 的大小；如果是 LinkedHashMap 的话，和 HashMap 一样的。</p>
<h3 id="3-2-为什么推荐-TreeMap-的元素最好都实现-Comparable-接口？但-key-是-String-的时候，我们却没有额外的工作呢？"><a href="#3-2-为什么推荐-TreeMap-的元素最好都实现-Comparable-接口？但-key-是-String-的时候，我们却没有额外的工作呢？" class="headerlink" title="3.2 为什么推荐 TreeMap 的元素最好都实现 Comparable 接口？但 key 是 String 的时候，我们却没有额外的工作呢？"></a>3.2 为什么推荐 TreeMap 的元素最好都实现 Comparable 接口？但 key 是 String 的时候，我们却没有额外的工作呢？</h3><p>答：因为 TreeMap 的底层就是通过排序来比较两个 key 的大小的，所以推荐 key 实现 Comparable 接口，是为了往你希望的排序顺序上发展， 而 String 本身已经实现了 Comparable 接口，所以使用 String 时，我们不需要额外的工作，不仅仅是 String ，其他包装类型也都实现了 Comparable 接口，如 Long、Double、Short 等等。</p>
<h1 id="集合在JDK7和JDK8有什么区别"><a href="#集合在JDK7和JDK8有什么区别" class="headerlink" title="集合在JDK7和JDK8有什么区别"></a>集合在JDK7和JDK8有什么区别</h1><h2 id="1-通用区别"><a href="#1-通用区别" class="headerlink" title="1.通用区别"></a>1.通用区别</h2><h3 id="所有集合都新增了forEach方法"><a href="#所有集合都新增了forEach方法" class="headerlink" title="所有集合都新增了forEach方法"></a>所有集合都新增了forEach方法</h3><p>List、Set、Map 在 Java 8 版本中都增加了 forEach 的方法，方法的入参是 Consumer，Consumer 是一个函数式接口，可以简单理解成允许一个入参，但没有返回值的函数式接口</p>
<h2 id="2-List区别"><a href="#2-List区别" class="headerlink" title="2 List区别"></a>2 List区别</h2><p>ArrayList 无参初始化时，Java 7 是直接初始化 10 的大小，Java 8 去掉了这个逻辑，初始化时是空数组，在第一次 add 时才开始按照 10 进行扩容。</p>
<p>需要注意，<strong>List在其他方面，Java7和Java8没有改动</strong>。</p>
<h2 id="3-Map区别"><a href="#3-Map区别" class="headerlink" title="3 Map区别"></a>3 Map区别</h2><h3 id="3-1-HashMap"><a href="#3-1-HashMap" class="headerlink" title="3.1 HashMap"></a>3.1 HashMap</h3><ol>
<li>和 ArrayList 一样，Java 8 中 HashMap 在无参构造器中，丢弃了 Java 7 中直接把数组初始化 16 的做法，而是采用在第一次新增的时候，才开始扩容数组大小；</li>
<li>hash 算法计算公式不同，Java 8 的 hash 算法更加简单，代码更加简洁；</li>
<li>Java 8 的 HashMap 增加了红黑树的数据结构，这个是 Java 7 中没有的，Java 7 只有数组 + 链表的结构，Java 8 中提出了数组 + 链表 + 红黑树的结构，一般 key 是 Java 的 API 时，比如说 String 这些 hashcode 实现很好的 API，很少出现链表转化成红黑树的情况，因为 String 这些 API 的 hash 算法够好了，只有当 key 是我们自定义的类，而且我们覆写的 hashcode 算法非常糟糕时，才会真正使用到红黑树，提高我们的检索速度。</li>
</ol>
<p>也是因为 Java 8 新增了红黑树，所以几乎所有操作数组的方法的实现，都发生了变动，比如说 put、remove 等操作，可以说 Java 8 的 HashMap 几乎重写了一遍，所以 Java 7 的很多问题都被 Java 8 解决了，比如扩容时极小概率死锁，丢失数据等等。</p>
<ol start="4">
<li>新增了一些好用的方法，比如 getOrDefault</li>
<li>新增了putIfAbsent(K key, V value) 方法，意思是，如果 map 中存在 key 了，那么 value 就不会覆盖，如果不存在 key ，新增成功。</li>
<li>新增了compute 方法，意思是允许我们把 key 和 value 的值进行计算后，再 put 到 map 中，为防止 key 值不存在造成未知错误，map 还提供了 computeIfPresent 方法，表示只有在 key 存在的时候</li>
</ol>
<p>上述 Java 8 新增的几种方法非常好用，在实际工作中，可以大大减少我们的代码量</p>
<h3 id="3-2-LinkedHashMap"><a href="#3-2-LinkedHashMap" class="headerlink" title="3.2 LinkedHashMap"></a>3.2 LinkedHashMap</h3><p>由于 Java 8 的底层数据有变动，导致 HashMap 操作数据的方法几乎重写，也使 LinkedHashMap 的实现名称上有所差异。</p>
<h2 id="4-其他区别"><a href="#4-其他区别" class="headerlink" title="4 其他区别"></a>4 其他区别</h2><p><strong>Arrays 提供了很多 parallel 开头的方法。</strong></p>
<p>Java 8 的 Arrays 提供了一些 parallel 开头的方法，这些方法支持并行的计算，在数据量大的时候，会充分利用 CPU ，提高计算效率，比如说 parallelSort 方法，方法底层有判断，只有数据量大于 8192 时，才会真正走并行的实现，在实际的实验中，并行计算的确能够快速的提高计算速度。</p>
<h2 id="5-面试题"><a href="#5-面试题" class="headerlink" title="5.面试题"></a>5.面试题</h2><ol>
<li><p>Java 8 在 List、Map 接口上新增了很多方法，为什么 Java 7 中这些接口的实现者不需要强制实现这些方法呢？<br>答：主要是因为这些新增的方法被 default 关键字修饰了，default 一旦修饰接口上的方法，我们需要在接口的方法中写默认实现，并且子类无需强制实现这些方法，所以 Java 7 接口的实现者无需感知。</p>
</li>
<li><p>Java 8 中有新增很多实用的方法，你在平时工作中有使用过么？</p>
</li>
</ol>
<p>答：有的，比如说 getOrDefault、putIfAbsent、computeIfPresent 方法等等，具体使用细节参考上文。</p>
<ol start="3">
<li>说说 computeIfPresent 方法的使用姿势？</li>
</ol>
<p>答：computeIfPresent 是可以对 key 和 value 进行计算后，把计算的结果重新赋值给 key，并且如果 key 不存在时，不会报空指针，会返回 null 值。</p>
<ol start="4">
<li>Java 8 集合新增了 forEach 方法，和普通的 for 循环有啥不同？</li>
</ol>
<p>答：新增的 forEach 方法的入参是函数式的接口，比如说 Consumer 和 BiConsumer，这样子做的好处就是封装了 for 循环的代码，让使用者只需关注实现每次循环的业务逻辑，简化了重复的 for 循环代码，使代码更加简洁，普通的 for 循环，每次都需要写重复的 for 循环代码，forEach 把这种重复的计算逻辑吃掉了，使用起来更加方便。</p>
<ol start="5">
<li>HashMap 8 和 7 有啥区别？</li>
</ol>
<p>答：HashMap 8 和 7 的差别太大了，新增了红黑树，修改了底层数据逻辑，修改了 hash 算法，几乎所有底层数组变动的方法都重写了一遍，可以说 Java 8 的 HashMap 几乎重新了一遍。</p>
<h2 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h2><p>总体来说，List 方面是小改动，HashMap 几乎重写了一套，所有的集合都新增了函数式的方法，比如说 forEach，也新增了很多好用的函数，比如说 getOrDefault，这些函数可以大大减少我们的代码量，让我们把关注点聚焦在业务逻辑的实现上，这其实是一种思想，把繁琐重复的计算逻辑抽取出来，从计算逻辑中扩展出业务逻辑的口子，让使用者只专心关注业务逻辑的实现即可。</p>
<h1 id="ConcurrentHashMap-源码解析和设计思路-未完"><a href="#ConcurrentHashMap-源码解析和设计思路-未完" class="headerlink" title="ConcurrentHashMap 源码解析和设计思路(未完)"></a>ConcurrentHashMap 源码解析和设计思路(未完)</h1><p>当我们碰到线程不安全场景下，需要使用 Map 的时候，我们第一个想到的 API 估计就是 ConcurrentHashMap，ConcurrentHashMap 内部封装了锁和各种数据结构来保证访问 Map 是线程安全的。</p>
<p>Q：说明一下，为什么要解决HashMap的多线程问题？</p>
<p>A：HashMap不是线程安全的，而如果每次多线程使用HashMap的时候都加上<code>synchronized</code>关键字，性能很低也很不合理，因为底层数组里有很多的元素，除非是对同一个元素执行put操作，否则不需要多线程加上阻塞来强制同步进行。</p>
<h2 id="总体概览"><a href="#总体概览" class="headerlink" title="总体概览"></a>总体概览</h2><p><strong>在JDK 1.7以及之前的版本里，是对数组的每个部分都进行分段</strong>，即：[数组1] , [数组2]，[数组3] -&gt; 每个数组都对应一个锁，分段加锁。但是，如果不同线程访问的数组的位置不同那么其实没必要耗费资源加锁。比如，多个线程过来，线程1要put的位置是数组1[5]，线程2要put的位置是数组2[21]，那么其实这两个线程之间不冲突，没必要针对不同的数组加锁。</p>
<p>所以，JDK 1.8以及之后，做了一些优化和改进，<strong>对锁粒度进行了细化</strong>。</p>
<p>现在我们只有一个数组，即<code>[一个大的数组]</code>，<font color=#FF0000>数组里每个元素进行put操作，都是有一个不同的锁</font>，刚开始进行put的时候，如果两个线程都是在数组[5]这个位置进行put，这个时候，<strong>对数组[5]这个位置进行put的时候，采取的是CAS的策略</strong>。</p>
<p>同一个时间，只有一个线程能成功执行这个CAS，就是说他刚开始先获取数组[5]这个位置的值，如果是null，那么之后执行CAS，线程1，比较一下，如果还是null，则put进去我的这条数据，此时，其他的线程执行CAS的时候都会失败。</p>
<p><font color=#FF0000>使用了分段加锁</font>，通过对数组每个元素执行CAS的策略，如果是很多线程对数组里不同的元素执行put，大家是没有关系的，如果其他线程失败了，其他线程此时会发现数组[5]这位置，已经给刚才有线程放值进去了。</p>
<p>此时就需要在这个位置基于链表+红黑树来进行处理，synchronized(数组[5])，加锁，基于链表或者是红黑树在这个位置插进去自己的数据。</p>
<p>所以，在JDK1.8之后实现了：<strong>如果你是对数组里同一个位置的元素进行操作，才会加锁串行化处理；如果是对数组不同位置的元素操作，此时大家可以并发执行的</strong>。ConcurrentHashMap就是在这上面进行了优化。</p>
<p><strong>总体概览小结</strong>：</p>
<p> <strong>jdk1.8之前ConcurrentHashMap实现线程安全使用的是<font color=#FF0000>分段锁技术</font></strong>，即将一个大数组分成几个小数组，当并发put时，处于同一个小数组的put操作会串行；不同小数组间的put操作不受影响 。</p>
<p><strong>jdk1.8及之后，ConcurrentHashMap<font color=#FF0000>优化了锁的细粒度</font></strong>，并发操作时，对数组中每一个位置元素进行CAS。当并发put时，对同一位置进行put操作，如果put失败，说明在这之前有线程对这个位置进行了put成功操作，则对这个位置上的链表或者红黑树使用synchronized加锁；对不同位置put操作是不受影响的。</p>
<h2 id="1-类注释"><a href="#1-类注释" class="headerlink" title="1. 类注释"></a>1. 类注释</h2><p>我们从类注释上大概可以得到如下信息：</p>
<ol>
<li>所有的操作都是线程安全的，我们在使用时，无需再加锁；</li>
<li>多个线程同时进行 put、remove 等操作时并不会阻塞，可以同时进行，和 HashTable 不同，HashTable 在操作时，会锁住整个 Map；</li>
<li>迭代过程中，即使 Map 结构被修改，也不会抛 ConcurrentModificationException 异常；</li>
<li>除了数组 + 链表 + 红黑树的基本结构外，新增了转移节点，是为了保证扩容时的线程安全的节点；</li>
<li>提供了很多 Stream 流式方法，比如说：forEach、search、reduce 等等。</li>
</ol>
<h2 id="2-结构"><a href="#2-结构" class="headerlink" title="2.结构"></a>2.结构</h2><p>虽然 ConcurrentHashMap 的底层数据结构，和方法的实现细节和 HashMap 大体一致，但两者在类结构上却没有任何关联</p>
<p>如下图：</p>
<p><img src="https://i.loli.net/2020/03/18/fsNkZXdAE1ytaJ7.png" alt="ConcurrentHashMap类继承关系图.png"></p>
<p>有的同学可能会问，为什么不继承 HashMap 呢？继承的确是个好办法，但尴尬的是，ConcurrentHashMap 都是在方法中间进行一些加锁操作，也就是说加锁把方法切割了，继承就很难解决这个问题。</p>
<p>ConcurrentHashMap 和 HashMap 两者的相同之处：</p>
<ol>
<li>数组、链表结构几乎相同，所以底层对数据结构的操作思路是相同的（只是思路相同，底层实现不同）；</li>
<li>都实现了 Map 接口，继承了 AbstractMap 抽象类，所以大多数的方法也都是相同的，HashMap 有的方法，ConcurrentHashMap 几乎都有，所以当我们需要从 HashMap 切换到 ConcurrentHashMap 时，无需关心两者之间的兼容问题。</li>
</ol>
<p>不同之处：</p>
<ol>
<li>红黑树结构略有不同，HashMap 的红黑树中的节点叫做 TreeNode，TreeNode 不仅仅有属性，还维护着红黑树的结构，比如说查找，新增等等；ConcurrentHashMap 中红黑树被拆分成两块，TreeNode 仅仅维护的属性和查找功能，新增了 TreeBin，来维护红黑树结构，并负责根节点的加锁和解锁；</li>
<li>新增 ForwardingNode （转移）节点，扩容的时候会使用到，通过使用该节点，来保证扩容时的线程安全。</li>
</ol>
<h2 id="3-Put操作"><a href="#3-Put操作" class="headerlink" title="3.Put操作"></a>3.Put操作</h2><p>ConcurrentHashMap 在 put 方法上的整体思路和 HashMap 相同，但在线程安全方面写了很多保障的代码，我们先来看下大体思路：</p>
<ol>
<li>如果数组为空，初始化，初始化完成之后，走 2；</li>
<li>计算当前槽点有没有值，没有值的话，cas 创建，失败继续自旋（for 死循环），直到成功，槽点有值的话，走 3；</li>
<li>如果槽点是转移节点(正在扩容)，就会一直自旋等待扩容完成之后再新增，不是转移节点走 4；</li>
<li>槽点有值的，先锁定当前槽点，保证其余线程不能操作，如果是链表，新增值到链表的尾部，如果是红黑树，使用红黑树新增的方法新增；</li>
<li>新增完成之后 check 需不需要扩容，需要的话去扩容。</li>
</ol>
<h3 id="3-1数组初始化时的线程安全"><a href="#3-1数组初始化时的线程安全" class="headerlink" title="3.1数组初始化时的线程安全"></a>3.1数组初始化时的线程安全</h3><p>数组初始化时，首先通过自旋来保证一定可以初始化成功，然后通过 CAS 设置 SIZECTL 变量的值，来保证同一时刻只能有一个线程对数组进行初始化，CAS 成功之后，还会再次判断当前数组是否已经初始化完成，如果已经初始化完成，就不会再次初始化，通过自旋 + CAS + 双重 check 等手段保证了数组初始化时的线程安全。</p>
<h3 id="3-2新增槽点值时的线程安全"><a href="#3-2新增槽点值时的线程安全" class="headerlink" title="3.2新增槽点值时的线程安全"></a>3.2新增槽点值时的线程安全</h3><p>此时为了保证线程安全，做了四处优化：</p>
<ol>
<li>通过自旋死循环保证一定可以新增成功。</li>
</ol>
<p>在新增之前，通过 <code>for (Node[] tab = table;;)</code> 这样的死循环来保证新增一定可以成功，一旦新增成功，就可以退出当前死循环，新增失败的话，会重复新增的步骤，直到新增成功为止。</p>
<ol start="2">
<li>当前槽点为空时，通过 CAS 新增。</li>
</ol>
<p>Java 这里的写法非常严谨，没有在判断槽点为空的情况下直接赋值，因为在判断槽点为空和赋值的瞬间，很有可能槽点已经被其他线程赋值了，所以我们采用 CAS 算法，能够保证槽点为空的情况下赋值成功，如果恰好槽点已经被其他线程赋值，当前 CAS 操作失败，会再次执行 for 自旋，再走槽点有值的 put 流程，这里就是自旋 + CAS 的结合。</p>
<ol start="3">
<li>当前槽点有值，锁住当前槽点。</li>
</ol>
<p>put 时，如果当前槽点有值，就是 key 的 hash 冲突的情况，此时槽点上可能是链表或红黑树，我们通过锁住槽点，来保证同一时刻只会有一个线程能对槽点进行修改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">V oldVal = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 锁定当前槽点，其余线程不能操作，保证了安全</span></span><br><span class="line"><span class="keyword">synchronized</span>(f)&#123;&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>红黑树旋转时，锁住红黑树的根节点，保证同一时刻，当前红黑树只能被一个线程旋转，如下图代码：</li>
</ol>
<p><img src="https://i.loli.net/2020/04/06/zo1ZKkudjsCLRUG.png" alt="红黑树旋转时代码.png"></p>
<p>通过以上 4 点，保证了在各种情况下的新增（不考虑扩容的情况下），都是线程安全的，通过自旋 + CAS + 锁三大姿势，实现的很巧妙。</p>
<h3 id="3-3-扩容时的线程安全"><a href="#3-3-扩容时的线程安全" class="headerlink" title="3.3  扩容时的线程安全"></a>3.3  扩容时的线程安全</h3><p>ConcurrentHashMap 的扩容时机和 HashMap 相同，都是在 put 方法的最后一步检查是否需要扩容，如果需要则进行扩容，但两者扩容的过程完全不同，ConcurrentHashMap 扩容的方法叫做 transfer，从 put 方法的 addCount 方法进去，就能找到 transfer 方法，transfer 方法的主要思路是：</p>
<ol>
<li>首先需要把老数组的值全部拷贝到扩容之后的新数组上，先从数组的队尾开始拷贝；</li>
<li>拷贝数组的槽点时，先把原数组槽点锁住，保证原数组槽点不能操作，成功拷贝到新数组时，把原数组槽点赋值为转移节点；</li>
<li>这时如果有新数据正好需要 put 到此槽点时，发现槽点为转移节点，就会一直等待，所以在扩容完成之前，该槽点对应的数据是不会发生变化的；</li>
<li>从数组的尾部拷贝到头部，每拷贝成功一次，就把原数组中的节点设置成转移节点；</li>
<li>直到所有数组数据都拷贝到新数组时，直接把新数组整个赋值给数组容器，拷贝完成</li>
</ol>
<p>扩容中的关键点，就是如何保证是线程安全的，小结有如下几点：</p>
<ol>
<li>拷贝槽点时，会把原数组的槽点锁住；</li>
<li>拷贝成功之后，会把原数组的槽点设置成转移节点，这样如果有数据需要 put 到该节点时，发现该槽点是转移节点，会一直等待，直到扩容成功之后，才能继续 put，可以参考 put 方法中的 helpTransfer 方法；</li>
<li>从尾到头进行拷贝，拷贝成功就把原数组的槽点设置成转移节点。</li>
<li>等扩容拷贝都完成之后，直接把新数组的值赋值给数组容器，之前等待 put 的数据才能继续 put。</li>
</ol>
<p>扩容方法还是很有意思的，通过在原数组上设置转移节点，put 时碰到转移节点时会等待扩容成功之后才能 put 的策略，来保证了整个扩容过程中肯定是线程安全的，因为数组的槽点一旦被设置成转移节点，在没有扩容完成之前，是无法进行操作的。</p>
<h2 id="4-get"><a href="#4-get" class="headerlink" title="4.get"></a>4.get</h2><p>ConcurrentHashMap 读的话，就比较简单，先获取数组的下标，然后通过判断数组下标的 key 是否和我们的 key 相等，相等的话直接返回，如果下标的槽点是链表或红黑树的话，分别调用相应的查找数据的方法，整体思路和 HashMap 很像。</p>
<h2 id="5-ConcurrentHashMap线程安全的具体实现方式-底层实现"><a href="#5-ConcurrentHashMap线程安全的具体实现方式-底层实现" class="headerlink" title="5.ConcurrentHashMap线程安全的具体实现方式/底层实现"></a>5.ConcurrentHashMap线程安全的具体实现方式/底层实现</h2><p>如下图：</p>
<h3 id="JDK1-7之前："><a href="#JDK1-7之前：" class="headerlink" title="JDK1.7之前："></a>JDK1.7之前：</h3><p><img src="https://i.loli.net/2020/04/27/5pKPNkChbBG8QHO.png" alt="JDK7及之前的ConcurrentHashMap.png"></p>
<p>具体实现：</p>
<p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的 数据也能被其他线程访问。</p>
<p><strong>ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成</strong>。 </p>
<p>Segment 实现了 ReentrantLock,所以 Segment 是一种可重入锁，扮演锁的角色。HashEntry 用于存储键值对数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个 HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。 </p>
<h3 id="JDK1-8的ConcurrentHashMap"><a href="#JDK1-8的ConcurrentHashMap" class="headerlink" title="JDK1.8的ConcurrentHashMap:"></a>JDK1.8的ConcurrentHashMap:</h3><p><img src="https://i.loli.net/2020/04/27/Nz8IYqKcWwyPoGE.png" alt="JDK8的ConcurrentHashMap.png"></p>
<p>ConcurrentHashMap取消了Segment分段锁，采用CAS和synchronized来保证并发安全。数据结构跟HashMap1.8 的结构类似，数组+链表/红黑二叉树。 </p>
<p>synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。</p>
]]></content>
      <categories>
        <category>Study Note</category>
        <category>Interview Note</category>
      </categories>
      <tags>
        <tag>List</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title>Overview of SSL and TLS protocol operration mechanism</title>
    <url>/2020/03/16/SSL-and-TLS/</url>
    <content><![CDATA[<blockquote>
<p>不希望负担变轻，只希望肩膀变强</p>
</blockquote>
<a id="more"></a>

<p>本文参考转载阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">这篇文章</a></p>
<p>都说HTTPS比HTTP更安全，WHY？主要就是因为HTTPS比HTTP多一个SSL/TLS协议。可以说，互联网的安全，是建立在SSL/TLS协议之上的。</p>
<p>SSL/TLS使用非对称加密，即加密使用的秘钥和解密使用的秘钥是不相同的。</p>
<p>本文简要介绍SSL/TLS协议的运行机制。文章的重点是设计思想和运行过程，不涉及具体的实现细节。</p>
<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>不使用SSL/TLS的HTTP通信，就是不加密的通信。所有信息明文传播，带来了三大风险。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>） 窃听风险（eavesdropping）：第三方可以获知通信内容。</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>） 篡改风险（tampering）：第三方可以修改通信内容。</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>） 冒充风险（pretending）：第三方可以冒充他人身份参与通信。</span><br></pre></td></tr></table></figure>

<p>SSL/TLS协议是为了解决这三大风险而设计的，希望达到：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>） 所有信息都是加密传播，第三方无法窃听。</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>） 具有校验机制，一旦被篡改，通信双方会立刻发现。</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>） 配备身份证书，防止身份被冒充。</span><br></pre></td></tr></table></figure>

<p>互联网是开放环境，通信双方都是未知身份，这为协议的设计带来了很大的难度。而且，协议还必须能够经受所有匪夷所思的攻击，这使得SSL/TLS协议变得异常复杂。</p>
<h1 id="基本运行过程"><a href="#基本运行过程" class="headerlink" title="基本运行过程"></a>基本运行过程</h1><p>SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。(<strong>即非对称加密，加密和解密的秘钥不同</strong>)</p>
<p>但是，这里有两个问题。</p>
<p>（1）如何保证公钥不被篡改？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。</span><br></pre></td></tr></table></figure>

<p>（2）公钥加密计算量太大，如何减少耗用的时间？</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">解决方法：每一次对话（<span class="keyword">session</span>），客户端和服务器端都生成一个"对话密钥"（<span class="keyword">session</span> key），用它来加密信息。由于"对话密钥"是对称加密，所以运算速度非常快，而服务器公钥只用于加密"对话密钥"本身，这样就减少了加密运算的消耗时间。</span><br></pre></td></tr></table></figure>

<p>因此，SSL/TLS协议的基本过程是这样的：</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>） 客户端向服务器端索要并验证公钥。</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>） 双方协商生成<span class="string">"对话密钥"</span>。</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>） 双方采用<span class="string">"对话密钥"</span>进行加密通信。</span><br></pre></td></tr></table></figure>

<p>上面过程的前两步，又称为”握手阶段”（handshake）。</p>
<h1 id="HTTPS四次握手详细过程"><a href="#HTTPS四次握手详细过程" class="headerlink" title="HTTPS四次握手详细过程"></a>HTTPS四次握手详细过程</h1><p>“握手阶段”的所有通信都是明文的。</p>
<h2 id="客户端发出请求（ClientHello）"><a href="#客户端发出请求（ClientHello）" class="headerlink" title="客户端发出请求（ClientHello）"></a>客户端发出请求（ClientHello）</h2><p>首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做ClientHello请求。</p>
<p>在这一步，客户端主要向服务器提供以下信息。</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>） 支持的协议版本，比如TLS <span class="number">1.0</span>版。</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>） 一个客户端生成的随机数，稍后用于生成<span class="string">"对话密钥"</span>。</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>） 支持的加密方法，比如RSA公钥加密。</span><br><span class="line"></span><br><span class="line">（<span class="number">4</span>） 支持的压缩方法。</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是，客户端发送的信息之中不包括服务器的域名。也就是说，理论上服务器只能包含一个网站，否则会分不清应该向客户端提供哪一个网站的数字证书。这就是为什么通常一台服务器只能有一张数字证书的原因。</p>
<p>对于虚拟主机的用户来说，这当然很不方便。2006年，TLS协议加入了一个Server Name Indication扩展，允许客户端向服务器提供它所请求的域名。</p>
<h2 id="服务器回应（SeverHello）"><a href="#服务器回应（SeverHello）" class="headerlink" title="服务器回应（SeverHello）"></a>服务器回应（SeverHello）</h2><p>服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello。服务器的回应包含以下内容。</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>） 确认使用的加密通信协议版本，比如TLS <span class="number">1.0</span>版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>） 一个服务器生成的随机数，稍后用于生成<span class="string">"对话密钥"</span>。</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>） 确认使用的加密方法，比如RSA公钥加密。</span><br><span class="line"></span><br><span class="line">（<span class="number">4</span>） 服务器证书。</span><br></pre></td></tr></table></figure>

<p>除了上面这些信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供”客户端证书”。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。</p>
<h2 id="客户端回应"><a href="#客户端回应" class="headerlink" title="客户端回应"></a>客户端回应</h2><p>客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。</p>
<p>如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>） 一个随机数。该随机数用服务器公钥加密，防止被窃听。</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>） 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>） 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。</span><br></pre></td></tr></table></figure>

<p>上面第一项的随机数，是整个握手阶段出现的第三个随机数，又称”pre-master key”。有了它以后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把”会话密钥”。</p>
<p>至于为什么一定要用三个随机数，来生成”会话密钥”，dog250解释得很好：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">"不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。</span></span><br><span class="line"></span><br><span class="line">对于RSA密钥交换算法来说，<span class="keyword">pre</span>-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。</span><br><span class="line"></span><br><span class="line"><span class="keyword">pre</span> master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么<span class="keyword">pre</span> master secret就有可能被猜出来，那么仅适用<span class="keyword">pre</span> master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上<span class="keyword">pre</span> master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。<span class="comment">"</span></span><br></pre></td></tr></table></figure>

<p>此外，如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息。</p>
<h2 id="服务器的最后回应"><a href="#服务器的最后回应" class="headerlink" title="服务器的最后回应"></a>服务器的最后回应</h2><p>服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的”会话密钥”。然后，向客户端最后发送下面信息。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。</span><br></pre></td></tr></table></figure>

<p>至此，整个握手阶段全部结束。<strong>接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议</strong>，只不过用”会话密钥”加密内容。</p>
<p>如下图：</p>
<p><img src="https://i.loli.net/2020/03/16/ekPaYWIzLdbwo9F.png" alt="HTTPS协议的加密.png"></p>
]]></content>
      <categories>
        <category>Study Note</category>
        <category>Interview Note</category>
      </categories>
      <tags>
        <tag>HTTPS</tag>
        <tag>SSL</tag>
        <tag>TLS</tag>
      </tags>
  </entry>
  <entry>
    <title>What is RESTful?</title>
    <url>/2020/03/13/what-is-restful/</url>
    <content><![CDATA[<blockquote>
<p>不希望负担变轻，只希望肩膀变强</p>
</blockquote>
<p>介绍RESTful核心概念，列举RESTful API设计与实践的案例</p>
<a id="more"></a>

<p>本文参考转载阮一峰老师博客系列文章<a href="http://www.ruanyifeng.com/blog/" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/</a></p>
<h1 id="理解RESTful架构"><a href="#理解RESTful架构" class="headerlink" title="理解RESTful架构"></a>理解RESTful架构</h1><h2 id="什么是RESTful架构"><a href="#什么是RESTful架构" class="headerlink" title="什么是RESTful架构"></a>什么是RESTful架构</h2><p>互联网发展到了现在，我们需要把网站看做是一个软件。它是一种”客户端-服务器”模式的软件，建立在分布式体系上，通过互联网通信，具有高延时和高并发的特性。</p>
<p>(NOTE：高延时：high latency，指一个数据包从客户端发送到网站服务器，然后再立即从网站服务器返回用户计算机的来回时间，简单来说就是数据从用户这边发送到服务器那边所用的时间。网络延时越高，意味着网速越慢。网络延时1数值，代表1毫秒，通常使用网络管理工具<code>PING</code>来测量网络延时，典型数值为几十到几百毫秒。)</p>
<p>但是在以前，软件开发和网络是不同的领域，而且少有交集。因为软件开发主要针对单机环境，网络则主要研究系统之间通信，而互联网的兴起，使得这两个领域开始融合。</p>
<p>RESTful架构是什么，是一个比较不容易说清楚的问题，这里给出比较简单的解释。</p>
<p>“REST”源自于Roy Thomas Fielding在他的2000年的博士论文。(此人同时也是HTTP协议1.0和1.1版本的主要设计者)</p>
<p>他说他写这篇文章的目的：”我这篇文章的写作目的，就是想在符合架构原理的前提下，理解和评估以网络为基础的应用软件的架构设计，得到一个功能强、性能好、适宜通信的架构。”</p>
<h2 id="名称"><a href="#名称" class="headerlink" title="名称"></a>名称</h2><p>REST，即Representational State Transfer的缩写。中文翻译：”表现层状态转化”。</p>
<p>顺理成章，一个符合REST原则的架构，就称之为RESTful架构。</p>
<p>要理解RESTful架构，最好的方法就是去理解Representational State Transfer这个词组到底是什么意思，它的每一个词代表了什么涵义。</p>
<h2 id="资源-Resources"><a href="#资源-Resources" class="headerlink" title="资源(Resources)"></a>资源(Resources)</h2><p>所谓”状态转移”,省略了主语。”表现层”其实指的是”资源”（Resources）的”表现层”。</p>
<p>所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URL（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URL就可以，因此URL就成了每一个资源的地址或独一无二的识别符。</p>
<p>所谓”上网”，就是与互联网上一系列的”资源”互动，调用它的URL。</p>
<h2 id="表现层-Representation"><a href="#表现层-Representation" class="headerlink" title="表现层(Representation)"></a>表现层(Representation)</h2><p>“资源”是一种信息实体，它可以有多种外在表现形式。我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。</p>
<p>比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。</p>
<p>URL只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URL应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述。</p>
<h2 id="状态转化-State-Transfer"><a href="#状态转化-State-Transfer" class="headerlink" title="状态转化(State Transfer)"></a>状态转化(State Transfer)</h2><p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。</p>
<p>互联网通信协议HTTP协议，是一个<strong>无状态协议</strong>。这意味着，所有的状态都保存在服务器端(不考虑Cookie的话)。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。</p>
<p>客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</p>
<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>综合上面的解释，我们总结一下什么是RESTful架构：</p>
<p>（1）每一个URL代表一种资源；</p>
<p>（2）客户端和服务器之间，传递这种资源的某种表现层；</p>
<p>（3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。</p>
<h2 id="设计的误区"><a href="#设计的误区" class="headerlink" title="设计的误区"></a>设计的误区</h2><p>RESTful架构有一些典型的设计误区。</p>
<p>最常见的一种设计错误，就是URL包含动词。因为”资源”表示一种实体，所以应该是名词，URI不应该有动词，动词应该放在HTTP协议中。</p>
<p>举例来说，某个URI是/posts/show/1，其中show是动词，这个URL就设计错了，正确的写法应该是/posts/1，然后用GET方法表示show。</p>
<p>如果某些动作是HTTP动词表示不了的，你就应该把动作做成一种资源。比如网上汇款，从账户1向账户2汇款500元，错误的URL是：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">POST /accounts/<span class="number">1</span>/transfer/<span class="number">500</span>/to/<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>正确的写法是把动词transfer改成名词transaction，资源不能是动词，但是可以是一种服务：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">POST /transaction HTTP/<span class="number">1.1</span></span><br><span class="line">Host: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">　　</span><br><span class="line"><span class="keyword">from</span>=<span class="number">1</span>&amp;to=<span class="number">2</span>&amp;amount=<span class="number">500.00</span></span><br></pre></td></tr></table></figure>

<p>另一个设计误区，就是在URI中加入版本号：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.example.com/app</span><span class="regexp">/1.0/foo</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.example.com/app</span><span class="regexp">/1.1/foo</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.example.com/app</span><span class="regexp">/2.0/foo</span></span><br></pre></td></tr></table></figure>

<p>因为不同的版本，可以理解成同一种资源的不同表现形式，所以应该采用同一个URL。版本号可以在HTTP请求头信息的Accept字段中进行区分（参见<a href="https://www.informit.com/articles/article.aspx?p=1566460" target="_blank" rel="noopener">Versioning REST Services</a>）：</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Accept:</span> vnd.example-<span class="keyword">com</span>.foo+json<span class="comment">; version=1.0</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">Accept:</span> vnd.example-<span class="keyword">com</span>.foo+json<span class="comment">; version=1.1</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">Accept:</span> vnd.example-<span class="keyword">com</span>.foo+json<span class="comment">; version=2.0</span></span><br></pre></td></tr></table></figure>

<h1 id="RESTful-API设计指南"><a href="#RESTful-API设计指南" class="headerlink" title="RESTful API设计指南"></a>RESTful API设计指南</h1><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>API与用户的通信协议，很多时候使用HTTPS协议。</p>
<p>HTTPS协议和HTTP协议的区别就是在于SSL/TLS证书，可以参考<a href="http://wmsheng.cn/2020/03/16/SSL-and-TLS/" target="_blank" rel="noopener">这篇文章</a></p>
<h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h2><p>应该尽量将API部署在专用域名之下。</p>
<p><code>https://api.example.com</code></p>
<p>如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。</p>
<p><code>https://example.org/api/</code></p>
<h2 id="版本-Versioning"><a href="#版本-Versioning" class="headerlink" title="版本(Versioning)"></a>版本(Versioning)</h2><p>应该将API的版本号放入URL。</p>
<p><code>https://api.example.com/v1/</code></p>
<p>另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。</p>
<h2 id="路径-Endpoint"><a href="#路径-Endpoint" class="headerlink" title="路径(Endpoint)"></a>路径(Endpoint)</h2><p>路径又称”终点”（endpoint），表示API的具体网址。</p>
<p>在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。</p>
<p>举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">https:<span class="regexp">//</span>api.example.com<span class="regexp">/v1/</span>zoos</span><br><span class="line">https:<span class="regexp">//</span>api.example.com<span class="regexp">/v1/</span>animals</span><br><span class="line">https:<span class="regexp">//</span>api.example.com<span class="regexp">/v1/</span>employees</span><br></pre></td></tr></table></figure>

<h2 id="HTTP动词"><a href="#HTTP动词" class="headerlink" title="HTTP动词"></a>HTTP动词</h2><p>对于资源的具体操作类型，由HTTP动词表示。</p>
<p>常用的HTTP动词有下面五个（括号里是对应的SQL命令）。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span>（<span class="keyword">SELECT</span>）：从服务器取出资源（一项或多项）。</span><br><span class="line">POST（<span class="keyword">CREATE</span>）：在服务器新建一个资源。</span><br><span class="line">PUT（<span class="keyword">UPDATE</span>）：在服务器更新资源（客户端提供改变后的完整资源）。</span><br><span class="line">PATCH（<span class="keyword">UPDATE</span>）：在服务器更新资源（客户端提供改变的属性）。</span><br><span class="line"><span class="keyword">DELETE</span>（<span class="keyword">DELETE</span>）：从服务器删除资源。</span><br></pre></td></tr></table></figure>

<p>还有两个不常用的HTTP动词。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">HEAD</span>：获取资源的元数据。</span><br><span class="line"><span class="attribute"><span class="nomarkup">OPTIONS</span></span>：获取信息，关于资源的哪些属性是客户端可以改变的。</span><br></pre></td></tr></table></figure>

<p>下面是一些例子。</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">GET <span class="string">/zoos</span>：列出所有动物园</span><br><span class="line">POST <span class="string">/zoos</span>：新建一个动物园</span><br><span class="line">GET <span class="string">/zoos/ID</span>：获取某个指定动物园的信息</span><br><span class="line">PUT <span class="string">/zoos/ID</span>：更新某个指定动物园的信息（提供该动物园的全部信息）</span><br><span class="line">PATCH <span class="string">/zoos/ID</span>：更新某个指定动物园的信息（提供该动物园的部分信息）</span><br><span class="line">DELETE <span class="string">/zoos/ID</span>：删除某个动物园</span><br><span class="line">GET <span class="string">/zoos/ID/animals</span>：列出某个指定动物园的所有动物</span><br><span class="line">DELETE <span class="string">/zoos/ID/animals/ID</span>：删除某个指定动物园的指定动物</span><br></pre></td></tr></table></figure>

<h2 id="过滤信息-Filtering"><a href="#过滤信息-Filtering" class="headerlink" title="过滤信息(Filtering)"></a>过滤信息(Filtering)</h2><p>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。</p>
<p>下面是一些常见的参数。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">?<span class="attribute">limit</span>=10：指定返回记录的数量</span><br><span class="line">?<span class="attribute">offset</span>=10：指定返回记录的开始位置。</span><br><span class="line">?<span class="attribute">page</span>=2&amp;per_page=100：指定第几页，以及每页的记录数。</span><br><span class="line">?<span class="attribute">sortby</span>=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</span><br><span class="line">?<span class="attribute">animal_type_id</span>=1：指定筛选条件</span><br></pre></td></tr></table></figure>
<p>参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。</p>
<h2 id="状态码-Status-Code"><a href="#状态码-Status-Code" class="headerlink" title="状态码(Status Code)"></a>状态码(Status Code)</h2><p>服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">200 </span>OK - [<span class="keyword">GET</span>]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</span><br><span class="line"><span class="symbol">201 </span>CREATED - [POST/<span class="keyword">PUT</span>/PATCH]：用户新建或修改数据成功。</span><br><span class="line"><span class="symbol">202 </span>Accepted - [*]：表示一个请求已经进入后台排队（异步任务）</span><br><span class="line"><span class="symbol">204 </span>NO CONTENT - [<span class="keyword">DELETE</span>]：用户删除数据成功。</span><br><span class="line"><span class="symbol">400 </span>INVALID REQUEST - [POST/<span class="keyword">PUT</span>/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</span><br><span class="line"><span class="symbol">401 </span>Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。</span><br><span class="line"><span class="symbol">403 </span>Forbidden - [*] 表示用户得到授权（与<span class="number">401</span>错误相对），但是访问是被禁止的。</span><br><span class="line"><span class="symbol">404 </span><span class="keyword">NOT</span> FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</span><br><span class="line"><span class="symbol">406 </span><span class="keyword">Not</span> Acceptable - [<span class="keyword">GET</span>]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</span><br><span class="line"><span class="symbol">410 </span>Gone -[<span class="keyword">GET</span>]：用户请求的资源被永久删除，且不会再得到的。</span><br><span class="line"><span class="symbol">422 </span>Unprocesable entity - [POST/<span class="keyword">PUT</span>/PATCH] 当创建一个对象时，发生一个验证错误。</span><br><span class="line"><span class="symbol">500 </span>INTERNAL SERVER <span class="keyword">ERROR</span> - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</span><br></pre></td></tr></table></figure>

<p>状态码的完全列表参见<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html" target="_blank" rel="noopener">这里</a>。</p>
<h2 id="错误处理-Error-handling"><a href="#错误处理-Error-handling" class="headerlink" title="错误处理(Error handling)"></a>错误处理(Error handling)</h2><p>如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attribute">error</span>: <span class="string">"Invalid API key"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h2><p>针对不同操作，服务器向用户返回的结果应该符合以下规范。</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">GET <span class="string">/collection</span>：返回资源对象的列表（数组）</span><br><span class="line">GET <span class="string">/collection/resource</span>：返回单个资源对象</span><br><span class="line">POST <span class="string">/collection</span>：返回新生成的资源对象</span><br><span class="line">PUT <span class="string">/collection/resource</span>：返回完整的资源对象</span><br><span class="line">PATCH <span class="string">/collection/resource</span>：返回完整的资源对象</span><br><span class="line">DELETE <span class="string">/collection/resource</span>：返回一个空文档</span><br></pre></td></tr></table></figure>

<h2 id="Hypermedia-API"><a href="#Hypermedia-API" class="headerlink" title="Hypermedia API"></a>Hypermedia API</h2><p>RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。</p>
<p>比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"link"</span>: &#123;</span><br><span class="line">  <span class="attr">"rel"</span>:   <span class="string">"collection https://www.example.com/zoos"</span>,</span><br><span class="line">  <span class="attr">"href"</span>:  <span class="string">"https://api.example.com/zoos"</span>,</span><br><span class="line">  <span class="attr">"title"</span>: <span class="string">"List of zoos"</span>,</span><br><span class="line">  <span class="attr">"type"</span>:  <span class="string">"application/vnd.yourformat+json"</span></span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。</p>
<p>Hypermedia API的设计被称为HATEOAS。Github的API就是这种设计，访问<a href="https://api.github.com/" target="_blank" rel="noopener">api.github.com</a>会得到一个所有可用API的网址列表。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"current_user_url"</span>: <span class="string">"https://api.github.com/user"</span>,</span><br><span class="line">  <span class="attr">"authorizations_url"</span>: <span class="string">"https://api.github.com/authorizations"</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面可以看到，如果想获取当前用户的信息，应该去访问api.github.com/user，然后就得到了下面结果。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"message"</span>: <span class="string">"Requires authentication"</span>,</span><br><span class="line">  <span class="attr">"documentation_url"</span>: <span class="string">"https://developer.github.com/v3"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码表示，服务器给出了提示信息，以及文档的网址。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>（1）API的身份认证应该使用OAuth 2.0框架。</p>
<p>（2）服务器返回的数据格式，应该尽量使用JSON，避免使用XML。</p>
<h1 id="RESTful-API最佳实践"><a href="#RESTful-API最佳实践" class="headerlink" title="RESTful API最佳实践"></a>RESTful API最佳实践</h1><p>RESTful 是目前最流行的 API 设计规范，用于 Web 数据接口的设计。</p>
<p>它的大原则容易把握，但是细节不容易做对。本文总结 RESTful 的设计细节，介绍如何设计出易于理解和使用的 API。</p>
<h2 id="URL设计"><a href="#URL设计" class="headerlink" title="URL设计"></a>URL设计</h2><h3 id="动词-宾语"><a href="#动词-宾语" class="headerlink" title="动词 + 宾语"></a>动词 + 宾语</h3><p>RESTful 的核心思想就是，客户端发出的数据操作指令都是”动词 + 宾语”的结构。比如，<code>GET /articles</code>这个命令，<code>GET</code>是动词，<code>/articles</code>是宾语。</p>
<p>动词通常就是五种 HTTP 方法，对应 CRUD 操作。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span>：读取（<span class="keyword">Read</span>）</span><br><span class="line">POST：新建（<span class="keyword">Create</span>）</span><br><span class="line">PUT：更新（<span class="keyword">Update</span>）</span><br><span class="line">PATCH：更新（<span class="keyword">Update</span>），通常是部分更新</span><br><span class="line"><span class="keyword">DELETE</span>：删除（<span class="keyword">Delete</span>）</span><br></pre></td></tr></table></figure>

<p>根据 HTTP 规范，动词一律大写。</p>
<h3 id="动词的覆盖"><a href="#动词的覆盖" class="headerlink" title="动词的覆盖"></a>动词的覆盖</h3><p>有些客户端只能使用<code>GET</code>和<code>POST</code>这两种方法。服务器必须接受POST模拟其他三个方法（PUT、PATCH、DELETE）。</p>
<p>这时，客户端发出的 HTTP 请求，要加上X-HTTP-Method-Override属性，告诉服务器应该使用哪一个动词，覆盖POST方法。</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">POST /api/Person/<span class="number">4</span> HTTP/<span class="number">1.1</span>  </span><br><span class="line">X-HTTP-<span class="function"><span class="keyword">Method</span>-<span class="title">Override</span>:</span> PUT</span><br></pre></td></tr></table></figure>

<p>上面代码中，X-HTTP-Method-Override指定本次请求的方法是<code>PUT</code>，而不是<code>POST</code>。</p>
<h3 id="宾语必须是名词"><a href="#宾语必须是名词" class="headerlink" title="宾语必须是名词"></a>宾语必须是名词</h3><p>宾语就是 API 的 URL，是 HTTP 动词作用的对象。它应该是名词，不能是动词。比如，<code>/articles</code>这个 URL 就是正确的，而下面的 URL 不是名词，所以都是错误的。</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="string">/getAllCars</span></span><br><span class="line"><span class="string">/createNewCar</span></span><br><span class="line"><span class="string">/deleteAllRedCars</span></span><br></pre></td></tr></table></figure>

<h3 id="复数URL"><a href="#复数URL" class="headerlink" title="复数URL"></a>复数URL</h3><p>既然 URL 是名词，那么应该使用复数，还是单数？</p>
<p>这没有统一的规定，但是常见的操作是读取一个集合，比如<code>GET /articles</code>（读取所有文章），这里明显应该是复数。</p>
<p>为了统一起见，建议都使用复数 URL，比如<code>GET /articles/2</code>要好于<code>GET /article/2</code>。</p>
<h3 id="避免多级URL"><a href="#避免多级URL" class="headerlink" title="避免多级URL"></a>避免多级URL</h3><p>常见的情况是，资源需要多级分类，因此很容易写出多级的 URL，比如获取某个作者的某一类文章。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">GET /authors/<span class="number">12</span>/categories/<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>这种 URL 不利于扩展，语义也不明确，往往要想一会，才能明白含义。</p>
<p>更好的做法是，除了第一级，其他级别都用查询字符串表达。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> /authors/12?<span class="attribute">categories</span>=2</span><br></pre></td></tr></table></figure>

<p>下面是另一个例子，查询已发布的文章。你可能会设计成下面的 URL。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> /articles/published</span><br></pre></td></tr></table></figure>

<p>查询字符串的写法明显更好。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> /articles?<span class="attribute">published</span>=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><h3 id="状态码必须精确"><a href="#状态码必须精确" class="headerlink" title="状态码必须精确"></a>状态码必须精确</h3><p>客户端的每一次请求，服务器都必须给出回应。回应包括 HTTP 状态码和数据两部分。</p>
<p>HTTP 状态码就是一个三位数，分成五个类别。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>xx：相关信息</span><br><span class="line"><span class="number">2</span>xx：操作成功</span><br><span class="line"><span class="number">3</span>xx：重定向</span><br><span class="line"><span class="number">4</span>xx：客户端错误</span><br><span class="line"><span class="number">5</span>xx：服务器错误</span><br></pre></td></tr></table></figure>

<p>这五大类总共包含100多种状态码，覆盖了绝大部分可能遇到的情况。每一种状态码都有标准的（或者约定的）解释，客户端只需查看状态码，就可以判断出发生了什么情况，所以服务器应该返回尽可能精确的状态码。</p>
<p>API 不需要<code>1xx</code>状态码，下面介绍其他四类状态码的精确含义。</p>
<h3 id="2xx状态码"><a href="#2xx状态码" class="headerlink" title="2xx状态码"></a>2xx状态码</h3><p><code>200</code>状态码表示操作成功，但是不同的方法可以返回更精确的状态码。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">GET:</span> <span class="number">200</span> <span class="string">OK</span></span><br><span class="line"><span class="attr">POST:</span> <span class="number">201</span> <span class="string">Created</span></span><br><span class="line"><span class="attr">PUT:</span> <span class="number">200</span> <span class="string">OK</span></span><br><span class="line"><span class="attr">PATCH:</span> <span class="number">200</span> <span class="string">OK</span></span><br><span class="line"><span class="attr">DELETE:</span> <span class="number">204</span> <span class="literal">No</span> <span class="string">Content</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>POST</code>返回<code>201</code>状态码，表示生成了新的资源；<code>DELETE</code>返回<code>204</code>状态码，表示资源已经不存在。</p>
<p>此外，<code>202 Accepted</code>状态码表示服务器已经收到请求，但还未进行处理，会在未来再处理，通常用于异步操作。下面是一个例子。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">202</span> Accepted</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "task": &#123;</span><br><span class="line">    "href": "/api/company/job-management/jobs/2130040",</span><br><span class="line">    "id": "2130040"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3xx状态码"><a href="#3xx状态码" class="headerlink" title="3xx状态码"></a>3xx状态码</h3><p>API 用不到<code>301</code>状态码（永久重定向）和<code>302</code>状态码（暂时重定向，<code>307</code>也是这个含义），因为它们可以由应用级别返回，浏览器会直接跳转，API 级别可以不考虑这两种情况。</p>
<p>API 用到的<code>3xx</code>状态码，主要是<code>303 See Other</code>，表示参考另一个 URL。它与<code>302</code>和<code>307</code>的含义一样，也是”暂时重定向”，区别在于<code>302</code>和<code>307</code>用于<code>GET</code>请求，而<code>303</code>用于<code>POST</code>、<code>PUT</code>和<code>DELETE</code>请求。收到<code>303</code>以后，浏览器不会自动跳转，而会让用户自己决定下一步怎么办。下面是一个例子。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">303</span> See Other</span><br><span class="line">Location: /api/orders/<span class="number">12345</span></span><br></pre></td></tr></table></figure>

<h3 id="4xx状态码"><a href="#4xx状态码" class="headerlink" title="4xx状态码"></a>4xx状态码</h3><p><code>4xx</code>状态码表示客户端错误，主要有下面几种。</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">400 </span>Bad Request：服务器不理解客户端的请求，未做任何处理。</span><br><span class="line"></span><br><span class="line"><span class="symbol">401 </span>Unauthorized：用户未提供身份验证凭据，或者没有通过身份验证。</span><br><span class="line"></span><br><span class="line"><span class="symbol">403 </span>Forbidden：用户通过了身份验证，但是不具有访问资源所需的权限。</span><br><span class="line"></span><br><span class="line"><span class="symbol">404 </span><span class="keyword">Not</span> Found：所请求的资源不存在，或不可用。</span><br><span class="line"></span><br><span class="line"><span class="symbol">405 </span>Method <span class="keyword">Not</span> Allowed：用户已经通过身份验证，但是所用的 HTTP 方法不在他的权限之内。</span><br><span class="line"></span><br><span class="line"><span class="symbol">410 </span>Gone：所请求的资源已从这个地址转移，不再可用。</span><br><span class="line"></span><br><span class="line"><span class="symbol">415 </span>Unsupported Media Type：客户端要求的返回格式不支持。比如，API 只能返回 JSON 格式，但是客户端要求返回 XML 格式。</span><br><span class="line"></span><br><span class="line"><span class="symbol">422 </span>Unprocessable Entity ：客户端上传的附件无法处理，导致请求失败。</span><br><span class="line"></span><br><span class="line"><span class="symbol">429 </span>Too Many Requests：客户端的请求次数超过限额。</span><br></pre></td></tr></table></figure>

<h3 id="5xx状态码"><a href="#5xx状态码" class="headerlink" title="5xx状态码"></a>5xx状态码</h3><p><code>5xx</code>状态码表示服务端错误。一般来说，API 不会向用户透露服务器的详细信息，所以只要两个状态码就够了。</p>
<p><code>500 Internal Server Error</code>：客户端请求有效，服务器处理时发生了意外。</p>
<p><code>503 Service Unavailable</code>：服务器无法处理请求，一般用于网站维护状态。</p>
<h2 id="服务器回应"><a href="#服务器回应" class="headerlink" title="服务器回应"></a>服务器回应</h2><h3 id="不要返回纯文本"><a href="#不要返回纯文本" class="headerlink" title="不要返回纯文本"></a>不要返回纯文本</h3><p>API 返回的数据格式，不应该是纯文本，而应该是一个 JSON 对象，因为这样才能返回标准的结构化数据。所以，服务器回应的 HTTP 头的<code>Content-Type</code>属性要设为<code>application/json</code>。</p>
<p>客户端请求时，也要明确告诉服务器，可以接受 JSON 格式，即请求的 HTTP 头的<code>ACCEPT</code>属性也要设成<code>application/json</code>。下面是一个例子。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">GET /orders/<span class="number">2</span> HTTP/<span class="number">1.1</span> </span><br><span class="line">Accept: application/json</span><br></pre></td></tr></table></figure>

<h3 id="发生错误时，不要返回200状态码"><a href="#发生错误时，不要返回200状态码" class="headerlink" title="发生错误时，不要返回200状态码"></a>发生错误时，不要返回200状态码</h3><p>有一种不恰当的做法是，即使发生错误，也返回<code>200</code>状态码，把错误信息放在数据体里面，就像下面这样。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "status": "failure",</span><br><span class="line">  "data": &#123;</span><br><span class="line">    "error": "Expected at least two items in list."</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，解析数据体以后，才能得知操作失败。</p>
<p>这张做法实际上取消了状态码，这是完全不可取的。正确的做法是，状态码反映发生的错误，具体的错误信息放在数据体里面返回。下面是一个例子。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">400</span> Bad Request</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "error": "Invalid payoad.",</span><br><span class="line">  "detail": &#123;</span><br><span class="line">     "surname": "This field is required."</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="提供链接"><a href="#提供链接" class="headerlink" title="提供链接"></a>提供链接</h3><p>API 的使用者未必知道，URL 是怎么设计的。一个解决方法就是，在回应中，给出相关链接，便于下一步操作。这样的话，用户只要记住一个 URL，就可以发现其他的 URL。这种方法叫做 HATEOAS。</p>
<p>举例来说，GitHub 的 API 都在 api.github.com 这个域名。访问它，就可以得到其他 URL。</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="string">"feeds_url"</span>: <span class="string">"https://api.github.com/feeds"</span>,</span><br><span class="line">  <span class="string">"followers_url"</span>: <span class="string">"https://api.github.com/user/followers"</span>,</span><br><span class="line">  <span class="string">"following_url"</span>: <span class="string">"https://api.github.com/user/following&#123;/target&#125;"</span>,</span><br><span class="line">  <span class="string">"gists_url"</span>: <span class="string">"https://api.github.com/gists&#123;/gist_id&#125;"</span>,</span><br><span class="line">  <span class="string">"hub_url"</span>: <span class="string">"https://api.github.com/hub"</span>,</span><br><span class="line">  <span class="string">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的回应中，挑一个 URL 访问，又可以得到别的 URL。对于用户来说，不需要记住 URL 设计，只要从 api.github.com 一步步查找就可以了。</p>
<p>HATEOAS 的格式没有统一规定，上面例子中，GitHub 将它们与其他属性放在一起。更好的做法应该是，将相关链接与其他属性分开。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "status": "In progress",</span><br><span class="line">   "links": &#123;[</span><br><span class="line">    &#123; "rel":"cancel", "method": "delete", "href":"/api/status/12345" &#125; ,</span><br><span class="line">    &#123; "rel":"edit", "method": "put", "href":"/api/status/12345" &#125;</span><br><span class="line">  ]&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Study Note</category>
        <category>Interview Note</category>
      </categories>
      <tags>
        <tag>HTTPS</tag>
        <tag>RESTful</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title>Java GC Study I</title>
    <url>/2020/03/05/Java-GC-Study-I/</url>
    <content><![CDATA[<blockquote>
<p>很多事情不是看到希望才去坚持，而是坚持了才看得到希望。</p>
</blockquote>
<a id="more"></a>

<p>正是因为有垃圾回收机制，才可以让程序员不用考虑程序执行之后对象内存的释放问题，将其交给JVM管理即可。</p>
<h1 id="垃圾回收——标记算法"><a href="#垃圾回收——标记算法" class="headerlink" title="垃圾回收——标记算法"></a>垃圾回收——标记算法</h1><h2 id="怎样的对象会被判定为垃圾？"><a href="#怎样的对象会被判定为垃圾？" class="headerlink" title="怎样的对象会被判定为垃圾？"></a>怎样的对象会被判定为垃圾？</h2><ul>
<li>没有被其他对象引用</li>
</ul>
<p>此时这个对象占据的内存会被释放，此对象也会被销毁。</p>
<h2 id="用什么方法判定对象不被引用了呢？"><a href="#用什么方法判定对象不被引用了呢？" class="headerlink" title="用什么方法判定对象不被引用了呢？"></a>用什么方法判定对象不被引用了呢？</h2><ul>
<li>引用计数算法</li>
<li>可达性分析算法</li>
</ul>
<h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p><strong>通过判断对象的引用数量来决定对象是否可以被回收。</strong></p>
<p>具体执行方法：</p>
<ul>
<li>每个对象实例都有一个引用计数器，被引用则+1，完成引用则-1</li>
<li>任何引用计数为0的对象实例可以被当做垃圾收集</li>
</ul>
<p>引用计数算法的优劣：</p>
<ul>
<li>优点：执行效率高，程序执行受影响较小。因为我们只需要过滤掉引用计数为0的对象，然后将其回收即可，可以交织在程序运行中。由于垃圾回收的过程中可以做到几乎不打断程序的执行，所以这种方法适用于程序需要不被长时间打断的实时环境。</li>
<li>缺点：无法检测出循环引用的情况，导致内存泄漏。这个缺点是很致命的，如果存在父对象与子对象互相引用的情况，那么它们的引用计数永远不可能为零，那么永远都不会被检测到为0，永远不会被释放。</li>
</ul>
<p>由于这种比较致命的缺点，主流JDK没有使用引用计数算法进行垃圾判定，而是用了下面的可达性分析算法。</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p><strong>通过判断对象的引用链是否可达来决定对象是否可以被回收</strong>。</p>
<p>这种方法从图论中引入。程序把所有的引用关系看作是一张图，通过一系列的名为GC Root的对象作为起始点，从这些节点开始向下搜索，搜索经过的路径会被称为”引用链”，即”reference chain”，当某个对象到其他图中的节点都不能相连的时候，也就是说从这个对象到其他部分的GC Root是不可达的，那么就判定这个对象为垃圾。</p>
<p>如图：</p>
<p><img src="https://s2.ax1x.com/2020/03/05/37rfUg.png" alt="可达性分析算法"></p>
<p>蓝色为存活对象，即可达对象，灰色的部分不可达了，为垃圾对象。</p>
<p>什么对象可以作为GC Root的对象呢？</p>
<ul>
<li>虚拟机栈中引用的对象(栈帧中的本地变量表)。比如在方法中new了一个Object，并赋值给了一个局部变量，那么在该局部变量没有被销毁之前，new出来的对象就会是GC Root。</li>
<li>方法区中的常量引用的对象。比如在类中定义了一个常量，而该常量保存的是某个对象的地址，那么被保存的对象也会成为GC的根对象。</li>
<li>方法区中的类静态属性引用的对象。这个和上面常量的情况如出一辙。</li>
<li>本地方法栈中JNI(Native方法)的引用对象</li>
<li>活跃线程的引用对象</li>
</ul>
<h1 id="垃圾回收——回收算法"><a href="#垃圾回收——回收算法" class="headerlink" title="垃圾回收——回收算法"></a>垃圾回收——回收算法</h1><p>判断了哪些对象是垃圾只是第一步，我们还需要解决一个很重要的问题：如何处理这些垃圾？或者说，如果回收这些垃圾？</p>
<p>垃圾回收算法有以下这几种：</p>
<h2 id="标记-清除算法-Mark-and-Sweep"><a href="#标记-清除算法-Mark-and-Sweep" class="headerlink" title="标记-清除算法(Mark and Sweep)"></a>标记-清除算法(Mark and Sweep)</h2><ul>
<li>标记：从根集合进行扫描，对存活的对象进行标记</li>
<li>清除：对堆内存从头到尾进行线性遍历，回收不可达对象内存</li>
</ul>
<p>如图：</p>
<p><img src="https://s2.ax1x.com/2020/03/05/37y678.jpg" alt="标记-清除算法"></p>
<p>如上图所示，经过了Mark阶段到达Sweep阶段的时候，所有不可达的对象都会被当做垃圾回收掉。</p>
<p>但是这种方法会存在一些问题，在标记-清除之后，可能会产生大量不连续的碎片，空间碎片多，可能导致之后开辟大对象空间的时候出现内存不够用的情况。</p>
<h2 id="复制算法-Copying"><a href="#复制算法-Copying" class="headerlink" title="复制算法(Copying)"></a>复制算法(Copying)</h2><p>复制算法将可用的内存按照容量和一定比例划分为两块或多块，并选择其中一块两块作为对象面，其他的作为空闲面。</p>
<ul>
<li>分为对象面和空闲面</li>
<li>对象在对象面上创建 </li>
<li>存活的对象被从对象面复制到空闲面。当被定义为对象面的块的内存用完了，就将还存活着的对象复制到其中一块空闲面上</li>
<li>将对象面所有对象清除</li>
</ul>
<p>这种算法适用于对象存活率低的场景，比如年轻代。这样每次都对内存块进行回收，这样就解决了内存碎片的问题。</p>
<p>推倒重建的过程只需要移动堆顶指针，按顺序分配内容即可。</p>
<p><img src="https://s2.ax1x.com/2020/03/05/37r2b8.png" alt="复制算法"></p>
<p>优势：</p>
<ul>
<li>解决碎片化问题</li>
<li>顺序分配内存，简单高效</li>
<li>适用于对象存活率低的场景(现在很多虚拟机都采用这种方法回收年轻代，因为年轻代每次都只存活10%左右，用复制算法效果不错)</li>
</ul>
<p>但是在老年代不能轻易选用这种算法，因为可能出现存活率特别高的情况。</p>
<h2 id="标记-整理算法-Compacting"><a href="#标记-整理算法-Compacting" class="headerlink" title="标记-整理算法(Compacting)"></a>标记-整理算法(Compacting)</h2><p>这种算法比较适合用于老年代的对象回收。它使用类似”标记-清除”算法的方式进行对象的标记，但是在清除的时候不同。</p>
<ul>
<li>标记：从根集合进行扫描，对存活的对象进行标记</li>
<li>清除：移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收</li>
</ul>
<p>“标记-整理”算法是在”标记-清除”的基础上又进行了对象的移动，因此成本更高，但是能够解决内存碎片的问题。</p>
<p><img src="https://s2.ax1x.com/2020/03/05/37RmRg.png" alt="标记整理算法"></p>
<p>也可以参考这张图：</p>
<p><img src="https://s2.ax1x.com/2020/03/05/37rWVS.png" alt="标记整理算法2"></p>
<p>执行这个算法的时候会把存活的对象压缩到一端，然后将所有可回收的对象清除掉。</p>
<p>这样做的好处：</p>
<ul>
<li>避免内存的不连续性</li>
<li>不用设置两块内存互换</li>
<li>适用于存活率高的场景(比如涉及分代收集算法中老年代的回收)</li>
</ul>
<h2 id="分代收集算法-Generational-Collector"><a href="#分代收集算法-Generational-Collector" class="headerlink" title="分代收集算法(Generational Collector)"></a>分代收集算法(Generational Collector)</h2><p>这是一种比较主流的垃圾回收算法。</p>
<p>可以理解是一套”组合拳”</p>
<ul>
<li>垃圾回收算法的组合拳</li>
<li>按照对象生命周期的不同划分区域以采用不同的垃圾回收算法</li>
<li>目的：提高JVM的回收效率</li>
</ul>
<p>前面已经提过，JDK8之前，比如JDK6和JDK7，里面有年轻代、老年代和永久代，如下图：</p>
<p><img src="https://s2.ax1x.com/2020/03/05/37r5Cj.png" alt="JDK6+7"></p>
<p>但是JDK8之后(包括JDK8)就去掉了永久代：</p>
<p><img src="https://s2.ax1x.com/2020/03/05/37rI8s.png" alt="JDK8后去掉永久代"></p>
<p>可以看到，JDK6、JDK7和JDK8中都有年轻代和老年代。其中年轻代的对象存活率低，采用复制算法。而老年代存活率高，一般使用”标记-清除算法”或者”标记-整理算法”。</p>
<h2 id="GC的分类"><a href="#GC的分类" class="headerlink" title="GC的分类"></a>GC的分类</h2><p>分代收集的GC分为两种：</p>
<ul>
<li>Minor GC。发生在年轻代中的垃圾收集工作，采用复制算法。</li>
<li>Full GC。与老年代的垃圾回收相关。</li>
</ul>
<p>年轻代是所有Java对象出生的地方，即Java对象申请的内存和存放对象，都是在年轻代进行的。</p>
<p>实际上，Java大部分对象都不会长久存活，”朝生夕灭”。新生代是GC发生的频繁区域。</p>
<p>老年代的回收一般伴随着年轻代的垃圾收集，因此第二种垃圾回收方式被命名为”Full GC”</p>
<h2 id="年轻代：尽可能快速地收集掉那些生命周期短的对象"><a href="#年轻代：尽可能快速地收集掉那些生命周期短的对象" class="headerlink" title="年轻代：尽可能快速地收集掉那些生命周期短的对象"></a>年轻代：尽可能快速地收集掉那些生命周期短的对象</h2><ul>
<li>Eden区</li>
<li>两个Survivor区</li>
</ul>
<p>对象刚被创建出来的时候，其内存空间首先被分配在Eden区。如果Eden区放不下新创建的对象的话，对象也有可能被直接放在Survivor甚至是老年代中。</p>
<p>而两个Survivor则分别被定义在from区和to区，并且哪个是from区，哪个是to区，也不是固定的，会随着垃圾回收的进行而相互转换。</p>
<p><img src="https://s2.ax1x.com/2020/03/05/37qRlq.png" alt="年轻代"></p>
<h3 id="年轻代垃圾回收的过程演示"><a href="#年轻代垃圾回收的过程演示" class="headerlink" title="年轻代垃圾回收的过程演示"></a>年轻代垃圾回收的过程演示</h3><p>通过一个实例演示年轻代的垃圾回收过程：</p>
<p>演示过程暂时忽略Eden区和Survivor区的大小比例，并且假设每个对象的大小都是一样的。Eden区最多能保存四个对象，Survivor区最多能保存三个对象。</p>
<p>一开始，如果对象在Eden出生，并且Eden被挤满，如下图：</p>
<p><img src="https://s2.ax1x.com/2020/03/05/3H1hJU.png" alt="3H1hJU.png"></p>
<p>此时会触发一次Minor GC。此时如果对象还存活(绿色的为存活对象)，它就会被复制到一个Survivor区里面，假设是复制到了S0里面，此时我们称S0为from区。复制之后会增加1个年龄。比如图中复制过去之后年龄为1.</p>
<p>然后清理所有使用过的Eden区域，如下图： </p>
<p><img src="https://s2.ax1x.com/2020/03/05/3H1fiT.png" alt="3H1fiT.png"></p>
<p>之后会清空Eden</p>
<p><img src="https://s2.ax1x.com/2020/03/05/3H1RoV.png" alt="3H1RoV.png"></p>
<p>然后过了一段时间，发现Eden区又被填满了，如图：</p>
<p><img src="https://s2.ax1x.com/2020/03/05/3H12d0.png" alt="3H12d0.png"></p>
<p>此时又会触发一次Minor GC，然后将Eden和S0里面的存活的对象都拷贝到S1里面，同时会把存活的对象的年龄都加1。</p>
<p>此时S1从to区变成了from区，而S0从from区变成了to区。</p>
<p><img src="https://s2.ax1x.com/2020/03/05/3H1gZq.png" alt="3H1gZq.png"></p>
<p>拷贝完成后，Eden和S0都会被清空，以此完成了第二次Minor GC。</p>
<p><img src="https://s2.ax1x.com/2020/03/05/3H14WF.png" alt="3H14WF.png"></p>
<p>之后我们假设Eden区又满了：</p>
<p><img src="https://s2.ax1x.com/2020/03/05/3H15z4.png" alt="3H15z4.png"></p>
<p>此时会出发第三次Minor GC，操作行为也和之前一样，年龄加1。同时S1里面如果有一个对象没有被用到，那么也要把它清除。</p>
<p>每次拷贝，存活对象的年龄都要加1.</p>
<p><img src="https://s2.ax1x.com/2020/03/05/3H1oQJ.png" alt="3H1oQJ.png"></p>
<p>拷贝完成后，S1和Eden又会被再次清空：</p>
<p><img src="https://s2.ax1x.com/2020/03/05/3H1Ty9.png" alt="3H1Ty9.png"></p>
<p>周而复始。对象在Survivor区每熬过一次Minor GC，其年龄就会被加1，当对象的年龄达到某个值之后(默认是15岁)，这些对象会成为老年代。</p>
<p>NOTE：这个默认年龄可以通过<code>-XX:MaxTenuringThreshold</code>调整</p>
<p>但这也不是一定的，如果存储的对象过大，Eden区和Survivor区都存不下，可能会需要用到老年代的空间协助存储。</p>
<h3 id="对象如何晋升到老年代"><a href="#对象如何晋升到老年代" class="headerlink" title="对象如何晋升到老年代"></a>对象如何晋升到老年代</h3><p>在分代算法当中，对象如何晋升到老年代？简单来说有3种场景：</p>
<ul>
<li>经历一定Minor GC次数(比如是15次)依然存活的对象</li>
<li>Survivor区中村放不下的对象</li>
<li>新生成的大对象(可以用:<code>-XX:+PretenuerSizeThreshold</code>来控制大对象的大小，只要大于这个大小，对象生成之后直接放入老年代)</li>
</ul>
<h3 id="常用的调优参数"><a href="#常用的调优参数" class="headerlink" title="常用的调优参数"></a>常用的调优参数</h3><p>介绍几个常用的用来做性能调优的参数。</p>
<ul>
<li>-XX:SurvivorRatio：Eden和Survivor的比值，默认8:1</li>
<li>-XX:NewRatio：老年代和年轻代内存大小的比例(比如若值为2，则老年代是年轻代大小的两倍，即young generation占据内存的三分之一)。</li>
<li>-XX:MaxTenuringThreshold:对象从年轻代晋升到老生代经历过GC次数的最大阈值</li>
</ul>
<p>新生代和老年代的总内存大小是通过”-Xms”和”-Xmx”来决定的。</p>
<h2 id="老年代：存放生命周期较长的对象"><a href="#老年代：存放生命周期较长的对象" class="headerlink" title="老年代：存放生命周期较长的对象"></a>老年代：存放生命周期较长的对象</h2><p>回顾这副图：</p>
<p><img src="https://s2.ax1x.com/2020/03/05/37qRlq.png" alt="年轻代"></p>
<p>可以看到，老年代占的内存比新生代大，而且大致的比例为2:1</p>
<p>老年代的对象存活率较高，而且没有额外空间做担保，所以老年代主要用的算法为：</p>
<ul>
<li>标记-清理算法</li>
<li>标记-整理算法</li>
</ul>
<p>之前已经详细介绍过这两种算法，这里就不再介绍了。</p>
<h3 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h3><p>当触发老年代的垃圾回收的时候，往往也会伴随对新生代堆内存的回收，即对整个堆进行垃圾回收，也就是所谓的Full GC，或者叫做Major GC。Major GC和Full GC是等价的，即收集所有的GC堆。</p>
<p>主要是因为HotSpot VM发展了很多年，外界对很多名词的解读都已经混乱了，当有人说到了”Major GC”的时候，一定要问清楚，他说的到底是针对所有代的Full GC，还是只是针对老年代的GC。</p>
<p>Full GC比Minor GC慢(慢十倍)，但因为老年代里面元素本身就不容易被淘汰，所以执行频率也会更低。</p>
<h3 id="触发Full-GC的条件"><a href="#触发Full-GC的条件" class="headerlink" title="触发Full GC的条件"></a>触发Full GC的条件</h3><ul>
<li>老年代空间不足——如果创建的对象很大，Eden区域放不下这个对象，会放入到老年代中。如果老年代空间也不足，就会触发Full GC。为了避免这种情况，最好就是不要创建太大的对象。</li>
<li>永久代空间不足——这主要是针对JDK7以及以前的版本。当系统中需要加载和调用的类很多，而同时持久代当中没有足够的空间去存放类的信息和方法信息的时候，就会触发出一次Full GC。而JDK8以后由于取消了永久代，就不存在”永久代空间不足”这种情况了。(这也是JDK8后面用元空间替代永久代的原因之一，为了降低Full GC的频率，减少GC的负担，提升其效率)</li>
<li>CMS GC时出现promotion failed, concurrent mode failure。对于采用CMS 进行老年代GC的程序而言，如果GC日志中出现了这两个字段。如果出现了，可能会触发Full GC。</li>
<li>Minor GC晋升到老年代的平均大小大于老年代的剩余空间</li>
<li>调用System.gc()——这个是我们在程序里面手动调用的，触发Full GC。需要注意这个方法只是提醒虚拟机，程序员希望你在这里回收一下对象。但是具体怎么做还是要看虚拟机自己，程序员没有控制权</li>
<li>使用RMI来进行RPC或管理的JDK应用，每小时执行1次Full GC</li>
</ul>
<p>这些点很多，面试的时候只要能够提到3点，基本可以点到为止了，可以答到老年代空间不足，程序手动调用System.gc()，然后如果用的JDK版本比较老，在JDK8之前的版本，会有永久代空间不足的情况。当然其他的能说出来更好。</p>
<p>需要注意：</p>
<p>1.promotion failed是在进行Minor GC的时候Survivor放不下了，对象只能放入老年代，而此时恰好老年代也放不下，这时候就会造成promotion failed。</p>
<p>2.concurrent mode failure是在执行CMS GC的过程中同时有对象要放入老年代中，而此时老年代空间不足，就会造成这个failure。</p>
<p>而对于Minor GC晋升的这第四点，是比较复杂的触发情况。HotSpot为了避免由于新生代对象晋升到老年代而导致老年代空间不足的现象，在进行Minor GC的时候做了一个判断：如果之前统计所得到的Minor GC晋升到老年代的平均大小大于老年代的剩余空间，就直接触发Full GC。例如，程序第一次触发GC后有6M的对象晋升到老年代，当下一次Minor GC发生的时候，首先先检查老年代的剩余空间是否大于6M，如果小于6M，则执行Full GC。</p>
<h1 id="垃圾回收——垃圾收集器"><a href="#垃圾回收——垃圾收集器" class="headerlink" title="垃圾回收——垃圾收集器"></a>垃圾回收——垃圾收集器</h1><h2 id="Stop-the-World"><a href="#Stop-the-World" class="headerlink" title="Stop-the-World"></a>Stop-the-World</h2><ul>
<li>JVM由于要执行GC而停止了应用程序的执行</li>
<li>会在任何一种GC算法中发生</li>
<li>多数GC优化通过减少Stop-the-World发生的时间来提高程序性能，从而让系统有高吞吐，低停顿的特点</li>
</ul>
<h2 id="Safepoint"><a href="#Safepoint" class="headerlink" title="Safepoint"></a>Safepoint</h2><p>JVM垃圾回收就好比是保洁阿姨在打扫卫生，如果一边打扫一遍有人扔垃圾，那很难能打扫完。怎么办呢？可以在开始打扫之前和所有人说好:”我要开始打扫了！你们不准扔垃圾了！”，这样就可以了。</p>
<ul>
<li>分析过程中对象引用关系不会发生变化的点——这是程序运行过程中的一个特殊点的，在这个点所有线程都被冻结了，不能出现分析过程中对象引用关系还在不断变化的情况。类似函数的可导，我们分析的结果需要在某个节点具备确定性，这个节点就叫做安全点。</li>
<li>产生Safepoint的地方一般是：方法调用；循环跳转；异常跳转等</li>
<li>安全点数量得适中——安全点选择不能太多也不能太少</li>
</ul>
<h2 id="JVM的运行模式"><a href="#JVM的运行模式" class="headerlink" title="JVM的运行模式"></a>JVM的运行模式</h2><p>JVM有两种运行模式：Server和Client。</p>
<p>这两种运行模式的区别在于：Server启动较慢，Client启动较快。但是启动后运行进入稳定期之后，Server模式的程序运行速度比Client更快。</p>
<p>因为Server模式启动的是重量级的虚拟机，对程序采用了更多优化，对比之下Client模式启用的是轻量级的虚拟机。</p>
<p>如果想要查看当前Java是Server模式还是Client模式，可以直接用<code>java -version</code>查看即可.</p>
<h2 id="垃圾收集器之间的联系"><a href="#垃圾收集器之间的联系" class="headerlink" title="垃圾收集器之间的联系"></a>垃圾收集器之间的联系</h2><p>垃圾收集器不存在哪个好那个坏的问题，而是涉及到适合哪个具体的JVM。不同的厂商，不同版本的JVM，提供的选择也不同，这也是HotSpot实现这么多收集器的原因。</p>
<p>一些常见的垃圾收集器、它们之间的关系和它们的适用范围，如图所示：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3b1jC8.png" alt="垃圾收集器之间的联系"></p>
<p>如果两个收集器之间有连线，说明它们可以搭配使用。</p>
<p>我们只需要大致熟悉每一个垃圾收集器的作用即可。</p>
<p>下面分别介绍：</p>
<hr>
<h2 id="年轻代收集器"><a href="#年轻代收集器" class="headerlink" title="年轻代收集器"></a>年轻代收集器</h2><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>可以在程序启动的时候通过<code>-XX:+UseSerialGC</code>设置使用此收集器。使用复制算法。</p>
<p>在JDK1.3之前，是Java虚拟机年轻代收集器的唯一选择。</p>
<p>Java中历史最悠久的收集器。</p>
<ul>
<li>单线程收集，GC时必须暂停所有工作线程</li>
<li>简单高效，Client默认用这个作为年轻代收集器</li>
</ul>
<p>工作过程如下图所示：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3b8lLj.png" alt="Serial收集器工作模拟图"></p>
<p>实际中系统分配给虚拟机管理的内存不会很大，一般就几十兆到一百兆，收集这么多的年轻代的停顿时间也就几十毫秒，一百毫秒左右。只要不是太频繁，这样的停顿是可以接受的。</p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>可以在程序启动的时候通过<code>-XX:+UseParNewGC</code>设置使用此收集器。使用复制算法。</p>
<ul>
<li>除了是多线程收集，其余的行为、特点和Serial收集器一样</li>
<li>单核执行效率不如Serial，在多核下执行才有优势</li>
</ul>
<p>在单核执行的环境中，表现不会比Serial更好，因为存在键程交互开销。但是随着CPU增加，它的表现会更好。它默认开启的收集线程数和CPU数相同。在CPU数量非常多的情况下，可以使用ParGCThreds的参数来限制垃圾收集的线程数</p>
<p>ParNew是Server模式下虚拟机首选的年轻代收集器。因为除了Serial之外，目前只有它可以和CMS收集器配合工作。</p>
<p>ParNew工作过程如下图：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3bG5gU.png" alt="ParNew"></p>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>可以在程序启动的时候通过<code>-XX:+UseParallelGC</code>设置使用此收集器。使用复制算法。</p>
<p>这个收集器和系统吞吐量有关。</p>
<p>什么是系统的吞吐量？</p>
<blockquote>
<p>吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)</p>
</blockquote>
<p>也就是运行用户代码时间/CPU消耗总时间。比如虚拟机一共运行了100分钟，垃圾收集用了2分钟，吞吐量就是98%</p>
<p>Parallel Scavenge收集器有些类似ParaNew收集器，也是多线程，但是与ParNew相比也有不同：</p>
<ul>
<li>相比ParNew，Parallel Scavenge对系统吞吐量的重视程度大于对用户线程停顿的时间的重视程度。虽然停顿时间短比较适合与用户相互的程序，因为响应速度更快可以提升用户体验；但高吞吐量可以高效率利用CPU时间，尽可能快地完成运算任务，比较适合在后台运算而不用和用户交互的任务。</li>
<li>在多核下执行才有优势，Server模式下默认的年轻代收集器</li>
</ul>
<p>Parallel Scavenge和ParNew工作过程基本相同，如下图：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3bG5gU.png" alt="ParNew"></p>
<p>值得一提的是，如果程序员本身对垃圾收集器不太了解，在程序优化过程中遇到了困难的时候，可以这样解决：在启动的时候加上参数<code>-XX:+UseAdaptiveSizePolicy</code>，使用Parallel Scavenge的自适应调节策略，这样就可以把内存管理的调优任务交给虚拟机自己去完成。</p>
<hr>
<h2 id="老年代收集器"><a href="#老年代收集器" class="headerlink" title="老年代收集器"></a>老年代收集器</h2><h3 id="Serial-Old收集器-MSC"><a href="#Serial-Old收集器-MSC" class="headerlink" title="Serial Old收集器(MSC)"></a>Serial Old收集器(MSC)</h3><p>可以在程序启动的时候通过<code>-XX:+UseSerialOldGC</code>设置使用此收集器。使用标记-整理算法。</p>
<p>Serial模式的老年版</p>
<ul>
<li>单线程收集，进行垃圾收集时，必须暂停所有工作线程</li>
<li>简单高效，Client模式下默认的老年代收集器</li>
</ul>
<p>工作流程如图：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3bYz0H.png" alt="Serial Old"></p>
<h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>可以在程序启动的时候通过<code>-XX:+UseParallelOldGC</code>设置使用此收集器。使用标记-整理算法。</p>
<p>这个收集器在JDK6之后才开始提供的。在此之前新生代的Parallel Scavenge收集器一直处在一个比较尴尬的位置，因为如果新生代选了它，老年代就只能选Serial Old收集器了。</p>
<p>Parallel Old收集器的出现就是为了解决这个问题。</p>
<p>直到Parallel Old出现之后，吞吐量优先收集器才有了名副其实的组合。</p>
<ul>
<li>多线程，吞吐量优先</li>
</ul>
<p>在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge + Parallel Old收集器的组合。</p>
<p>工作流程如图：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3bczkV.png" alt="Parallel Old收集器"></p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>可以在程序启动的时候通过<code>-XX:+UseConcMarkSweepGC</code>设置使用此收集器。使用标记-清除算法。</p>
<p>实际上，CMS收集器几乎占据着JVM老年代收集器的半壁江山。它的划时代的意义就是垃圾回收线程几乎能与用户线程做到同时工作——说是”几乎”，是因为它不能完全做到不”Stop-the-World”，它只是能尽可能地缩短停顿时间。需要注意如果你的程序对停顿比较敏感，并且在应用程序运行的时候可以提供更大的内存和更多的CPU，那么用CMS是好的选择。</p>
<p>此外，如果在JVM中有相对较多而且存活时间较长的对象，也更适合使用CMS。</p>
<p>CMS的整个垃圾回收过程可以分为下面六步：</p>
<ol>
<li><font color=#FF0000>初始标记</font>：stop-the-world，JVM停顿正在执行的任务，从垃圾回收的根对象开始，只扫描和根对象直接关联的对象，时间短</li>
<li>并发标记：并发追溯标记，程序不停顿。这个阶段中应用标记的线程和并发标记的线程并发执行，所以用户不会感受到停顿。</li>
<li>并发预清理：查找执行并发标记时晋升老年代的对象。可能有一些对象从新生代晋升到老年代，或者有些对象直接被分配到老年代，通过重新扫描，减少下一个阶段重新标记的工作(因为下一阶段会重新stop-the-world)。这个过程不停顿</li>
<li><font color=#FF0000>重新标记</font>：暂停虚拟机，扫描CMS堆中剩余对象，扫描从根对象开始向下追溯，并处理对象单元。这一步相对较慢</li>
<li>并发清理：清理垃圾对象，程序不停顿</li>
<li>并发重置：重置CMS收集器的数据结构，等待下一次垃圾回收</li>
</ol>
<p>上述过程中，初始标记和重新标记需要短暂的stop-the-world的</p>
<p>工作流程如下图：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3bvBJU.png" alt="CMS垃圾收集器"></p>
<p>并发标记的过程实际上是和用户线程同时工作的，也就是一边丢垃圾，一边打扫。但这也可能产生一个问题，就是某个垃圾如果在打扫之后产生的，那么这个垃圾就只能等到下次垃圾回收才能被收掉，也就是说垃圾打扫完一次后没有完全打扫干净。</p>
<p>但是CMS收集器因为用的是”标记-清除算法”而不是”标记-整理算法”，就不可避免导致了垃圾碎片化的问题。如果此时需要分配较大的对象，那就只能触发一次GC了。</p>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>可以在程序启动的时候通过<code>-XX:+UseG1GC</code>设置使用此收集器。使用多种算法，即”复制算法 + 标记-整理算法”。</p>
<p>G1收集器既用于年轻代，也用于老年代。全称：<font color=#FF0000>Garbage First收集器</font>。</p>
<p>实际上，HotSpot最终的目的是让G1收集器最后能替换掉JDK5发布的CMS收集器。</p>
<p>Garbage First收集器的特点：</p>
<ol>
<li>并行和并发——使用多个CPU来缩短stop-the-world的停顿时间，与用户线程并发执行</li>
<li>分代收集——独立管理整个堆，但是能够采用不同的方式去处理新创建的对象和已经熬过多次GC的旧对象以获得更好的收集效果</li>
<li>空间整合——基于”标记-整理算法”，解决了内存碎片的问题</li>
<li>可预测停顿——能建立可预测的停顿时间模型，设置用户在某个地方的停顿时长不能超过m毫秒，类似这样</li>
</ol>
<p>在Garbage First垃圾收集器之前的收集器，都是只针对年轻代或者老年代的。而Garbage First可以同时针对年轻代和老年代。</p>
<p>在使用Garbage First收集器的时候，Java堆的布局和使用其他垃圾收集器时有很大不同：</p>
<ul>
<li>将整个Java堆内存划分成多个大小相等的Region——虽然还保留新生代和老年代的概念，但是新生代和老年代不再是物理隔离的了</li>
<li>年轻代和老年代不再物理隔离——它们可以是不连续的Region的集合。这也使得分配内存空间的时候可以不是连续的</li>
</ul>
<p><img src="https://s2.ax1x.com/2020/03/06/3qSkGT.png" alt="G1堆内存分配"></p>
<p>也就是说此时在JVM启动的时候不需要决定哪些Region属于老年代，哪些Region属于年轻代。因为随着时间推移，年轻代的Region被回收以后，就会变为可用状态，此时也可以把它分配成老年代。</p>
<p>和其他的HotSpot一样，当一个年轻代GC发生时，整个年轻代会被回收，G1的老年代收集器有所不同，它在老年代不需要整个老年代进行回收，只有一部分Region被调用。</p>
<p>G1的年轻代由Eden Region和Survivor Region组成。当一个JVM分配Eden Region失败后，会触发一个年轻代回收，意味着Eden区满了。之后GC开始释放空间，第一个年轻代收集器会移动所有的存储对象，从Eden Region到Survivor Region,这就是copy to survivor的过程。</p>
<p>JDK11还有研发Epsilon GC和ZGC，这里暂时先不介绍。</p>
<h2 id="回顾一个问题"><a href="#回顾一个问题" class="headerlink" title="回顾一个问题"></a>回顾一个问题</h2><p><img src="https://s2.ax1x.com/2020/03/06/3b1jC8.png" alt="垃圾收集器之间的联系"></p>
<p>如上图，为什么CMS不能和Parallel Scavenge一起工作呢？两者为什么不兼容呢？</p>
<p>CMS是HotSpot在JDK5的时候推出的第一款整整意义上的并发收集器，第一次实现了让垃圾收集线程与用户线程同时工作。</p>
<p>CMS作为老年代收集器不能和Parallel Scavenge一起工作主要是因为Parallel Scavenge和CMS代码框架不同。</p>
<h1 id="GC相关面试题"><a href="#GC相关面试题" class="headerlink" title="GC相关面试题"></a>GC相关面试题</h1><h2 id="Object的finalize-方法的作用是否与C-的析构函数作用相同"><a href="#Object的finalize-方法的作用是否与C-的析构函数作用相同" class="headerlink" title="Object的finalize()方法的作用是否与C++的析构函数作用相同"></a>Object的finalize()方法的作用是否与C++的析构函数作用相同</h2><p>答：</p>
<ul>
<li>finalize()和C++的析构函数不同，析构函数调用的时机是确定的，对象离开作用域后就会调用，然后对象被delete掉。而finalize()具有不确定性，也就是对象还没用完可能就被GC</li>
<li>将未被引用的对象放置于F-Queue队列</li>
<li>方法执行随时可能会被终止</li>
<li>给予对象最后一次重生的机会</li>
</ul>
<p>但是由于finalize()方法代价比较高昂，所以不建议使用。</p>
<h2 id="Java中的强引用、软引用、弱引用、虚引用有什么用"><a href="#Java中的强引用、软引用、弱引用、虚引用有什么用" class="headerlink" title="Java中的强引用、软引用、弱引用、虚引用有什么用"></a>Java中的强引用、软引用、弱引用、虚引用有什么用</h2><h3 id="强引用-Strong-Reference"><a href="#强引用-Strong-Reference" class="headerlink" title="强引用(Strong Reference)"></a>强引用(Strong Reference)</h3><ul>
<li>最普遍的引用：Object obj = new Object()，这里obj就是强引用</li>
<li>抛出OutOfMemoryError终止程序也不会回收具有强引用的对象</li>
<li>通过将对象设置为null来弱化引用，使其被回收</li>
</ul>
<h3 id="软引用-Soft-Reference"><a href="#软引用-Soft-Reference" class="headerlink" title="软引用(Soft Reference)"></a>软引用(Soft Reference)</h3><ul>
<li>对象处在有用但非必须的状态</li>
<li>只有当内存空间不足时，GC会回收该引用的对象的内存</li>
<li>可以用来实现高速缓存——这样我们就可以避免OutOfMemory的问题。因为软引用的内存会在内存不足的情况下回收。</li>
</ul>
<p>强引用和软引用例子如下图：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3qsJ3Q.png" alt="强引用和软引用例子"></p>
<h3 id="弱引用-Weak-Reference"><a href="#弱引用-Weak-Reference" class="headerlink" title="弱引用(Weak Reference)"></a>弱引用(Weak Reference)</h3><ul>
<li>非必须的对象，比软引用更弱一些</li>
<li>生命周期更短，在GC时会被回收——无论当前内存是否紧缺，GC都会回收被弱引用关联的对象</li>
<li>被回收的概率也不大，因为GC线程优先级比较低</li>
<li>弱引用适用于偶尔使用且不影响垃圾收集的对象</li>
</ul>
<p>弱引用案例：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3qyBqI.png" alt="弱引用例子"></p>
<p>弱引用同样可以配合引用队列去使用。</p>
<h3 id="虚引用-Phantom-Reference"><a href="#虚引用-Phantom-Reference" class="headerlink" title="虚引用(Phantom Reference)"></a>虚引用(Phantom Reference)</h3><p>“虚无缥缈”，其生命周期比较不固定</p>
<ul>
<li>不会决定对象的生命周期</li>
<li>任何时候都可能被垃圾收集器回收</li>
<li>跟踪对象被垃圾收集器回收的活动，起哨兵作用</li>
<li>比较特殊，必须和引用队列ReferenceQueue联合使用</li>
</ul>
<p><img src="https://s2.ax1x.com/2020/03/06/3q63lQ.png" alt="虚引用例子"></p>
<p>GC在回收一个对象时，若发现这个对象有虚引用，那么回收前会先将这个引用加入到与之关联的引用队列当中。</p>
<h3 id="四种引用之间的关系"><a href="#四种引用之间的关系" class="headerlink" title="四种引用之间的关系"></a>四种引用之间的关系</h3><p><img src="https://s2.ax1x.com/2020/03/06/3q64pD.png" alt="四种引用之间的关系"></p>
<h3 id="引用类结构层次"><a href="#引用类结构层次" class="headerlink" title="引用类结构层次"></a>引用类结构层次</h3><p><img src="https://s2.ax1x.com/2020/03/06/3qcmjJ.png" alt="引用类结构层次"></p>
<h3 id="引用队列-ReferenceQueue"><a href="#引用队列-ReferenceQueue" class="headerlink" title="引用队列(ReferenceQueue)"></a>引用队列(ReferenceQueue)</h3><p>引用队列名义上是一个队列，但其内部没有实际存储结构。</p>
<ul>
<li>无实际存储结构，存储逻辑依赖于内部节点之间的关系来表达的——类似链表，节点是Reference本身，它自己只存储链表的头结点，而后面的节点都通过Reference指向下一个的next来保持。</li>
<li>存储关联的且被GC的软引用，弱引用以及虚引用</li>
</ul>
]]></content>
      <categories>
        <category>Study Note</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Basic Interview I</title>
    <url>/2020/03/04/Java-Basic-Interview-I/</url>
    <content><![CDATA[<blockquote>
<p>知识犹如人体的血液一样宝贵。——高士其</p>
</blockquote>
<a id="more"></a>

<h2 id="1-JDK和JRE有什么区别？"><a href="#1-JDK和JRE有什么区别？" class="headerlink" title="1.JDK和JRE有什么区别？"></a>1.JDK和JRE有什么区别？</h2><p>• JDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。<br>• JRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。</p>
<p>具体来说 JDK 其实包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 java 程序调试和分析的工具。简单来说：如果你需要运行 java 程序，只需安装 JRE 就可以了，如果你需要编写 java 程序，需要安装 JDK。</p>
<h2 id="2-和equals的区别"><a href="#2-和equals的区别" class="headerlink" title="2.==和equals的区别"></a>2.==和equals的区别</h2><p><font color=#FF000>== 解读</font></p>
<p>对于基本类型和引用类型 == 的作用效果是不同的，如下所示：<br>• 基本类型：比较的是值是否相同；<br>• 引用类型：比较的是引用是否相同；</p>
<p>代码示例：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">String x = <span class="string">"string"</span>;</span><br><span class="line">String y = <span class="string">"string"</span>;</span><br><span class="line">String z = <span class="keyword">new</span> <span class="constructor">String(<span class="string">"string"</span>)</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(x==y); <span class="comment">// true</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(x==z); <span class="comment">// false</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(x.equals(y)); <span class="comment">// true</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(x.equals(z)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>代码解读：因为 x 和 y 指向的是同一个引用，所以 == 也是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为true</p>
<p><font color=#FF000>equals 解读</font></p>
<p>equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。看下面的代码就明白了。</p>
<p>首先来看默认情况下 equals 比较一个有相同值的对象，代码如下：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> &#123;</span>    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(<span class="keyword">String</span> name)</span> </span>&#123;        </span><br><span class="line">	<span class="keyword">this</span>.name = name;    </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">String</span> name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">return</span> name;    </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">String</span> name)</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">this</span>.name = name;    </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Cat c1 = <span class="keyword">new</span> Cat(<span class="string">"王磊"</span>);</span><br><span class="line">Cat c2 = <span class="keyword">new</span> Cat(<span class="string">"王磊"</span>);</span><br><span class="line">System.out.<span class="built_in">println</span>(c1.equals(c2)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原来 equals 本质上就是 ==。</p>
<p>那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">String</span> s1 = <span class="keyword">new</span> <span class="keyword">String</span>(<span class="string">"老王"</span>);</span><br><span class="line"><span class="keyword">String</span> s2 = <span class="keyword">new</span> <span class="keyword">String</span>(<span class="string">"老王"</span>);</span><br><span class="line">System.out.<span class="built_in">println</span>(s1.equals(s2)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">boolean</span> equals(<span class="keyword">Object</span> anObject) &#123;</span><br><span class="line">    <span class="keyword">if</span> (this == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject instanceof String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="type">int</span> n = <span class="keyword">value</span>.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.<span class="keyword">value</span>.length) &#123;</span><br><span class="line">            <span class="type">char</span> v1[] = <span class="keyword">value</span>;</span><br><span class="line">            <span class="type">char</span> v2[] = anotherString.<span class="keyword">value</span>;</span><br><span class="line">            <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n<span class="comment">-- != 0) &#123;</span></span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。</p>
<p>总结 ：== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p>
<h2 id="3-两个对象的hashCode-相同，则equals-也一定为true，对么？"><a href="#3-两个对象的hashCode-相同，则equals-也一定为true，对么？" class="headerlink" title="3.两个对象的hashCode()相同，则equals()也一定为true，对么？"></a>3.两个对象的hashCode()相同，则equals()也一定为true，对么？</h2><p>不对，两个对象的 hashCode()相同，equals()不一定 true。</p>
<p>代码示例：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">"通话"</span>;</span><br><span class="line">String str2 = <span class="string">"重地"</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>format(<span class="string">"str1：%d | str2：%d"</span>,</span><br><span class="line">                                       str1.hash<span class="constructor">Code()</span>, str2.hash<span class="constructor">Code()</span>));</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(str1.equals(str2));</span><br></pre></td></tr></table></figure>


<p>执行的结果：</p>
<p>str1：1179395 | str2：1179395</p>
<p>false</p>
<p>代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode()相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。</p>
<h2 id="4-final在java中有什么作用？"><a href="#4-final在java中有什么作用？" class="headerlink" title="4.final在java中有什么作用？"></a>4.final在java中有什么作用？</h2><p>• final 修饰的类叫最终类，该类不能被继承。<br>• final 修饰的方法不能被重写。<br>• final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</p>
<h2 id="5-java中的Math-round-1-5-等于多少？"><a href="#5-java中的Math-round-1-5-等于多少？" class="headerlink" title="5.java中的Math.round(-1.5)等于多少？"></a>5.java中的Math.round(-1.5)等于多少？</h2><p>等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃。</p>
<h2 id="6-String属于基础的数据类型么？"><a href="#6-String属于基础的数据类型么？" class="headerlink" title="6.String属于基础的数据类型么？"></a>6.String属于基础的数据类型么？</h2><p>String 不属于基础类型，基础类型有 8 种：byte（一个字节，8位）、 boolean（只有true和false两个值，默认false）、char（两个字节，十六位）、short（两个字节，十六位，最大存储值是65536，数据范围是-32768<del>32767之间）、int（四个字节，三十二位，最大存储容量是2的32次方减1，范围是负2的31次方到正的2的31次方减1）、float（四个字节，三十二位，数据范围在3.4e-45</del>1.4e38）、long（八个字节，六十四位，最大存储容量是2的64次方减1,范围是负2的63次方到正2的63次方减1）、double（八个字节，六十四位，数据范围在4.9e-324~1.8e308，赋值时可以加d也可以不加），而 String 属于对象。</p>
<p><img src="https://s2.ax1x.com/2020/03/04/35IdWF.png" alt="Java数据类型"></p>
<p>数据之间的转换：</p>
<p>1.表示值范围小的，可以自动转换成范围大的。比如下面都可以自动转换：</p>
<p>byte b;int i=b; long l=b; float f=b; double d=b;</p>
<p>2.但是如果低级的char向高级类型转换的时候，会转换成对应的ASCII码值。例如：</p>
<p>char c=’c’; int i=c;<br>System.out.println(“output:”+i);输出：output:99;</p>
<p>3.每个包装类中会有形为xxValue()的方法，可以得到其对饮的简单类型数据。利用这种方法，也可以实现不同数值型变量间的转换，例如，对于一个双精度实型类，intValue()可以得到其对应的整型变量，而doubleValue()可以得到其对应的双精度实型变量。</p>
<p>4.字符串和其他类型的转换<br>首先是其他类型向字符串类型转换：</p>
<pre><code>①. 调用类的串转换方法：X.toString();
②. 自动转换：X + &quot;&quot;;
③. 使用String的方法：String.valueOf(X)</code></pre><p>然后字符串作为值，转换成其他类型：</p>
<pre><code>①. 静态parseXXX方法
比如，String s=&quot;1&quot;;
byte b = Byte.parseByte( s );
short t = Short.parseShort( s );
int i = Integer.parseInt( s );
long l = Long.parseLong( s );
Float f = Float.parseFloat( s );
Double d = Double.parseDouble( s );

②. Character的getNumericValue(char ch)方法

③. 先转换成相应的封装类实例，再调用对应的方法转换成其他类型</code></pre><p>例如，字符中”32.1”转换double型的值的格式为:new Float(“32.1”).doubleValue()。也可以用:Double.valueOf(“32.1”).doubleValue()</p>
<p>5.Date类与其他数据类型的转换<br>（暂省略）</p>
<p><strong>小总结：</strong></p>
<p>只有boolean不参与数据类型的转换<br>（1）.自动类型的转换：</p>
<p>a.常数在表数范围内是能够自动类型转换的</p>
<p>b.数据范围小的能够自动数据类型大的转换（注意特例）<br>int到float，long到float，long到double 是不会自动转换的，不然将会丢失精度</p>
<p>c.引用类型能够自动转换为父类的</p>
<p>d.基本类型和它们包装类型是能够互相转换的</p>
<p>（2）.强制类型转换：用圆括号括起来目标类型，置于变量前</p>
<p>注：<font color=#FF0000>java有五种引用类型：数组、类、接口、枚举、标注</font></p>
<p>个人总结：</p>
<p>①：如果是小数类型，而且位数比较小，比如四位，建议用BigDecimal，如果是double类型会有失精度，有时候会用科学技术法表示（比如1.0E-4，不利于人看），而且用double有时候还要对类型进行转换</p>
<p>②： Int  double都是包装类型的，建议使用包装类型，包装类型能区分null 和 0，就像在 spring-mvc接收时使用int类型接收值，如果这个属性不传值，ajax请求会报400错误，而且不能区分这个数值是否为空</p>
<p>③： for 循环中如果要对字符串进行拼接，建议使用 StringBuffer ，如果没有线程安全问题，直接使用 StringBuilder，原因StringBuffer的所有操作是保证线程安全的，可以理解成使用了 synchronized 关键字，对性能是有影响的。</p>
<p>④：对所有包装类进行操作（比如toString()）要进行空指针判断，我们不能保证这个是有值的</p>
<h2 id="7-java中操作字符串都有哪些类？他们之间有什么区别？"><a href="#7-java中操作字符串都有哪些类？他们之间有什么区别？" class="headerlink" title="7.java中操作字符串都有哪些类？他们之间有什么区别？"></a>7.java中操作字符串都有哪些类？他们之间有什么区别？</h2><p>操作字符串的类有：String、StringBuffer、StringBuilder。</p>
<p>String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。</p>
<p>StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。</p>
<h2 id="8-String-str-”i”-与-String-str-new-String-“i”-一样吗？"><a href="#8-String-str-”i”-与-String-str-new-String-“i”-一样吗？" class="headerlink" title="8.String str=”i” 与 String str=new String(“i”) 一样吗？"></a>8.String str=”i” 与 String str=new String(“i”) 一样吗？</h2><p>不一样，因为内存的分配方式不一样。String str=”i”的方式，java 虚拟机会将其分配到常量池中；而 String str=new String(“i”) 则会被分到堆内存中。</p>
<h2 id="9-如何将字符串反转？"><a href="#9-如何将字符串反转？" class="headerlink" title="9.如何将字符串反转？"></a>9.如何将字符串反转？</h2><p>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。</p>
<p>实例代码：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">// <span class="keyword">StringBuffer </span><span class="keyword">reverse</span></span><br><span class="line"><span class="keyword">StringBuffer </span><span class="keyword">stringBuffer </span>= new <span class="keyword">StringBuffer();</span></span><br><span class="line"><span class="keyword">stringBuffer.append("abcdefg");</span></span><br><span class="line"><span class="keyword">System.out.println(stringBuffer.reverse()); </span>// gfedcba</span><br><span class="line">// <span class="keyword">StringBuilder </span><span class="keyword">reverse</span></span><br><span class="line"><span class="keyword">StringBuilder </span><span class="keyword">stringBuilder </span>= new <span class="keyword">StringBuilder();</span></span><br><span class="line"><span class="keyword">stringBuilder.append("abcdefg");</span></span><br><span class="line"><span class="keyword">System.out.println(stringBuilder.reverse()); </span>// gfedcba</span><br></pre></td></tr></table></figure>

<h2 id="10-String类的常用方法都有哪些？"><a href="#10-String类的常用方法都有哪些？" class="headerlink" title="10.String类的常用方法都有哪些？"></a>10.String类的常用方法都有哪些？</h2><p>• indexOf()：返回指定字符的索引。<br>• charAt()：返回指定索引处的字符。<br>• replace()：字符串替换。<br>• trim()：去除字符串两端空白。<br>• split()：分割字符串，返回一个分割后的字符串数组。<br>• getBytes()：返回字符串的 byte 类型数组。<br>• length()：返回字符串长度。<br>• toLowerCase()：将字符串转成小写字母。<br>• toUpperCase()：将字符串转成大写字符。<br>• substring()：截取字符串。<br>• equals()：字符串比较。</p>
<h2 id="11-抽象类必须要有抽象方法吗？"><a href="#11-抽象类必须要有抽象方法吗？" class="headerlink" title="11.抽象类必须要有抽象方法吗？"></a>11.抽象类必须要有抽象方法吗？</h2><p>不需要，抽象类不一定非要有抽象方法。</p>
<p>示例代码：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Cat</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"hi~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码，抽象类并没有抽象方法但完全可以正常运行。</p>
<h2 id="12-普通类和抽象类有哪些区别？"><a href="#12-普通类和抽象类有哪些区别？" class="headerlink" title="12.普通类和抽象类有哪些区别？"></a>12.普通类和抽象类有哪些区别？</h2><p>• 普通类不能包含抽象方法，抽象类可以包含抽象方法。<br>• 抽象类不能直接实例化，普通类可以直接实例化。</p>
<h2 id="13-抽象类能使用final修饰吗？"><a href="#13-抽象类能使用final修饰吗？" class="headerlink" title="13.抽象类能使用final修饰吗？"></a>13.抽象类能使用final修饰吗？</h2><p>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类，如下图所示，编辑器也会提示错误信息：</p>
<p><img src="https://s2.ax1x.com/2020/03/04/35Iwz4.jpg" alt="35Iwz4.jpg"></p>
<h2 id="14-接口和抽象类有什么区别？"><a href="#14-接口和抽象类有什么区别？" class="headerlink" title="14.接口和抽象类有什么区别？"></a>14.接口和抽象类有什么区别？</h2><p>• 实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。<br>• 构造函数：抽象类可以有构造函数；接口不能有。<br>• main 方法：抽象类可以有 main 方法，并且我们能运行它；接口不能有 main 方法。<br>• 实现数量：类可以实现很多个接口；但是只能继承一个抽象类。<br>• 访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。</p>
<h2 id="15-java中的IO流分为几种？"><a href="#15-java中的IO流分为几种？" class="headerlink" title="15.java中的IO流分为几种？"></a>15.java中的IO流分为几种？</h2><p>按功能来分：输入流（input）、输出流（output）。</p>
<p>按类型来分：字节流和字符流。</p>
<p>字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。</p>
<h2 id="16-BIO、NIO、AIO有什么区别？"><a href="#16-BIO、NIO、AIO有什么区别？" class="headerlink" title="16.BIO、NIO、AIO有什么区别？"></a>16.BIO、NIO、AIO有什么区别？</h2><p>• BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。<br>• NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。<br>• AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</p>
<h2 id="17-Files的常用方法有哪些？"><a href="#17-Files的常用方法有哪些？" class="headerlink" title="17.Files的常用方法有哪些？"></a>17.Files的常用方法有哪些？</h2><p>• Files.exists()：检测文件路径是否存在。<br>• Files.createFile()：创建文件。<br>• Files.createDirectory()：创建文件夹。<br>• Files.delete()：删除一个文件或目录。<br>• Files.copy()：复制文件。<br>• Files.move()：移动文件。<br>• Files.size()：查看文件个数。<br>• Files.read()：读取文件。<br>• Files.write()：写入文件。</p>
]]></content>
      <categories>
        <category>Interview Note</category>
      </categories>
      <tags>
        <tag>Interview</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Operating System Interview I</title>
    <url>/2020/02/25/Operating-System-Interview-I/</url>
    <content><![CDATA[<blockquote>
<p>横眉冷对千夫指，俯首甘为孺子牛。——鲁迅</p>
</blockquote>
<a id="more"></a>

<p>操作系统面试相关知识汇总：</p>
<p><img src="https://s2.ax1x.com/2020/02/25/3JaemQ.png" alt="3JaemQ.png"></p>
<p>操作系统知识对于服务问题的排查和定位非常重要。</p>
<h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程的结构如下图所示：</p>
<p><img src="https://s2.ax1x.com/2020/02/25/3t5L5R.png" alt="3t5L5R.png"></p>
<ul>
<li>每个进程都包含线程</li>
<li>进程里面也包含内存。</li>
<li>“句柄“在英文中叫做“handle”，文件和网络资源与内存不同，它是所有进程所共有的，也就是说我这个进程和那个进程都是可以打开同一个文件的，或者都是可以同时去抢同一个网络的端口。</li>
</ul>
<p>是不是把电脑的内存分配一部分给它呢？并不是。<br>这里的内存是逻辑内存。电脑的32位和64位到底是什么意思呢？就是在内存上面，是指它们内存的寻址空间。32位代表2的32次方，也就是4G大小，也就是每个进程都有一个4G内存的一个空间。这只是说它有4G内存的空间可以用，不是说我就把4G的内存分配给你了。</p>
<p>进程之间的内存的独立是合理且必须的，举个例子，如果我的进程的指针可以改一改，指向你正在输入银行卡密码的进程，那么我就可以得到你微信或者网上银行的内存了，那就很不安全，甚至恐怖了。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程的结构如下图所示：</p>
<p><img src="https://s2.ax1x.com/2020/02/25/3tIprD.png" alt="3tIprD.png"></p>
<p>我制作的这张图可以说比较形象地说明了线程的内部结构。</p>
<p>首先，线程里面包含栈。我们习惯说“调用堆栈”，实际上这里“堆“没有意义，这里的调用“堆栈”其实就是调用栈。</p>
<ul>
<li><p>栈里面有什么？——主线程中的main函数会进行各种调用，每次调用，会把所有的参数和返回的地址压到栈里面，一层一层地放入栈。包括每个函数地局部变量也都会放在栈里面。</p>
</li>
<li><p>线程还有很重要的一个东西“PC”——program counter的意思，里面存放的是下一个要执行的指令的地址。所以总的来说，我们的操作系统运行的是一个一个的线程，进程只是一个容器，线程才是真正运行的东西</p>
</li>
<li><p>TLS——thread local storage——每个进程都有自己的一块内存，那么线程有没有呢？也是有的，就是这个TLS。我们可以在TLS中分配内存，存放变量，这些数据就是我们的线程所独有的数据</p>
</li>
</ul>
<p>总得来说，线程才是我们操作的系统真正运行的，进程只是一个容器，他把一部分东西放在一起，旁边放了一个很强的隔离，把不同的程序隔离开来。</p>
<h2 id="进程和线程的区别和联系？"><a href="#进程和线程的区别和联系？" class="headerlink" title="进程和线程的区别和联系？"></a>进程和线程的区别和联系？</h2><p>从宏观上来回答：</p>
<p>a. 进程是系统资源分配的最小单位，线程是程序执行的最小单位</p>
<p>b.进程使用独立的数据空间，而线程共享进程的数据空间</p>
<p>但是这只是很宏观的角度，我们需要从更细的角度去钻研一下，进程(process)和线程(thread)的区别。而且面试官可能会从你的回答来继续后面的问题。</p>
<p>比如面试者回答说”它们的内存结构不同，进程之间不能共享内存，线程之间可以共享内存”，那面试官可以问与内存有关的内容，比如我们<strong>如何寻址</strong>？</p>
<p>再比如面试者回答“线程之间通信很方便，但是进程之间通信比较复杂”，那么面试官会问<strong>进程间通信有哪些方法，比较一下优劣点</strong>，等等。</p>
<ul>
<li><p>共享内存，因为进程间不能共享内存，所以我们会用一些进程间相互交互的方案，比较常见的就是通过TCP/IP的端口来实现。也有其他方案，但是TCP/IP是最通用的，其他方案可能和某个特定操作系统的相关性要更大一些。</p>
</li>
<li><p>线程间通信就很简单了，只要两个线程的指针指向同一块内存，它们之间就可以通信。</p>
</li>
<li><p>In terms of 开销，进程的开销当然比较大，因为我们要给它分配很多内存，而线程我们只是给它分配一个栈，分配一个PC指针(program counter)就可以了。此外，进程之间切换的开销会大于线程之间切换的开销。</p>
</li>
</ul>
<h2 id="进程间通信-IPC"><a href="#进程间通信-IPC" class="headerlink" title="进程间通信(IPC)"></a>进程间通信(IPC)</h2><p>之前已经介绍了进程和线程之间的区别，进程就像一个container,里面有很多的线程。而除了有很多线程，更重要的一点，它有一块自己的内存。这块内存是这个进程里面所有线程之间共享的，所以线程之间共享数据很方便——我开一块内存，告诉你地址，你也能用，当然如果同时读写的话会有线程安全性问题，需要加一些同步的机制来防止线程安全性的问题。</p>
<p>但是进程和进程之间都有一块自己独立的内存，这块内存的大小和物理内存大小无关，和系统是32位还是64位有关。进程之间是不能互相看到信息的。</p>
<p>这里列举进程之间通信的7种方法：</p>
<ol>
<li>文件</li>
<li>管道/命名管道</li>
<li>Signal</li>
<li>共享内存</li>
<li>消息队列</li>
<li>同步机制，如信号量(semaphore)</li>
<li>Socket</li>
</ol>
<h3 id="1-写一个文件：最简单的方法，一个进程写一个文件，另一个进程去访问这个文件，由此两个进程之间可以交换信息，得以通信。"><a href="#1-写一个文件：最简单的方法，一个进程写一个文件，另一个进程去访问这个文件，由此两个进程之间可以交换信息，得以通信。" class="headerlink" title="1.写一个文件：最简单的方法，一个进程写一个文件，另一个进程去访问这个文件，由此两个进程之间可以交换信息，得以通信。"></a>1.写一个文件：最简单的方法，一个进程写一个文件，另一个进程去访问这个文件，由此两个进程之间可以交换信息，得以通信。</h3><h3 id="2-管道：两个进程之间建立消息通信的通道。不命名的管道一般是单向的，一方可以向另一方从管道里发送数据；命名管道可以单向也可以双向。"><a href="#2-管道：两个进程之间建立消息通信的通道。不命名的管道一般是单向的，一方可以向另一方从管道里发送数据；命名管道可以单向也可以双向。" class="headerlink" title="2.管道：两个进程之间建立消息通信的通道。不命名的管道一般是单向的，一方可以向另一方从管道里发送数据；命名管道可以单向也可以双向。"></a>2.管道：两个进程之间建立消息通信的通道。不命名的管道一般是单向的，一方可以向另一方从管道里发送数据；命名管道可以单向也可以双向。</h3><p>比如：<br>-打印一个日志文件：cat XXX</p>
<p>-查找带有某个字符串内容：grep -e “ERROR” –color</p>
<p>此外，如果还用统计，可以用wc（word count）命令</p>
<h3 id="3-Signal：linux系统中最常用。一个进程给另一个进程发送信号，一般是一串数字，这个数字有自己特定的含义。比如”kill”可以-send-a-signal-to-a-process-强行”kill”掉。"><a href="#3-Signal：linux系统中最常用。一个进程给另一个进程发送信号，一般是一串数字，这个数字有自己特定的含义。比如”kill”可以-send-a-signal-to-a-process-强行”kill”掉。" class="headerlink" title="3.Signal：linux系统中最常用。一个进程给另一个进程发送信号，一般是一串数字，这个数字有自己特定的含义。比如”kill”可以 send a signal to a process,强行”kill”掉。"></a>3.Signal：linux系统中最常用。一个进程给另一个进程发送信号，一般是一串数字，这个数字有自己特定的含义。比如”kill”可以 send a signal to a process,强行”kill”掉。</h3><h3 id="4-共享内存：虽然进程之间是彼此独立的，但是操作系统可以提供一个机制，两个进程可以约定好，打开一个文件，这个文件映射到内存中，也就是多个进程使用同一块内存。"><a href="#4-共享内存：虽然进程之间是彼此独立的，但是操作系统可以提供一个机制，两个进程可以约定好，打开一个文件，这个文件映射到内存中，也就是多个进程使用同一块内存。" class="headerlink" title="4.共享内存：虽然进程之间是彼此独立的，但是操作系统可以提供一个机制，两个进程可以约定好，打开一个文件，这个文件映射到内存中，也就是多个进程使用同一块内存。"></a>4.共享内存：虽然进程之间是彼此独立的，但是操作系统可以提供一个机制，两个进程可以约定好，打开一个文件，这个文件映射到内存中，也就是多个进程使用同一块内存。</h3><p><strong>共享内存方式适用于进程间数据共享的场景</strong>。</p>
<h3 id="5-消息队列：一个进程可以向另一个进程发消息。"><a href="#5-消息队列：一个进程可以向另一个进程发消息。" class="headerlink" title="5.消息队列：一个进程可以向另一个进程发消息。"></a>5.消息队列：一个进程可以向另一个进程发消息。</h3><p><strong>进程间数据交换的场景可以使用Unix Socket或者消息队列</strong>。</p>
<h3 id="6-同步机制，信号量。"><a href="#6-同步机制，信号量。" class="headerlink" title="6.同步机制，信号量。"></a>6.同步机制，信号量。</h3><p>很经典的知识点。如果进程或者线程进入之后，可能不是在进行写操作，而是进行读之类的操作，此时没必要只限制一个进程或者线程去执行。</p>
<p>信号量用一个整型(sem)表示，它是一个有符号数。针对信号量有两个原子操作：</p>
<ul>
<li><font color=#FF0000><strong>P()</strong></font>(Perlaag(荷兰语，减少))<ul>
<li>sem减1</li>
<li>若sem &lt; 0,进入等待，否则继续</li>
</ul>
</li>
<li><font color=#FF0000><strong>V()</strong></font>(Verhoog(荷兰语，增加))<ul>
<li>sem加1</li>
<li>若sem&lt;=0,唤醒一个等待进程</li>
</ul>
</li>
</ul>
<p>可以用火车站台举例子，如果只有两个车站和站台，只有2个资源的信号量，那么一开始sem是2。来了一辆车，sem会减1，若sem减小到了0，那么再来的资源就只能等待了。</p>
<p>信号量有两种：二进制信号量(0或1)、一般/计数信号量(可以取任何非负值)</p>
<p>P()操作可能会让进程阻塞挂起、V()操作可能可以唤醒进程。</p>
<p>在临界区之前用P()操作，在临界区之后用V()操作加回去。</p>
<p>使用二值信号量的一个例子：如果要设置两个Thread的同步关系，那么可以把condition初始化值设置为0：<code>condition = new Semaphore(0)</code>，<br>让Thread在执行条件(比如condition())之前执行减法P()操作，这样condition就不得不暂停，直到condition里面的信号量回到0才能继续执行。此时可以在ThreadB中执行V()操作，此时才可以把ThreadA唤醒，使得Thread继续执行。</p>
<p><strong>也可以用信号量解决有缓冲区的生产者-消费者问题</strong>。此时需要用到计数信号量。</p>
<p><img src="https://s2.ax1x.com/2020/02/26/3U1SYV.png" alt="3U1SYV.png"></p>
<p>图中的情况和Lock完全不同。生产者可能生产很多内容都往buffer里面”挤”，但是作为消费者的线程，可能不能一口气消耗掉所有buffer里面的数据。</p>
<p>有关生产者消费者模型的问题，有以下要求(约束)：</p>
<ul>
<li>在任何一个时间只能有一个线程操作缓冲区(互斥)</li>
<li>当缓冲区为空，消费者必须等待生产者(调度/同步约束)</li>
<li>当缓存区满，生产者必须等待消费者(调度/同步约束)</li>
</ul>
<p>解决这三个约束的办法，就是定义三个信号量，每个约束单独用一个信号量控制：</p>
<ul>
<li>二进制信号量(处理互斥)</li>
<li>一般信号量fullBuffers(一开始为0，取不到数据，标记消费者是否可以去取数据了)</li>
<li>一般信号量emptyBuffers(一开始为n，可以用P()函数去取)</li>
</ul>
<p>具体定义操作：</p>
<p><img src="https://s2.ax1x.com/2020/02/26/3U6nhT.png" alt="3U6nhT.png"></p>
<p>上面这两个函数中，即用到了互斥机制，也用到了同步机制，来解决生产者和消费者的问题。</p>
<p>fullBuffers一开始是0。emptyBuffers里面一开始设置可以放入n。</p>
<p>生产者函数：Deposit、消费者函数：Remove()</p>
<p>需要注意初始值的赋值，需要知道一开始Buffer是不是空的。</p>
<p>一个问题：上述生产者消费者模型中，<strong>P、V操作的顺序有影响吗？</strong>——答：因为V操作不会阻塞，所以交换V操作没有问题。</p>
<p>但是生产者的P操作不能交换，因为P操作是阻塞的，可能产生死锁。比如生产者很快，Buffer满了，生产者先执行mutex的P操作，可以执行。但是之后执行emptyBuffer()的时候，因为此时Buffer满了，emptyBuffers已经是0了，所以再执行P操作之后，Deposit会进入到睡眠状态。之后消费者如果P顺序不变，第一个fullBuufers操作没问题，但是第二个mutex会卡住，导致最后不能执行到emptyBuffers操作的V操作，无法唤醒生产者的操作，产生死锁。</p>
<p>所以，对信号量的操作的顺序需要注意。</p>
<h3 id="7-Socket：最后一种，而且没回答出来这个其实整个答案都不算好。因为前面6种只能作为同一个机器的进程之间的通信，而Socket可以是不同机器的进程之间的通信。"><a href="#7-Socket：最后一种，而且没回答出来这个其实整个答案都不算好。因为前面6种只能作为同一个机器的进程之间的通信，而Socket可以是不同机器的进程之间的通信。" class="headerlink" title="7.Socket：最后一种，而且没回答出来这个其实整个答案都不算好。因为前面6种只能作为同一个机器的进程之间的通信，而Socket可以是不同机器的进程之间的通信。"></a>7.Socket：最后一种，而且没回答出来这个其实整个答案都不算好。因为前面6种只能作为同一个机器的进程之间的通信，而<strong>Socket可以是不同机器的进程之间的通信</strong>。</h3><p>可以在机器上开一个端口，作为一个服务器，让用户连接。这种通信包含了网络上的服务端和服务器的这种结构。</p>
<p>用浏览器去访问一个网站，这时<strong>浏览器的进程</strong>和<strong>远端服务器的进程要进行通信</strong>。</p>
<p>Socket可以作为不同机器之间进程的通信——通过客户端，服务器的方法。这里面走的一般是TCP的协议或者UDP的协议。</p>
<h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><p>介绍两个调度算法：<strong>时间片轮转调度算法</strong>和<strong>动态优先级调度算法</strong></p>
<p>时间片轮转调度是一种最古老，最简单而且最公平的算法，每个进程被分配一段时间，称作是时间片，轮流分享CPU的计算资源。这个时间片的设置比较讲究。比如linux早期是百分之一秒，现在设置为千分之一秒。</p>
<p>和之前做过的堆机场吞吐量优化的项目类似，动态优先级调度算法就是给每个进程都设置一个权值，而且这个权值会随自变量而改变，而系统会根据每个进程的优先级来判断之后优先调度哪一个进程。</p>
<h1 id="存储和寻址"><a href="#存储和寻址" class="headerlink" title="存储和寻址"></a>存储和寻址</h1><p>存储整体结构如下图：</p>
<p><img src="https://s2.ax1x.com/2020/02/26/3UostH.png" alt="3UostH.png"></p>
<p>最底层是硬盘，可以长久存放程序，而且一般都比较大。</p>
<p>然后是内存，它里面存放的数据断电就会没有，但是它可以更加快速地随机地进行访问。</p>
<p>再往上就进入了CPU。CPU除了运算模块，还有缓存。缓存也有各种级别，有些缓存是共有的，有些是自己独有的。</p>
<p>再往上就是离CPU运算单元更近的，寄存器。</p>
<p>这些存储单元的存储速度有什么特点？从上到下由快到慢。寄存器是最快的因为他就在运算模块的旁边。硬盘是最慢的。价格也是由贵到便宜。</p>
<p>谷歌的搜索会把整个互联网放在它们的内存中，尤其是对访问量高的网页。访问量低的网页才会被放在硬盘里。这样基于内存的搜索引擎肯定是又快又好的。</p>
<h2 id="寻址过程"><a href="#寻址过程" class="headerlink" title="寻址过程"></a>寻址过程</h2><p>那么我们操作系统是如何寻址的？——也就是说给定一个地址之后，操作系统是怎么在这个层次性的结构中找到需要的数据呢？</p>
<p>需要结合寻址空间：</p>
<ul>
<li>寻址空间：每一个<strong>进程</strong>里面的指针可以取到的地址的范围。这个寻址空间和我们机器上装了多少存储空间，某时刻有多少个进程，都没有关系。每个进程都有自己独立的寻址空间。</li>
</ul>
<p>那这个寻址空间有多大呢？一般会考虑到两种大小的寻址空间：32位和64位。</p>
<p>32位：2的32次方位字节(Byte,注意不是Bit，也就说不是位或者比特)。1G=2^10 M =2^10 * 2^10 K = 2^10 * 2^10 * 2^10 B，所以32位为 2^32/2^10/2^10/2^10 = 2^2 = 4G</p>
<p>64位：可以有10^19次方Byte的寻址空间，这个空间非常大，一时半会不需要考虑不够用……</p>
<p>举一个寻址的例子：<code>int n = *p;</code>，这段代码翻译成汇编，其实就是：<code>MOV EAX, [EBX]</code></p>
<p>具体流程如下图所示：</p>
<p><img src="https://s2.ax1x.com/2020/02/26/3ay5IP.png" alt="3ay5IP.png"></p>
<p>这段代码,int n = <em>p，p代表一个地址，</em>p表示把指向int类型的数据的指针p指向的内容读取出来，赋值给n</p>
<p>图中虚线表示，逻辑内存对应到物理内存是不一定对应得出来的，有可能它在物理内存里面（直接取出来就可以），也可能不在物理内存里面，在虚拟内存里面。操作系统会在硬盘上开辟一个空间作为虚拟内存，虚拟内存不会把具体多少字节放过去，而是把p的分页放进去（通常几k或者几兆这样，根据操作系统配置而定）。</p>
<p>通常硬盘是比较大的，只要放得下，可以不断把内存中的东西放到硬盘上去。</p>
<p>如果想要放入物理内存但是发现物理内存不够，那么就只能用算法在物理内存里面找到一块很久没有用过的地方，用新的分页部分把它替换出来，这个过程称作是“分页”或“交换”，这个时候p就进入了物理内存里面。</p>
<p>如果在win的C盘发现有一块空间（几百兆或者几G）是不能访问的，那么这是win分配的虚拟内存的块空间。<br>在Linux中用户也是没有权限看到这块空间的，然后物理内存里面有了p的数据，我们可以把它取出来，放到寄存器里面。</p>
<p>一个运行良好的系统，绝大部分数据都是在物理内存里面的，这样能够很快。但是物理内存使用过多会造成过度分页，由于硬盘很慢，这样的话系统就会变得很慢。</p>
<h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><ul>
<li><p><strong>中断的概念</strong>：中断指处理机处理程序运行中出现的紧急事件的整个过程.程序运行过程中，系统外部、系统内部或者现行程序本身若出现紧急事件，处理机立即中止现行程序的运行，自动转入相应的处理程序(中断服务程序)，待处理完后，再返回原来的程序运行，这整个过程称为程序中断。</p>
</li>
<li><p><strong>中断的流程</strong>：改变工作模式至中断模式 -&gt; 保存现场 -&gt; 分析中断原因，跳到中断起始地址处理中断 -&gt; 返回到原来模式 -&gt; 恢复现场继续执行原来的程序。</p>
</li>
</ul>
<h1 id="操作系统问题集合"><a href="#操作系统问题集合" class="headerlink" title="操作系统问题集合"></a>操作系统问题集合</h1><h2 id="进程和线程的区别和联系？-1"><a href="#进程和线程的区别和联系？-1" class="headerlink" title="进程和线程的区别和联系？"></a>进程和线程的区别和联系？</h2><p>（1）<strong>粒度性分析</strong>：线程的粒度小于进程。</p>
<p>（2）<strong>调度性分析</strong>：进程是资源拥有的基本单位，线程是独立调度与独立运行的基本单位，出了寄存器，程序计数器等必要的资源外基本不拥有其他资源。</p>
<p>（3）<strong>系统开销分析</strong>：由于线程基本不拥有系统资源，所以在进行切换时，线程切换的开销远远小于进程。</p>
<p>两者联系：进程和线程都是操作系统所运行的程序运行的基本单元。</p>
<h2 id="简单说说寻址的过程？"><a href="#简单说说寻址的过程？" class="headerlink" title="简单说说寻址的过程？"></a>简单说说寻址的过程？</h2><p>-可以结合上述内容。</p>
<h2 id="32位操作系统和64位操作系统区别是什么？"><a href="#32位操作系统和64位操作系统区别是什么？" class="headerlink" title="32位操作系统和64位操作系统区别是什么？"></a>32位操作系统和64位操作系统区别是什么？</h2><p>-32位和64位是它们的寻址空间大小的区别，这和系统物理内存大小无关。</p>
<h2 id="说出你知道的进程间通信机制？"><a href="#说出你知道的进程间通信机制？" class="headerlink" title="说出你知道的进程间通信机制？"></a>说出你知道的进程间通信机制？</h2><p>-参考上述七种方法，最重要的是socket，最容易忽略的是“读写文件”（读文件和写文件）。</p>
<h2 id="说一下中断的概念和流程？"><a href="#说一下中断的概念和流程？" class="headerlink" title="说一下中断的概念和流程？"></a>说一下中断的概念和流程？</h2><p>参考上面内容。</p>
]]></content>
      <categories>
        <category>Interview Note</category>
      </categories>
      <tags>
        <tag>Interview</tag>
        <tag>operating system</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer Networks Interview I</title>
    <url>/2020/02/25/Computer-Networks-Interview-I/</url>
    <content><![CDATA[<blockquote>
<p>知识犹如人体的血液一样宝贵。——高士其</p>
</blockquote>
<a id="more"></a>

<p>本文内容参考一些网络文章：<a href="https://juejin.im/post/5d5414cb6fb9a06b20055e27" target="_blank" rel="noopener">Henry_Jeannie</a></p>
<h1 id="OSI七层网络协议和TCP-IP四层网络协议"><a href="#OSI七层网络协议和TCP-IP四层网络协议" class="headerlink" title="OSI七层网络协议和TCP/IP四层网络协议"></a>OSI七层网络协议和TCP/IP四层网络协议</h1><p>首先需要理解OSI七层和TCO/IP四层网络协议，这个4/7模型是网络知识的基础。</p>
<p>但是我觉得，首先，我们可以思考一下，为什么要弄得这么麻烦，这么多层去传输数据？为什么不可以在物理层就设计好呢？<br>——这个想法是合理的，但是网络的发展过程中实际上是理论基础不强的，都是解决一个一个小问题来发展的。所以这是历史发展的角度，当时为了解决这些问题才出现这个层的。虽然从理论上可能能够更好，但是当时为了解决当时的问题才出现这个层和结构的。</p>
<p>其他的，比如我们的java语言，支持泛型这一点就是在过去的基础上堆砌出来的，而不是从头设计的机制。</p>
<h2 id="OSI开放式互联参考模型-OSI七层参考模型"><a href="#OSI开放式互联参考模型-OSI七层参考模型" class="headerlink" title="OSI开放式互联参考模型(OSI七层参考模型)"></a>OSI开放式互联参考模型(OSI七层参考模型)</h2><p>OSI七层网络模型如下图所示：</p>
<p><img src="https://s2.ax1x.com/2020/02/27/3dZDTf.png" alt="3dZDTf.png"></p>
<p>整个运行的流程是先自上而下，后自下而上地处理数据头部。</p>
<p>由下往上来看：</p>
<ol>
<li>物理层：定义网络设备的标准，包括：网线类型、接口类型、传输介质的类型，将他们转化成电流强弱来进行传输，比特转换（数模和模数转换）</li>
</ol>
<ol start="2">
<li>数据链路层：传输数据的时候会产生传输的数据不完整等可能。数据链路层定义了如何格式化数据来进行传输。以及控制如何对物理介质进行访问。也提供错误检测和纠正，以确保数据传输的可靠性。这一层把比特数据转换成了“帧”，<font color=#FF0000>交换机</font>工作在这一层，并对帧进行解码。根据帧中包含的信息把数据发送到正确的接收方。</li>
</ol>
<ol start="3">
<li>网络层：这一层的协议<strong>把网络地址翻译成对应的物理地址</strong>，并决定如何将发送的数据从发送方路由到接收方。由于路由器工作在网络各段，所以<font color=#FF0000>路由器</font>工作在这一层。（关注IP协议）</li>
</ol>
<ol start="4">
<li>传输层（OSI模型中最重要的一层）：解决主机间的数据传输问题。为了保证传输体量大的数据的准确性，可能需要对数据进行切割，切割成一个一个的段落进行发送。（关注TCP和UDP协议）</li>
</ol>
<ol start="5">
<li>会话层：可以不用每次都去寻址，发送底层的包。会话层是用来建立和管理应用程序之间的通信。</li>
</ol>
<ol start="6">
<li>表示层：比如win的很多文件在linux上不能执行，vice verser, 用来解决不同操作系统之间的通信语法问题。这一层中数据将按照网络能理解的方式进行格式化，</li>
</ol>
<ol start="7">
<li>应用层：规定发送方和接收方必须使用一个固定长度的消息头，消息头也必须使用某种固定的结构。消息头必须记录消息的长度等一系列信息，以方便接收方能接受发送方所发送的数据。应用层方便用户利用网络中接收到的数据。没有这一层，你在不同电脑中传递的数据都是“1”和“0”.  这一层中要关注的是 TCP/IP中的HTTP协议</li>
</ol>
<p>需要注意，OSI不是一个标准，而是制定标准的时候使用的概念性框架。</p>
<p>记忆方法，就记开头的第一个字，更容易记住！</p>
<p>应、表、会、传、网、数、物</p>
<h2 id="OSI的实现：TCP-IP模型-TCP-IP四层参考模型"><a href="#OSI的实现：TCP-IP模型-TCP-IP四层参考模型" class="headerlink" title="OSI的实现：TCP/IP模型(TCP/IP四层参考模型)"></a>OSI的实现：TCP/IP模型(TCP/IP四层参考模型)</h2><p><img src="https://s2.ax1x.com/2020/02/27/3dKMaq.png" alt="3dKMaq.png"></p>
<h1 id="TCP传输协议"><a href="#TCP传输协议" class="headerlink" title="TCP传输协议"></a>TCP传输协议</h1><h2 id="TCP协议简介"><a href="#TCP协议简介" class="headerlink" title="TCP协议简介"></a>TCP协议简介</h2><p>TCP协议是一个基于连接的协议，在连接的基础上可以达到一个可靠的传输。怎样是可靠的传输？我们的数据包是按照顺序收到的，也就是说我发出的数据包的顺序和你收到数据包的顺序一定是一样的。</p>
<p>-此外，我们要保证我发出的包和你收到的包是一样的，是不出错的。</p>
<p>-还有其他的重要的功能，包括流量控制和拥塞控制。<br>流量控制可以保证不会发生：发送端发送数据太快，接收端来不及接收。拥塞控制指网络出现拥塞的时候，情况不会恶化。</p>
<p>TCP 链接一旦建立，就可以在链接上进行双向的通信。</p>
<p>具体细节：</p>
<ul>
<li>面向连接的、可靠的、基于字节流(不是基于报文，可以根据字节大小进行编号)的传输层通信协议</li>
<li>将应用层的数据流分割成报文段并发送给目标节点的TCP层</li>
<li>数据包都有序号，对方受到则发送ACK确认，未收到则重传</li>
</ul>
<p>TCP的报文格式：</p>
<p><img src="https://s2.ax1x.com/2020/02/27/3dLdBR.jpg" alt="3dLdBR.jpg"></p>
<p>接下来介绍TCP的三次握手和四次挥手。</p>
<p>首先，我们要用网络化的思想方法（这个网络化的思想方法是非常工程化的思想方法）。我们首先承认现实，网络是不可靠的，任何包都可能丢，我们设计TCP协议的过程中，一定要牢记这句话，因为如果不是基于这个事实，那么所有的设计其实都是过于复杂的，都是没有意义的。</p>
<p>然后，我们需要秉持工程化的思路，我们就是会不断遇到问题，然后解决问题。之后很可能再遇到新的问题，再解决这个新的问题。通过这种思想，我们会不断遇到问题，解决问题，不断迭代。通过这样做，我们得到的其实不是一个完美的协议，而是一个能用就好的东西。</p>
<p>这就是网络相关问题的现实：不断遇到问题，然后解决问题，长此以往不断迭代，迭代到能用即可。</p>
<p>这种思想不会是普适的，有些问题是需要我们通过理论上完美解决才好的，比如数据库，数据库就是通过理论去解决问题的。</p>
<h2 id="TCP三次握手和四次挥手需要用到的符号变量"><a href="#TCP三次握手和四次挥手需要用到的符号变量" class="headerlink" title="TCP三次握手和四次挥手需要用到的符号变量"></a>TCP三次握手和四次挥手需要用到的符号变量</h2><ul>
<li><strong>序列号</strong><code>seq</code>： 用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号<code>seq</code>就是这个报文段中的第一个字节的数据编号。</li>
</ul>
<ul>
<li><strong>确认号</strong><code>ack</code>： 期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。</li>
</ul>
<ul>
<li><strong>确认</strong><code>ACK</code>： 仅当<code>ACK=1</code>时，确认号字段才有效。<code>ACK=0</code>时，确认号无效</li>
</ul>
<ul>
<li><p><strong>同步</strong><code>SYN</code>： 连接建立时用于同步序号。当<code>SYN=1</code>，<code>ACK=0</code>时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得<code>SYN=1</code>，<code>ACK=1</code>。因此，<code>SYN=1</code>表示这是一个连接请求，或连接接受报文。<code>SYN</code>这个标志位只有在<code>TCP</code>建产连接时才会被置1，握手完成后<code>SYN</code>标志位被置0。</p>
</li>
<li><p><strong>终止</strong><code>FIN</code>： 用来释放一个连接。<code>FIN=1</code>表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接</p>
</li>
</ul>
<h2 id="TCP三次握手-建立连接"><a href="#TCP三次握手-建立连接" class="headerlink" title="TCP三次握手(建立连接)"></a>TCP三次握手(建立连接)</h2><p>首先需要记得，TCP的三次握手，需要用到两个类型的变量：<strong>SYN、ACK</strong>。它们的作用分别是：</p>
<ul>
<li>ACK：确认。仅当ACK=1时确认号字段才有效。当ACK=0时，确认号无效。TCP规定，在连接建立后所有的传送的报文段都必须把ACK置1.</li>
<li>FIN：终止。用来释放一个连接。当FIN=1时，表明此报文段的发送方的数据已经发送完毕，并要求释放运输连接。</li>
</ul>
<p>接下来看 TCP 建连的三次握手。TCP 是基于链接的，所以在传输数据前需要先建立链接，TCP 在传输上是双工传输，不区分 Client 端与 Server 端，为了便于理解，我们把主动发起建连请求的一端称作 Client 端，把被动建立链接的一端称作 Server 端。</p>
<p><img src="https://i.loli.net/2020/03/12/Lja9iFcHx2hubp8.jpg" alt="TCP三次握手"></p>
<p>一开始，Server端先监听端口，其初始状态是LISTEN。Client端主动打开连接，开始三次握手。</p>
<p><strong>第一次握手</strong>：客户端向服务器发出连接请求报文，这时报文首部中的同部位<code>SYN=1</code>，同时随机生成初始序列号 <code>seq=x</code>，此时，客户端进程进入了 <code>SYN-SENT</code>状态，等待服务器的确认。</p>
<p><strong>第二次握手</strong>：服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 <code>ACK=1</code>，<code>SYN=1</code>，确认号是<code>ack=x+1</code>，同时也要为自己随机初始化一个序列号 <code>seq=y</code>，此时，服务器进程进入了<code>SYN-RCVD</code>状态，询问客户端是否做好准备。；</p>
<p><strong>第三次握手</strong>：客户端进程收到确认后，还要向服务器给出确认。确认报文的<code>ACK=1</code>，<code>ack=y+1</code>，此时，连接建立，客户端进入<code>ESTABLISHED</code>状态，服务器端也进入<code>ESTABLISHED</code>状态。</p>
<p>后面双方可以进行数据传输。</p>
<p>三次握手的简化流程图为：(建连的时序是从上到下，左右两边的绿色字分别代表 Client 端与 Server 端当时的链接状态。)</p>
<p><img src="https://i.loli.net/2020/03/12/aihnWwjl18HIRtE.png" alt="TCP三次握手简化.png"></p>
<p><font color=#FF0000>在面试时需要明白三次握手是为了建立双向的链接，需要记住 Client 端和 Server 端的链接状态变化。</font></p>
<p>其他问题：</p>
<ul>
<li>首次握手时候的隐患：SYN超时——针对SYN Flood的防护措施。</li>
</ul>
<p>——<font color=#FF0000>面试回答建连的问题时，可以提到 SYN 洪水攻击发生的原因，就是 Server 端收到 Client 端的 SYN 请求后，发送了 ACK 和 SYN，但是 Client 端不进行回复，导致 Server 端大量的链接处在 SYN_RCVD 状态，进而影响其他正常请求的建连。可以设置 tcp_synack_retries = 0 加快半链接的回收速度，或者调大 tcp_max_syn_backlog 来应对少量的 SYN 洪水攻击。因为是Server端接收到了Client端的SYN包之后的回复的时候出现的问题，所以可以认为是首次握手时候产生的隐患。</font></p>
<ul>
<li>建立连接后，Client出现故障怎么办？</li>
</ul>
<p>——保活机制：1.相对方发送保活探测报文，如果未接收到相应则继续发送。2.尝试次数达到了设定的保活探测次数但是仍未收到响应的话，则中断连接。</p>
<h2 id="TCP四次挥手-终止连接"><a href="#TCP四次挥手-终止连接" class="headerlink" title="TCP四次挥手(终止连接)"></a>TCP四次挥手(终止连接)</h2><p>TCP四次挥手同样需要使用两个类型的变量：FIN和ACK。</p>
<p><img src="https://i.loli.net/2020/03/12/P76skMIGWAO3Ntv.jpg" alt="TCP四次挥手"></p>
<p>从图中看出，通信中 Client 和 Server 两端的链接都是 ESTABLISHED 状态。实际上，TCP 链接的关闭，通信双方都可以先发起，我们暂且把先发起的一方看作 Client</p>
<p><strong>第一次挥手</strong>：客户端进程发出连接释放<code>FIN</code>报文，并且停止发送数据。释放数据报文首部，<code>FIN=1</code>，其序列号为<code>seq=x</code>,此时，客户端进入<code>FIN_WAIT_1</code>（终止等待1）状态。</p>
<p><strong>第二次挥手</strong>：服务端进程收到连接释放<code>FIN</code>报文，发出确认<code>ACK</code>报文，<code>ACK=1</code>，<code>ack=x+1</code>，并且带上自己的序列号<code>seq=y</code>，此时，服务端就进入了<code>CLOSE_WAIT</code>（关闭等待）状态。此时，服务端通知高层的应用进程，客户端向服务端的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务端若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个<code>CLOSE_WAIT</code>状态持续的时间。客户端收到服务端的确认请求后，此时，客户端就进入<code>FIN_WAIT_2</code>（终止等待2）状态，等待服务器发送连接释放报文，在这之前依然可以接收服务端发送过来的最后的数据。</p>
<p><strong>第三次挥手</strong>：服务端将最后的数据发送给客户端完成后，就向客户端发送连接释放<code>FIN</code>报文，<code>FIN=1</code>，<code>ack=x+1</code>，此时的序列号为<code>seq=z</code>，此时，服务端就进入了<code>LAST-ACK</code>（最后确认）状态，等待客户端的确认。</p>
<p><strong>第四次挥手</strong>：客户端接收到服务端的连接释放<code>FIN</code>报文后，必须发出确认报文，<code>ACK=1</code>，<code>ack=z+1</code>，而自己的序列号是<code>seq=x+1</code>，此时，客户端就进入了<code>TIME_WAIT</code>（时间等待）状态。此时服务端收到客户端发送过来的确认报文，就立即撤销自己的传输控制块<code>TCB</code>,进入<code>CLOSED</code>状态，<strong>注意此时的TCP连接还没有释放，必须经过2MSL（最长报文段寿命）的时间后，客户端没有收到服务端发来的任何数据，证明服务端已正常关闭，此时客户端会撤销相应传输控制块<code>TCB</code>后，进入<code>CLOSED</code>状态</strong>。至此，TCP的连接才真正的断开了。（服务端结束TCP连接的时间要比客户端稍微早一些）</p>
<p>这里面试官比较可能会问：为什么需要等待2倍的最大报文生存时间之后Client再关闭链接？原因有两个：</p>
<ol>
<li>保证TCP协议的全双工连接能够可靠关闭；</li>
<li>保证这次连接的重复数据段从网络中消失，防止端口被重用时可能产生数据混淆。</li>
</ol>
<p>TCP四次挥手的简化图：</p>
<p><img src="https://i.loli.net/2020/03/12/jU8sIKLGTvMmpBy.png" alt="TCP四次挥手简化.png"></p>
<p>需要注意，在四次挥手的过程中，可以提到在实际应用中有可能遇到大量Socket处在TIME_WAIT或者CLOSE_WAIT状态的问题。一般开启 <code>tcp_tw_reuse</code> 和 <code>tcp_tw_recycle</code> 能够加快 TIME-WAIT 的 Sockets 回收；而大量 CLOSE_WAIT 可能是被动关闭的一方存在代码 bug，没有正确关闭链接导致的。</p>
<h2 id="TCP三次握手和四次挥手的对比总结"><a href="#TCP三次握手和四次挥手的对比总结" class="headerlink" title="TCP三次握手和四次挥手的对比总结"></a>TCP三次握手和四次挥手的对比总结</h2><p>无论是建连还是断连，都是需要在两个方向上进行，只不过建连时，Server 端的 SYN 和 ACK 合并为一次发送，而断链时，<strong>两个方向上数据发送停止的时间可能不同，所以不能合并发送 FIN 和 ACK</strong>。</p>
<h2 id="TCP要三次握手的原因"><a href="#TCP要三次握手的原因" class="headerlink" title="TCP要三次握手的原因"></a>TCP要三次握手的原因</h2><p>TCP的握手为什么要三次呢？最后一次不要了，改为两次握手，可以么？</p>
<p>假如现在客户端想向服务端进行握手，它发送了第一个连接的请求报文，但是由于网络信号差或者服务器负载过多，这个请求没有立即到达服务端，而是在某个网络节点中长时间的滞留了，以至于滞留到客户端连接释放以后的某个时间点才到达服务端，那么这就是一个失效的报文，但是服务端接收到这个失效的请求报文后，就误认为客户端又发了一次连接请求，服务端就会想向客户端发出确认的报文，表示同意建立连接。</p>
<p>假如不采用三次握手，那么只要服务端发出确认，表示新的建立就连接了。但是现在客户端并没有发出建立连接的请求，其实这个请求是失效的请求，一切都是服务端在自相情愿，因此客户端是不会理睬服务端的确认信息，也不会向服务端发送确认的请求，但是服务器却认为新的连接已经建立起来了，并一直等待客户端发来数据，这样的情况下，服务端的很多资源就没白白浪费掉了。</p>
<p>采用三次握手的办法就是为了防止上述这种情况的发生，比如就在刚才的情况下，客户端不会向服务端发出确认的请求，服务端会因为收不到确认的报文，就知道客户端并没有要建立连接，那么服务端也就不会去建立连接，这就是三次握手的作用。</p>
<p>NOTE:用更专业的内容可以说，之前发送过程中滞留的包，是”<strong>已失效的连接请求报文段</strong>“</p>
<h2 id="TCP要四次挥手的原因"><a href="#TCP要四次挥手的原因" class="headerlink" title="TCP要四次挥手的原因"></a>TCP要四次挥手的原因</h2><p>TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工 模式，这就意味着，在客户端想要断开连接时，客户端向服务端发送<code>FIN</code>报文，只是表示客户端已经没有数据要发送了，但是这个时候客户端还是可以接收来自服务端的数据。</p>
<p>当服务端接收到<code>FIN</code>报文，并返回<code>ACK</code>报文，表示服务端已经知道了客户端要断开连接，客户端已经没有数据要发送了，但是这个时候服务端可能依然有数据要传输给客户端。</p>
<p>当服务端的数据传输完之后，服务端会发送<code>FIN</code>报文给客户端，表示服务端也没有数据要传输了，服务端同意关闭连接，之后，客户端收到<code>FIN</code>报文，立即发送给客户端一个<code>ACK</code>报文，确定关闭连接。在之后，客户端和服务端彼此就愉快的断开了这次的<code>TCP</code>连接。</p>
<p>或许会有疑问，为什么服务端的<code>ACK</code>报文和<code>FIN</code>报文都是分开发送的，但是在三次握手的时候却是<code>ACK</code>报文和<code>SYN</code>报文是一起发送的，因为在三次握手的过程中，当服务端收到客户端的SYN连接请求报文后，可以直接发送<code>SYN</code>+<code>ACK</code>报文。其中<code>ACK</code>报文是用来应答的，<code>SYN</code>报文是用来同步的。但是在关闭连接时，当服务端接收到<code>FIN</code>报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个<code>ACK</code>报文，告诉客户端，你发的<code>FIN</code>报文我收到了，只有等到服务端所有的数据都发送完了，才能发送<code>FIN</code>报文，因此<code>ACK</code>报文和<code>FIN</code>报文不能一起发送。所以断开连接的时候才需要四次挥手来完成。</p>
<h1 id="UDP传输协议"><a href="#UDP传输协议" class="headerlink" title="UDP传输协议"></a>UDP传输协议</h1><h2 id="UDP报文"><a href="#UDP报文" class="headerlink" title="UDP报文"></a>UDP报文</h2><p><img src="https://s2.ax1x.com/2020/02/27/30kC5D.jpg" alt="UDP报文"></p>
<p>可以看出，UDP和TCP报文一样，都有源端口号、目的端口号等内容。</p>
<h2 id="UDP协议特点"><a href="#UDP协议特点" class="headerlink" title="UDP协议特点"></a>UDP协议特点</h2><ul>
<li>面向非连接</li>
<li>不维护连接状态，支持同时向多个客户端传输相同的消息</li>
<li>数据包报头只有8个字节，额外开销较小</li>
<li>吞吐量只受限于数据生成速率、传输速率以及机器性能</li>
<li>尽最大努力交付，不保证可靠交付，不需要维持复杂度的连接状态表</li>
<li>面向报文，不对应用程序提交的报文信息进行拆分或者合并</li>
</ul>
<h1 id="TCP和UDP的比较"><a href="#TCP和UDP的比较" class="headerlink" title="TCP和UDP的比较"></a>TCP和UDP的比较</h1><p>这个问题比较大，但是其实比较好回答，结合以下几个方面回答即可：</p>
<ul>
<li>面向连接 vs 无连接</li>
<li>可靠性</li>
<li>有序性</li>
<li>速度</li>
<li>量级</li>
</ul>
<h1 id="TCP滑动窗口"><a href="#TCP滑动窗口" class="headerlink" title="TCP滑动窗口"></a>TCP滑动窗口</h1><h2 id="TCP滑动窗口解决了什么问题"><a href="#TCP滑动窗口解决了什么问题" class="headerlink" title="TCP滑动窗口解决了什么问题"></a>TCP滑动窗口解决了什么问题</h2><p>解决的问题，最基本的就是，如果我们每发送一个包都要得到ACK，那么网络延迟很长的话会很浪费。于是我们可以采用滑动窗口，在窗口中发送过去，让它来ACK，这样可以更好地利用我们的带宽。此外，它还能做到流量控制（流控），我们可以保证两边的收发速度相对一致。</p>
<h2 id="TCP滑动窗口原理介绍"><a href="#TCP滑动窗口原理介绍" class="headerlink" title="TCP滑动窗口原理介绍"></a>TCP滑动窗口原理介绍</h2><p>TCP主要使用滑动窗口机制来实现流量控制，这个滑动窗口对于有包发送和接收顺序要求的TCP来说，非常重要。</p>
<p>首先，对于TCP，假设如果没有滑动窗口，每个包只能一个一个，按照序号发送，那么为了满足TCP这个要求，我们只能如图这么设计：</p>
<p><img src="https://s2.ax1x.com/2020/02/27/30UCo8.png" alt="使用滑动窗口前"></p>
<p>但是这个方案缺点很明显，如果1号没发成功，2号根本不能发，否则乱序了，导致吞吐量太低。</p>
<p>使用滑动窗口方案改进之后的示意图如下：</p>
<p><img src="https://s2.ax1x.com/2020/02/27/30U9df.png" alt="使用滑动窗口后"></p>
<p>但是，一次发送2个包过去，如何能够解决确认收到的问题呢？</p>
<p>这就是用到了滑动窗口了，滑动窗口是一个长度被设定好的”窗口”，举例子说明：</p>
<p><img src="https://s2.ax1x.com/2020/02/27/30dtIK.png" alt="滑动窗口1"></p>
<p>灰色是已经发送了的包。黄色和绿色都是在窗口里面的包，黄色是在窗口中已经发送但是没有收到确认的包。绿色是在窗口中同时没有发送的包。</p>
<p>过一段时间之后，情况变成下图所示：</p>
<p><img src="https://s2.ax1x.com/2020/02/27/30dUPO.png" alt="滑动窗口2"></p>
<p>新加入了没有发送的11号包，然后在这段时间内，又发送了8和9号包。</p>
<p>再往后，5发送之后，会读入12；6发送之后，会再读入13，以此类推。</p>
<p>再来看看丢包的情况：我这个包发送过去对方发了ACK，但是我没收到。或者我这个包根本就没法送出去。总之，从发送方角度来看，就是我没有收到ACK。</p>
<p>而做法就是，我如果等了一段时间，没有收到ACK，我会把10和11号包也都发送掉。</p>
<p><img src="https://s2.ax1x.com/2020/02/27/30dYa6.png" alt="滑动窗口3"></p>
<p>但是此时我的窗口已经发满了，不能再读入12，我就只能等到ACK的接收。</p>
<p>如果我始终得不到，就会激发超时重传。</p>
<p>需要注意，ACK的按照顺序的ACK，对方一定会等到5号包出现才会发送ACK，哪怕先收到了6号，7号的包，在TCP协议下，对方也不会发送ACK</p>
<p>如此一来，我们就能保证滑动窗口发送和接收的顺序。</p>
<p>此时可能发生：</p>
<p><img src="https://s2.ax1x.com/2020/02/27/30dJVx.png" alt="滑动窗口4"></p>
<p>此时是之前6，7和8都已经收到了，并且对方想要发送ACK，但是无奈5号包没有收到。此时在我们这边发送了5号包过去，对方收到了之后，会把5,6,7，8一起发送过来，并且 新把12,13,14,15加入到窗口中。</p>
<p>窗口协议的概念整体就是这样的，书上写得比较复杂，但是从工程学角度还是很好理解的。</p>
<p>我们为了优化TCP四次握手的吞吐量问题，我们把数据包一起发送，此时会有窗口的问题产生，我们为了更加有效运用吞吐量，我们使用滑动窗口这个数据结构来解决。这个其实是很朴素的想法。</p>
<p>油管上搬运来的TCP滑动窗口的实现示意动画： <a href="https://www.bilibili.com/video/av71309262?from=search&seid=14837245094414199121" target="_blank" rel="noopener">点击此处</a></p>
<h2 id="TCP滑动窗口具体变量和计算过程"><a href="#TCP滑动窗口具体变量和计算过程" class="headerlink" title="TCP滑动窗口具体变量和计算过程"></a>TCP滑动窗口具体变量和计算过程</h2><p>首先，滑动窗口有两个计算的变量：RTT和RTO</p>
<ul>
<li>RTT：发送一个数据包到收到对应的ACK所花费的时间。<font color=#FF0000>就是发送数据到接收到ACK的时间差</font></li>
<li>RTO：重传时间间隔。<font color=#FF0000>通过RTT计算得到。设置一个RTO作为间隔时间，超过了RTO就重传，没超过RTO就等待ACK</font></li>
</ul>
<p>相关计算公式和示意图：</p>
<p><img src="https://s2.ax1x.com/2020/02/27/30BxyQ.png" alt="窗口数据的计算和示意图1"></p>
<p><img src="https://s2.ax1x.com/2020/02/27/30BvQg.png" alt="窗口数据的计算和示意图2"></p>
<p><img src="https://s2.ax1x.com/2020/02/27/30BjSS.png" alt="窗口数据的计算和示意图3"></p>
<p><font color=#FF0000>需要注意，TCP的滑动窗口大小可以为0.当然这是一种特殊情况，如果接收方正在忙，可以先让滑动窗口的大小为0，等到后面再重新调整。</font></p>
<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>HTTP全名为<strong>“超文本传输协议”</strong>，支持客户/服务器模式，即Client发送请求给Server，Server发送响应回去。大部分目前都是基于HTTP1.1的。</p>
<h2 id="HTTP的请求结构"><a href="#HTTP的请求结构" class="headerlink" title="HTTP的请求结构"></a>HTTP的请求结构</h2><p>请求报文如下图所示：</p>
<p><img src="https://s2.ax1x.com/2020/02/28/30H6jH.png" alt="HTTP请求报文"></p>
<p>举一个用Wireshark抓HTTP请求报文的例子：</p>
<p><img src="https://s2.ax1x.com/2020/02/28/30Hgud.png" alt="HTTP请求抓包实例"></p>
<h2 id="HTTP的响应结构"><a href="#HTTP的响应结构" class="headerlink" title="HTTP的响应结构"></a>HTTP的响应结构</h2><p>响应报文如下图所示：</p>
<p><img src="https://s2.ax1x.com/2020/02/28/30Hs3D.png" alt="HTTP响应报文"></p>
<p>举一个用Wireshark抓HTTP响应报文的例子：</p>
<p><img src="https://s2.ax1x.com/2020/02/28/30Hyge.png" alt="HTTP请求抓包实例"></p>
<h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><p>一共有五种取值可能：</p>
<ul>
<li>1xx：指示信息——表示请求已经接收，继续处理，<font color=#FF0000>但是整个请求还没成功</font></li>
<li>2xx：成功——表示请求已被成功接收、理解、接受，已经成功处理了请求的状态代码</li>
<li>3xx：重定向——要完成请求，但是需要进一步操作(往往要再跳转一步)</li>
<li>4xx：客户端错误——请求有语法错误或请求无法实现</li>
<li>5xx：服务器错误——服务器未能实现合法的请求，表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求的错误。</li>
</ul>
<p>常见HTTP状态码及其作用：</p>
<p>200 OK：正常返回信息</p>
<p>400 Bad Request：客户端请求有语法错误，不能被服务器所理解</p>
<p>401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用</p>
<p>403 Forbidden：服务器收到请求，但拒绝提供服务(比如IP被禁了)</p>
<p>404 Note Found：请求资源不存在，eg.输入了错误的URL</p>
<p>500 Internal Server Error：服务器发生不可预期的错误</p>
<p>503 Server Unabaliable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常</p>
<h2 id="GET请求和POST请求的区别"><a href="#GET请求和POST请求的区别" class="headerlink" title="GET请求和POST请求的区别"></a>GET请求和POST请求的区别</h2><p>可以从三个层面解释：</p>
<ul>
<li>HTTP报文层面：GET将请求信息放在URL中，POST放在报文体中。</li>
<li>数据库层面：GET符合<strong>幂等性 <em>(对数据库的多次操作效果一样，PUT也是幂等的)</em></strong>和<strong>安全性 <em>(操作不会改变数据库中的数据)</em></strong>，POST不符合。</li>
<li>其他层面：GET可以被缓存、被存储，而POST不行</li>
</ul>
<h2 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h2><h3 id="Cookie简介"><a href="#Cookie简介" class="headerlink" title="Cookie简介"></a>Cookie简介</h3><p>举一个使用Cookie的最简单的例子：登录某个网站后，勾选了同意记录信息只有，客户端发送HTTP响应的同时也会发送客户端的信息，下次再登录就可以通过记忆，不用再输入密码了。</p>
<ul>
<li>Cookie由服务器发送给客户端的特殊信息，以文本的形式存放在客户端</li>
<li>客户端再次请求的时候，会把Cookie回发</li>
<li>服务器接收到后，会解析Cookie生成与客户端相对应的内容</li>
</ul>
<h3 id="Cookie实现方式"><a href="#Cookie实现方式" class="headerlink" title="Cookie实现方式"></a>Cookie实现方式</h3><p>示意图如下：</p>
<p><img src="https://s2.ax1x.com/2020/02/28/3BJhXq.png" alt="Cookie实现示意图"></p>
<h3 id="Session简介"><a href="#Session简介" class="headerlink" title="Session简介"></a>Session简介</h3><ul>
<li>服务器端的机制，在服务器上保存的信息</li>
<li>解析客户端请求并操作session id，按需保存状态信息</li>
</ul>
<h3 id="Session实现方式"><a href="#Session实现方式" class="headerlink" title="Session实现方式"></a>Session实现方式</h3><p>如下图：</p>
<p><img src="https://s2.ax1x.com/2020/02/28/3BJIBV.png" alt="3BJIBV.png"></p>
<p>实际上，Session有两种实现方式：</p>
<ul>
<li>使用Cookie实现</li>
<li>使用URL回写实现</li>
</ul>
<p>TOMCAT一开始同时支持Cookie和URL回写两种方式，之后如果发现浏览器支持Cookie，就停止URL回写。</p>
<h3 id="Cookie和Session的区别"><a href="#Cookie和Session的区别" class="headerlink" title="Cookie和Session的区别"></a>Cookie和Session的区别</h3><ul>
<li>Cookie数据存放在客户端的浏览器上，Session数据放在服务器上</li>
<li>Session相对于Cookie更安全(<font color=#FF0000>Session保存在服务器端，更安全，但是占用服务器的资源</font>)</li>
<li>若考虑减轻服务器负担，应当使用Cookie</li>
</ul>
<h1 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h1><p>简而言之，HTTPS是更加安全版本的HTTP，多了一层SSL或TLS。</p>
<p>HTTP和HTTPS结构图如下所示：</p>
<p><img src="https://s2.ax1x.com/2020/02/28/3BwxRU.png" alt="HTTP和HTTPS结构"></p>
<h2 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h2><p><strong>SSL(Security Sockets Layer,安全套阶层)</strong></p>
<ul>
<li>为网络通信提供安全及数据完整性的一种安全协议</li>
<li>操作系统对外的API，SSL3.0后更名为TLS</li>
<li>采用身份验证和数据加密保证网络通信的安全和数据的完整性</li>
</ul>
<h2 id="加密方式"><a href="#加密方式" class="headerlink" title="加密方式"></a>加密方式</h2><ul>
<li>对称加密：加密和解密都使用同一个秘钥</li>
<li>非对称加密(区块链常用)：加密使用的秘钥和解密使用的秘钥是不相同的</li>
<li>哈希算法(常用MD5)：将任意长度的信息转换为固定长度的值，算法不可逆</li>
<li>数字签名：证明某个消息或者文件是某人发出/认同的</li>
</ul>
<h2 id="HTTPS数据传输流程"><a href="#HTTPS数据传输流程" class="headerlink" title="HTTPS数据传输流程"></a>HTTPS数据传输流程</h2><ul>
<li>浏览器将支持的加密算法信息发送给服务器</li>
<li>服务器选择一套浏览器支持的加密算法，以证书的形式回发给浏览器</li>
<li>浏览器验证证书合法性，并验证证书公钥加密信息发送给服务器</li>
<li>服务器使用私钥解密信息，验证哈希，加密响应消息回发浏览器</li>
<li>浏览器解密响应信息，并对消息进行验真，之后进行加密交互数据</li>
</ul>
<h2 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h2><ul>
<li>HTTPS需要到CA申请证书，HTTP不需要</li>
<li>HTTPS密文传输，HTTP明文传输</li>
<li>连接方式不同，HTTPS默认使用443端口，HTTP默认使用80端口</li>
<li>HTTPS=HTTP+加密+认证+完整性保护，比HTTP更安全</li>
</ul>
<h2 id="HTTPS真的很安全么"><a href="#HTTPS真的很安全么" class="headerlink" title="HTTPS真的很安全么"></a>HTTPS真的很安全么</h2><p>也不能肯定，很多浏览器默认会填充http://，网页需要从HTTP跳转到HTTPS，这个过程有被劫持的风险</p>
<p>可以使用HSTS(HTTP Strict Transport Security)进行优化</p>
<h1 id="常见题：在浏览器输入URL，按下回车之后经历的流程"><a href="#常见题：在浏览器输入URL，按下回车之后经历的流程" class="headerlink" title="常见题：在浏览器输入URL，按下回车之后经历的流程"></a>常见题：在浏览器输入URL，按下回车之后经历的流程</h1><p>答案：<font color=#FF0000>一共有六步</font></p>
<ol>
<li>DNS解析。——<font color=#FF0000>浏览器进行DNS解析</font></li>
<li>TCP连接。——<font color=#FF0000>浏览器向服务器发送TCP连接，过程参考TCP三次握手</font></li>
<li>发送HTTP请求——<font color=#FF0000>浏览器向服务器发送HTTP请求，内容参考前面HTTP请求包结构</font></li>
<li>服务器处理请求并返回HTTP报文——<font color=#FF0000>服务器返回HTTP报文，结构参考前面HTTP响应包结构</font></li>
<li>浏览器解析渲染页面</li>
<li>连接结束——<font color=#FF0000>参考TCP四次挥手</font></li>
</ol>
<p><strong>需要注意，这里的第五步和第六步几乎是同时进行的。</strong></p>
<p>DNS缓存由近到远分别是：浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存根，域名服务器缓存，顶级域名服务器缓存，过程中从哪个缓存中找到了对应的服务器IP，就直接返回，不再继续查询后面的缓存。</p>
]]></content>
      <categories>
        <category>Interview Note</category>
      </categories>
      <tags>
        <tag>Interview</tag>
        <tag>Networks</tag>
      </tags>
  </entry>
  <entry>
    <title>Java JVM Study I</title>
    <url>/2020/02/25/Java-JVM-Study-I/</url>
    <content><![CDATA[<blockquote>
<p>知识犹如人体的血液一样宝贵。——高士其</p>
</blockquote>
<a id="more"></a>

<p>每种语言都有其独特的优势和特点。对于Java来说，其独特之处主要可以从六个方面来说：</p>
<ul>
<li>平台无关性</li>
<li>面向对象</li>
<li>GC(垃圾回收)</li>
<li>类库</li>
<li>语言特性和异常处理</li>
</ul>
<p>而Java的JVM最值得学习的点，是：<font color=#FF0000>JVM内存结构模型和GC</font></p>
<h1 id="Java的平台无关性如何实现"><a href="#Java的平台无关性如何实现" class="headerlink" title="Java的平台无关性如何实现"></a>Java的平台无关性如何实现</h1><p>平台无关性，实际上就是java代码”编译一次，到处执行”这个特点的简称。</p>
<p><img src="https://s2.ax1x.com/2020/02/28/3DqNYq.png" alt="3DqNYq.png"></p>
<p>可以说，生成”.class”文件，是java跨平台的基础。</p>
<p><strong>为什么JVM不把java解析成机器码然后执行呢？</strong></p>
<p>主要是两个原因，一个是如果解析成机器码，需要大量准备工作，每次执行都需要根据机器的内部构造去设定值。另一个原因是，解析成class文件，可以让JVM虚拟机发挥更大的作用，比如Scala语言也可以通过解析成class文件来通过JVM虚拟机运行。</p>
<h1 id="JVM如何加载class文件"><a href="#JVM如何加载class文件" class="headerlink" title="JVM如何加载class文件"></a>JVM如何加载class文件</h1><p>Java是跨平台的，这意味着 Java 开发出来的程序经过编译后，可以在 Linux 上运行，也可以在 Windows 上运行；可以在 PC、服务器上运行，也可以在手机上运行；可以在 X86 的 CPU 上运行，也可以在 ARM 的 CPU 上运行。</p>
<p>不同操作系统，特别是不同 CPU 架构，是不可能执行相同的指令的。Java之所以拥有能够在不同平台运行的神奇特性，就是因为 Java 编译的字节码文件不是直接在底层的系统平台上运行的，而是在 Java 虚拟机 JVM 上运行，JVM 屏蔽了底层系统的不同，为 Java 字节码文件构造了一个统一的运行环境。JVM 本质上也是一个应用程序，启动以后加载执行 Java 字节码文件。</p>
<p>JVM的是内存中的虚拟机。</p>
<p>JVM的详细的内存结构模型如图：</p>
<p><img src="https://s2.ax1x.com/2020/03/04/3503A1.jpg" alt="JVM详细内存结构模型"></p>
<p>只要符合class Loader的格式要求就能加载。</p>
<p>因为java执行效率不如C和C++，有时候需要用Native Interface去调用别的语言的库。</p>
<p><code>Class.forName()</code>作用：返回与给定字符串名称相关联的类或者接口对应的class对象。</p>
<h2 id="类从编译到执行的过程"><a href="#类从编译到执行的过程" class="headerlink" title="类从编译到执行的过程"></a>类从编译到执行的过程</h2><ul>
<li>编译器将**.java源文件编译为.class字节码文件</li>
<li>ClassLoader将字节码转化为JVM的Class对象</li>
<li>JVM利用Class对象实例化Robot对象</li>
</ul>
<p>对上图进行简化之后可以得到：</p>
<p><img src="https://s2.ax1x.com/2020/03/04/3508tx.png" alt="JVM简化内存结构模型"></p>
<h1 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h1><p>理论上来说：</p>
<p><strong>Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为Java语言的反射机制。</strong></p>
<p>但是这里回答比较理论，最好可以列举几个常用的反射函数，或者写反射的例子。</p>
<p>重要的部分：Class、Class.forName、newInstance()、Method、getDeclareMethod、setAccessible()、invoke()</p>
<p>NOTE:</p>
<ul>
<li>“getDeclardeMethod”可以获取public, private, protected的方法，但是不能获取继承的方法和实现接口的方法</li>
<li>“getMethod”可以获取public方法，此外还可以获取继承的方法和实现接口的方法</li>
<li>反射就是把java中的各种成分映射成java对象，比如这里映射成了class,filed,method</li>
</ul>
<h1 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h1><h2 id="类从编译到执行的过程-1"><a href="#类从编译到执行的过程-1" class="headerlink" title="类从编译到执行的过程"></a>类从编译到执行的过程</h2><p>以Robot.java这个源文件的执行流程举例：</p>
<ul>
<li>编译器将Robot.java源文件编译为Robot.class字节码文件</li>
<li>ClassLoader将字节码转换为JVM中的Class<Robot>对象</li>
<li>JVM利用Class<Robot>对象实例化为Robot对象</li>
</ul>
<h2 id="谈谈ClassLoader"><a href="#谈谈ClassLoader" class="headerlink" title="谈谈ClassLoader"></a>谈谈ClassLoader</h2><p>ClassLoader在Java中有着非常重要的作用，他主要工作在Class装载的加载阶段，它的主要作用是从系统外部获得Class二进制数据流。它是Java的核心组件，<strong>所有Class都将由ClassLoader进行加载，ClassLoader负责通过将Class文件里的二进制数据流装载进系统，然后交给Java虚拟机进行连接、初始化等操作。</strong></p>
<p>ClassLoader是一个抽象类(abstract class)。</p>
<ul>
<li>BootStrapClassLoader：C++编写，加载核心库java.*</li>
<li>ExtClassLoader：Java编写，加载扩展库javax.*</li>
<li>AppClassLoader：Java编写，加载程序所在目录，类路径</li>
<li>自定义ClassLoader：Java编写，定制化加载</li>
</ul>
<p>回答流程：ClassLoader的作用 -&gt; 本质 -&gt; 种类</p>
<h1 id="类加载器-ClassLoader-的双亲委派机制"><a href="#类加载器-ClassLoader-的双亲委派机制" class="headerlink" title="类加载器(ClassLoader)的双亲委派机制"></a>类加载器(ClassLoader)的双亲委派机制</h1><p>首先需要明确，不同的ClassLoader加载类的方式和路径有所不同，为了提高效率，各自有各自的分工，各自有各自负责的区块，使得逻辑更加明确，我们才能够有各种能够相互共存的ClassLoader。</p>
<p>实际上不同的ClassLoader在执行任务的时候都是各司其职，所谓我们需要一个机制，让各种类加载器之间能够相互协作，形成一个整体，这个机制就是双亲委派机制。</p>
<p>整体原理如图：</p>
<p><img src="https://s2.ax1x.com/2020/03/04/3ISDZ8.png" alt="3ISDZ8.png"></p>
<ol>
<li>自底向上检查类是否已经加载</li>
<li>自顶向下尝试加载类</li>
</ol>
<h2 id="为什么要用双亲委派机制去加载类？"><a href="#为什么要用双亲委派机制去加载类？" class="headerlink" title="为什么要用双亲委派机制去加载类？"></a>为什么要用双亲委派机制去加载类？</h2><p>双亲委派机制能避免多份同样字节码的加载。</p>
<p>比如常用的System.out.println()，我们其实只需要一个System的静态class，而且只需要一份，然后反复用即可。如果不用委托的方式，类A用的时候要加载一次，类B再用的时候又要再加载一份System字节码。这样内存中就会存在多份System字节码。相反如果用了委托机制，每次使用的时候都会由下往上逐层查找，看哪一个ClassLoader装载过这个类。对于System类来说，因为它是属于Bootstrap ClassLoader管辖范围内的，假设A是第一次调用，那么这时候会用Bootstrap ClassLoader将System类装载进去。在B调用的时候，也会逐层查找。查找过程会发现之前已经被Bootstrap加载过了，就会直接拿过来用即可了。</p>
<h1 id="loadClass和forName的区别"><a href="#loadClass和forName的区别" class="headerlink" title="loadClass和forName的区别"></a>loadClass和forName的区别</h1><h2 id="类的加载方式"><a href="#类的加载方式" class="headerlink" title="类的加载方式"></a>类的加载方式</h2><ul>
<li>隐式加载：new，这种方法比较常用。程序运行过程中通过new定义对象的时候，隐式调用类加载器，加载对应的类到JVM中。使用了new之后不再需要调用class对象的newInstance()方法再去获得对象的实例了。</li>
<li>显示加载：loadClass、forName等。对于显示加载来说，在我们获取到了class对象之后，需要调用class对象的newInstance()方法来生成对象的实例。</li>
</ul>
<p>此外，new支持调用带参数的构造器来生成对象实例。而class对象的newInstance()方法则不支持传入参数，需要反射，调用构造器的newInstance()方法才能支持参数。</p>
<h2 id="类的装载过程"><a href="#类的装载过程" class="headerlink" title="类的装载过程"></a>类的装载过程</h2><p>之前我们说的类的装载和加载都是一个意思(都是表示加载)。但是这里为了区分，我们用<strong>装载</strong>表示class对象的生成过程，<strong>加载只是其中的一个部分</strong>。</p>
<p>Java类装载有三个部分：</p>
<p><img src="https://s2.ax1x.com/2020/03/04/3ImatI.png" alt="Java类装载过程"></p>
<h2 id="loadClass和forName的区别-1"><a href="#loadClass和forName的区别-1" class="headerlink" title="loadClass和forName的区别"></a>loadClass和forName的区别</h2><p>这两个方法俩都是显示加载。</p>
<p>首先，他们俩都能在运行的时候知道某个类的所有属性和方法。</p>
<p>但是他俩存在区别：</p>
<ul>
<li>Class.forName得到的class是已经初始化完成的</li>
<li>Classloader.loadClass得到的class是还没有链接的，还没有初始化的。</li>
</ul>
<p>loadClass和forName的区别在实际中的作用：比如我们要在程序中连接MySQL，这个时候需要加载driver。此时我们就不能用loadClass而必须用forName。</p>
<p>为什么呢？因为MySQL的jar包里面的代码，Driver初始化是写在static代码块里的，所以必须调用forName才能执行它，进而实例化Driver对象，创建数据库驱动。</p>
<p>那么什么时候要用到loadClass呢？——Spring IOC中，在资源加载器获取要读入的资源的时候，其读取一些bean的配置文件的时候，如果以classpath的方式加载，就需要使用classLoader.loadClass来加载了。因为Spring IOC大量使用了延时加载，也就是懒加载。为了加快加载速度，Spring IOC大量使用了延时加载技术，而使用classLoader不需要执行类的初始化代码和链接步骤，这样可以加快类的初始化速度，把类的初始化工作留到实际使用这个类的时候再去做。</p>
<h1 id="Java内存模型-Java-Memory-Model"><a href="#Java内存模型-Java-Memory-Model" class="headerlink" title="Java内存模型(Java Memory Model)"></a>Java内存模型(Java Memory Model)</h1><p>Java内存模型具体指的实际就是上面的”Runtime Data Area”,或者叫”运行期数据区”</p>
<h2 id="内存简介"><a href="#内存简介" class="headerlink" title="内存简介"></a>内存简介</h2><p>计算机所有程序都是在内存中运行的，只是这个”内存”包括虚拟内存，也包括”硬盘”这样的外存支持。</p>
<p>在程序运行的过程中，需要不断将内存的逻辑地址和物理地址进行映射，找到相关的指令和数据去执行。</p>
<p><img src="https://s2.ax1x.com/2020/03/04/3IR6AO.png" alt="内存简介"></p>
<h2 id="地址空间的划分"><a href="#地址空间的划分" class="headerlink" title="地址空间的划分"></a>地址空间的划分</h2><p>内核是主要的操作系统程序与C运行时的空间，包含用于连接计算机硬件，调度程序与提供联网和虚拟内存服务的逻辑和基于C的进程。</p>
<p>用户空间才是Java进程实际运行时使用的内存空间。</p>
<p>如图：</p>
<p><img src="https://s2.ax1x.com/2020/03/04/3IRg4e.png" alt="3IRg4e.png"></p>
<p>32位系统进程最多可以访问3GB，内核代码可以访问所有物理内存。64位系统进程最多可以访问512GB，内核代码同样可以访问所有物理内存。</p>
<h2 id="线程独占部分"><a href="#线程独占部分" class="headerlink" title="线程独占部分"></a>线程独占部分</h2><p>哪些是线程独占的，哪些部分又是线程共享的呢？</p>
<p>以JDK8为例进行分析(JDK其他版本也有类似之处)。</p>
<p><img src="https://s2.ax1x.com/2020/03/04/3I5ko6.png" alt="JDK8内存模型"></p>
<p>下面对每一块线程独占的部分都进行介绍：</p>
<h3 id="程序计数器-Program-Counter-Register-即PC"><a href="#程序计数器-Program-Counter-Register-即PC" class="headerlink" title="程序计数器(Program Counter Register,即PC)"></a>程序计数器(Program Counter Register,即PC)</h3><ol>
<li><p>它是一块较小的内存空间，它可以看做是<strong>当前线程所执行的字节码行号指示器(逻辑)</strong>。</p>
</li>
<li><p>在虚拟机的概念模型里，字节码解释器工作时，通过改变计数器的值来选取下一条需要执行的字节码指令。包括分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成。</p>
</li>
<li><p>由于JVM的多线程是通过线程之间的来回切换，并且分配处理器执行时间的方式来实现的，所以在任何一个确定的时刻，一个处理器只会执行一条线程中的指令。因此，为了确保线程在切换后能回到正确的位置，每条线程都需要有一个独立的程序计数器，并且各条线程之间的计数器互不影响，独立存储。我们称这样的内存为”线程私有”的内存，这个计数器的值也和线程之间是一对一的关系。</p>
</li>
<li><p>如果一个线程正在执行Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址，那么如果正在执行的是Native方法，则计数器值会为<code>&quot;Undefined&quot;</code></p>
</li>
<li><p>此外，由于只是记录行号，程序计数器不会存暴掉，即程序计数器不会存在内存泄漏的问题。</p>
</li>
</ol>
<p>小总结：<strong>程序计数器是逻辑计数器，而不是物理计数器。为了线程切换后都能回到正确的执行位置，每个线程都有一个独立的程序计数器，它是线程独立的，并且只为Java方法计数。Native方法对应的程序计数器则是Undefined。使用程序计数器，不用担心会发生内存泄漏的问题。</strong></p>
<ul>
<li>当前线程所执行的字节码行号指示器</li>
<li>改变计数器的值来选取下一条需要执行的字节码指令</li>
<li>和线程一一对应</li>
<li>只对Java方法计数，如果是Native方法则计数器值为Undefined</li>
<li>不会发生内存泄漏</li>
</ul>
<h3 id="Java虚拟机栈-Stack"><a href="#Java虚拟机栈-Stack" class="headerlink" title="Java虚拟机栈(Stack)"></a>Java虚拟机栈(Stack)</h3><p>Java虚拟机栈也是线程私有的，是Java方法执行的内存模型。每个方法被执行的时候都会创建一个栈帧，结构如下图：</p>
<p><img src="https://s2.ax1x.com/2020/03/04/3IqmNR.png" alt="3IqmNR.png"></p>
<p>图中的局部变量表和操作数栈有什么区别？</p>
<ul>
<li>局部变量表：包含方法执行过程中的所有变量，包含this引用、所有方法参数，其他局部变量(包括布尔值、Byte、char、long、short、int、float、double等等类型)</li>
<li>操作数栈：在执行字节码指令过程中被用到，这种方式类似原生CPU寄存器。大部分JVM字节码把时间花费在操作数栈的操作上，包括入栈、出栈、复制、交换、产生消费变量</li>
</ul>
<p>栈本身是一个后进先出的数据结构。因此当前执行的方法在栈的顶部，每次方法调用时一个新的栈帧创建，并压入栈顶。当方法正常返回或抛出未捕获的异常时，栈帧就会出栈。除了栈帧的压栈和出栈，栈不能被直接操作。</p>
<p>解读Java可能出现的异常</p>
<p><strong>java.lang.StackOverflowError</strong></p>
<p>递归为什么会引发java.lang.StackOverflowError异常？</p>
<p>递归执行次数过多，栈帧过高。每次调用递归，都会创建一个对应的栈帧，并把建立的栈帧压入虚拟机栈中。</p>
<ol>
<li>如果递归层数过高，不断调用自身，每新调用一次方法，就会生成一个栈帧。</li>
<li>它会保存当前方法的栈帧状态</li>
<li>栈帧上下文切换的时候会切换到最新的方法栈帧当中</li>
</ol>
<p>如果递归调用过多，则会产生过多的栈帧，栈帧超过虚拟栈深度限制，就会报错。</p>
<p>解决的方法主要是限制递归的次数，或者可以直接用循环替换递归。</p>
<p><strong>java.lang.OutOfMemoryError</strong></p>
<p>虚拟机栈过多会引发java.lang.OutOfMemoryError异常。当虚拟机栈可以动态扩展时，如果无法申请足够多的内存，就会抛出这个异常。</p>
<p>如果虚拟机栈可以动态扩展，并超出内存，就会报这个错误。</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><ul>
<li>与虚拟机栈类似，主要作用于标注了native的方法</li>
</ul>
<p>带有native关键字的方法，比如之前的forName0()之类的方法，用的是本地方法栈。</p>
<h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>虚拟机栈是Java虚拟机自动管理的。栈类似一个集合，但是有容量限制，由多个栈帧组合而成。编写代码的时候，每调用一个方法，Java虚拟机就为其分配一块空间，就增加一层栈帧。<font color=#FF0000>而当方法调用结束后，对应的栈帧就会被自动释放掉。这就是为什么栈不需要GC，但是堆需要</font>。</p>
<h2 id="线程共享部分"><a href="#线程共享部分" class="headerlink" title="线程共享部分"></a>线程共享部分</h2><p>从之前”JDK8内存模型”这张图中可以看到，JVM里线程共享的主要是两个部分：MataSpace和Java堆</p>
<h3 id="元空间-MetaSpace-与永久代-PermGen-的区别"><a href="#元空间-MetaSpace-与永久代-PermGen-的区别" class="headerlink" title="元空间(MetaSpace)与永久代(PermGen)的区别"></a>元空间(MetaSpace)与永久代(PermGen)的区别</h3><p>JDK8之后，MetaSpace开始把类的元数据放在本地堆内存中，这段区域在JDK7以及以前，都是属于永久代的。</p>
<p>元空间和永久代都用来存储class的相关信息，包括class对象的方法和filed等。</p>
<p>元空间永久代都是方法区的实现，实现方法不同。方法区只是一种JVM的规范。</p>
<p>Java7之后，把原先位于方法区的字符串常量池移动到了Java堆中，并且在JDK8之后，使用源空间替代了永久代。</p>
<p>这一替代不仅是名字上的替代，两者最大的区别是：<strong>元空间使用本地内存，而永久代使用的是JVM的内存</strong>。这样设置的一个好处就是解决了内存不足的问题，<code>java.lang.OutOfMemoryError:PemGen space</code>这个错误将不复存在。因为此时MetaSpace的大小取决于本地内存的大小。本地内存有多大，MetaSpace就有多大。当然，实际运行的时候不可能放任MetaSpace的壮大，JVM在运行的时候会根据需要动态地设置其大小。</p>
<p><strong>MetaSpace相比PermGen的优势</strong></p>
<ul>
<li>字符串常量池存在永久代中，容易出现性能问题和内存溢出</li>
<li>永久代类和方法的信息大小难以确定，给永久代的大小指定带来困难</li>
<li>永久代会为GC带来不必要的复杂性，而且回收效率可能较低</li>
<li>用元空间方便HotSpot与其他JVM如Jrockit的集成</li>
</ul>
<p><font color=#FF0000>重点记住：元空间和永久代的主要区别，是前者内存空间主要使用的是本机内存。</font>MetaSpace没有了字符串常量池，它在JDK7中已经被移动到了堆中。MetaSpace其他存储的东西，包括类文件，在JVM运行时候的数据结构，以及class相关的内容，如method,filed，大体上都与永久代一样，只是划分上更加合理。比如类元素的生命周期与类加载器一致，每个类加载器(classLoader)都会分配一个单独的存储空间。</p>
<h3 id="Java堆-Heap"><a href="#Java堆-Heap" class="headerlink" title="Java堆(Heap)"></a>Java堆(Heap)</h3><p>对于大多数应用来说，Java堆是Java虚拟机所管理的内存中最大的一块。Java堆是被所有内存共享的一块内存区域。在虚拟机启动时创建此内存区域的唯一目的，就是存放对象实例，几乎所有的对象实例都在这里分配内存。</p>
<p>以一个32位处理器的Java内存布局为例：</p>
<p><img src="https://s2.ax1x.com/2020/03/05/3TNVFx.png" alt="32位处理器的Java内存布局"></p>
<p>可以看到，Java堆会占用非常大的一块内存。</p>
<p>此外，Java堆是垃圾收集器管理的主要区域，因此很多时候也被称为GC堆。</p>
<p>如果从内存回收的角度看，由于现在的收集器基本都采用分代收集的算法，所以Java堆中还可以细分为新生代和老年代。</p>
<p>可以参见下图：</p>
<p><img src="https://s2.ax1x.com/2020/03/05/3TNefK.png" alt="GC堆"></p>
<h1 id="Java内存模型常考题解析"><a href="#Java内存模型常考题解析" class="headerlink" title="Java内存模型常考题解析"></a>Java内存模型常考题解析</h1><h2 id="JVM三大性能条有参数：-Xms-Xmx-Xss的含义"><a href="#JVM三大性能条有参数：-Xms-Xmx-Xss的含义" class="headerlink" title="JVM三大性能条有参数：-Xms -Xmx -Xss的含义"></a>JVM三大性能条有参数：-Xms -Xmx -Xss的含义</h2><p>在调用java指令执行程序的时候，我们可以使用这三个参数去调整Java堆和线程所占内存的大小。它们的作用分别是：</p>
<ul>
<li>-Xss：规定了每个线程虚拟机栈(堆栈)的大小</li>
<li>-Xms：堆的初始值</li>
<li>-Xmx：堆能达到的最大值</li>
</ul>
<p>-Xss一般来说256K就够了，此配置会影响此进程中并发线程数的大小。</p>
<p>-Xms为初始的Java堆的大小，即该进程刚创建出来的时候它的专属Java堆的大小。一旦对象容量超过了Java堆的初始容量，Java堆会自动扩容，扩容至-Xmx的大小。</p>
<p>在很多情况下，我们通常将-Xms和-Xmx设置成一样大，因为当Heap不够用而发生扩容时，会发生内存抖动，影响程序运行时的稳定性。</p>
<p>当程序运行比较慢，或者频繁报出内存方面的错误的时候，可以试着从这三个参数入手，尝试调整堆和线程的大小，以求程序性能可以达到要求，但是在程序性能还能满足要求的时候没必要调整。</p>
<h2 id="Java内存模型中堆和栈的区别——内存分配策略"><a href="#Java内存模型中堆和栈的区别——内存分配策略" class="headerlink" title="Java内存模型中堆和栈的区别——内存分配策略"></a>Java内存模型中堆和栈的区别——内存分配策略</h2><ul>
<li>静态存储：编译时确定每个数组目标在运行时的存储空间需求。这种方式不允许程序中有可变数据结构的存在，也不允许有递归和嵌套的结构出现，因为它们都会导致编译程序无法计算准确的存储空间。</li>
<li>栈式存储：数据区需求在编译时未知，运行时模块入口前确定。这种方式也可以被称为动态的存储方式。分配过程和栈一样，先进后出的方式。</li>
<li>堆式存储：编译时或运行时模块入口都无法确定，动态分配。比如可变长度串和对象实例。</li>
</ul>
<h2 id="Java内存模型中堆和栈的区别"><a href="#Java内存模型中堆和栈的区别" class="headerlink" title="Java内存模型中堆和栈的区别"></a>Java内存模型中堆和栈的区别</h2><ul>
<li>两者联系：引用对象、数组时，栈里定义变量保存堆中目标的首地址。</li>
</ul>
<p>创建好的数组和对象都会保存在堆中，想要引用堆中的某个对象或者数组，可以在栈中定义一个特殊的变量，让栈中的这个变量保存目标对象或者数组在堆中的首地址，由此一来，栈中的这个变量就是数组或者对象的引用变量，以后就可以在程序中使用栈的这个引用变量来访问堆中的数组或者对象。引用变量相当于是为数组或者对象起的一个名称。</p>
<p>引用变量也是一个普通变量，在程序运行到其作用域之外后就会被释放掉。而数组和对象本身在堆中分配，即使程序运行到了其范围之外，它们本身也不会被释放掉。它们在没有引用变量指向的时候，才会变成垃圾，在后面被GC掉。</p>
<p>如图：</p>
<p><img src="https://s2.ax1x.com/2020/03/05/3TyMCj.png" alt="堆和栈的区别"></p>
<p>具体区别：</p>
<ul>
<li>管理方式：栈可以自动释放，堆需要GC</li>
<li>空间大小：栈比堆小。栈存储地址，堆在Java程序中占的空间总是比较大，因为要存储对象实例和数组。</li>
<li>碎片相关：栈产生的碎片远小于堆。堆虽然有GC，但是不是实时的，随着使用就会积攒起来碎片。而栈的操作基本都是一一对应的，而且每一个最小单位和堆空间里面复杂的结构不同。所以栈在使用过程中很少出现内存碎片。</li>
<li>分配方式：栈空间支持静态和动态分配两种方式，而堆仅支持动态分配。而且栈空间分配的内存完全不需要考虑释放的问题，而堆空间虽然有GC，但是我们还是要考虑其垃圾释放的问题。</li>
<li>效率：栈的效率比堆高</li>
</ul>
<p>栈空间只有两个操作：入栈和出栈。</p>
<p>栈空间相比堆空间，弱点是灵活度不高，尤其是在动态网页的时候。而堆空间优点在于动态分配，实现方式可能是动态链表的结构，所以其管理的时候操作方式也比栈空间复杂很多。但是也使得堆空间的效率不如栈空间，而且要低很多。</p>
<h2 id="元空间-Meta-Space-、堆、线程独占部分间的联系——内存角度"><a href="#元空间-Meta-Space-、堆、线程独占部分间的联系——内存角度" class="headerlink" title="元空间(Meta Space)、堆、线程独占部分间的联系——内存角度"></a>元空间(Meta Space)、堆、线程独占部分间的联系——内存角度</h2><p>以一段程序为例：</p>
<p><img src="https://s2.ax1x.com/2020/03/05/3TRPXR.png" alt="样例程序"></p>
<p>hw就是存在于虚拟机栈上面的一个变量，它指向我们真正创建好的HelloWorld实例。我们通过对hw的引用就可以定位到堆中的HelloWorld实例的地址，调用它的setName方法将”test”赋值到name这个成员变量里面。</p>
<p>样例程序执行过程：</p>
<p><img src="https://s2.ax1x.com/2020/03/05/3TRpp4.png" alt="样例程序执行过程"></p>
<p>面试官可能会抓住不同版本的JDK的差异来做文章，其中比较有代表性的就是String的intern()方法。它的差异主要体现在JDK6和JDK6之后。</p>
<p>解释一下JDK6和JDK6之后版本的intern()方法的区别？</p>
<p><img src="https://s2.ax1x.com/2020/03/05/3TR91J.png" alt="JDK版本问题"></p>
<p>总的来说，JDK6和JDK6+版本的区别在于JDK6中通过intern()方法仅会在字符串常量池里添加字符串对象，而JDK6+不仅可以向池中添加字符串对象，还能添加字符串对象在堆中的引用。</p>
<p>可以举个例子，用JDK6，调用intern()方法，当字符串常量池被挤爆了之后，会报<code>java.lang.OutOfMemoryError:PemGen space</code>这个错。</p>
]]></content>
      <categories>
        <category>Study Note</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java JVM+GC Interview I</title>
    <url>/2020/02/25/Java-JVM-Interview-I/</url>
    <content><![CDATA[<blockquote>
<p>知识犹如人体的血液一样宝贵。——高士其</p>
</blockquote>
<a id="more"></a>

<p>JVM面试相关知识汇总：</p>
<p><img src="https://s2.ax1x.com/2020/03/04/35Lr90.png" alt="35Lr90.png"></p>
<p>上图中，内存模型、类加载机制、GC垃圾回收是比较重点的内容。</p>
<h1 id="1-简单描述JVM的内存模型"><a href="#1-简单描述JVM的内存模型" class="headerlink" title="1. 简单描述JVM的内存模型"></a>1. 简单描述JVM的内存模型</h1><p>回答这个问题，要答出两个要点：一个是各部分的功能，另一个是哪些线程共享，哪些线程独占。</p>
<p><img src="https://i.loli.net/2020/03/16/CcQiorLdHl4w9EK.png" alt="Java内存模型.png"></p>
<ul>
<li>栈，也叫方法栈，是线程私有的，线程在执行每个方法时都会同时创建一个栈帧，用来存储局部变量表、操作栈、动态链接、方法出口等信息。调用方法时执行入栈，方法返回时执行出栈。</li>
<li>本地方法栈与栈类似，也是用来保存线程执行方法时的信息，不同的是，执行 Java 方法使用栈，而执行 native 方法使用本地方法栈。</li>
<li>程序计数器保存着当前线程所执行的字节码位置，每个线程工作时都有一个独立的计数器。程序计数器为执行 Java 方法服务，执行 native 方法时，程序计数器为空。</li>
</ul>
<p>以上三个部分：栈、本地方法栈、程序计数器，都是线程独占的。</p>
<ul>
<li>堆是JVM管理的内存中最大的一块，堆被所有线程共享，目的是为了存放对象实例，几乎所有的对象实例都在这里分配。当堆内存没有可用的空间时，会抛出OOM异常。根据对象存活的周期不同，JVM把堆内存进行分代管理，由垃圾回收器来进行对象的回收管理。</li>
<li>方法区也是各个线程共享的内存区域，又叫非堆区。用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，JDK1.7中的永久代和JDK1.8中的Metaspace都是方法区的一种实现。</li>
</ul>
<h1 id="2-什么情况会触发FullGC？"><a href="#2-什么情况会触发FullGC？" class="headerlink" title="2.什么情况会触发FullGC？"></a>2.什么情况会触发FullGC？</h1><ul>
<li>老年代空间不足——如果创建的对象很大，Eden区域放不下这个对象，会放入到老年代中。如果老年代空间也不足，就会触发Full GC。为了避免这种情况，最好就是不要创建太大的对象。</li>
<li>永久代空间不足——这主要是针对JDK7以及以前的版本。当系统中需要加载和调用的类很多，而同时持久代当中没有足够的空间去存放类的信息和方法信息的时候，就会触发出一次Full GC。而JDK8以后由于取消了永久代，就不存在”永久代空间不足”这种情况了。(这也是JDK8后面用元空间替代永久代的原因之一，为了降低Full GC的频率，减少GC的负担，提升其效率)</li>
<li>CMS GC时出现promotion failed, concurrent mode failure。对于采用CMS 进行老年代GC的程序而言，如果GC日志中出现了这两个字段。如果出现了，可能会触发Full GC。</li>
<li>Minor GC晋升到老年代的平均大小大于老年代的剩余空间</li>
<li>调用System.gc()——这个是我们在程序里面手动调用的，触发Full GC。需要注意这个方法只是提醒虚拟机，程序员希望你在这里回收一下对象。但是具体怎么做还是要看虚拟机自己，程序员没有控制权</li>
<li>使用RMI来进行RPC或管理的JDK应用，每小时执行1次Full GC</li>
</ul>
<p>这些点很多，面试的时候只要能够提到3点，基本可以点到为止了，可以答到老年代空间不足，程序手动调用System.gc()，然后如果用的JDK版本比较老，在JDK8之前的版本，会有永久代空间不足的情况。当然其他的能说出来更好。</p>
<p>需要注意：</p>
<p>1.promotion failed是在进行Minor GC的时候Survivor放不下了，对象只能放入老年代，而此时恰好老年代也放不下，这时候就会造成promotion failed。</p>
<p>2.concurrent mode failure是在执行CMS GC的过程中同时有对象要放入老年代中，而此时老年代空间不足，就会造成这个failure。</p>
<p>而对于Minor GC晋升的这第四点，是比较复杂的触发情况。HotSpot为了避免由于新生代对象晋升到老年代而导致老年代空间不足的现象，在进行Minor GC的时候做了一个判断：如果之前统计所得到的Minor GC晋升到老年代的平均大小大于老年代的剩余空间，就直接触发Full GC。例如，程序第一次触发GC后有6M的对象晋升到老年代，当下一次Minor GC发生的时候，首先先检查老年代的剩余空间是否大于6M，如果小于6M，则执行Full GC。</p>
<h1 id="3-Java类加载器有几种，关系是怎样的？"><a href="#3-Java类加载器有几种，关系是怎样的？" class="headerlink" title="3.Java类加载器有几种，关系是怎样的？"></a>3.Java类加载器有几种，关系是怎样的？</h1><h1 id="3-双亲委派机制的加载流程是怎样的，有什么好处？"><a href="#3-双亲委派机制的加载流程是怎样的，有什么好处？" class="headerlink" title="3.双亲委派机制的加载流程是怎样的，有什么好处？"></a>3.双亲委派机制的加载流程是怎样的，有什么好处？</h1><h1 id="5-JDK1-8为什么用Metaspace替换掉PermGen？Metaspace保存在哪里？"><a href="#5-JDK1-8为什么用Metaspace替换掉PermGen？Metaspace保存在哪里？" class="headerlink" title="5.JDK1.8为什么用Metaspace替换掉PermGen？Metaspace保存在哪里？"></a>5.JDK1.8为什么用Metaspace替换掉PermGen？Metaspace保存在哪里？</h1><h1 id="6-编译器会对指令做哪些优化？-简单描述编译器的指令重排"><a href="#6-编译器会对指令做哪些优化？-简单描述编译器的指令重排" class="headerlink" title="6.编译器会对指令做哪些优化？(简单描述编译器的指令重排)"></a>6.编译器会对指令做哪些优化？(简单描述编译器的指令重排)</h1><h1 id="7-简单描述volatile可以解决什么问题？如何做到的？"><a href="#7-简单描述volatile可以解决什么问题？如何做到的？" class="headerlink" title="7.简单描述volatile可以解决什么问题？如何做到的？"></a>7.简单描述volatile可以解决什么问题？如何做到的？</h1><h1 id="8-简单描述一下GC的分代回收"><a href="#8-简单描述一下GC的分代回收" class="headerlink" title="8.简单描述一下GC的分代回收"></a>8.简单描述一下GC的分代回收</h1><h1 id="9-G1垃圾回收算法与CMS的区别有哪些？"><a href="#9-G1垃圾回收算法与CMS的区别有哪些？" class="headerlink" title="9.G1垃圾回收算法与CMS的区别有哪些？"></a>9.G1垃圾回收算法与CMS的区别有哪些？</h1><h1 id="10-对象引用有哪几种方式，有什么特点？"><a href="#10-对象引用有哪几种方式，有什么特点？" class="headerlink" title="10.对象引用有哪几种方式，有什么特点？"></a>10.对象引用有哪几种方式，有什么特点？</h1><h1 id="11-使用过哪些JVM调试工具，主要分析哪些内容？"><a href="#11-使用过哪些JVM调试工具，主要分析哪些内容？" class="headerlink" title="11.使用过哪些JVM调试工具，主要分析哪些内容？"></a>11.使用过哪些JVM调试工具，主要分析哪些内容？</h1>]]></content>
      <categories>
        <category>Interview Note</category>
      </categories>
      <tags>
        <tag>Interview</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Concurrent-Programming-Study-I</title>
    <url>/2020/02/25/Java-Concurrent-Programming-Study-I/</url>
    <content><![CDATA[<blockquote>
<p>盼望一件事会发生的人祈祷；相信一件事将发生的人专注；让一件事能发生的人行动</p>
</blockquote>
<a id="more"></a>

<h1 id="Java进程和线程的关系"><a href="#Java进程和线程的关系" class="headerlink" title="Java进程和线程的关系"></a>Java进程和线程的关系</h1><ul>
<li>Java对操作系统提供的功能进行封装，包括进程和线程</li>
<li>运行一个Java程序会产生一个进程，一个进程包含至少一个线程</li>
<li>每一个Java进程对应一个JVM实例，而每一个JVM实例会唯一对应一个堆。每个线程都有自己私有的栈</li>
<li>Java采用单线程编程模型，如果程序不声明创建线程，程序会自动创建主线程——进程就好像投资者，线程才是真正干活的人。</li>
<li>当Java程序启动时，主线程立刻运行。主线程可以创建子线程，原则上要后于子线程完成执行。</li>
</ul>
<p>因为主要干活的都是线程，所以后面分析都以线程为主，进程为辅。</p>
<h1 id="Thread中的start和run方法的区别"><a href="#Thread中的start和run方法的区别" class="headerlink" title="Thread中的start和run方法的区别"></a>Thread中的start和run方法的区别</h1><p>用run()方法会沿用主线程执行方法，用start()会新创建一个子线程。</p>
<p>如下图所示：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3qXBa6.png" alt="3qXBa6.png"></p>
<p>总结来是：</p>
<ul>
<li>调用start()方法会创建一个新的子线程并启动</li>
<li>run()方法只是Thread的一个普通方法的调用</li>
</ul>
<p>如果结合源码，会发现调用start的时候，会调用到thread_entry这个方法，会新创建内容。如下图所示：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3qXjZq.png" alt="3qXjZq.png"></p>
<h1 id="Thread和Runnable的关系"><a href="#Thread和Runnable的关系" class="headerlink" title="Thread和Runnable的关系"></a>Thread和Runnable的关系</h1><ul>
<li>Thread是一个类，而Runnable是一个接口。具体来说，Thread是实现了Runnable接口的类，使得run支持多线程。</li>
<li>由于Java类的单一继承原则，推荐多使用Runnable接口</li>
</ul>
<p>Thread是一个类：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3qjBOs.png" alt="3qjBOs.png"></p>
<p>Runnable是一个接口：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3qjwlQ.png" alt="3qjwlQ.png"></p>
<p>实际上Runnable里面并没有多线程的特性，而是依赖实现它的Thread去调用start()方法来创建新线程的，然后再在这个子线程里面调用Thread实现好的run方法来执行相应的业务逻辑。</p>
<h1 id="如何实现处理线程的返回值"><a href="#如何实现处理线程的返回值" class="headerlink" title="如何实现处理线程的返回值"></a>如何实现处理线程的返回值</h1><h2 id="如何给run-传参"><a href="#如何给run-传参" class="headerlink" title="如何给run()传参"></a>如何给run()传参</h2><p>一般来说和线程相关的业务逻辑需要放在run()里面去执行。但是既然run()没有参数，那么如何给run()传参数呢？</p>
<p>主要有三种方法：</p>
<ul>
<li>构造函数传参</li>
<li>成员变量传参——用setName之类的方法给成员变量赋值</li>
<li>回调函数传参</li>
</ul>
<h2 id="实现处理线程的返回值是痛点"><a href="#实现处理线程的返回值是痛点" class="headerlink" title="实现处理线程的返回值是痛点"></a>实现处理线程的返回值是痛点</h2><p>这里考查的是有没有活用线程相关的知识。</p>
<p>实现方式也是有三种：</p>
<ol>
<li><strong>主线程等待法——让主线程循环等待，直到目标子线程返回值为止。缺点是需要自己手动实现等待的逻辑。</strong></li>
</ol>
<p>代码实例：</p>
<p>一开始按照原先的多线程的案例去尝试打印，发现只让线程sleep()一下，我们不能精准控制等到start()子任务执行完返回结果的时候才执行下一条语句。</p>
<p>如下图所示：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3LSdNq.png" alt="3LSdNq.png"></p>
<p>在这个例子中，主线程在执行完t.start()之后，没有等run()里面sleep()执行完，而是直接往下走去执行打印的语句了，所以最后打印出来的结果，cw.value是null。</p>
<p>那如何让其等到子线程的返回值再执行打印呢？——我们可以用主线程等待法。</p>
<p>如下图所示：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3LpHzT.png" alt="3LpHzT.png"></p>
<p>但是因为需要自己手动实现这个等待的逻辑，所以当需要等待的变量很多的时候，代码会变得臃肿。更致命的是，具体要等待多久比较难把握，比较难有精准的控制。</p>
<ol start="2">
<li><strong>使用Thread类的join()阻塞当前线程以等待子线程处理完毕</strong></li>
</ol>
<p>如下图所示：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3L9Ine.png" alt="3L9Ine.png"></p>
<p>只需要加一行<code>t.join()</code>代码即可成功等待，并且也不需要让线程去等待了。</p>
<p>join()等待法可以做到比主线程等待法更精准的控制，实现起来也更简单。</p>
<p>但是缺点是粒度不够细。</p>
<ol start="3">
<li><strong>通过Callable接口实现：通过FutureTask 或 线程池获取</strong></li>
</ol>
<p>在JDK5之前，线程是没有返回值的。</p>
<h1 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h1><p>按照官方的说法，线程的状态一共有如下图所示的留个状态：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3LiilV.png" alt="3LiilV.png"></p>
<p>具体来说：</p>
<ol>
<li>新建(New)：创建后尚未启动的线程的状态。刚创建的线程，如果还没有调用start()方法，那么这个线程会处于New状态。</li>
<li>运行(Runnable)：包含Running和Ready。处于此状态的进程可能正在执行，也可能正在等待CPU为它分配执行时间。</li>
<li>无限期等待(Waiting)：不会被分配CPU执行时间，需要显式被唤醒</li>
</ol>
<p>让线程进入无限期等待有三种方法：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3LFpHe.png" alt="3LFpHe.png"></p>
<ol start="4">
<li>限期等待(Timed Waiting)：在一定时间后会由系统自动唤醒。处于这种状态的进程也不会被CPU分配执行时间，但是不用显示唤醒，过一段时间后系统会自动唤醒它们。</li>
</ol>
<p>让线程进入限期等待主要有六种方法：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3LFsv6.png" alt="3LFsv6.png"></p>
<ol start="5">
<li>阻塞(Blocked):等待获取排它锁。</li>
</ol>
<p>阻塞状态和等待状态的区别是，阻塞状态在等待获取一个排它锁(这会在另一个线程放弃这个锁的时候发生)。而等待状态就是等时间或者被唤醒，不用等其他线程的锁。</p>
<p>比如说，当某个线程进入到了synchronized修饰的方法或者代码块，即获取锁去执行的时候，其他想进入此方法或者代码块的线程就只能等待，他们的状态就都是blocked</p>
<ol start="6">
<li>结束(Terminated)：已终止线程的状态，线程已经结束执行。</li>
</ol>
<p>当线程的run()或者主线程的main()完成时，我们就认为它终止了。这个线程对象虽然可能还是活的，但是它已经不是一个单独执行的线程了。</p>
<p>线程只要终止了，就不能再复生。在一个终止的线程上调用start()会抛出<code>java.lang.IllegalThreadStateException</code>这个异常。 </p>
<p>程序举例：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3L8a6S.png" alt="3L8a6S.png"></p>
<p>在关闭了线程之后再次启动，也无法执行。</p>
<h1 id="sleep和wait的区别"><a href="#sleep和wait的区别" class="headerlink" title="sleep和wait的区别"></a>sleep和wait的区别</h1><h2 id="基本的差别"><a href="#基本的差别" class="headerlink" title="基本的差别"></a>基本的差别</h2><ul>
<li>sleep是Thread类的方法，wait是Object类中定义的方法</li>
<li>sleep()方法可以在任何地方使用</li>
<li>wait()方法只能在synchronized方法或synchronized块中使用</li>
</ul>
<h2 id="最主要的本职区别"><a href="#最主要的本职区别" class="headerlink" title="最主要的本职区别"></a>最主要的本职区别</h2><ul>
<li>Thread.sleep只会让出CPU，不会导致锁行为的改变</li>
<li>Object.wait不仅让出CPU，还会释放已经占有的同步资源锁</li>
</ul>
<h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><h2 id="线程安全问题的主要诱因"><a href="#线程安全问题的主要诱因" class="headerlink" title="线程安全问题的主要诱因"></a>线程安全问题的主要诱因</h2><ul>
<li>存在共享数据(也称临界资源)</li>
<li>存在多条线程共同操作这些共享数据</li>
</ul>
<h2 id="解决问题的根本方法"><a href="#解决问题的根本方法" class="headerlink" title="解决问题的根本方法"></a>解决问题的根本方法</h2><p>同一时刻有且只有一个线程在操作共享数据，其他线程必须等到该线程处理完数据后再对共享数据进行操作</p>
<h2 id="互斥锁的特性"><a href="#互斥锁的特性" class="headerlink" title="互斥锁的特性"></a>互斥锁的特性</h2><p>互斥锁可以达到互斥访问的目的。简单来说就是某个共享数据如果在某时刻正在被一个线程访问，如果数据被当前访问的数据加了互斥锁，那么在同一时刻其他线程只能处于等待状态，直到当前线程处理完释放掉该锁。</p>
<p>互斥锁有两种特性：</p>
<ol>
<li>互斥性：即在同一时间只允许一个线程持有某个对象锁，通过这种特性来实现多线程的协调机制，这样在同一时间只有一个线程对需要同步的代码块(符合操作)进行访问。互斥性也称为操作的原子性。</li>
<li>可见性：必须确保在锁被释放之前，对共享变量所做的修改，对随后获得该锁的另一个线程是可见的(即在获得锁时应获得最新共享变量的值)，否则另一个线程可能是在本地缓存的某个副本上继续操作，从而引起不一致。</li>
<li>synchronized锁的不是代码，而是<strong>对象</strong>。</li>
</ol>
<p>之前已经知道了，JVM的堆存储空间是线程间共享的，所以恰当地、合理地给一个线程上锁，是解决线程安全问题的关键。</p>
<h2 id="根据获取的锁的分类：获取对象锁和获取类锁"><a href="#根据获取的锁的分类：获取对象锁和获取类锁" class="headerlink" title="根据获取的锁的分类：获取对象锁和获取类锁"></a>根据获取的锁的分类：获取对象锁和获取类锁</h2><p>获取对象锁的两种用法：</p>
<ol>
<li>同步代码块(synchronized(this), synchronized(类实例对象))，锁是小括号()中的实例对象。</li>
<li>同步非静态方法(synchronized method)，锁是当前对象的实例对象</li>
</ol>
<p>获取类锁的两种用法</p>
<ol>
<li>同步代码块(synchronized (类.class))，锁是小括号()中的类对象(Class对象)。</li>
<li>同步静态方法(synchronized static method)，锁是当前对象的类对象(Class对象)。</li>
</ol>
<h2 id="对象锁和类锁的总结"><a href="#对象锁和类锁的总结" class="headerlink" title="对象锁和类锁的总结"></a>对象锁和类锁的总结</h2><ol>
<li>有线程访问对象的同步代码块时，另外的线程可以访问该对象的非同步代码块；</li>
<li>若锁住的是同一个对象，一个线程在访问对象的同步代码块时，另一个访问对象的同步代码块的线程会被阻塞；</li>
<li>若锁住的是同一个对象，一个线程在访问对象的同步方法时，另一个访问对象同步方法的线程会被阻塞；</li>
<li>若锁住的是同一个对象，一个线程在访问对象的同步代码块时，另一个访问对象同步方法的线程会被阻塞，反之亦然；</li>
<li>同一个类的不同对象的对象锁互不干扰；</li>
<li>类锁由于也是一种特殊的对象锁，因此表现和上述1,2,3,4一致，而由于一个类只有一把对象锁，所以同一个类的不同对象使用类锁将会是同步的；</li>
<li>类锁和对象锁互不干扰</li>
</ol>
<h1 id="synchronized底层实现原理"><a href="#synchronized底层实现原理" class="headerlink" title="synchronized底层实现原理"></a>synchronized底层实现原理</h1><ul>
<li>Java对象头</li>
<li>Monitor</li>
</ul>
<h1 id="synchronized和ReentrantLock的区别"><a href="#synchronized和ReentrantLock的区别" class="headerlink" title="synchronized和ReentrantLock的区别"></a>synchronized和ReentrantLock的区别</h1><p>Java5之前只有synchronized，Java5之后开始提供ReentrantLock(再入锁)。ReentrantLock的语义和synchronized基本相同</p>
<p>ReentrantLock位于<code>java.util.concurrent.locks</code>包下，也就是业界著名的”JUC”。</p>
<p>ReentrantLock和CountDownLatch、FutureTask、Semaphore一样都是基于AQS实现的。</p>
]]></content>
      <categories>
        <category>Study Note</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Concurrent Programming Interview II</title>
    <url>/2020/02/24/Java-Concurrent-Programming-Interview-II/</url>
    <content><![CDATA[<blockquote>
<p>耐心和恒心总会得到报酬的。——爱因斯坦</p>
</blockquote>
<a id="more"></a>

<h2 id="1-并行和并发有什么区别？"><a href="#1-并行和并发有什么区别？" class="headerlink" title="1.并行和并发有什么区别？"></a>1.并行和并发有什么区别？</h2><p>• 并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。<br>• 并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。<br>• 在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群。</p>
<p>所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。</p>
<h2 id="2-线程和进程的区别？"><a href="#2-线程和进程的区别？" class="headerlink" title="2.线程和进程的区别？"></a>2.线程和进程的区别？</h2><p>简而言之，进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源，减少切换次数，从而效率更高。线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位。同一进程中的多个线程之间可以并发执行。</p>
<h2 id="3-守护进程是什么？"><a href="#3-守护进程是什么？" class="headerlink" title="3.守护进程是什么？"></a>3.守护进程是什么？</h2><p>守护线程（即daemon thread），是个服务线程，准确地来说就是服务其他的线程。</p>
<h2 id="4-创建线程有哪几种方式？"><a href="#4-创建线程有哪几种方式？" class="headerlink" title="4.创建线程有哪几种方式？"></a>4.创建线程有哪几种方式？</h2><p>1.继承Thread类创建线程类<br>• 定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。<br>• 创建Thread子类的实例，即创建了线程对象。<br>• 调用线程对象的start()方法来启动该线程。</p>
<p>2.通过Runnable接口创建线程类<br>• 定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。<br>• 创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。<br>• 调用线程对象的start()方法来启动该线程。</p>
<p>3.通过Callable和Future创建线程<br>• 创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。<br>• 创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。<br>• 使用FutureTask对象作为Thread对象的target创建并启动新线程。<br>• 调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。</p>
<h2 id="5-说一下runnable-和-callable-有什么区别？"><a href="#5-说一下runnable-和-callable-有什么区别？" class="headerlink" title="5.说一下runnable 和 callable 有什么区别？"></a>5.说一下runnable 和 callable 有什么区别？</h2><p>有点深的问题了，也看出一个Java程序员学习知识的广度。<br>• Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；<br>Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</p>
<h2 id="6-线程有哪些状态？"><a href="#6-线程有哪些状态？" class="headerlink" title="6.线程有哪些状态？"></a>6.线程有哪些状态？</h2><p>线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。<br>• 创建状态。在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态。<br>• 就绪状态。当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。<br>• 运行状态。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。<br>• 阻塞状态。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致线程阻塞。<br>• 死亡状态。如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪</p>
<h2 id="7-sleep-和-wait-有什么区别？"><a href="#7-sleep-和-wait-有什么区别？" class="headerlink" title="7.sleep() 和 wait() 有什么区别？"></a>7.sleep() 和 wait() 有什么区别？</h2><p>sleep()：方法是线程类（Thread）的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。因为sleep() 是static静态的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep() 方法，线程虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象。</p>
<p>wait()：wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程</p>
<h2 id="8-notify-和-notifyAll-有什么区别？"><a href="#8-notify-和-notifyAll-有什么区别？" class="headerlink" title="8.notify() 和 notifyAll() 有什么区别？"></a>8.notify() 和 notifyAll() 有什么区别？</h2><p>• 如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。<br>• 当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争。<br>• 优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。</p>
<h2 id="9-线程的run-和-start-有什么区别？"><a href="#9-线程的run-和-start-有什么区别？" class="headerlink" title="9.线程的run() 和 start() 有什么区别？"></a>9.线程的run() 和 start() 有什么区别？</h2><p>每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，方法run()称为线程体。通过调用Thread类的start()方法来启动一个线程。</p>
<p>start()方法来启动一个线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码；这时此线程是处于就绪状态， 并没有运行。然后通过此Thread类调用方法run()来完成其运行状态， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。</p>
<p>run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的。 如果直接调用run(),其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。</p>
<h2 id="10-创建线程池有哪几种方式？"><a href="#10-创建线程池有哪几种方式？" class="headerlink" title="10.创建线程池有哪几种方式？"></a>10.创建线程池有哪几种方式？</h2><p>1.newFixedThreadPool(int nThreads)</p>
<p>创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程。</p>
<p>2.newCachedThreadPool()</p>
<p>创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制。</p>
<ol start="3">
<li>newSingleThreadExecutor()</li>
</ol>
<p>这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的顺序来串行执行。</p>
<ol start="4">
<li>newScheduledThreadPool(int corePoolSize)</li>
</ol>
<p>创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。</p>
]]></content>
      <categories>
        <category>Interview Note</category>
      </categories>
      <tags>
        <tag>Interview</tag>
        <tag>Java</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Concurrent Programming Interview I</title>
    <url>/2020/02/24/Java-Concurrent-Programming-Interview-I/</url>
    <content><![CDATA[<a id="more"></a>

]]></content>
      <categories>
        <category>Interview Note</category>
      </categories>
      <tags>
        <tag>Interview</tag>
        <tag>Java</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>DataBase Interview II(Mysql)</title>
    <url>/2020/02/20/Database-Interview-II/</url>
    <content><![CDATA[<blockquote>
<p>人真正的强大，不是维护着自尊心的时候，而是抛开自尊心的时候——《请回答1988》</p>
</blockquote>
<a id="more"></a>

<h2 id="1-数据库的三范式是什么？"><a href="#1-数据库的三范式是什么？" class="headerlink" title="1. 数据库的三范式是什么？"></a>1. 数据库的三范式是什么？</h2><p>第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。</p>
<p>第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。</p>
<p>第三范式：任何非主属性不依赖于其它非主属性。</p>
<h2 id="2-一张自增表里面总共有17条数据，删除了最后2条数据，重启mysql数据库，又插入了一条数据，此时id是几？"><a href="#2-一张自增表里面总共有17条数据，删除了最后2条数据，重启mysql数据库，又插入了一条数据，此时id是几？" class="headerlink" title="2.一张自增表里面总共有17条数据，删除了最后2条数据，重启mysql数据库，又插入了一条数据，此时id是几？"></a>2.一张自增表里面总共有17条数据，删除了最后2条数据，重启mysql数据库，又插入了一条数据，此时id是几？</h2><p>• 表类型如果是 MyISAM ，那 id 就是 18。<br>• 表类型如果是 InnoDB，那 id 就是 15。</p>
<p>InnoDB 表只会把自增主键的最大 id 记录在内存中，所以重启之后会导致最大 id 丢失。</p>
<h2 id="3-如何获取当前数据库版本？"><a href="#3-如何获取当前数据库版本？" class="headerlink" title="3.如何获取当前数据库版本？"></a>3.如何获取当前数据库版本？</h2><p>使用 select version() 获取当前 MySQL 数据库版本。</p>
<h2 id="4-说一下ACID是什么？"><a href="#4-说一下ACID是什么？" class="headerlink" title="4.说一下ACID是什么？"></a>4.说一下ACID是什么？</h2><p>• Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。<br>• Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等<br>• Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</p>
<p>• Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失</p>
<h2 id="5-char和varchar的区别是什么？"><a href="#5-char和varchar的区别是什么？" class="headerlink" title="5.char和varchar的区别是什么？"></a>5.char和varchar的区别是什么？</h2><p>char(n) ：固定长度类型，比如订阅 char(10)，当你输入”abc”三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。</p>
<p>chat 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。</p>
<p>varchar(n) ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。</p>
<p>所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。</p>
<h2 id="6-float和double的区别是什么？"><a href="#6-float和double的区别是什么？" class="headerlink" title="6.float和double的区别是什么？"></a>6.float和double的区别是什么？</h2><p>• float 最多可以存储 8 位的十进制数，并在内存中占 4 字节。<br>• double 最可可以存储 16 位的十进制数，并在内存中占 8 字节。</p>
<h2 id="7-mysql的内连接、左连接、右连接有什么区别"><a href="#7-mysql的内连接、左连接、右连接有什么区别" class="headerlink" title="7.mysql的内连接、左连接、右连接有什么区别?"></a>7.mysql的内连接、左连接、右连接有什么区别?</h2><p>内连接关键字：inner join；左连接：left join；右连接：right join。</p>
<p>内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。</p>
<h2 id="8-mysql的索引是什么实现的？"><a href="#8-mysql的索引是什么实现的？" class="headerlink" title="8.mysql的索引是什么实现的？"></a>8.mysql的索引是什么实现的？</h2><p>索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。</p>
<p>具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。</p>
<h2 id="9-怎么验证mysql的索引是否满足需求？"><a href="#9-怎么验证mysql的索引是否满足需求？" class="headerlink" title="9.怎么验证mysql的索引是否满足需求？"></a>9.怎么验证mysql的索引是否满足需求？</h2><p>使用 explain 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。</p>
<p>explain 语法：explain select * from table where type=1。</p>
<h2 id="10-说一下数据库的事务隔离？"><a href="#10-说一下数据库的事务隔离？" class="headerlink" title="10.说一下数据库的事务隔离？"></a>10.说一下数据库的事务隔离？</h2><p>MySQL 的事务隔离是在 MySQL. ini 配置文件里添加的，在文件的最后添加：transaction-isolation = REPEATABLE-READ</p>
<p>可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。<br>• READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。<br>• READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。<br>• REPEATABLE-READ：可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。<br>• SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</p>
<p>脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</p>
<p>不可重复读 ：是指在一个事务内，多次读同一数据。</p>
<p>幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p>
<h2 id="11-说一下Mysql常用的引擎？"><a href="#11-说一下Mysql常用的引擎？" class="headerlink" title="11.说一下Mysql常用的引擎？"></a>11.说一下Mysql常用的引擎？</h2><p>InnoDB 引擎：InnoDB 引擎提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。</p>
<p>MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 select count(*) from table 指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。</p>
<p>MyIASM 引擎：MySQL 的默认引擎，但不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。</p>
<h2 id="12-说一下mysql的行锁和表锁？"><a href="#12-说一下mysql的行锁和表锁？" class="headerlink" title="12.说一下mysql的行锁和表锁？"></a>12.说一下mysql的行锁和表锁？</h2><p>MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。<br>• 表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。<br>• 行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。</p>
<h2 id="13-说一下乐观锁和悲观锁？"><a href="#13-说一下乐观锁和悲观锁？" class="headerlink" title="13.说一下乐观锁和悲观锁？"></a>13.说一下乐观锁和悲观锁？</h2><p>• 乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。<br>• 悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。</p>
<p>数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。 </p>
<h2 id="14-mysql问题排查都有哪些手段？"><a href="#14-mysql问题排查都有哪些手段？" class="headerlink" title="14.mysql问题排查都有哪些手段？"></a>14.mysql问题排查都有哪些手段？</h2><p>• 使用 show processlist 命令查看当前所有连接信息。<br>• 使用 explain 命令查询 SQL 语句执行计划。<br>• 开启慢查询日志，查看慢查询的 SQL。</p>
<h2 id="15-如何做mysql的性能优化？"><a href="#15-如何做mysql的性能优化？" class="headerlink" title="15.如何做mysql的性能优化？"></a>15.如何做mysql的性能优化？</h2><p>• 为搜索字段创建索引。<br>• 避免使用 select *，列出需要查询的字段。<br>• 垂直分割分表</p>
<p>选择正确的存储引擎。</p>
]]></content>
      <categories>
        <category>Interview Note</category>
      </categories>
      <tags>
        <tag>DataBase</tag>
        <tag>Interview</tag>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>DataBase Interview I</title>
    <url>/2020/02/19/DataBase-Interview/</url>
    <content><![CDATA[<blockquote>
<p>才能一旦让懒惰支配，它就一无可为。——克雷洛夫</p>
</blockquote>
<a id="more"></a>

<h2 id="数据库架构设计"><a href="#数据库架构设计" class="headerlink" title="数据库架构设计"></a>数据库架构设计</h2><p>如果提问：如何设计一个关系型数据库？实际上是考察你对数据库模块化的划分能力，当然也包括对数据库的概念的理解程度。</p>
<p>要开发数据库需要以下模块：</p>
<p><img src="https://s2.ax1x.com/2020/02/19/3Ax1HO.png" alt="3Ax1HO.png"></p>
<ul>
<li><p>存储管理模块可以控制IO次数，因为读取次数会非常花时间，在实际中，一次读取多行的效率远比多次读取(每次读取一两行)要省时间的多。</p>
</li>
<li><p>非常常用的一种方法，就是引入缓存机制，把取出来的数据块存放在缓存里，下次需要的时候直接从内存返回，而不用发生IO。管理缓存的方法很多，可以使用比如LRU等。注意，我们的缓存不宜过大，而且算法中需要有淘汰机制。</p>
</li>
</ul>
<p>总的来说，要回答如何设计一个关系型数据库(RDBMS：Relational Database Management System),首先要将其划分成两大部分，一个是存储部分，该部分类似一个文件系统，将数据持久化到存储设备当中。另一个是程序实例模块来对存储进行管理。而在程序实例模块中，需要包含下面八个模块：</p>
<p>①. 将数据的逻辑关系转换成物理存储关系的存储管理模块；</p>
<p>②. 优化执行效率的缓存机制模块</p>
<p>③. 将SQL语句进行解析的SQL解析模块</p>
<p>④. 记录操作的日志管理模块</p>
<p>⑤. 进行多用户权限管理的权限划分模块</p>
<p>⑥. 灾难恢复的容灾模块</p>
<p>⑦. <strong>优化查询效率的索引管理模块</strong> (重点)</p>
<p>⑧. <strong>使数据库支持并发操作的锁模块</strong> (重点)</p>
<p>实际上，数据库开发设计的模块结构和我们自己设计和开发的软件系统很相似，这个架构是很经典的，对程序的开发和设计也是很有借鉴意义的。</p>
<h2 id="索引相关问题"><a href="#索引相关问题" class="headerlink" title="索引相关问题"></a>索引相关问题</h2><h3 id="为什么要使用索引？"><a href="#为什么要使用索引？" class="headerlink" title="为什么要使用索引？"></a>为什么要使用索引？</h3><p>索引(Index)是可以帮助MYSQL高效获取数据的数据结构。如果数据量很小，那么哪怕是全表扫描，也可能比加了索引之后更快。但是如果数据量很大，那么全表扫描将是噩梦。</p>
<p>实际上，可以理解索引的灵感来自于”字典”，通过类似”偏旁部首”之类的”索引”可以更快速地找到要查的词。</p>
<p>具体作用描述：</p>
<ol>
<li>索引能极大地减少存储引擎需要扫描的数据量</li>
<li>索引可以把随机IO变成顺序IO</li>
<li>索引可以帮助我们在进行分组、排序等操作时，避免使用临时表</li>
</ol>
<h3 id="什么样的信息能成为索引？"><a href="#什么样的信息能成为索引？" class="headerlink" title="什么样的信息能成为索引？"></a>什么样的信息能成为索引？</h3><ul>
<li>主键、唯一键及普通键等，只要能让数据具备一定区分性的字段，都可以成为索引。</li>
</ul>
<h3 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h3><p>在选择建并且生成索引之后，可以选择不同的数据结构进行索引的查找。一般常用的是二分查找树进行二分查找、建立B-树结构查找、建立B+树查找(MySQL选择的结构)、建立Hash结构查找。下面简单介绍每种结构的细节。</p>
<p>回答：<font color=#FF0000>通常来说，索引的数据结构是B+树，比较小众的也有哈希结构、BitMap(位图)等</font></p>
<h4 id="二叉查找树结构进行索引查找"><a href="#二叉查找树结构进行索引查找" class="headerlink" title="二叉查找树结构进行索引查找"></a>二叉查找树结构进行索引查找</h4><p>大体的结构：</p>
<p><img src="https://s2.ax1x.com/2020/02/19/3VOG60.png" alt="3VOG60.png"></p>
<ul>
<li>二叉查找树符合左小右大的规则，查找的时候使用二分查找</li>
<li>检索深度每增加1，就会增加1次IO。但是需要注意的是整个树是通过很多数据块组合而成的，当许多数据块组合在一起的时候，会造成二叉树的深度很大，从而基本上没法避免多次的IO，从而造成很悲剧的后果：使用了索引，速度甚至可能比不用更慢，因为IO次数太多了。</li>
</ul>
<h4 id="B-树结构进行索引查找"><a href="#B-树结构进行索引查找" class="headerlink" title="B- 树结构进行索引查找"></a>B- 树结构进行索引查找</h4><p>B-树又称作”多路平衡查找树”</p>
<p><img src="https://s2.ax1x.com/2020/02/19/3VXkEF.png" alt="3VXkEF.png"></p>
<p>定义：</p>
<ul>
<li>根节点至少包括两个孩子</li>
<li>树中每个结点最多含有m个孩子(m&gt;=2)</li>
<li>除根节点和叶节点外，其他每个节点至少有ceil(m/2)个孩子(ceil为取上限，举例，1.2和1.5，都是取2)</li>
<li>所有叶子节点都位于同一层(即叶子节点高度都相同)</li>
</ul>
<h4 id="B-树结构进行索引查找-1"><a href="#B-树结构进行索引查找-1" class="headerlink" title="B+树结构进行索引查找"></a>B+树结构进行索引查找</h4><p><img src="https://s2.ax1x.com/2020/02/19/3Vvr1s.png" alt="3Vvr1s.png"></p>
<p>B+树实际上是B树的变体，其定义和B树不同的地方为：</p>
<ul>
<li>非叶子节点的子树指针与关键字个数相同</li>
<li>非叶子节点的子树指针P[i]，指向关键字值[K[i],K[i+1])<font color=#FFF0000>(左闭右开，即可以大于等于K[i]，但必须大于K[i+1]  )</font>的子树</li>
<li>非叶子节点仅用来索引，数据都保存在叶子节点中。<font color=#FFF0000>所有的数据实际都存储在叶子节点上，所以每一次遍历都必须遍历到叶子节点上。</font>这也使得B+树的层级可以更少，树可以更矮。</li>
<li>所有叶子节点均有一个链指针指向下一个叶子节点。<font color=#FFF0000>搜索的实际是上图中粉色的块的部分。</font>这个链指针主要服务于<strong>范围统计</strong>，定位到了某个叶指针之后，可以快速横向地去做统计。比如要统计索引&gt;10的，找到了第二个Q之后，直接统计后面所有的Q内容即可。</li>
</ul>
<p>结论：B+树相比B树更适合用来做存储索引</p>
<ul>
<li>B+树的磁盘读写代价更低。B+树内部只存储索引(或者说叶子节点的指针)，B树需要不断在父节点和叶子节点之间来回移动，所以B+树的高度能降低。</li>
<li>B+树查询效率更加稳定。因为所有实质内容都存储在根节点上，所以几乎所有数据的查询的时间都是稳定的：O(n)</li>
<li>B+树更有利于对数据库的扫描。B+树只需要遍历叶子节点就可以实现全部关键字信息的扫描。比如之前提到的，数据库中频繁使用的范围查询，使用B+树查询能够大大增加效率。</li>
</ul>
<h4 id="Hash结构进行索引查找"><a href="#Hash结构进行索引查找" class="headerlink" title="Hash结构进行索引查找"></a>Hash结构进行索引查找</h4><p>和哈希表的原理类似，通过一个哈希函数，将不同的key通过某种哈希映射得到value，然后存储在不同的链表节点上。如图：</p>
<p><img src="https://s2.ax1x.com/2020/02/20/3ZCI3D.png" alt="3ZCI3D.png"></p>
<p>哈希索引在理论上性能优于B+树。</p>
<p>但是哈希表相比B+树有一些缺点，却是更需要重视的：</p>
<ul>
<li>仅仅能满足”=”,”IN”，不能使用范围查询。因为哈希运算后得到的值之间的大小关系是根本不能保证和哈希运算前一样的，所以不能进行范围比较，只能进行具体的值的大小的比较。</li>
<li>无法被用来避免数据的排序操作</li>
<li>不能利用部分索引键查询</li>
<li>不能避免表扫描</li>
<li>遇到大量Hash值相等的情况后性能并不一定就会比B树索引高</li>
</ul>
<h4 id="BitMap索引"><a href="#BitMap索引" class="headerlink" title="BitMap索引"></a>BitMap索引</h4><p>需要注意，目前比较少的主流数据库支持位图索引，比较出名的是Oracl。位图索引不是主流索引。</p>
<p><img src="https://s2.ax1x.com/2020/02/20/3ZP7GT.png" alt="3ZP7GT.png"></p>
<p>这个索引可以算是一个”神器”。当表中的某个字段只有几种可能值的时候，比如性别，此时如果要实现性别统计，使用位图索引可以说是最佳选择。</p>
<p>位图索引比较类似B+树。</p>
<ul>
<li>锁的力度大，不适合高并发的联机数据处理系统(OLTP系统)，适合并发较少，且统计较多的OLAP系统</li>
</ul>
<h3 id="密集索引和稀疏索引的区别"><a href="#密集索引和稀疏索引的区别" class="headerlink" title="密集索引和稀疏索引的区别"></a>密集索引和稀疏索引的区别</h3><ul>
<li>密集索引文件中的每个搜索码值都对应一个索引值</li>
<li>稀疏索引文件只为索引码的某些值建立索引项</li>
</ul>
<p>密集索引和稀疏索引如下图所示：</p>
<p><img src="https://s2.ax1x.com/2020/02/20/3ZY1eA.png" alt="3ZY1eA.png"></p>
<p>一个表只能创建一个密集索引。</p>
<p>针对Mysql进行分析，其主要有两种存储引擎：MyISAM和InnoDB：</p>
<ul>
<li>MyISAM(数据和索引是分开的，文件后缀为.MYI、.MYD,前者存储索引，后者存储数据)：主键索引、唯一建索引和普通索引，全部都是稀疏索引。</li>
<li>InnoDB(数据和索引是合在一起的，文件后缀为.idb)则有且仅有一个密集索引。</li>
</ul>
<p>对于InnoDB的索引的额外知识：</p>
<ul>
<li>若一个主键被定义，该主键则作为密集索引</li>
<li>若没有主键被定义，该表的第一个唯一非空索引则作为密集索引</li>
<li>若没有主键，也没有合适的唯一索引，innodb内部会生成一个隐藏主键(是一个6字节的列，该列的值会随着数据的插入而自增)(密集索引)</li>
<li>非主键索引存储相关键位和其对应的主键值，包含两次查找(一次查找次级索引自身，一次查找主键)</li>
</ul>
<p><img src="https://s2.ax1x.com/2020/02/20/3ZagE9.png" alt="3ZagE9.png"></p>
<h3 id="索引额外的问题，以mysql为例"><a href="#索引额外的问题，以mysql为例" class="headerlink" title="索引额外的问题，以mysql为例"></a>索引额外的问题，以mysql为例</h3><h4 id="如何定位并优化慢查询Sql"><a href="#如何定位并优化慢查询Sql" class="headerlink" title="如何定位并优化慢查询Sql"></a>如何定位并优化慢查询Sql</h4><p>这个问题主要考察有没有做过sql优化，需要具体场景具体分析，这里给出大致思路</p>
<ul>
<li>根据慢日志定位慢查询sql</li>
<li>使用explain等工具分析sql</li>
<li>修改sql或尽量让sql走索引</li>
</ul>
<p>下面具体分析：</p>
<ul>
<li>根据慢日志定位慢查询sql</li>
</ul>
<p>什么是慢日志？——用来记录一些执行比较慢的sql</p>
<p><code>show variables like &#39;%quer%&#39;;//查看相关变量</code></p>
<p>查询结果：</p>
<p><img src="https://s2.ax1x.com/2020/02/20/3ZXX0f.png" alt="3ZXX0f.png"></p>
<p>其中需要重点关注三个变量：</p>
<p><code>show_query_log</code>(慢日志是否打开),</p>
<p><code>slow_query_log_file</code>(日志写入的文件路径)，</p>
<p><code>long_query_time</code>(多少秒以上的sql语句会被当做慢语句记录到文件中,一般设置为1秒)</p>
<p>一般来说可以用set设置慢查询开关和阈值时间(路径一般不迫切更改)</p>
<blockquote>
<p>set global slow_query_log = on;</p>
<p>set global long_query_time = 1;//必须重连才能生效</p>
</blockquote>
<p>但是如果想要永久生效，最好是去配置文件里面配好，而不是用set的方式。</p>
<p>查看系统慢查询的数量的语句：<code>show status like &#39;%slow_queries%&#39;</code>，能够把运行下来执行慢的语句数量统计出来。</p>
<p>通过查看慢日志的具体值，可以在分析之后进行调优。</p>
<ul>
<li>使用explain等工具分析sql</li>
</ul>
<p>在分析查询性能的时候explain关键字非常管用，一般放在select语句前面，用于描述mysql如何执行查询操作。以及mysql返回的结果和需要查询的行数。</p>
<p><img src="https://s2.ax1x.com/2020/02/20/3er9iQ.png" alt="3er9iQ.png"></p>
<p>重点介绍看两个字段：type和extra</p>
<ol>
<li>type：如果出现了index或all，表示语句进行了全表扫描，需要优化</li>
<li>extra：类型很多，其中using filesort/Using temporary出现的话，会对性能产生较大影响，必须优化：</li>
</ol>
<p><img src="https://s2.ax1x.com/2020/02/20/3erzOx.png" alt="3erzOx.png"></p>
<ul>
<li>修改sql或者尽量让sql走索引</li>
</ul>
<p>当我们进行查询的时候，如果一开始用的属性是没有索引的，可以更改成有索引的对象，可以减少查询时间。</p>
<p>但是有时候我们就是不能用带索引的属性，那么只能在新的需要查询的属性中加上索引了。</p>
<p>Mysql的索引优化器本质上也是一个软件，在不同的查询条件下可能就算你用了主键，查询效果也不够好。这个时候可以利用关键字<code>force index(primary)</code>进行对比，综合判断哪个索引的值最适合做此次的查询。</p>
<p>举一个调优的最简单的例子：如果我们是用户表，其中有用户账号account和用户名name，其中account有索引，则如果我们用name查询用了10s，用account查询用了6秒，那么实际我们将此次mysql查询的性能优化了40%</p>
<h4 id="联合索引的最左匹配原则的成因"><a href="#联合索引的最左匹配原则的成因" class="headerlink" title="联合索引的最左匹配原则的成因"></a>联合索引的最左匹配原则的成因</h4><p>什么是联合索引？——由多列组成的索引</p>
<p>假设将数据库某张表中的A列和B列设置成联合索引，查询的时候在where语句中调用(where A=** and B=**)的时候会走A和B这个组合索引；而且如果单独用A查询，也会走AB联合索引。<font color=#FF0000>但是如果直接select B，则会走”ALL”，即不走索引，全表扫描。</font></p>
<ul>
<li>最左匹配原则本身很重要。简单理解，是Mysql会从左一直向右匹配直到遇到范围查询(&gt;,&lt;,between,like)就停止匹配。比如a=3 and b=4 and c&gt;5 and d=6,如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到。其中a,b,d的顺序可以任意调整，比如(b,a,d,c),(a,d,b,c)，结果都是一样的。注意这里不是没有用到索引，而是最多只用到了(a)(a,b),(a,b,c)索引，没有能够用到(a,b,c,d)索引</li>
<li>=和in可以乱序的。比如a = 1 and b = 2 and c = 3建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。</li>
</ul>
<p>对于(a,b,c,d)这个例子，mysql创建复合索引的规则是首先会对复合索引的最左边的，也就是第一个a字段的数据进行排序，在第一个字段的排序基础上，然后再对后面第二个的b字段进行排序，如果此时c是范围查询的话，则没法获取到有序的d，因此是不行的。</p>
<h4 id="索引是建立得越多越好么？"><a href="#索引是建立得越多越好么？" class="headerlink" title="索引是建立得越多越好么？"></a>索引是建立得越多越好么？</h4><p>当然不是：</p>
<ul>
<li>数据量小的表不需要建立索引，增加额外的索引开销(比如看一两页的宣传手册，谁会需要索引呢？)</li>
<li>数据变更需要维护索引，因此更多的索引意味着更多的维护成本</li>
<li>更多的索引以为这也需要更多的空间(一本100页的书，目录不能是50页呀)</li>
</ul>
<h2 id="锁相关问题"><a href="#锁相关问题" class="headerlink" title="锁相关问题"></a>锁相关问题</h2><h3 id="MyISAM与InnoDB关于锁方面的区别是什么"><a href="#MyISAM与InnoDB关于锁方面的区别是什么" class="headerlink" title="MyISAM与InnoDB关于锁方面的区别是什么"></a>MyISAM与InnoDB关于锁方面的区别是什么</h3><ul>
<li><p>MyISAM默认用的是表级锁，不支持行级锁</p>
</li>
<li><p>InnoDB默认用的是行级锁，但是也支持表级锁</p>
</li>
</ul>
<p>分别来说：</p>
<h4 id="MyISAM默认用的是表级锁，不支持行级锁"><a href="#MyISAM默认用的是表级锁，不支持行级锁" class="headerlink" title="MyISAM默认用的是表级锁，不支持行级锁"></a>MyISAM默认用的是表级锁，不支持行级锁</h4><p>当使用MyISAM作为Mysql引擎时，对一个表进行操作时，会锁住整张表，其他session不能操作</p>
<p>读锁（共享锁）不释放，无法增加写锁</p>
<p>读锁（共享锁）不释放，可以增加读锁</p>
<p>写锁（排他锁）不释放，无法增加读锁</p>
<p>写锁 (排它锁) 不释放，无法增加写锁</p>
<p>给表加上读锁写锁或者读锁的写法：</p>
<blockquote>
<p>lock tables *** read | write;<br>unlock tables;</p>
</blockquote>
<h4 id="InnoDB默认用的是行级锁，但是也支持表级锁"><a href="#InnoDB默认用的是行级锁，但是也支持表级锁" class="headerlink" title="InnoDB默认用的是行级锁，但是也支持表级锁"></a>InnoDB默认用的是行级锁，但是也支持表级锁</h4><p>InnoDB使用的是二段锁，也就是加锁和解锁分成两个步骤进行，就像军训走正步一样，一个动作全部加锁，一个动作全部解锁。</p>
<p>InnoDB的行级锁会把某张表中的某一行锁住，这样如果你锁住了第3行，那么操作第4行是不会受影响的。</p>
<p>需要注意，InnoDB在sql没有用到索引的时候，会自动走表级锁。但是如果sql用到了索引，就会转为使用行级锁。</p>
<h4 id="MyISAM和InnoDB各自适合的场景"><a href="#MyISAM和InnoDB各自适合的场景" class="headerlink" title="MyISAM和InnoDB各自适合的场景"></a>MyISAM和InnoDB各自适合的场景</h4><ul>
<li><p>MyISAM适合的场景：</p>
<ul>
<li>频繁执行全表count语句(InnoDB不保存表的具体行数，但MyISAM会使用一个变量保存整张表的行数，执行count的时候可以调用之前保存过的变量,)</li>
<li>对数据进行增删改的频率不高，查询非常频繁(增删改设计锁表操作)</li>
<li>没有事务</li>
</ul>
</li>
<li><p>InnoDB适合的场景：</p>
<ul>
<li>数据增删改查都频繁(每次只锁行)</li>
<li>可靠性要求高</li>
<li>需要支持事务</li>
</ul>
</li>
</ul>
<h4 id="数据库锁的分类"><a href="#数据库锁的分类" class="headerlink" title="数据库锁的分类"></a>数据库锁的分类</h4><ul>
<li>按锁的粒度划分，可分为<strong>表级锁、行级锁、页级锁</strong>。InnoDB默认支持行级锁，同时支持表级锁。MyISAM只支持表级锁。</li>
<li>按锁的级别划分，可分为共享锁、排它锁</li>
<li>按加锁方式划分，可分为自动锁(mysql自动加上的锁)、显式锁(用语句加上的锁)</li>
<li>按操作划分，可分为DML锁(对数据操作)、DDL锁(对表结构操作)</li>
<li>按使用方式划分，可分为乐观锁(基于数据版本)、悲观锁(利用数据库提供的功能，对外界修改保守态度)</li>
</ul>
<p>其中，乐观锁和悲观锁不仅在数据库中会使用，在程序中也经常用到。悲观锁实际上会拒绝所有外部的修改。对于并发，悲观锁实际上也是先取锁，后访问的保守策略。为数据处理的安全提供了保证。但是对于数据库，处理过多的锁可能会给数据库造成额外的开销，并且增加产生死锁的机会，所以对于事务要不要加锁需要谨慎。</p>
<p>乐观锁认为数据一般不会造成冲突，所以只会在数据提交更新的时候才会检测数据是否冲突。如果发现冲突，则返回用户错误的信息。<strong>悲观锁一般需要使用数据库提供的锁机制，但是乐观锁一般不用。</strong>乐观锁一般记录数据库版本。记录版本的方式一般也有两种，一个是使用<strong>版本号</strong>，另一个是使用<strong>时间戳</strong>。添加版本号，可以通过添加一个int类型的version变量实现。</p>
<h3 id="数据库事务的四大特性"><a href="#数据库事务的四大特性" class="headerlink" title="数据库事务的四大特性"></a>数据库事务的四大特性</h3><p><strong>ACID</strong></p>
<ul>
<li>Atomicity：<strong>原子性</strong>，要么都做，要么都不做。比如银行取钱，我这边还没取完，你就不能操作我的账户。比较相似的是，如果一个用户正在操作他的账户，而且他的账户里面的钱的金额很大，可能出现的情况就是他点确认了，但是数据要处理几秒，那么这段时间这个账户也是不能被操作的。</li>
<li>Consistency，<strong>一致性</strong>，一个事务要持续做完。这个事务一般情况下需要满足既定好的假设，满足各种条件约束。</li>
<li>Isolation，<strong>隔离性</strong>，事务之间是互相独立的。一个事务的执行不能影响其他事务。</li>
<li>Durability，<strong>持久性</strong>，事务需要是持久的，比如介质受损了，比如断电之后，数据也还能保存。</li>
</ul>
<p>其中，Isolation，隔离性，是最关键的一个属性。</p>
<p>事务隔离级别有四个。事务会先begin transaction，然后开始做。</p>
<ul>
<li>Read uncommitted，事务的隔离级别非常低，别的事务完成到了一半还没committ的时候，就能够被我读出来。（不能避免脏读）</li>
<li>Read Committed，顾名思义，只能读取到别人已经Committed的内容。但是如果你已经读取了，在你读取之后别人又有了修改，别人修改之后你再读，读取到的是别人修改之后的内容，隔离性相对来说也不是很强。(可以避免脏读)</li>
<li>Repeatable Reads,这个针对上一个，这种读法始终只能读取到我自己begin transaction时候的值。</li>
<li>Serializable， 两个事务同时发生的时候，一定只会读取到其中一个的结果。</li>
</ul>
<h3 id="事务隔离级别以及各级别下的并发访问问题"><a href="#事务隔离级别以及各级别下的并发访问问题" class="headerlink" title="事务隔离级别以及各级别下的并发访问问题"></a>事务隔离级别以及各级别下的并发访问问题</h3><h4 id="事务并发访问引起的问题以及如何避免"><a href="#事务并发访问引起的问题以及如何避免" class="headerlink" title="事务并发访问引起的问题以及如何避免"></a>事务并发访问引起的问题以及如何避免</h4><ul>
<li>更新丢失(lost update)，即数据库的一个更新覆盖掉了另一个更新的内容。但是现在Mysql所有事务隔离级别在数据库层面上均可避免这个问题。</li>
</ul>
<p>举一个银行取款存款事务的例子：</p>
<p><img src="https://s2.ax1x.com/2020/02/23/3lQIZ4.png" alt="3lQIZ4.png"></p>
<ul>
<li>脏读(Dirty Read)，指一个事务读到了另一个事务未提交的更新数据。这个问题可以在READ-COMMITTED事务隔离级别以上才能避免。</li>
</ul>
<p>查看事务隔离级别：</p>
<blockquote>
<p>select @@tx_isolation</p>
</blockquote>
<p>NOTE:tx就是事务(transaction)缩写</p>
<p>设置事务隔离级别：</p>
<blockquote>
<p>set session transaction isolation level read committed;</p>
</blockquote>
<p>开启事务：</p>
<blockquote>
<p>start tansaction;</p>
</blockquote>
<ul>
<li>不可重复读(None repeatable read),事务A多次读取了数据，但是事务B在事务A读取的过程中有操作数据，导致事务A多次读取出来的数据不一致。把事务隔离级别修改成REPEATABLE-READ级别以上可以避免这个问题。</li>
</ul>
<p>InnoDB默认的隔离级别就是REPEATABLE-READ，支持多次读也<br>能读取到相同结果。</p>
<p>设置事务隔离级别为REPEATABLE-READ：</p>
<blockquote>
<p>set session transaction isolation level repeatable read;</p>
</blockquote>
<p>事务的隔离级别设置到REPEATABLE-READ以上，就可以避免不可重复度的问题。</p>
<p>实际上，InnoDB引擎默认的事务隔离级别就是REPEATABLE-READ。</p>
<ul>
<li>幻读(Phantom read)：事务A读取与搜索条件相匹配的若干行，而事务B同时进行了添加、删除的操作，导致A每次结果都不一样，貌似出现了幻觉。设置事务隔离级别为SERIALIZABLE可以解决。</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><ul>
<li>更新丢失——Mysql所有事务隔离级别在数据库层面上均可避免。</li>
<li>脏读——READ-COMMITTED事务隔离级别以上可以避免</li>
<li>不可重复读——REPEATABLE-READ事务隔离级别以上可以避免</li>
<li>幻读——SERIALIZABLE事务隔离级别可避免</li>
</ul>
<p>如下图：</p>
<p><img src="https://s2.ax1x.com/2020/02/23/33EMr9.png" alt="33EMr9.png"></p>
<p>感觉上不可重复度和幻读这两个问题很相似。实际上，不可重复读侧重对同一数据的修改。幻读则侧重添加和删除。</p>
<p>数据库事务隔离级别越高，串行度越高。虽然可以避免错误的发生，但其并发性能会降低，效率会降低。Oracle默认为Read Committed、MySQL默认为REPETABLE READ。</p>
<h3 id="InnoDB可重复读隔离级别下如何避免幻读"><a href="#InnoDB可重复读隔离级别下如何避免幻读" class="headerlink" title="InnoDB可重复读隔离级别下如何避免幻读"></a>InnoDB可重复读隔离级别下如何避免幻读</h3><p><strong>表象：快照读(非阻塞读)——伪MVCC(多版本并发控制)</strong></p>
<p>表象不是真正原因。</p>
<p>当前读有以下操作：</p>
<blockquote>
<p>select … lock in share mode, select … for update </p>
<p>update, delete, insert</p>
</blockquote>
<p>当前读是加了锁的增删改查语句，不论是加了共享锁还是排它锁，都是当前读。当前读的特点是读取当前最新的记录，并且锁住当前数据使得其他事务不能修改数据。</p>
<p>当前读的操作原理：</p>
<p><img src="https://s2.ax1x.com/2020/02/23/33JNzd.png" alt="33JNzd.png"></p>
<ul>
<li>快照读：简单的select操作，不加锁的非阻塞读。<font color=#FF0000>当然，“不加锁”的前提是事务隔离级别不为Serializable，否则都是串行执行的，快照读就退化为当前读了。</font></li>
</ul>
<h4 id="RC、RR级别下的InnoDB的非阻塞读如何实现"><a href="#RC、RR级别下的InnoDB的非阻塞读如何实现" class="headerlink" title="RC、RR级别下的InnoDB的非阻塞读如何实现"></a>RC、RR级别下的InnoDB的非阻塞读如何实现</h4><ul>
<li><p>数据行里DB_TRX_ID, DB_ROLL_PTR, DB_ROW_ID字段</p>
<ul>
<li>DB_TRX_ID：最后一次对本行数据做修改的事务ID</li>
<li>DB_ROLL_PTR：回滚指针，undo日志记录</li>
<li>DB_ROW_ID：行号，单调递增。</li>
</ul>
</li>
<li><p>undo日志：当用户对数据产生变更时，就会产生undo记录。undo记录中存储的是老版数据。</p>
</li>
</ul>
<p>undo log包含两种：Insert undo log和update undo log。其中Insert undo log会记录Insert的操作，用于回滚，并且在commit只后可以立即丢弃，它不是重点。重点是update undo log。 事务对数据进行delete、update的时候会产生update undo log，它不仅在事务回滚的时候需要，快照读也需要，它不能随便删除，只有当数据库不需要此类日志的时候才会删除。</p>
<p>事务对某行的数据更新的过程：</p>
<p><img src="https://s2.ax1x.com/2020/02/24/33tSun.png" alt="33tSun.png"></p>
<p>流程：</p>
<ol>
<li>锁定该行</li>
<li>将该行的数据拷贝一份到undo log中</li>
<li>修改当前行的值</li>
<li>使用回滚指针指向undo log中修改前的行</li>
</ol>
<p>后面如果要对历史数据操作，可以去undo log里面找。</p>
<ul>
<li>read view：用来做可见性判断。当我们执行快照读select的时候，会针对查询的数据创建特定的read view来决定可以查看当前哪一个版本的数据。</li>
</ul>
<p>MVCC(Multi Version Concurrency Control)：多版本并发控制，读写不冲突。</p>
<h4 id="Gap锁"><a href="#Gap锁" class="headerlink" title="Gap锁"></a>Gap锁</h4><ul>
<li><p>Gap锁会用在非唯一索引或者不走索引的当前读中</p>
</li>
<li><p>走非唯一索引</p>
</li>
</ul>
<p><img src="https://s2.ax1x.com/2020/02/24/33I4ns.png" alt="33I4ns.png"></p>
<p>官方文档有介绍，给出需要修改的索引，会对对象的周边进行上锁，上锁的范围会是左开右闭的区间。</p>
<p><img src="https://s2.ax1x.com/2020/02/24/33oVud.png" alt="33oVud.png"></p>
<ul>
<li>不走索引</li>
</ul>
<p>若当前读不走索引，它会对所有的Gap都上锁，就类似锁表了，同样可以达到防止幻读的效果。</p>
<p><img src="https://s2.ax1x.com/2020/02/24/38SGWj.png" alt="38SGWj.png"></p>
<p>但是相比表锁，这样上锁的代价更大，会降低数据库的效率。</p>
<h4 id="锁模块之RR如何避免幻读"><a href="#锁模块之RR如何避免幻读" class="headerlink" title="锁模块之RR如何避免幻读"></a>锁模块之RR如何避免幻读</h4><p><strong>内在：next-key锁(行锁+gap锁)</strong></p>
<ul>
<li>行锁：对单个行记录上的锁</li>
<li>Gap锁：防止同一事务两次读，防止出现幻读</li>
</ul>
<p>主键或者唯一索引会用Gap锁么？——视情况而定</p>
<ul>
<li>如果where条件全部命中，则不用Gap锁，只会加记录锁</li>
<li>如果where条件部分命中或者全不命中，则会加Gap锁。Gap锁用在非唯一索引或不走索引的当前读中。</li>
</ul>
<p>需要注意，加锁的时候，如果我们走的时候主键之外的索引，那么我们需要对当前索引以及主键索引对应的记录都上锁。</p>
<p>加锁的具体情况举例：</p>
<p>当where条件全部命中的时候，不会加gap锁，只加记录锁。</p>
<p><img src="https://s2.ax1x.com/2020/02/24/33gGuV.png" alt="33gGuV.png"></p>
<h4 id="锁模块小结"><a href="#锁模块小结" class="headerlink" title="锁模块小结"></a>锁模块小结</h4><p>常见问题：</p>
<ul>
<li>MyISAM与InnoDB关于锁方面的区别是什么</li>
<li>数据库事务的四大特性</li>
<li>事务隔离级别以及各级别下的并发访问问题</li>
<li>InnoDB可重复读隔离级别下如何避免幻读</li>
<li>RC、RR级别下的InnoDB的非阻塞读如何实现</li>
</ul>
<h3 id="关键语法"><a href="#关键语法" class="headerlink" title="关键语法"></a>关键语法</h3><p>很多复杂的SQL都和查询、筛选相关。</p>
<ul>
<li>GROUP BY</li>
<li>HAVING</li>
<li>统计相关：COUNT, SUM, MAX, MIN, AVG</li>
</ul>
<p>和他们相关的，都是完成一些统计的任务。</p>
<h4 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h4><p>作用：根据给定数据列的每个成员，对查询结果进行分组统计，最终得到一个分组汇总表。</p>
<p>条件：</p>
<ul>
<li>满足”SELECT子句中的列明必须为分组列或列函数”。说白了意思就是，如果你用了GROUP BY,那么查询的结果要么包含GRAOUP BY使用的列，要么带有统计函数(COUNT, SUM, MAX ,MIN ,AVG等)相关的列。而且这个条件只针对同一张表成立。</li>
<li>列函数对于GROUP BY子句定义的每个组返回一个结果</li>
</ul>
<p>举一个例子，首先看举例的三张表之间的关系</p>
<p><img src="https://s2.ax1x.com/2020/02/24/38uMnS.png" alt="38uMnS.png"></p>
<p>其中学生通过主键student_id与score连接，course通过主键course_id和score连接。</p>
<p>不同表的建立语句：</p>
<p>student表：<br><img src="https://s2.ax1x.com/2020/02/24/38voG9.png" alt="38voG9.png"></p>
<p>course表：<br><img src="https://s2.ax1x.com/2020/02/24/38v7x1.png" alt="38v7x1.png"></p>
<p>score表：<br><img src="https://s2.ax1x.com/2020/02/24/38vT2R.png" alt="38vT2R.png"></p>
<p>完成查询的功能：</p>
<blockquote>
<p>查询所有同学的学号、选课数、总成绩</p>
</blockquote>
<p>解决这类写SQL问题的技巧之一，就是根据题目描述，写出所有可能的子SQL，然后再把这些子SQL拼接起来，达到要求。</p>
<p>比如这里要查询所有同学，所以要用学生表的主键: group by student_id</p>
<p>然后需要查询学生的学号、选课数、总成绩，所以需要select:<br>select student_id,count(course_id),sum(score);</p>
<p>而同时出现了学生、课程和分数的表，只有score表：from score</p>
<p>整合上面这些子SQL，可以写出：</p>
<blockquote>
<p>select student_id,count(course_id),sum(score)</p>
<p>from score</p>
<p>group by student_id;</p>
</blockquote>
<p>group by 会按照student_id把学生进行分组，然后count()和sum()函数会针对每个组进行聚合计算。</p>
<p>列函数会对于group by子句定义的每个组各返回一个结果。</p>
<p>如果选了group by,那么你的select 语句中选出的列要么是你group by里用到的列，要么就是带有之前sum,count等列函数的列。<font color=#FF0000>但是这个理论只针对同一张表有效。</font></p>
<p>比如要解决这个查询问题：</p>
<blockquote>
<p>查询所有同学的学号、姓名、选课数、总成绩</p>
</blockquote>
<p>相比之前的查询，多了一个姓名。此时只从score中查询就不够了，需要联合student表取出列名。</p>
<blockquote>
<p>select s.studnet_id, stu.name, count(s.course_id),sum(s.score)</p>
<p>from</p>
<p>score s, student stu</p>
<p>where</p>
<p>s.studnet_id = stu.student_id</p>
<p>group by s.student_id; </p>
</blockquote>
<p>注意，where一定要写在group by前面，</p>
<p>结合这个新的例子，我们可以知道：group by里面出现某个表的字段，select里面的列要么是该group by里出现的列，要么是别的表的列或者带有函数的列。</p>
<h4 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h4><p>如果没有group by子句，那么having和where是可以互换的。</p>
<ul>
<li>通常与group by一起使用。当它与group by一起使用时，可以放在group by 后面作为过滤的条件。HAVING相当于所有where的操作符</li>
<li>WHERE过滤行，HAVING过滤组</li>
<li>出现在同一sql的顺序：WHERE &gt; GROUP BY &gt; HAVING</li>
</ul>
<p>还是以之前三张表为例，完成这个查询：<strong>查询平均成绩大于60分的同学的学号和平均成绩</strong></p>
<blockquote>
<p>select student_id,avg(score)</p>
<p>from score</p>
<p>group by student_id</p>
<p>having avg(score)&gt;60 </p>
</blockquote>
<p><strong>取出studnet_id为1的学生的成绩情况</strong></p>
<blockquote>
<p>select * from score where student_ir=1;</p>
</blockquote>
<p>下面这个写法结果相同：</p>
<blockquote>
<p>select * from score having student_id=1;</p>
</blockquote>
<p><strong>查询没有学全所有课的同学的学号、姓名</strong></p>
<blockquote>
<p>select studnet_id,name</p>
<p>from</p>
<p>studnet stu,</p>
<p>score s</p>
<p>where stu.studnet_id = s.student_id</p>
<p>group by s.student_id</p>
<p>having count( * )&lt;(select count( * ) from course)</p>
</blockquote>
<p>最后需要结合大量实战题目，才能提升编写SQL的能力和基本功。</p>
]]></content>
      <categories>
        <category>Interview Note</category>
      </categories>
      <tags>
        <tag>DataBase</tag>
        <tag>Interview</tag>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Analysis of LeetCode High Frequency Problems IV</title>
    <url>/2020/02/12/Analysis-of-LeetCode-High-Frequency-Problems-IV/</url>
    <content><![CDATA[<p>详细讲解LeetCode考察较多的3道题目：336、340、407。</p>
<a id="more"></a>

<h2 id="336-Palindrome-Pairs-回文对-Hard"><a href="#336-Palindrome-Pairs-回文对-Hard" class="headerlink" title="336.Palindrome Pairs(回文对)(Hard)"></a><a href="https://leetcode-cn.com/problems/palindrome-pairs/" target="_blank" rel="noopener">336.Palindrome Pairs(回文对)(Hard)</a></h2><h2 id="340-longest-Substring-with-at-most-k-distinct-characters-至多包含K个不同字符的最长子串-Hard"><a href="#340-longest-Substring-with-at-most-k-distinct-characters-至多包含K个不同字符的最长子串-Hard" class="headerlink" title="340.longest Substring with at most k distinct characters(至多包含K个不同字符的最长子串)(Hard)"></a><a href="https://leetcode-cn.com/problems/longest-substring-with-at-most-k-distinct-characters/" target="_blank" rel="noopener">340.longest Substring with at most k distinct characters(至多包含K个不同字符的最长子串)(Hard)</a></h2><h2 id="407-Trapping-rain-water-ii-接雨水-II-Hard"><a href="#407-Trapping-rain-water-ii-接雨水-II-Hard" class="headerlink" title="407.Trapping rain water ii(接雨水 II)(Hard)"></a><a href="https://leetcode-cn.com/problems/trapping-rain-water-ii/" target="_blank" rel="noopener">407.Trapping rain water ii(接雨水 II)(Hard)</a></h2>]]></content>
      <categories>
        <category>Algorithms Note</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Analysis of LeetCode High Frequency Problems III</title>
    <url>/2020/02/12/Analysis-of-LeetCode-High-Frequency-Problems-III/</url>
    <content><![CDATA[<p>详细讲解LeetCode考察较多的3道题目：10、84、28。</p>
<a id="more"></a>

<h2 id="10-Regular-Expression-Matching-正则表达式匹配-Hard"><a href="#10-Regular-Expression-Matching-正则表达式匹配-Hard" class="headerlink" title="10.Regular Expression Matching(正则表达式匹配)(Hard)"></a><a href="https://leetcode-cn.com/problems/regular-expression-matching/" target="_blank" rel="noopener">10.Regular Expression Matching(正则表达式匹配)(Hard)</a></h2><p>Given an input string (<code>s</code>) and a pattern (<code>p</code>), implement regular expression matching with support for <code>&#39;.&#39;</code> and <code>&#39;*&#39;</code>.</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="string">'.'</span> Matches <span class="keyword">any</span> single <span class="keyword">character</span>.</span><br><span class="line"><span class="string">'*'</span> Matches <span class="literal">zero</span> <span class="keyword">or</span> more <span class="keyword">of</span> <span class="keyword">the</span> preceding <span class="keyword">element</span>.</span><br></pre></td></tr></table></figure>

<p>The matching should cover the <strong>entire</strong> input string (not partial).</p>
<p><strong>Note:</strong></p>
<ul>
<li><code>s</code> could be empty and contains only lowercase letters <code>a-z</code>.</li>
<li><code>p</code> could be empty and contains only lowercase letters <code>a-z</code>, and characters like <code>.</code> or <code>*</code>.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">Input:</span></span><br><span class="line">s = <span class="string">"aa"</span></span><br><span class="line">p = <span class="string">"a"</span></span><br><span class="line"><span class="string">Output:</span> <span class="literal">false</span></span><br><span class="line"><span class="string">Explanation:</span> <span class="string">"a"</span> does not match the entire string <span class="string">"aa"</span>.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = <span class="string">"aa"</span></span><br><span class="line">p = <span class="string">"a*"</span></span><br><span class="line">Output: <span class="literal">true</span></span><br><span class="line">Explanation: <span class="string">'*'</span> means <span class="literal">zero</span> <span class="keyword">or</span> more <span class="keyword">of</span> <span class="keyword">the</span> preceding <span class="keyword">element</span>, <span class="string">'a'</span>. Therefore, <span class="keyword">by</span> repeating <span class="string">'a'</span> once, <span class="keyword">it</span> becomes <span class="string">"aa"</span>.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">Input:</span></span><br><span class="line">s = <span class="string">"ab"</span></span><br><span class="line">p = <span class="string">".*"</span></span><br><span class="line"><span class="string">Output:</span> <span class="literal">true</span></span><br><span class="line"><span class="string">Explanation:</span> <span class="string">".*"</span> means <span class="string">"zero or more (*) of any character (.)"</span>.</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = <span class="string">"aab"</span></span><br><span class="line">p = <span class="string">"c*a*b"</span></span><br><span class="line">Output: <span class="literal">true</span></span><br><span class="line">Explanation: c can be repeated <span class="number">0</span> <span class="keyword">times</span>, a can be repeated <span class="number">1</span> <span class="built_in">time</span>. Therefore, <span class="keyword">it</span> matches <span class="string">"aab"</span>.</span><br></pre></td></tr></table></figure>

<p><strong>Example 5:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">Input:</span></span><br><span class="line">s = <span class="string">"mississippi"</span></span><br><span class="line">p = <span class="string">"mis*is*p*."</span></span><br><span class="line"><span class="section">Output: false</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：如果可以调库，可以利用String的<code>matches</code>方法来判断即可：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(<span class="keyword">String</span> s, <span class="keyword">String</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.matches(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是上面的操作其实更像是一个玩笑(^_^)</p>
<p>这道题是可以用动态规划解决的经典问题，用动态规划自底向上地解决这道题，可以避免在过程中产生的重复的计算过程。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span>ean isMatch(String s, String p) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span> || p == <span class="literal">null</span>) <span class="keyword">return</span> s.equals(p);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> m = s.length(), n = p.length();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 状态dp[i][j]表示s的前i个能否被p的前j个匹配</span></span><br><span class="line">        <span class="built_in">bool</span>ean[][] dp = new <span class="built_in">bool</span>ean[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化dp[0][0]等于true,表示当两字符串长度都为0，也就是空</span></span><br><span class="line">        <span class="comment">// 字符串时，他们互相匹配</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 最重要的步骤之一</span></span><br><span class="line">        <span class="comment">// 初始化二维矩阵第一列所有值：</span></span><br><span class="line">        <span class="comment">// 当s为空字符串时，对p字符串的任一位置，要使得这个位置的子串能和空字符串匹配，</span></span><br><span class="line">        <span class="comment">// 要求，这个子串都是由一系列的型号组合构成</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="comment">// 注意因为申请boolean数组是长度+1，所以p的charAt位置和j的位置相差1，即j-1位置是p.charAt的位置</span></span><br><span class="line">            dp[<span class="number">0</span>][j] = j &gt; <span class="number">1</span> &amp;&amp; p.charAt(j<span class="number">-1</span>) == <span class="string">'*'</span> &amp;&amp; dp[<span class="number">0</span>][j<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 接下来就是给这个二维矩阵填表了,逻辑和递归一模一样</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="comment">// p的当前字符不是星号(*)时，判断当前两字符是否相等，如果相等，则看看dp[i-1][j-1]的值，</span></span><br><span class="line">                <span class="comment">// 因为它保存了前一个匹配的结果</span></span><br><span class="line">                <span class="keyword">if</span>(p.charAt(j - <span class="number">1</span>) != <span class="string">'*'</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] &amp;&amp; isMatch(s.charAt(i - <span class="number">1</span>), p.charAt(j<span class="number">-1</span>));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 当p当前字符是星号(*)时,进行两种尝试：</span></span><br><span class="line">                    <span class="comment">// -用星号组合表示空字符串，看看是否能匹配，即dp[i][j-2]</span></span><br><span class="line">                    <span class="comment">// -用星号组合表示一个字符，看看是否能匹配，即dp[i-1][j]</span></span><br><span class="line">                    dp[i][j] = dp[i][j<span class="number">-2</span>] || dp[i<span class="number">-1</span>][j] &amp;&amp; isMatch(s.charAt(i<span class="number">-1</span>),p.charAt(j<span class="number">-2</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">bool</span>ean isMatch(char a, char b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a == b || b == <span class="string">'.'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态规划方法的复杂度：</p>
<ul>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(n^2)</li>
</ul>
<h2 id="84-Largest-Rectangle-in-Histogram-柱状图中最大的矩形-Hard"><a href="#84-Largest-Rectangle-in-Histogram-柱状图中最大的矩形-Hard" class="headerlink" title="84.Largest Rectangle in Histogram(柱状图中最大的矩形)(Hard)"></a><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">84.Largest Rectangle in Histogram(柱状图中最大的矩形)(Hard)</a></h2><h2 id="28-implement-strstr-实现strStr-Easy"><a href="#28-implement-strstr-实现strStr-Easy" class="headerlink" title="28.implement-strstr(实现strStr())(Easy)"></a><a href="https://leetcode-cn.com/problems/implement-strstr/" target="_blank" rel="noopener">28.implement-strstr(实现strStr())(Easy)</a></h2>]]></content>
      <categories>
        <category>Algorithms Note</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Analysis of LeetCode High Frequency Problems II</title>
    <url>/2020/02/12/Analysis-of-LeetCode-High-Frequency-Problems-II/</url>
    <content><![CDATA[<p>详细讲解LeetCode考察较多的3道题目：56、435、269。</p>
<a id="more"></a>


<h2 id="56-Merge-Intervals-合并区间-Mid"><a href="#56-Merge-Intervals-合并区间-Mid" class="headerlink" title="56.Merge Intervals(合并区间)(Mid)"></a><a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">56.Merge Intervals(合并区间)(Mid)</a></h2><h2 id="435-Non-Overlapping-Intervals-无重叠区间-Mid"><a href="#435-Non-Overlapping-Intervals-无重叠区间-Mid" class="headerlink" title="435.Non Overlapping Intervals(无重叠区间)(Mid)"></a><a href="https://leetcode-cn.com/problems/non-overlapping-intervals" target="_blank" rel="noopener">435.Non Overlapping Intervals(无重叠区间)(Mid)</a></h2><h2 id="269-Alien-Dictionary-火星词典-Hard"><a href="#269-Alien-Dictionary-火星词典-Hard" class="headerlink" title="269.Alien Dictionary(火星词典)(Hard)"></a><a href="https://leetcode-cn.com/problems/alien-dictionary/" target="_blank" rel="noopener">269.Alien Dictionary(火星词典)(Hard)</a></h2>]]></content>
      <categories>
        <category>Algorithms Note</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Analysis of LeetCode High Frequency Problems I</title>
    <url>/2020/02/12/Analysis-of-LeetCode-High-Frequency-Problems-I/</url>
    <content><![CDATA[<p>详细讲解LeetCode考察较多的3道题目：03、04、23。</p>
<a id="more"></a>

<h2 id="3-Longest-Substring-Without-Repeating-Characters-无重复字符的最长子串-Mid"><a href="#3-Longest-Substring-Without-Repeating-Characters-无重复字符的最长子串-Mid" class="headerlink" title="3.Longest Substring Without Repeating Characters(无重复字符的最长子串)(Mid)"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3.Longest Substring Without Repeating Characters(无重复字符的最长子串)(Mid)</a></h2><p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">Input: <span class="string">"abcabcbb"</span></span><br><span class="line">Output: <span class="number">3</span> </span><br><span class="line">Explanation: The answer <span class="keyword">is</span> <span class="string">"abc"</span>, <span class="keyword">with</span> <span class="keyword">the</span> <span class="built_in">length</span> <span class="keyword">of</span> <span class="number">3.</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">Input: <span class="string">"bbbbb"</span></span><br><span class="line">Output: <span class="number">1</span></span><br><span class="line">Explanation: The answer <span class="keyword">is</span> <span class="string">"b"</span>, <span class="keyword">with</span> <span class="keyword">the</span> <span class="built_in">length</span> <span class="keyword">of</span> <span class="number">1.</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Input: <span class="string">"pwwkew"</span></span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is <span class="string">"wke"</span>, with the length of 3. </span><br><span class="line">            <span class="built_in"> Note </span>that the answer must be a substring, <span class="string">"pwke"</span> is a subsequence <span class="keyword">and</span> <span class="keyword">not</span> a substring.</span><br></pre></td></tr></table></figure>

<hr>
<p>解：<strong>解法一：暴力法</strong></p>
<p>找到所有子串，然后每一个子串都一个一个地去判断是否有重复的字符。</p>
<p>要分析这个方法的时间复杂度，首先我们需要弄清楚一些问题，假设字符串长度为n，那么它有多少个非空子串？</p>
<p>答案是 n*(n+1)/2 个。</p>
<p>怎么计算出来的？</p>
<ul>
<li>长度为1的子串，有n个</li>
<li>长度为2的子串，有n-1个</li>
<li>长度为3的子串，有n-2个</li>
</ul>
<p>…</p>
<ul>
<li>长度为k的子串，有n-k+1个</li>
<li>当k=n时，n-k+1=1，即长度为n的子串就是1个</li>
</ul>
<p>所有情况相加，可以得到：<br>n+(n-1)+(n-2)+(n-3)+…+2+1 = n(n+1)/2<br>算上空字符串，一共有：(n(n+1)/2) + 1</p>
<p>在这里可以进行对比，子串和子序列的区别。比如，对于长度为n的字符串，一共有多少子序列？</p>
<p>答案是2^n</p>
<p>怎么计算得到的？</p>
<ul>
<li><p>子序列不同于子串</p>
</li>
<li><p>子序列中的元素不需要相互挨着</p>
</li>
<li><p>长度为1的子序列有n个，即：C(1,n)</p>
</li>
<li><p>长度为2的子序列有C(2,n)个</p>
</li>
<li><p>长度为3的子序列有C(3,n)个</p>
</li>
</ul>
<p>…</p>
<ul>
<li>长度为k的子序列有C(k,n)个</li>
<li>所有子序列的个数(包括空序列)为：C(0,n) + C(1,n) + C(2,n) + C(3,n) + … + C(n,n) = 2^n</li>
</ul>
<p>这里有关统计字符串的子串和子序列的过程和方法，和结果，务必熟悉和记下来，对于分析各种问题能有帮助。</p>
<p>如果对所有的子串进行判断，从每个子串里寻找最长且没有重复字符的，复杂度为：O(n* (n+1)/2 * n) = O(n^3)</p>
<p>当然，这不是最好的办法。</p>
<p><strong>解法二：线性法</strong></p>
<ul>
<li>把每次遍历到的字符放入到一个哈希集合中，这样每次判断当前遍历过的内容中是否包含下一个要遍历的字符的时候，用哈希表的contains方法，时间复杂度为O(1),比不放到哈希表中的O(n)的速度能够得到提高。</li>
</ul>
<p>具体解法：</p>
<ul>
<li>定义一个哈希集合set</li>
<li>从给定字符串的头开始，每次检查当前字符是否在集合内。如果不在，说明该字符不会造成冲突和重复，将其加入到集合中，并统计当前集合长度，或许为最长子串</li>
</ul>
<p>如果出现了重复的子串，处理方法是定义两个指针，i为慢指针，j为快指针。</p>
<p>当 j 遇到一个重复出现的字符时，我们从慢指针开始一个一个地将 i 指针指向的字符从集合中删除，然后判断是否可以把新字符加入到集合而不会重复。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义一个哈希集合set,初始化结果max为0</span></span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 利用快慢指针i(慢)和j(快)扫描一遍字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; j &lt; s.length(); j++) &#123;</span><br><span class="line">            <span class="comment">// 如果快指针指向的字符已经出现在哈希集合中,不断尝试将慢指针指向的字符从哈希集合中删除</span></span><br><span class="line">            <span class="keyword">while</span>(set.contains(s.charAt(j))) &#123;</span><br><span class="line">                set.remove(s.charAt(i));</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 当快指针的字符终于能加入到哈希集合的时候，更新结果max</span></span><br><span class="line">            set.add(s.charAt(j));</span><br><span class="line">            max = Math.max(max, set.size());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历完毕后，返回结果max</span></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度分析：O(n)。使用了快慢指针策略，字符串最多被遍历两次。快指针会被添加到哈希表集合，慢指针遇到的字符会从哈希集合中删除。哈希集合操作时间为O(1)，因此整个算法复杂度为：n * O(1) + n*O(1) = O(n)</li>
<li>空间复杂度分析：O(n)。由于使用到哈希集合，最坏的情况下，即给定的字符串没有任何重复的字符，我们需要把每个字符都加入集合。</li>
</ul>
<p><strong>解法三：优化的线性法</strong></p>
<p>基于方法二的线性法。也就是，如果我们在遍历过程中遇到了set已经有的字符的时候，如何不让慢指针一步一步移动，而是直接移动到重复元素的后面呢？这样可以大大减少比较次数。</p>
<p>这样一来我们需要能够记录每个字符出现的下标位置，可以用哈希表记录，因为查找过程时间复杂度也是O(1)</p>
<p>而且此时，我们不能像之前一样去数哈希集合的元素作为max的结果。比如可能出现一种情况，就是当前快指针j遍历到的元素在之前已经出现过了，那么此时不能让i又跳回到前面去呀！所以i的值需要有max计算得到：i = Math.max(i, map.get(s.charAt(j) + 1));</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义一个哈希表map用来记录上次某字符出现的位置,初始化结果max为0</span></span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 利用快慢指针i(慢)和j(快)扫描一遍字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; j &lt; s.length(); j++) &#123;</span><br><span class="line">            <span class="comment">// 如果发现快指针所对应的字符已经出现过，慢指针就进行跳跃</span></span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(s.charAt(j))) &#123;</span><br><span class="line">                i = Math.max(i, map.get(s.charAt(j)) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 把快指针所对应的字符添加到哈希表中，更新结果max</span></span><br><span class="line">            map.put(s.charAt(j), j);</span><br><span class="line">            max = Math.max(max, j - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历完毕后，返回结果max</span></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-Median-of-Two-Sorted-Arrays-寻找两个有序数组的中位数-Hard"><a href="#4-Median-of-Two-Sorted-Arrays-寻找两个有序数组的中位数-Hard" class="headerlink" title="4.Median of Two Sorted Arrays(寻找两个有序数组的中位数)(Hard)"></a><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays" target="_blank" rel="noopener">4.Median of Two Sorted Arrays(寻找两个有序数组的中位数)(Hard)</a></h2><p>There are two sorted arrays <strong>nums1</strong> and <strong>nums2</strong> of size m and n respectively.</p>
<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
<p>You may assume <strong>nums1</strong> and <strong>nums2</strong> cannot be both empty.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">nums1 = [<span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">nums2 = [<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">The median <span class="keyword">is</span> <span class="number">2.0</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">nums1 = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">nums2 = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">The median <span class="keyword">is</span> (<span class="number">2</span> + <span class="number">3</span>)/<span class="number">2</span> = <span class="number">2.5</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：</p>
<p>油管上有关这道题的非常好的讲解：<a href="https://www.youtube.com/watch?v=CMjAo8_8JYM" target="_blank" rel="noopener">“Median of two sorted Arrays”: A Google Software Engineering Interview Question PART 1</a></p>
<p>解法一：暴力法</p>
<ul>
<li>利用归并排序的思想将它们合并成一个长度为m+n的有序数组</li>
<li>合并的时间复杂度为 m+n，从中选取中位数</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] mergedArray = mergeTwoSortedArray(nums1,nums2);</span><br><span class="line">        <span class="keyword">int</span> n = mergedArray.length;</span><br><span class="line">        <span class="comment">// 先排好序，再返回中位数</span></span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//若排好序的数组为偶数个，则取中间两个的平均数</span></span><br><span class="line">            <span class="keyword">return</span> (mergedArray[(n-<span class="number">1</span>) / <span class="number">2</span>] + mergedArray[n/<span class="number">2</span>]) / <span class="number">2.0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//总元素个数为奇数个，则选取中间那个</span></span><br><span class="line">            <span class="keyword">return</span> mergedArray[n/<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] mergeTwoSortedArray(<span class="keyword">int</span>[] nums1,<span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] merged = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length + nums2.length];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//两个array同时扫描</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums1.length &amp;&amp; j &lt; nums2.length) &#123;</span><br><span class="line">            merged[k++] = nums1[i] &lt; nums2[j] ? nums1[i++] : nums2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums1.length) &#123;</span><br><span class="line">            merged[k++] = nums1[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; nums2.length) &#123;</span><br><span class="line">            merged[k++] = nums2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> merged;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>整体时间复杂度为O(m+n)，要大于题目要求的O(log(m+n))，不符合要求</li>
<li>空间复杂度：O(m+n)</li>
</ul>
<p>可以自然地想到要用Binary Search</p>
<p>解法二：切分法，比较偏重数学</p>
<p>这种方法需要考虑m+n为奇数还是偶数。假设m+n=L，</p>
<ul>
<li>如果L为奇数，即两个数组元素总个数为奇数，则中位数为第：int(L/2)+1小的数。</li>
<li>如果L为偶数，则中位数为第 int(L/2) 小于int(L/2)+1小的数求和的平均值。</li>
</ul>
<p>所以我们的问题转变成了，在两个有序数组中寻找第k小的数，f(k)</p>
<ul>
<li>当L为奇数时，若令 k=L/2，则结果为f(k+1)</li>
<li>当L为偶数时，结果为：(f(k) + f(k+1))/2</li>
</ul>
<p>那么接下来的问题是，怎么从两个排好序的数组中找到第k小的数呢？</p>
<p>假设nums1[] = {a0, a1, a2, a3, a4}、nums2[] = {b0, b1, b2, b3}<br>举例，如果从nums1和nums2中分别取出k1和k2个元素：</p>
<p><img src="https://s2.ax1x.com/2020/02/17/3iuZt0.png" alt="3iuZt0.png"></p>
<ol>
<li>a2=b1，这种算是最舒服的情况了,此时a2或者b1就是我们要找的第k小的数。因为此时我们如果把a0, a1, a2, b0, b1按照大小顺序合并在一起，那么a2和b1肯定排在最后，a0, a1 和b0都排在前面，不需要考虑这三个的大小关系。</li>
<li>a2&lt;b1， 这种情况开始不舒服了，我们无法肯定a2和b1是第五小的数。但是这种情况下我们可以确定，第五小的数一定不会是a0, a1, a2中的一个，同时也不会是b2和b3中的一个。所以，整个的搜索范围可以缩小为：{a3, a4, b0, b1}</li>
<li>a2&gt;b1，我们同样无法肯定a2和b1是第五小的数。但是这种情况下我们可以确定，第五小的数不可能是b0, b1和a3, a4。所以这种情况下，整个搜索范围可以缩小为：{a0, a1, a2, b2, b3}</li>
</ol>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据两个字符串长度的总和判断如何调用递归函数以及返回结果</span></span><br><span class="line">        <span class="keyword">int</span> m = nums1.length, n = nums2.length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> k = (m + n) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>((m+n) % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 当总长度为奇数时，返回正中间的数</span></span><br><span class="line">            <span class="keyword">return</span> findKth(nums1, <span class="number">0</span>, m-<span class="number">1</span>, nums2, <span class="number">0</span>, n-<span class="number">1</span>, k+<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当总长度为偶数时，返回两个数的平均值</span></span><br><span class="line">            <span class="keyword">return</span> (findKth(nums1, <span class="number">0</span>, m-<span class="number">1</span>, nums2, <span class="number">0</span>, n-<span class="number">1</span>, k) + </span><br><span class="line">                    findKth(nums1, <span class="number">0</span>, m-<span class="number">1</span>, nums2, <span class="number">0</span>, n-<span class="number">1</span>, k+<span class="number">1</span>)) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进入findKth,这个函数目的是寻找第k小的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findKth</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> start1, <span class="keyword">int</span> end1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> start2, <span class="keyword">int</span> end2, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = end1 - start1 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n = end2 - start2 + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果nums1数组的长度大于nums2数组的长度，将二者互换，加快程序结束的速度</span></span><br><span class="line">        <span class="keyword">if</span>(m &gt; n) &#123;</span><br><span class="line">            <span class="keyword">return</span> findKth(nums2, start2, end2, nums1, start1, end1, k);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当nums1数组长度为0的时候，直接返回nums2数组中第k小的数</span></span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums2[start2 + k - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当k == 1时，返回两个数组中的最小值</span></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.min(nums1[start1], nums2[start2]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 分别选两个数组的中间数</span></span><br><span class="line">        <span class="keyword">int</span> na = Math.min(k/<span class="number">2</span>, m);</span><br><span class="line">        <span class="keyword">int</span> nb = k - na;</span><br><span class="line">        <span class="keyword">int</span> va = nums1[start1 + na -<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> vb = nums2[start2 + nb -<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 比较下两者的大小</span></span><br><span class="line">        <span class="comment">// 如果相等，表明中位数已经找到，返回该值即可</span></span><br><span class="line">        <span class="keyword">if</span>(va == vb) &#123;</span><br><span class="line">            <span class="keyword">return</span> va;</span><br><span class="line">            <span class="comment">// 如果不相等，进行剪枝处理</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(va &lt; vb) &#123;</span><br><span class="line">            <span class="keyword">return</span> findKth(nums1, start1 + na, end1, nums2,start2,  start2 + nb - <span class="number">1</span>, k - na);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> findKth(nums1, start1, start1 + na - <span class="number">1</span>, nums2, start2 + nb, end2, k - nb);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解法三：二分查找</p>
<p>首先，我们需要利用两个数组已经是有序的这么一个性质，从A和B这两个数组中找到分割点，那么剩下的数字个数就是符合二分查找的数字数量。</p>
<p>我们需要把握住一个特质：分割完之后，我们需要让A和B两个数组符合这个要求：A的分割点左边数组的最大值要小于B的分割点右边的最小值，而且B的分割点左边数组的最大值要小于A的分割点右边的最小值(<font color=#FF0000>这个条件很至关重要，满足了这个条件，就算找到了目标分割线。</font>)。样例如下图：</p>
<p><img src="https://i.loli.net/2020/04/24/2KalmBA3N8TLZbg.png" alt="04题二分查找的示意图.png"></p>
<p>因为题目提到了要求时间复杂度小于O(log(m+n))一下，所以自然想到二分查找。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lenA = A.length, lenB = B.length;</span><br><span class="line">        <span class="comment">//如果A不是较短的，则交换位置。因为下面的操作默认A是较短的数组</span></span><br><span class="line">        <span class="comment">//为什么选较短的？——选短的，二分查找也能更快。</span></span><br><span class="line">        <span class="keyword">if</span>(lenA &gt; lenB) &#123;</span><br><span class="line">            <span class="keyword">return</span> findMedianSortedArrays(B,A);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//特殊情况，如果A和B中短的数组是空的，那么直接返回另一个数组的中位数即可</span></span><br><span class="line">        <span class="keyword">if</span>(lenA == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((<span class="keyword">double</span>) B[(lenB - <span class="number">1</span>) / <span class="number">2</span>] + (<span class="keyword">double</span>) B[lenB / <span class="number">2</span>]) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//新数组总长度为len</span></span><br><span class="line">        <span class="keyword">int</span> len = lenA + lenB;</span><br><span class="line">        <span class="comment">//上面已经提到，整个过程只对数组A进行binary search，所以只定义A的Start和End来维护</span></span><br><span class="line">        <span class="comment">//每次binary search的范围</span></span><br><span class="line">        <span class="keyword">int</span> AStartK = <span class="number">0</span>, AEndK = lenA;</span><br><span class="line">        <span class="comment">// cutA记录数组分割的左边元素个数、cutB记录分割的左边元素个数</span></span><br><span class="line">        <span class="keyword">int</span> cutA, cutB;</span><br><span class="line">        <span class="keyword">while</span>(AStartK &lt;= AEndK) &#123;</span><br><span class="line">            cutA = (AStartK + AEndK) / <span class="number">2</span>;</span><br><span class="line">            cutB = len / <span class="number">2</span> - cutA;</span><br><span class="line">            <span class="comment">//L1=Integer.MIN_VALUE和L2=Integer.MIN_VALUE这两种情况肯定是不同时出现的，这样在后面Math.max(L1, L2)那里就可以让另外一个不等于Integer.MIN_VALUE的稳定当选</span></span><br><span class="line">            <span class="keyword">double</span> L1 = (cutA == <span class="number">0</span>) ? Integer.MIN_VALUE : A[cutA - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">double</span> L2 = (cutB == <span class="number">0</span>) ? Integer.MIN_VALUE : B[cutB - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">//R1和R2同理</span></span><br><span class="line">            <span class="keyword">double</span> R1 = (cutA == lenA) ? Integer.MAX_VALUE : A[cutA];</span><br><span class="line">            <span class="keyword">double</span> R2 = (cutB == lenB) ? Integer.MAX_VALUE : B[cutB];</span><br><span class="line">            <span class="keyword">if</span>(L1 &gt; R2) &#123;</span><br><span class="line">                AEndK = cutA - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(L2 &gt; R1) &#123;</span><br><span class="line">                AStartK = cutA + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(len % <span class="number">2</span> == <span class="number">0</span>) &#123; <span class="comment">//如果合并之后数组元素个数为偶数</span></span><br><span class="line">                    <span class="comment">//则要取L1和L2的最大值与R1、R2的最小值的平均数</span></span><br><span class="line">                    <span class="keyword">return</span> (Math.max(L1, L2) + Math.min(R1,R2)) / <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果合并后元素个数为奇数，则直接在L1和L2中更小的即可</span></span><br><span class="line">                    <span class="keyword">return</span> Math.min(R1,R2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(logm)，m为较短的数组的长度</li>
<li>空间复杂度：O(1)</li>
</ul>
<h2 id="23-Merge-k-Sorted-Lists-合并K个排序链表-Hard"><a href="#23-Merge-k-Sorted-Lists-合并K个排序链表-Hard" class="headerlink" title="23.Merge k Sorted Lists(合并K个排序链表)(Hard)"></a><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">23.Merge k Sorted Lists(合并K个排序链表)(Hard)</a></h2><p>Merge <em>k</em> sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>,</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>,</span><br><span class="line">  <span class="number">2</span>-&gt;<span class="number">6</span></span><br><span class="line">]</span><br><span class="line">Output: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span></span><br></pre></td></tr></table></figure>
<hr>
<p>解：<strong>解法一：暴力法</strong></p>
<ul>
<li>用一个数组保存所有链表中的数，之后进行排序，再从头到尾将数组遍历，生成一个排好序的链表</li>
<li>假设每个链表平均长度为n,整体时间复杂度为O(nk * log(nk))，偏大</li>
</ul>
<p><strong>解法二：最小堆</strong></p>
<ul>
<li>每次比较k个链表头，时间复杂度为O(k)</li>
<li>对k个链表头创建一个大小为k的最小堆<ul>
<li>创建一个大小为k的最小堆所需时间为O(k)</li>
<li>从堆中取最小的数，所需时间都是O(logk)</li>
<li>如果每个链表平均长度为n，则共有nk个元素，即用大小为k的最小堆过滤nk个元素</li>
<li>整体时间复杂度为O(nk*log(k))</li>
<li>空间复杂度为O(k)，我们有k个list，占据k个空间</li>
</ul>
</li>
</ul>
<p>我们一直维护这个大小为k的最小堆，直到遍历完所有链表的节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果输入为[]，边界条件</span></span><br><span class="line">        <span class="keyword">if</span>(lists.length == <span class="number">0</span> || lists == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 利用一个空的链表头方便我们插入节点</span></span><br><span class="line">        ListNode fakeHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>), p = fakeHead;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义一个最小堆来保存k个链表节点</span></span><br><span class="line">        <span class="keyword">int</span> k = lists.length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将k个链表的头放到最小堆中,因为使用ListNode数据结构，所以重新定义比较器</span></span><br><span class="line">        PriorityQueue&lt;ListNode&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k, <span class="keyword">new</span> Comparator&lt;ListNode&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(ListNode a, ListNode b)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a.val - b.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从k个链表中将当前最小节点取出，插入到结果链表中</span></span><br><span class="line">        <span class="comment">// 每条链表都会有一个指针i，这个for把每条链表的第一个加入到小顶堆中</span></span><br><span class="line">        <span class="comment">// 因为本身就有k个链表，所以相当于初始化的步骤</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(lists[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                heap.offer(lists[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 真正使用最小堆的操作，将堆中元素一个一个取出，插入到结果链表中</span></span><br><span class="line">        <span class="keyword">while</span>(!heap.isEmpty()) &#123;</span><br><span class="line">            ListNode node = heap.poll();</span><br><span class="line">            </span><br><span class="line">            p.next = node;</span><br><span class="line">            p = p.next;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// p是结果链表节点，node是当前遍历的节点</span></span><br><span class="line">            <span class="comment">// 如果当前链表有后续节点，在poll()了它之后自然要访问它后续节点</span></span><br><span class="line">            <span class="keyword">if</span>(node.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                heap.offer(node.next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 最后返回结果链表</span></span><br><span class="line">        <span class="keyword">return</span> fakeHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述定义小顶堆的代码也可以用Lambda表达式简化：</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">PriorityQueue&lt;ListNode&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(</span><br><span class="line">    (a,b) -&gt; a.val - b.val</span><br><span class="line">);</span><br></pre></td></tr></table></figure>


<p><strong>解法三：分治法</strong></p>
<p>利用分治思想，非常类似归并排序操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主函数非常类似归并排序的过程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果输入为[]，边界条件</span></span><br><span class="line">    <span class="keyword">if</span>(lists.length == <span class="number">0</span> || lists == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(low == high) <span class="keyword">return</span> lists[low];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从中间切一刀</span></span><br><span class="line">    <span class="keyword">int</span> middle = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归地处理坐标和右边的列表，最后合并起来</span></span><br><span class="line">    <span class="keyword">return</span> mergeTwoLists(</span><br><span class="line">        mergeKLists(lists, low, middle),</span><br><span class="line">        mergeKLists(lists, middle + <span class="number">1</span>, high)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode a, ListNode b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>) <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>) <span class="keyword">return</span> a;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(a.val &lt;= b.val) &#123;</span><br><span class="line">        a.next = mergeTwoLists(a.next, b);</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    b.next = mergeTwoLists(a, b.next);</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(nk * log(k))</li>
<li>空间复杂度：O(1)，可以直接在链表上进行操作</li>
</ul>
]]></content>
      <categories>
        <category>Algorithms Note</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Others</title>
    <url>/2020/01/13/LeetCode-Practice-by-Categories-Others/</url>
    <content><![CDATA[<blockquote>
<p>时间像海绵里的水，只要你愿意挤，总还是有的。——鲁迅</p>
</blockquote>
<p>LeetCode其他题目其解决思路和具体代码。</p>
<a id="more"></a>

<h2 id="169-Majority-Element-多数元素-Easy"><a href="#169-Majority-Element-多数元素-Easy" class="headerlink" title="169. Majority Element(多数元素)(Easy)"></a><a href="https://leetcode-cn.com/problems/majority-element/description/" target="_blank" rel="noopener">169. Majority Element(多数元素)(Easy)</a></h2><p>Given an array of size n, find the majority element. The majority element is the element that appears more than <code>⌊ n/2 ⌋</code> times.</p>
<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">Output: <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">Output: <span class="number">2</span></span><br></pre></td></tr></table></figure>
<hr>
<p>解：题目名字是”多数元素”，实际上，就是众数。</p>
<p>思路一：如果你头脑足够灵活，数学感觉足够好，那么实际上抓住一个点就可以：题目问的多数元素，其实不算真正的众数。这里的多数元素出现的次数必须大于 <code>n/2</code> ，所以，如果一个数组中一定有众数，那么这个数组排好序之后，下标为 <code>nums.length/2</code> 的那个元素，就是众数。利用排序，排好序之后返回下标为 <code>nums.length/2</code>的元素，就是这道题需要的结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为用到了系统自带的排序方法，所以这种方法的时间复杂度是O(NlogN)。</p>
<p>方法二：开两个变量，result为最后返回的结果，count用于统计，因为按照题目定义，众数出现次数一定大于 n/2 ，所以count只要回到了0，说明当前result不可能是最后的众数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">0</span>) </span><br><span class="line">                result = num;</span><br><span class="line">            <span class="keyword">if</span>(result != num) </span><br><span class="line">                count --;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                count ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h2 id="7-Reverse-Integer-整数反转-Mid"><a href="#7-Reverse-Integer-整数反转-Mid" class="headerlink" title="7. Reverse Integer(整数反转)(Mid)"></a><a href="https://leetcode-cn.com/problems/reverse-integer/" target="_blank" rel="noopener">7. Reverse Integer(整数反转)(Mid)</a></h2><p>Given a 32-bit signed integer, reverse digits of an integer.</p>
<p><strong>Example 1</strong>:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="number">123</span></span><br><span class="line"><span class="attr">Output:</span> <span class="number">321</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2</strong>:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="number">-123</span></span><br><span class="line"><span class="attr">Output:</span> <span class="number">-321</span></span><br></pre></td></tr></table></figure>
<p><strong>Example 3</strong>:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="number">120</span></span><br><span class="line"><span class="attr">Output:</span> <span class="number">21</span></span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong><br>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31,  2^31 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p>
<hr>
<p>解：x最大可以取2^31-1，但是当x取最大值的时候，再reverse之后的数字大小会超出原本Integer能够保存的最大2^31-1的范围了，会报错移除。所以我们需要考虑到如何解决这个溢出的问题。</p>
<p>需要注意：1，翻转后的数字是否会溢出、2，有关负数的处理</p>
<ol>
<li><p>如果不发生溢出，每次的当前结果可以得到是<code>x0*10+y=x1</code>，x1为计算之后得到的新的值。此时我们可以转换一下，解出来x的值：<code>x=(x1-y)/10</code>，可以想到，如果整个计算结果不发生溢出，这个式子是成立的。但是如果计算结果发生了溢出(比如到了2^31-1)，那么这个式子会不成立，我们可以通过这个方式检查当前数字反转之后是否会溢出。</p>
</li>
<li><p>比如传入的是-123，那么<code>-123/10=-12</code>，而且<code>-123%10=-3</code>，然后<code>result*10+x%10</code>这个公式实际上也是负数之间的计算，所以对于负数，不用单独考虑，就用一样的公式计算即可。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 用一个公式的正和反是否相等来判断当前数字是否溢出</span></span><br><span class="line">            <span class="comment">// result表示以前的数字，乘10再加上新来的数字即为翻转后的数newReverse</span></span><br><span class="line">            <span class="keyword">int</span> newReverse = result * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>((newReverse - x % <span class="number">10</span>) / <span class="number">10</span> != result) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 溢出则返回0</span></span><br><span class="line">            result = newReverse;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-Palindrome-Number-回文数-Mid"><a href="#9-Palindrome-Number-回文数-Mid" class="headerlink" title="9. Palindrome Number(回文数)(Mid)"></a><a href="https://leetcode-cn.com/problems/palindrome-number/" target="_blank" rel="noopener">9. Palindrome Number(回文数)(Mid)</a></h2><p>Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="number">121</span></span><br><span class="line"><span class="attr">Output:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">Input: <span class="number">-121</span></span><br><span class="line">Output: <span class="literal">false</span></span><br><span class="line">Explanation: From left <span class="built_in">to</span> <span class="literal">right</span>, <span class="keyword">it</span> reads <span class="number">-121.</span> From <span class="literal">right</span> <span class="built_in">to</span> left, <span class="keyword">it</span> becomes <span class="number">121</span>-. Therefore <span class="keyword">it</span> is <span class="keyword">not</span> <span class="keyword">a</span> palindrome.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">Output:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">Explanation:</span> <span class="string">Reads</span> <span class="number">01</span> <span class="string">from</span> <span class="string">right</span> <span class="string">to</span> <span class="string">left.</span> <span class="string">Therefore</span> <span class="string">it</span> <span class="string">is</span> <span class="string">not</span> <span class="string">a</span> <span class="string">palindrome.</span></span><br></pre></td></tr></table></figure>

<p><strong>Follow up:</strong></p>
<p>Coud you solve it without converting the integer to a string?</p>
<hr>
<p>解：为了避免溢出问题(如果给的数字本身不是回文，翻转之后有可能大于int.MAX,造成溢出)，直接比较反转的int数的一半即可。</p>
<p>首先要处理临界情况，所有的负数都不可能是回文(这就可以过滤到很多啦！)。</p>
<p>后面的操作就是取出来数字了，取个位可以用对10取余，取十位可以用除以10之后再对10取余。</p>
<p>判断是否到了原始数字的一半，可以让原始数字除以10，再让反转后的数字乘上10。此时如果原始数字小于反转后的数字，就意味着我们已经处理了一半位数的数字了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 处理特殊情况</span></span><br><span class="line">        <span class="comment">// 所有负数都一定不是回文数</span></span><br><span class="line">        <span class="comment">// 如果某一个数字最后一位是0，那么如果它是回文数，</span></span><br><span class="line">        <span class="comment">// 那么开头也一定要是0，只有0符合</span></span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> revertedNumber  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( x &gt; revertedNumber ) &#123;</span><br><span class="line">            revertedNumber  = revertedNumber  * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x = x/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。</span></span><br><span class="line">        <span class="comment">// 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，</span></span><br><span class="line">        <span class="comment">// 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。</span></span><br><span class="line">        <span class="keyword">return</span> (x == revertedNumber  || x == revertedNumber /<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(log10(N))，因为每次迭代，我们会将输入除以10，因此时间复杂度为O(log10(N))</li>
<li>空间复杂度：O(1)</li>
</ul>
<h2 id="1109-Corporate-Flight-Bookings-航班预订统计-Mid"><a href="#1109-Corporate-Flight-Bookings-航班预订统计-Mid" class="headerlink" title="1109. Corporate Flight Bookings(航班预订统计)(Mid)"></a><a href="https://leetcode-cn.com/problems/corporate-flight-bookings/" target="_blank" rel="noopener">1109. Corporate Flight Bookings(航班预订统计)(Mid)</a></h2><p>There are <code>n</code> flights, and they are labeled from <code>1</code> to <code>n</code>.</p>
<p>We have a list of flight bookings.  The <code>i</code>-th booking <code>bookings[i] = [i, j, k]</code> means that we booked <code>k</code> seats from flights labeled <code>i</code> to <code>j</code> inclusive.</p>
<p>Return an array <code>answer</code> of length <code>n</code>, representing the number of seats booked on each flight in order of their label.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: bookings = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">20</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">25</span>]], n = <span class="number">5</span></span><br><span class="line">Output: [<span class="number">10</span>,<span class="number">55</span>,<span class="number">45</span>,<span class="number">25</span>,<span class="number">25</span>]</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= bookings.length &lt;= 20000</code></li>
<li><code>1 &lt;= bookings[i][0] &lt;= bookings[i][1] &lt;= n &lt;= 20000</code></li>
<li><code>1 &lt;= bookings[i][2] &lt;= 10000</code></li>
</ul>
<hr>
<p>解：这道题利用很经典的”上下车”的思路，可以把<code>booking[i]=[i, j, k]</code>理解成在<code>i</code>站上车<code>k</code>人，这些人乘坐到了第<code>j</code>站，然后在<code>j+1</code>站下车，我们要返回的是按照顺序的每一站上车的人数。</p>
<p>根据上面的思路，定义一个<code>counter[]</code>数组来记录每站人数的变化，<strong><code>counter[i]</code>表示第i+1站</strong>。遍历<code>bookings[],bookings[i]=[i,j,k]</code>表示在i站增加<code>k</code>人,即<code>counter[i-1] += k</code>，在<code>j+1</code>站减少<code>k</code>人，即<code>counter[j] -= k</code></p>
<p>最后遍历counter[]数组，得到每站的总人数：每站的总人数为前一站人数加上当前人数变化：counter[i] += counter[i-1]</p>
<p>重点：第i站上车、第j+1站下车。一开始counter只用于记录某一站人数的变化，后面counter用于保存每一站总共的人数。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>[] corpFlightBookings(<span class="built_in">int</span>[][] bookings, <span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="comment">// 需要注意：counter记录的是人数变化量</span></span><br><span class="line">        <span class="built_in">int</span>[] counter = new <span class="built_in">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span>[] booking : bookings) &#123;</span><br><span class="line">            <span class="comment">// counter[i]表示第i-1站上车，上车人数是booking[2]</span></span><br><span class="line">            counter[booking[<span class="number">0</span>] - <span class="number">1</span>] += booking[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(booking[<span class="number">1</span>] &lt; n) &#123; <span class="comment">// 如果在最后一站或者最后一站之前下车，就要减去</span></span><br><span class="line">                counter[booking[<span class="number">1</span>]] -= booking[<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 统计最后每一站的人数的结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            counter[i] += counter[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n),n是航班的数量</li>
<li>空间复杂度：O(n)</li>
</ul>
<h2 id="135-Candy-分发糖果-Hard"><a href="#135-Candy-分发糖果-Hard" class="headerlink" title="135. Candy(分发糖果)(Hard)"></a><a href="https://leetcode-cn.com/problems/candy/" target="_blank" rel="noopener">135. Candy(分发糖果)(Hard)</a></h2><p>There are <em>N</em> children standing in a line. Each child is assigned a rating value.</p>
<p>You are giving candies to these children subjected to the following requirements:</p>
<ul>
<li>Each child must have at least one candy.</li>
<li>Children with a higher rating get more candies than their neighbors.</li>
</ul>
<p>What is the minimum candies you must give?</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>]</span><br><span class="line">Output: <span class="number">5</span></span><br><span class="line">Explanation: You can allocate to the first, second <span class="keyword">and</span> third child with <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span> candies respectively.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">Output: <span class="number">4</span></span><br><span class="line">Explanation: You can allocate <span class="built_in">to</span> <span class="keyword">the</span> <span class="keyword">first</span>, <span class="keyword">second</span> <span class="keyword">and</span> <span class="keyword">third</span> child <span class="keyword">with</span> <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span> candies respectively.</span><br><span class="line">             The <span class="keyword">third</span> child gets <span class="number">1</span> candy because <span class="keyword">it</span> satisfies <span class="keyword">the</span> above <span class="literal">two</span> conditions.</span><br></pre></td></tr></table></figure>

<hr>
<p>解：需要注意题目说的是，评分高的children分到的candy是比他的<strong>neighbors</strong>多，而不是比其他所有评分比他低的小孩多</p>
<p>一个比较巧妙的方法是，可以从左往右和从右往左两次遍历，改变当前结果数组candy需要遵循这个公式：<code>candy[i] = Math.max(candy[i],candy[i+1]+1)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="keyword">int</span>[] ratings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ratings == <span class="keyword">null</span> || ratings.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = ratings.length;</span><br><span class="line">        <span class="comment">// 最后的结果数组</span></span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="comment">// 初始化每个小孩至少有一个糖果</span></span><br><span class="line">        Arrays.fill(result, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 然后开始遍历，一次从前往后，一次从后往前</span></span><br><span class="line">        <span class="comment">// 两次遍历的过程中第一个都不用管，因为在下一次遍历中会遍历到的</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从左往右,从第2个小孩开始直到最后一个</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前小孩评分比他右边的小孩高，他分到的糖果数</span></span><br><span class="line">            <span class="comment">// 就比他右边的小孩多1个</span></span><br><span class="line">            <span class="keyword">if</span>(ratings[i] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                result[i] = result[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从右往左，从倒数第二个小孩开始直到第一个</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 如果当前小孩评分比他左边小孩低，他左边小孩分到的</span></span><br><span class="line">            <span class="comment">// 糖果数是其本身存储的值和当前右边小孩糖果数+1的最大值</span></span><br><span class="line">            <span class="keyword">if</span>(ratings[i] &gt; ratings[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                result[i] = Math.max(result[i], result[i + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> temp : result) sum += temp;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指offer-面试题03-数组中重复的数字-Easy"><a href="#剑指offer-面试题03-数组中重复的数字-Easy" class="headerlink" title="剑指offer 面试题03 数组中重复的数字(Easy)"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/" target="_blank" rel="noopener">剑指offer 面试题03 数组中重复的数字(Easy)</a></h2><p>找出数组中重复的数字。</p>
<p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>]</span><br><span class="line">输出：<span class="number">2</span> 或 <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong></p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">2 </span>&lt;= n &lt;= <span class="number">100000</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：这道题没有说额外空间的限制，所以可以和面试官讨论一下再决定用哪种方法。</p>
<p>方法一：哈希表，利用哈希Set放入重复元素的时候会返回false(添加失败)来做，每次返回false的时候就将函数返回这个值即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.add(num)) &#123;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<p>方法二：抓住题目条件，所有数字范围都在0~n-1之内。如果没有重复数字，那么对每一个数排序之后其值都等于下标值。</p>
<p>利用这一点做哈希，遍历整个数组，如果当前数字不等于其下标，就将其和其下标位置的元素交换。在交换过程中，某个重复的数字迟早会有冲突，此时返回即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(i != nums[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] == nums[nums[i]]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">                nums[i] = nums[temp];</span><br><span class="line">                nums[temp] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)，空间复杂度得到了优化</li>
</ul>
<h2 id="146-LRU-Cache-LRU缓存机制-Mid"><a href="#146-LRU-Cache-LRU缓存机制-Mid" class="headerlink" title="146. LRU Cache(LRU缓存机制)(Mid)"></a><a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">146. LRU Cache(LRU缓存机制)(Mid)</a></h2><p>Design and implement a data structure for <strong>Least Recently Used (LRU)</strong> cache. It should support the following operations: <code>get</code> and <code>put</code>.</p>
<p><code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br><code>put(key, value)</code> - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</p>
<p>The cache is initialized with a <strong>positive</strong> capacity.</p>
<p><strong>Follow up:</strong></p>
<p>Could you do both operations in <strong>O(1)</strong> time complexity?</p>
<p><strong>Example:</strong></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">LRUCache <span class="keyword">cache</span> = new LRUCache( <span class="number">2</span> <span class="comment">/* capacity */</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">cache</span>.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">cache</span>.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">cache</span>.get(<span class="number">1</span>);       // <span class="keyword">returns</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">cache</span>.put(<span class="number">3</span>, <span class="number">3</span>);    // evicts key <span class="number">2</span></span><br><span class="line"><span class="keyword">cache</span>.get(<span class="number">2</span>);       // <span class="keyword">returns</span> <span class="number">-1</span> (<span class="keyword">not</span> <span class="built_in">found</span>)</span><br><span class="line"><span class="keyword">cache</span>.put(<span class="number">4</span>, <span class="number">4</span>);    // evicts key <span class="number">1</span></span><br><span class="line"><span class="keyword">cache</span>.get(<span class="number">1</span>);       // <span class="keyword">returns</span> <span class="number">-1</span> (<span class="keyword">not</span> <span class="built_in">found</span>)</span><br><span class="line"><span class="keyword">cache</span>.get(<span class="number">3</span>);       // <span class="keyword">returns</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">cache</span>.get(<span class="number">4</span>);       // <span class="keyword">returns</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<hr>
<p>注：因为这道题在写之后会有很大的改动，所以可以记住题目原本的代码其实很短，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>解：LRU cache是页面置换算法。具体使用场景：在进程运行过程中，若其所要访问的页面不在内存而需把它们调入内存，但内存已无空闲空间时，为了保证该进程能正常运行，系统必须从内存中调出一页程序或数据送磁盘的对换区中。但应将哪个页面调出，须根据一定的算法来确定。通常，把选择换出页面的算法称为页面置换算法(Page-Replacement Algorithms)。</p>
<p>LRU是Least Recently Used的缩写，即最近最少使用，是一种常用的页面置换算法，选择最近最久未使用的页面予以淘汰。该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 t，当须淘汰一个页面时，选择现有页面中其 t 值最大的，即最近最少使用的页面予以淘汰。</p>
<p>本质上，这个替换算法和现在的推荐系统有异曲同工之妙。</p>
<p>推荐算法就是根据之前元素被使用的频次和被使用的时间，来预测新来的元素为某一个老元素的概率是多少。</p>
<p>现代计算机中，替换算法越来越使用人工智能来做了，而不是简单基于逻辑式的公式。</p>
<p>LRU cache源自于用得非常多的缓存的思想。它有两个比较重要的策略：大小和替换策略。除了LRU(Least Recently Used)，还有一种可以和它相似的，只是替换策略不同的缓存机制：LFU(Least Frequently Used)，具体区别可以从名字中看出。</p>
<p>按照题目的要求，我们自己完成的LRU cache应当保证<strong>查询</strong>与<strong>修改</strong>的时间复杂度都为O(1)。</p>
<p>如果最朴素的，全部自己实现，那么就是哈希表加双向链表。这样就训练一下双向链表怎么写。</p>
<p>所有双向链表或者单向链表的题目，没有巧，就是多练，即可。</p>
<p>在现实工作中，其实不太可能去手写一个链表、map、set或者排序，都是有现成的库。</p>
<p>有些公司可能比较刻板，需要多练一些基本功。</p>
<p>官方题解中，给出了两种解法，<a href="https://leetcode-cn.com/problems/lru-cache/solution/lru-huan-cun-ji-zhi-by-leetcode/" target="_blank" rel="noopener">详情可以点击这里</a></p>
<p>方法一：使用<strong>有序字典</strong>这个数据结构，它综合了哈希表和链表。对于java，系统使用了LinkedHashMap这个类实现；对于Python，系统使用了OrderedDict实现字典序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">Integer</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(capacity, <span class="number">0.75F</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getOrDefault(key, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;Integer, Integer&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; capacity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p><strong>拓展:</strong>linkedhashmap和hashmap有什么区别？<br>HashMap就只是一个哈希表，键值对对应，最多允许一条记录的键值为Null，而且HashMap不支持线程同步，即任一时刻如果多个线程同时写HashMap，可能导致数据的不一致性。如果需要同步，对于HashMap，可以用Collections的synchronizedMap方法使HashMap拥有同步的能力。</p>
<p>LinkedHashMap也是一个HashMap，<strong>但是它内部维持了一个双向链表</strong>，可以保持顺序。</p>
<p>总之，LinkedHashMap的内部实现原理，就是一个双向的LinkedList+HashMap,所以名字是：LinkedHashMap。</p>
<p>方法二：不用LinkedHashMap，自己手写双向链表+哈希表</p>
<p>利用哈希表，辅以双向链表记录键值对的信息，所以可以在O(1)时间内完成put和get操作，同时也支持O(1)删除第一个添加的节点。</p>
<p><img src="https://pic.leetcode-cn.com/815038bb44b7f15f1f32f31d40e75c250cec3c5c42b95175ec012c00a0243833-146-1.png" alt="双向链表+哈希"></p>
<p>一个需要注意的是，在双向链表实现中，这里使用一个<em>伪头部</em>和<em>伪尾部</em>标记界限，这样在更新的时候就不需要检查是否是 <code>null</code> 节点。</p>
<p><img src="https://pic.leetcode-cn.com/48292c190e50537087ea8c60ed44062675d55a73d1a59035d26e277a36b7b8e2-146-2.png" alt="伪头结点和伪尾节点"></p>
<p>至于到代码，我们需要自己定义一个双向链表的节点以及它的各种操作方法。这里定义了增加、删除、移动到头部、pop出Tail。实际上要写的只有addNode和removeNode，这两个写好了，其他两个方法只要调用它们就好。需要注意这里增加的位置是指定在head之后、删除的位置是在tail前一个。</p>
<p>然后需要定义缓存空间cache，完成它的三个函数：初始化、get()、put()。</p>
<p>这过程中我们需要两个变量：key和value，其中key就是保存某个秘钥。而value则是这个秘钥的值。(分页置换算法相关知识)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DLinkedNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key, value;</span><br><span class="line">        DLinkedNode prev;</span><br><span class="line">        DLinkedNode next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(DLinkedNode node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// always add new node right after head</span></span><br><span class="line">        node.next = head.next;</span><br><span class="line">        node.prev = head;</span><br><span class="line">        </span><br><span class="line">        head.next.prev = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(DLinkedNode node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// remove an existing node from the double LinkedList</span></span><br><span class="line">        DLinkedNode next = node.next;</span><br><span class="line">        DLinkedNode prev = node.prev;</span><br><span class="line">        </span><br><span class="line">        next.prev = prev;</span><br><span class="line">        prev.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(DLinkedNode node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// move certain node to the head</span></span><br><span class="line">        removeNode(node);</span><br><span class="line">        addNode(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> DLinkedNode <span class="title">popTail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// pop the current tail</span></span><br><span class="line">        DLinkedNode target = tail.prev;</span><br><span class="line">        removeNode(target);</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, DLinkedNode&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> DLinkedNode head, tail;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 默认调用无参构造函数</span></span><br><span class="line">        head = <span class="keyword">new</span> DLinkedNode();</span><br><span class="line">        </span><br><span class="line">        tail = <span class="keyword">new</span> DLinkedNode();</span><br><span class="line">        </span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        DLinkedNode node = cache.get(key);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 成功取到，因为本身是Least Recently Used，所以最近使用的放到头部</span></span><br><span class="line">        moveToHead(node);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        DLinkedNode node = cache.get(key);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            DLinkedNode newNode = <span class="keyword">new</span> DLinkedNode();</span><br><span class="line">            newNode.key = key;</span><br><span class="line">            newNode.value = value;</span><br><span class="line">            </span><br><span class="line">            cache.put(key, newNode);</span><br><span class="line">            addNode(newNode);</span><br><span class="line">            </span><br><span class="line">            ++size;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果存不下了，要pop</span></span><br><span class="line">            <span class="keyword">if</span>(size &gt; capacity) &#123;</span><br><span class="line">                <span class="comment">// pop the tail</span></span><br><span class="line">                DLinkedNode tail = popTail();</span><br><span class="line">                cache.remove(tail.key);</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// update the value</span></span><br><span class="line">            node.value = value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：对于<code>put</code>和<code>get</code>都是O(1)</li>
<li>空间复杂度：O(capacity),因为哈希表和双向链表最多存储<code>capacity + 1</code>个元素</li>
</ul>
<h2 id="寻找K数"><a href="#寻找K数" class="headerlink" title="寻找K数"></a>寻找K数</h2><p>K数是指一个数组中，它前面的数都比它小，它后面的数都比它大。找出一个数组中所有的K数</p>
<hr>
<p>解：题目描述很简单，但是实际考虑起来需要注意，首先K数在一个数组里面很可能不止1个，然后数组的第一个的左边和数组最后一个的右边，该怎么处理？</p>
<p>把数组最左边设置为负无穷(Integer.MIN_VALUE),最右边设置成正无穷(Integer.MAX_VALUE),新开一个大小为原来大小+2的数组，把最左边和最右边处理完之后，依次遍历每个元素，然后以每个元素为轴，分别比较其左边和右边的每一个元素，满足左边都比它小同时右边都比它大的，这个数就是K树。</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; findK(int[] array) &#123;</span><br><span class="line">    int len = array.length;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="type">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 为了存放正无穷和负无穷的数组</span></span><br><span class="line">    int[] <span class="keyword">new</span><span class="type">Array</span> = <span class="keyword">new</span> <span class="type">int</span>[len + <span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 初始化newArray,赋值array进去，同时设置0和len-1位置</span></span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span><span class="type">Array</span>[i] = array[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">new</span><span class="type">Array</span>[<span class="number">0</span>] = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">new</span><span class="type">Array</span>[len+<span class="number">1</span>] = Integer.MAX_VALUE;</span><br><span class="line">    <span class="comment">// 标记当前 i 数是否是K数，只要不满足要求就设置为false</span></span><br><span class="line">    boolean flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">        <span class="comment">// 第一次判断，i左边的所有数是否都比它小</span></span><br><span class="line">        <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt;= i<span class="number">-1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">new</span><span class="type">Array</span>[j] &gt;= <span class="keyword">new</span><span class="type">Array</span>[i]) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第二次判断，i右边的所有数是否都比它大</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">for</span>(int j = i+<span class="number">1</span>; j &lt;= len+<span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">new</span><span class="type">Array</span>[j] &lt;= <span class="keyword">new</span><span class="type">Array</span>[i]) &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 两次判断都成功，则i就是K数</span></span><br><span class="line">        <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span><span class="type">Array</span>[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指offer21-调整数组顺序使奇数位于偶数前面-Easy"><a href="#剑指offer21-调整数组顺序使奇数位于偶数前面-Easy" class="headerlink" title="剑指offer21.调整数组顺序使奇数位于偶数前面(Easy)"></a><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/" target="_blank" rel="noopener">剑指offer21.调整数组顺序使奇数位于偶数前面(Easy)</a></h2><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p>
<p><strong>示例：</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>] </span><br><span class="line">注：[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>] 也是正确的答案之一。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= nums.length &lt;= 50000</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10000</code></li>
</ol>
<hr>
<p>解：方法一：可以用两个指针，一头一尾，头指针先不断遍历找到偶数，然后尾指针不断遍历找到奇数，然后将两者交换即可。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>[] exchange(<span class="built_in">int</span>[] nums) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> left = <span class="number">0</span>, right = nums.length<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 先找到左边的偶数</span></span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; (nums[left] &amp; <span class="number">1</span>) != <span class="number">0</span> ) left++;</span><br><span class="line">            <span class="comment">// 再找到右边的奇数</span></span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; (nums[right] &amp; <span class="number">1</span>) == <span class="number">0</span> ) right--;</span><br><span class="line">            <span class="comment">// 找到之后直接将两者交换。这样比写四个if-else去遍历所有情况更快</span></span><br><span class="line">            swap(nums, left, right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> swap(<span class="built_in">int</span>[] arr, <span class="built_in">int</span> i, <span class="built_in">int</span> j) &#123;</span><br><span class="line">        <span class="built_in">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(N),N为数组nums长度，过程下来left和right两个指针遍历整个数组。</li>
<li>空间复杂度：O(1)，额外开销只有两个指针</li>
</ul>
<p>但是如果对于工程要求比较高，面试官可能更希望我们能够写出如下可以扩展的写法。怎么扩展？</p>
<p>我们可以把代码拆解成两部分，一部分判断数字应该在数组前半部分还是后半部分的标准；二是拆分数组的操作。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>[] exchange(<span class="built_in">int</span>[] nums) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> left = <span class="number">0</span>, right = nums.length<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 先找到左边的偶数</span></span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; !isEven(nums[left]) ) left++;</span><br><span class="line">            <span class="comment">// 再找到右边的奇数</span></span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; isEven(nums[right]) ) right--;</span><br><span class="line">            <span class="comment">// 找到之后直接将两者交换。这样比写四个if-else去遍历所有情况更快</span></span><br><span class="line">            swap(nums, left, right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> swap(<span class="built_in">int</span>[] arr, <span class="built_in">int</span> i, <span class="built_in">int</span> j) &#123;</span><br><span class="line">        <span class="built_in">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span>ean isEven(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">return</span> (n&amp;<span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：也是用两个指针，但是一快一慢。快的在前，找到奇数就和慢指针指向的元素交换。</p>
<p>操作流程：</p>
<ul>
<li>定义快慢双指针 fast 和 low ，fast 在前， low 在后 .</li>
<li>fast 的作用是向前搜索奇数位置，low 的作用是指向下一个奇数应当存放的位置</li>
<li>fast 向前移动，当它搜索到奇数时，将它和 nums[low] 交换，此时 low 向前移动一个位置 .</li>
<li>重复上述操作，直到 fast 指向数组末尾 .</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] exchange(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.length) &#123;</span><br><span class="line">            <span class="keyword">if</span>((nums[fast] &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                swap(nums, slow, fast);</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-Roman-to-Integer-罗马数字转整数-Easy"><a href="#13-Roman-to-Integer-罗马数字转整数-Easy" class="headerlink" title="13. Roman to Integer(罗马数字转整数)(Easy)"></a><a href="https://leetcode-cn.com/problems/roman-to-integer/" target="_blank" rel="noopener">13. Roman to Integer(罗马数字转整数)(Easy)</a></h2><p>Roman numerals are represented by seven different symbols: <code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>.</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">Symbol</span>       <span class="string">Value</span></span><br><span class="line"><span class="attr">I</span>             <span class="string">1</span></span><br><span class="line"><span class="attr">V</span>             <span class="string">5</span></span><br><span class="line"><span class="attr">X</span>             <span class="string">10</span></span><br><span class="line"><span class="attr">L</span>             <span class="string">50</span></span><br><span class="line"><span class="attr">C</span>             <span class="string">100</span></span><br><span class="line"><span class="attr">D</span>             <span class="string">500</span></span><br><span class="line"><span class="attr">M</span>             <span class="string">1000</span></span><br></pre></td></tr></table></figure>

<p>For example, two is written as <code>II</code> in Roman numeral, just two one’s added together. Twelve is written as, <code>XII</code>, which is simply <code>X</code> + <code>II</code>. The number twenty seven is written as <code>XXVII</code>, which is <code>XX</code> + <code>V</code> + <code>II</code>.</p>
<p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not <code>IIII</code>. Instead, the number four is written as <code>IV</code>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as <code>IX</code>. There are six instances where subtraction is used:</p>
<ul>
<li><code>I</code> can be placed before <code>V</code> (5) and <code>X</code> (10) to make 4 and 9. </li>
<li><code>X</code> can be placed before <code>L</code> (50) and <code>C</code> (100) to make 40 and 90. </li>
<li><code>C</code> can be placed before <code>D</code> (500) and <code>M</code> (1000) to make 400 and 900.</li>
</ul>
<p>Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Input:</span> <span class="string">"III"</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Input:</span> <span class="string">"IV"</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Input:</span> <span class="string">"IX"</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="string">"LVIII"</span></span><br><span class="line"><span class="attr">Output:</span> <span class="number">58</span></span><br><span class="line"><span class="attr">Explanation:</span> <span class="string">L</span> <span class="string">=</span> <span class="number">50</span><span class="string">,</span> <span class="string">V=</span> <span class="number">5</span><span class="string">,</span> <span class="string">III</span> <span class="string">=</span> <span class="number">3</span><span class="string">.</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 5:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="string">"MCMXCIV"</span></span><br><span class="line"><span class="attr">Output:</span> <span class="number">1994</span></span><br><span class="line"><span class="attr">Explanation:</span> <span class="string">M</span> <span class="string">=</span> <span class="number">1000</span><span class="string">,</span> <span class="string">CM</span> <span class="string">=</span> <span class="number">900</span><span class="string">,</span> <span class="string">XC</span> <span class="string">=</span> <span class="number">90</span> <span class="string">and</span> <span class="string">IV</span> <span class="string">=</span> <span class="number">4</span><span class="string">.</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：实际上就是类似map的对应的关系，但是这里不用Map，用switch，能够快很多：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> preNum = getValue(s.charAt(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; s.length(); i ++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = getValue(s.charAt(i));</span><br><span class="line">            <span class="keyword">if</span>(preNum &lt; num) &#123;</span><br><span class="line">                sum -= preNum;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += preNum;</span><br><span class="line">            &#125;</span><br><span class="line">            preNum = num;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += preNum;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(ch) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'I'</span>: <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'V'</span>: <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'X'</span>: <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'L'</span>: <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'C'</span>: <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'D'</span>: <span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'M'</span>: <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithms Note</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode String Algorithm</title>
    <url>/2020/01/13/LeetCode-Practice-by-Categories-String-Algorithm/</url>
    <content><![CDATA[<blockquote>
<p>世界上最快乐的事，莫过于为理想而奋斗——苏格拉底</p>
</blockquote>
<p>LeetCode字符串相关题目，其解决思路和具体代码。</p>
<a id="more"></a>

<h2 id="面试题：如何把一个String类型的ip地址保存到一个int类型的整型数组里？注意输入的String可能含有非法字符，比如空格等。"><a href="#面试题：如何把一个String类型的ip地址保存到一个int类型的整型数组里？注意输入的String可能含有非法字符，比如空格等。" class="headerlink" title="面试题：如何把一个String类型的ip地址保存到一个int类型的整型数组里？注意输入的String可能含有非法字符，比如空格等。"></a>面试题：如何把一个String类型的ip地址保存到一个int类型的整型数组里？注意输入的String可能含有非法字符，比如空格等。</h2><p>解：传入的String本身已经有分隔符”.”分好了，所以这道题不需要额外做LeetCode93题那样的额外的IP地址复原操作，直接利用位运算保存到int里面即可。</p>
<p><strong>当然，后面面试官可能会加大难度，这时候就要去做LeetCode93题那样的复原工作了</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">IPV4ToInt</span><span class="params">(String ipv4_string)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 过滤非法字符</span></span><br><span class="line">		String ipv4_string0 = ipv4_string.replaceAll(<span class="string">"\\s+"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 切分获取IP各段</span></span><br><span class="line">		String[] ipv4_string1 = ipv4_string0.split(<span class="string">"\\."</span>);</span><br><span class="line">		<span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = ipv4_string1.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">			<span class="keyword">int</span> sliceTemp = Integer.parseInt(ipv4_string1[i]) &lt;&lt; <span class="number">8</span> * i;</span><br><span class="line">			result |= sliceTemp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="125-Valid-Palindrome-验证回文串-Easy"><a href="#125-Valid-Palindrome-验证回文串-Easy" class="headerlink" title="125.Valid Palindrome(验证回文串)(Easy)"></a><a href="https://leetcode-cn.com/problems/valid-palindrome/" target="_blank" rel="noopener">125.Valid Palindrome(验证回文串)(Easy)</a></h2><p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p>
<p><strong>Note</strong>: For the purpose of this problem, we define empty string as valid palindrome.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">Input:</span> <span class="string">"A man, a plan, a canal: Panama"</span></span><br><span class="line"><span class="string">Output:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">Input:</span> <span class="string">"race a car"</span></span><br><span class="line"><span class="string">Output:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：双指针法（LeetCode国际站）</p>
<p>需要提前学习，Java的Character包装类中有两个对这道题很有用的方法：</p>
<ol>
<li>Character.isLetterOrDigit()，判断当前内容是否是全英文或数字。但是这有个坑，如果用了中文，识别不出来(默认提供unicode的支持)，可以用Apache Commons子项目中的lang库，CharUtils的<code>isAsciiAlpha(char)</code>、<code>isAsciiNumeric(char)</code>、<code>isAsciiAlphanumberic(char)</code>等对字符进行字母，大小写字母，数字等的判断。——实际上commons项目是一个大宝库，里面提供了很多对JDK增强的API，lang库就是对java.lang的增强。比如使用反射生成toString的ToStringBuilder，使用反射生成hashCode的HashCodeBuilder等。</li>
<li>Character.toLowerCase()，这个方法可以将大写字符转换为小写字符。</li>
</ol>
<p>具体代码：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public boolean is<span class="constructor">Palindrome(String <span class="params">s</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 双指针法</span></span><br><span class="line">        <span class="keyword">if</span>(s.length<span class="literal">()</span> &lt;= <span class="number">1</span>) return <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">char</span><span class="literal">[]</span> c = s.<span class="keyword">to</span><span class="constructor">CharArray()</span>;</span><br><span class="line">        <span class="comment">// i为头，j为尾(最后一个为长度减1)</span></span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">0</span>, j = c.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j<span class="operator"> &amp;&amp; </span>!<span class="module-access"><span class="module"><span class="identifier">Character</span>.</span></span>is<span class="constructor">LetterOrDigit(<span class="params">c</span>[<span class="params">i</span>])</span>) <span class="comment">//剔除所有非字母或数字的字符</span></span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j<span class="operator"> &amp;&amp; </span>!<span class="module-access"><span class="module"><span class="identifier">Character</span>.</span></span>is<span class="constructor">LetterOrDigit(<span class="params">c</span>[<span class="params">j</span>])</span>)</span><br><span class="line">                j--;</span><br><span class="line">            <span class="keyword">if</span>(<span class="module-access"><span class="module"><span class="identifier">Character</span>.</span></span><span class="keyword">to</span><span class="constructor">LowerCase(<span class="params">c</span>[<span class="params">i</span><span class="operator">++</span>])</span> != <span class="module-access"><span class="module"><span class="identifier">Character</span>.</span></span><span class="keyword">to</span><span class="constructor">LowerCase(<span class="params">c</span>[<span class="params">j</span>--])</span>) <span class="comment">// 统一转换成小写字母再比较</span></span><br><span class="line">                return <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以用for循环来写，这样变量直接定义在循环里面，代码更简洁：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public boolean is<span class="constructor">Palindrome(String <span class="params">s</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// corner case    </span></span><br><span class="line">        <span class="keyword">if</span>(s.length<span class="literal">()</span> &lt;= <span class="number">1</span>) return <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">char</span><span class="literal">[]</span> c = s.<span class="keyword">to</span><span class="constructor">CharArray()</span>;</span><br><span class="line">        for(<span class="built_in">int</span> i = <span class="number">0</span>, j = c.length-<span class="number">1</span>; i &lt; j;) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="module-access"><span class="module"><span class="identifier">Character</span>.</span></span>is<span class="constructor">LetterOrDigit(<span class="params">c</span>[<span class="params">i</span>])</span>) i++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="module-access"><span class="module"><span class="identifier">Character</span>.</span></span>is<span class="constructor">LetterOrDigit(<span class="params">c</span>[<span class="params">j</span>])</span>) j--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="module-access"><span class="module"><span class="identifier">Character</span>.</span></span><span class="keyword">to</span><span class="constructor">LowerCase(<span class="params">c</span>[<span class="params">i</span><span class="operator">++</span>])</span> != <span class="module-access"><span class="module"><span class="identifier">Character</span>.</span></span><span class="keyword">to</span><span class="constructor">LowerCase(<span class="params">c</span>[<span class="params">j</span>--])</span>) return <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>后记</strong>：受到这道题的启发，当我们需要去解决输入的一个字符串是否为回文串的时候，我们需要向面试官确认三点：空字符串是否为定义为回文串？输入是否会有空格、分隔符等非法字符？输入为字母的话是否都为大写或者小写字母？(数字不用担心，直接用就行)。</p>
<p>前两点对应Character.isLetterOrDigit()方法，第三点对应Character.toLowerCase()方法</p>
<h2 id="680-Valid-Palindrome-II-验证回文串-II-Easy"><a href="#680-Valid-Palindrome-II-验证回文串-II-Easy" class="headerlink" title="680.Valid Palindrome II(验证回文串 II)(Easy)"></a><a href="https://leetcode-cn.com/problems/valid-palindrome-ii/" target="_blank" rel="noopener">680.Valid Palindrome II(验证回文串 II)(Easy)</a></h2><p>Given a non-empty string <code>s</code>, you may delete <strong>at most</strong> one character. Judge whether you can make it a palindrome.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="string">"aba"</span></span><br><span class="line"><span class="attr">Output:</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Input</span>: "abca"</span><br><span class="line">Output: <span class="keyword">True</span></span><br><span class="line">Explanation: You could <span class="keyword">delete</span> the <span class="type">character</span> <span class="string">'c'</span>.</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ol>
<li>The string will only contain lowercase characters a-z. The maximum length of the string is 50000.</li>
</ol>
<hr>
<p>解：这道题虽然是125的进化版，但是输入已经约定是都是lowercase的character，所以不需要像上面那样再调用Character.isLetterOrDigit了。</p>
<p>解决这道题也可以用双指针，一头一尾。但是这里主要要考虑可以删除一个字符的情况，可以选择左边指针删除或者右边指针删除</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public boolean valid<span class="constructor">Palindrome(String <span class="params">s</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> left = <span class="number">0</span>, right = s.length<span class="literal">()</span>-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 左右两边的字符不相等的时候，可以跳过一次左边或者右边的字符</span></span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">char</span><span class="constructor">At(<span class="params">left</span>)</span> != s.<span class="built_in">char</span><span class="constructor">At(<span class="params">right</span>)</span>) &#123;</span><br><span class="line">                return is<span class="constructor">Palindrome(<span class="params">s</span>, <span class="params">left</span>+1, <span class="params">right</span>)</span><span class="operator"> || </span>is<span class="constructor">Palindrome(<span class="params">s</span>,<span class="params">left</span>, <span class="params">right</span>-1)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left++; right--;</span><br><span class="line">        &#125;</span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean is<span class="constructor">Palindrome(String <span class="params">s</span>, <span class="params">int</span> <span class="params">left</span>, <span class="params">int</span> <span class="params">right</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right ) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">char</span><span class="constructor">At(<span class="params">left</span><span class="operator">++</span>)</span> != s.<span class="built_in">char</span><span class="constructor">At(<span class="params">right</span>--)</span>) &#123;</span><br><span class="line">                return <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-Longest-Palindromic-Substring-最长回文子串-Mid"><a href="#5-Longest-Palindromic-Substring-最长回文子串-Mid" class="headerlink" title="5.Longest Palindromic Substring(最长回文子串)(Mid)"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5.Longest Palindromic Substring(最长回文子串)(Mid)</a></h2><p>Given a string <strong>s</strong>, find the longest palindromic substring in <strong>s</strong>. You may assume that the maximum length of <strong>s</strong> is 1000.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Input</span>: "babad"</span><br><span class="line">Output: "bab"</span><br><span class="line">Note: "aba" <span class="keyword">is</span> <span class="keyword">also</span> a <span class="keyword">valid</span> answer.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Input:</span> <span class="string">"cbbd"</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="string">"bb"</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：完整分析参考<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/" target="_blank" rel="noopener">这篇文章</a></p>
<p>首先要明确回文子串的定义，单个字符，比如”a”，本身就是回文子串。然后如果多于一个字符了，比如两个字符，那必须是”aa”才能是回文子串，三个的话”aba”是回文子串，以此类推。</p>
<p>这道题是647的扩展，647只要求找到有多少回文子串，而这道题要返回最长的回文子串。</p>
<p>方法一：暴力法，枚举所有长度大于2的子串，一共有O(n^2)个，然后对每一个子串进行验证，需要O(n)，总共的时间复杂度为O(n^3)，太大了。</p>
<p>方法二：优化的暴力法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> lo, maxLen;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 优化后的暴力穷举</span></span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            extendPalindrome(s, i ,i); <span class="comment">// odd length</span></span><br><span class="line">            extendPalindrome(s, i, i+<span class="number">1</span>); <span class="comment">// even length</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 摘取出来s的最长回文</span></span><br><span class="line">        <span class="keyword">return</span> s.substring(lo, lo + maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extendPalindrome</span><span class="params">(String s, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// j是向左扩散，k是向右扩散。只要j和k上面的字符相同，就不断地走</span></span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; k &lt; s.length() &amp;&amp; s.charAt(j) == s.charAt(k)) &#123;</span><br><span class="line">            j--; k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 走完之后，判断当前遍历到的是不是最长的子串，如果是，就更新max长度，同时记录</span></span><br><span class="line">        <span class="comment">//当前遍历的最左边的位置，也就是起点</span></span><br><span class="line">        <span class="keyword">if</span>(maxLen &lt; k - j - <span class="number">1</span>) &#123;</span><br><span class="line">            lo = j + <span class="number">1</span>;</span><br><span class="line">            maxLen = k - j - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法三：动态规划。</p>
<p>动态规划用空间换时间，<strong>而且对于这种字符串来说，针对字符串的动态规划一般套路是把字符串放到行和列上，处理这个”二维矩阵”的每个字符串之间的关系</strong>。</p>
<p>动态规划最关键的步骤是想出来”状态转移方程”，而事实上，”回文”天然就是具有”状态转移”性质的。</p>
<p>可以知道，一个长度为1的字符本身就是回文串、如果长度为2，那么是回文串的条件必须是</p>
<p><strong>定义的状态</strong>：用一个boolean[][]类型的二维数组，dp[i][j]表示子串s[i,j]是否为回文子串，具体说来是从下标为i的字符到下标为j的字符的substring是否为回文子串</p>
<p>因为整个遍历的过程，i始终会小于j(一前一后两个指针)，所以在dp的二维矩阵中实际只填写上半部分即可。</p>
<p>初始化可以用一个循环把对角线上所有值都赋为true，但是实际这一步也可以省略，因为单个字符本身就是回文，而后面dp[i][i]也根本不会被参考的。</p>
<p><strong>状态转移方程</strong>：<code>dp[i][j] = (s[i]==s[j]) and dp[i+1][j-1]</code></p>
<ol>
<li>看到dp[i+1][j-1]就要考虑边界情况，边界条件是[i+1][j-1]不能构成区间，即长度为2，<strong>参考”篮子王”的处理边界的思路，可以处理所有长度为2的字符串，即可，不需要额外考虑判断条件</strong>。</li>
</ol>
<p><strong>考虑输出</strong>：只要一得到<code>dp[i][j]==true</code>，就记录子串的长度和起始位置。注意没必要截取它，因为截取字符串也要消耗性能，只要记录此时的回文串的”起始位置(start)”和”回文长度(maxLen)”即可</p>
<p><strong>具体思路</strong>：</p>
<ol>
<li>在子串左边界j逐渐扩大的过程中，枚举左边界可能出现的位置</li>
<li>左边界枚举的时候可以从小到大，也可以从大到小</li>
</ol>
<p>这两种思路代码差别仅在于内层循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 方法二，DP</span></span><br><span class="line">        <span class="comment">// corner case</span></span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span> || s == <span class="keyword">null</span>) <span class="keyword">return</span> s;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 记录最长子串的长度的maxLen和起始位置start</span></span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>, start = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化，对角线都为单个元素,全部为true</span></span><br><span class="line">        <span class="comment">// 但是这个初始化过程可以省略，因为只有一个字符的时候肯定是回文</span></span><br><span class="line">        <span class="comment">// dp[i][i]根本不会被其他状态值所参考</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// i &lt; len-1 是因为最后要加到i+1，也就是下标为len-1的位置</span></span><br><span class="line">        <span class="comment">// 处理长度为2的边界条件，长度为2时i+1和j-1会越界</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == s.charAt(i+<span class="number">1</span>)) &#123;</span><br><span class="line">                dp[i][i+<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">                maxLen = <span class="number">2</span>;</span><br><span class="line">                start = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; j - <span class="number">1</span>; i++) &#123; <span class="comment">// i &lt; j的话长度为2，之前已经处理过了</span></span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 只要dp[i][j]是true,就证明此时子串s[i,j]是回文串</span></span><br><span class="line">                <span class="comment">// 记录此时回文长度和起始位置,用substring的时候下标从1开始</span></span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] == <span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> tempLen = j - i + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(tempLen &gt; maxLen) &#123;</span><br><span class="line">                        maxLen = tempLen;</span><br><span class="line">                        start = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start, start+maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(n^2)</li>
</ul>
<p>方法四：中心扩散法</p>
<p>回文串一定是对称的，所以我们可以每次循环选择一个中心，进行左右扩展，判断左右字符是否相等即可。</p>
<p>由于存在奇数的字符串和偶数的字符串，所以我们需要从一个字符开始扩展，或者从两个字符之间开始扩展，所以总共有 <code>n+n-1</code> 个中心。（n为n个数，n-1为n个数之间的间隙位置数量）</p>
<p>对于一个有n个元素的字符数组来说，索引为0和len-1的元素不需要扩散，因为扩散不出去。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = expandAroundCenter(s, i, i);</span><br><span class="line">        <span class="keyword">int</span> len2 = expandAroundCenter(s, i, i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> len = Math.max(len1, len2);</span><br><span class="line">        <span class="keyword">if</span> (len &gt; end - start) &#123;</span><br><span class="line">            start = i - (len - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            end = i + len / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(start, end + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expandAroundCenter</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = left, R = right;</span><br><span class="line">    <span class="keyword">while</span> (L &gt;= <span class="number">0</span> &amp;&amp; R &lt; s.length() &amp;&amp; s.charAt(L) == s.charAt(R)) &#123;</span><br><span class="line">        L--;</span><br><span class="line">        R++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> R - L - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法好处在于逻辑更清晰，在LeetCode用例测试中最后耗时也更短（虽然时间复杂度分析起来和方法三的动态规划都是O(n^2)）。</p>
<p>还有一个马拉车算法，暂时不讲，面试很难写完。</p>
<p><strong>总而言之</strong>，”马拉车算法”虽然很著名，但是对待这种字符串的问题，最常用的还是二维的动态规划。实际上，碰到字符串问题，只要牵扯到动态规划，一般都是把这个字符串复制一份，分别放到行和列上。</p>
<p>对于这道题，需要注意：</p>
<ol>
<li>用一个boolean[][]的二维数组来做动态规划</li>
<li>实际只需要填写上半区域的空</li>
<li>因为<strong>“一个回文去掉两头以后，剩下的部分依然是回文(不讨论边界)”</strong>，所以状态转移方程可以知道为：<code>dp[i][j]=(s[i] == s[j]) and dp[i+1][j-1]</code>,在矩形坐标上来看就是，只要不在边界上，一个为回文的子串的[i][j]位置一定和其左下角的[i+1][j-1]一致</li>
<li>注意考虑边界问题，即[i+1][j-1]不能组成区间的情况。我们可以单独处理这个情况。实际上这个边界情况就是目标子串长度为2的情况。我们用一个循环单独处理即可</li>
</ol>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a><strong>后记</strong></h3><p>这确实是一道很经典的有关字符串回文子串处理的题目，经过在LeetCode国际站上的学习，除去中心扩散法，找到了一个很简洁的动态规划版本的代码。我上面提供的代码虽然思路很清晰，但是有些冗长或者啰嗦了。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> static String longestPalindrome(String s) &#123;</span><br><span class="line">        <span class="built_in">int</span> n = s.length();</span><br><span class="line">        String res = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">int</span> palindromeStartsAt = <span class="number">0</span>, maxLen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">bool</span>ean[][] dp = new <span class="built_in">bool</span>ean[n][n];</span><br><span class="line">        <span class="comment">// dp[i][j] indicates whether substring s starting at index i and ending at j is palindrome</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// keep increasing the possible palindrome string</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = i; j &lt; n; j++) &#123; <span class="comment">// find the max palindrome within this window of (i,j)</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//check if substring between (i,j) is palindrome</span></span><br><span class="line">                dp[i][j] = (s.charAt(i) == s.charAt(j)) <span class="comment">// chars at i and j should match</span></span><br><span class="line">                           &amp;&amp; </span><br><span class="line">                           ( j-i &lt; <span class="number">3</span>  <span class="comment">// if window is less than or equal to 3, just end chars should match</span></span><br><span class="line">                             || dp[i+<span class="number">1</span>][j<span class="number">-1</span>]  ); <span class="comment">// if window is &gt; 3, substring (i+1, j-1) should be palindrome too</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//update max palindrome string</span></span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] &amp;&amp; (j-i+<span class="number">1</span> &gt; maxLen)) &#123;</span><br><span class="line">                    palindromeStartsAt = i;</span><br><span class="line">                    maxLen = j-i+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(palindromeStartsAt, palindromeStartsAt+maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="647-Palindromic-Substrings-回文子串-Mid"><a href="#647-Palindromic-Substrings-回文子串-Mid" class="headerlink" title="647.Palindromic Substrings(回文子串)(Mid)"></a><a href="https://leetcode-cn.com/problems/palindromic-substrings/" target="_blank" rel="noopener">647.Palindromic Substrings(回文子串)(Mid)</a></h2><p>Given a string, your task is to count how many palindromic substrings in this string.</p>
<p>The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">Input:</span> <span class="string">"abc"</span></span><br><span class="line"><span class="string">Output:</span> <span class="number">3</span></span><br><span class="line"><span class="string">Explanation:</span> Three palindromic <span class="string">strings:</span> <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">Input:</span> <span class="string">"aaa"</span></span><br><span class="line"><span class="string">Output:</span> <span class="number">6</span></span><br><span class="line"><span class="string">Explanation:</span> Six palindromic <span class="string">strings:</span> <span class="string">"a"</span>, <span class="string">"a"</span>, <span class="string">"a"</span>, <span class="string">"aa"</span>, <span class="string">"aa"</span>, <span class="string">"aaa"</span>.</span><br></pre></td></tr></table></figure>

<hr>
<p>解：这道题可以完全参考第五题的思路。只是最后输出要求不同，第五题要记录最长的子串，这道题要统计所有子串的数量而已。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> countSubstrings(String s) &#123;</span><br><span class="line">        <span class="comment">//corner case</span></span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span> || s == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> result = <span class="number">0</span>, len = s.length();</span><br><span class="line">        <span class="built_in">bool</span>ean[][] dp = new <span class="built_in">bool</span>ean[len][len];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化对角线</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; len ; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理长度为2的边界条件，长度为2时i+1和j-1会越界</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == s.charAt(i+<span class="number">1</span>)) &#123;</span><br><span class="line">                dp[i][i+<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">2</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; j<span class="number">-1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(dp[i][j] == <span class="literal">true</span>) result++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同上，给出简化的动态规划的代码来解决这道647题：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> countSubstrings(String s) &#123;</span><br><span class="line">        <span class="built_in">int</span> len = s.length();</span><br><span class="line">        <span class="built_in">int</span> result = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>) <span class="keyword">return</span> len;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">bool</span>ean[][] dp = new <span class="built_in">bool</span>ean[len][len];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = i; j &lt; len; j++) &#123;</span><br><span class="line">                dp[i][j] = s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt; <span class="number">3</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(dp[i][j]) result++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="820-Short-Encoding-of-Words-单词的压缩编码-Mid"><a href="#820-Short-Encoding-of-Words-单词的压缩编码-Mid" class="headerlink" title="820.Short Encoding of Words(单词的压缩编码)(Mid)"></a><a href="https://leetcode-cn.com/problems/short-encoding-of-words/" target="_blank" rel="noopener">820.Short Encoding of Words(单词的压缩编码)(Mid)</a></h2><p>Given a list of words, we may encode it by writing a reference string S and a list of indexes A.</p>
<p>For example, if the list of words is <code>[&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;]</code>, we can write it as <code>S = &quot;time#bell#&quot;</code> and <code>indexes = [0, 2, 5]</code>.</p>
<p>Then for each index, we will recover the word by reading from the reference string from that index until we reach a <code>&quot;#&quot;</code> character.</p>
<p>What is the length of the shortest reference string S possible that encodes the given words?</p>
<p><strong>Example:</strong></p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Input:</span> words = [<span class="string">"time"</span>, <span class="string">"me"</span>, <span class="string">"bell"</span>]</span><br><span class="line"><span class="symbol">Output:</span> <span class="number">10</span></span><br><span class="line"><span class="symbol">Explanation:</span> S = <span class="string">"time#bell#"</span> <span class="keyword">and</span> indexes = [<span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>].</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ol>
<li><code>1 &lt;= words.length &lt;= 2000.</code></li>
<li><code>1 &lt;= words[i].length &lt;= 7.</code></li>
<li>Each word has only lowercase letters.</li>
</ol>
<hr>
<p>解：根据题意，如果单词<code>Y</code>是另一个单词<code>X</code>的一部分，那么Y就不用考虑了，因为X编码之后里面一定包含Y。反过来说，如果单词Y不在任何别的单词X的后缀中出现，那么Y一定是编码字符串的一部分。</p>
<p>因此，此题的目标就是移除words里的所有单词，使得words里没有一个单词是另一个单词的后缀，最后的结果就是<code>sum(word.length + 1 for word in words)</code></p>
<p>因为题目条件说到words里面的每一个单词长度都不大于7，所以我们可以枚举所有单词，对于每个后缀，我们都将其从words列表中删除。为了查询的高效，可以用哈希表来存储，这里用HashSet</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumLengthEncoding</span><span class="params">(<span class="keyword">String</span>[] words)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化set</span></span><br><span class="line">        Set&lt;<span class="keyword">String</span>&gt; <span class="built_in">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(words));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">String</span> <span class="keyword">word</span> : words) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; <span class="keyword">word</span>.length(); k++) &#123;</span><br><span class="line">                <span class="comment">// 若当前word中包含了k，将这个单词移除，因为它可以被包含</span></span><br><span class="line">                <span class="built_in">set</span>.<span class="built_in">remove</span>(<span class="keyword">word</span>.substring(k));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">String</span> <span class="keyword">word</span> : <span class="built_in">set</span>) &#123;</span><br><span class="line">            <span class="comment">// 加1即为"#"</span></span><br><span class="line">            ans += <span class="keyword">word</span>.length() + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后返回总的长度即可</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="43-Multiply-Strings-字符串相乘-Mid"><a href="#43-Multiply-Strings-字符串相乘-Mid" class="headerlink" title="43.Multiply Strings(字符串相乘)(Mid)"></a><a href="https://leetcode-cn.com/problems/multiply-strings/" target="_blank" rel="noopener">43.Multiply Strings(字符串相乘)(Mid)</a></h2><p>Given two non-negative integers <code>num1</code> and <code>num2</code> represented as strings, return the product of <code>num1</code> and <code>num2</code>, also represented as a string.</p>
<p><strong>Example 1</strong>:</p>
<p>Input: num1 = “2”, num2 = “3”<br>Output: “6”</p>
<p><strong>Example 2</strong>:</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Input:</span> num1 = <span class="string">"123"</span>, num2 = <span class="string">"456"</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="string">"56088"</span></span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ol>
<li>The length of both <code>num1</code> and <code>num2</code> is &lt; 110.</li>
<li>Both <code>num1</code> and <code>num2</code> contain only digits 0-9.</li>
<li>Both <code>num1</code> and <code>num2</code> do not contain any leading zero, except the number 0 itself.</li>
<li>You <strong>must not use any built-in BigInteger library or convert the inputs to integer</strong> directly.</li>
</ol>
<hr>
<p>解：如果只是普通的数字之间的乘法，那是非常简单的。但是需要注意一个规律：<font color=#FF0000>两个数字相乘，得到的结果的位数一定不超过相乘的这两个数的长度之和</font>。</p>
<p>所以我们可以直接开辟一个num1.length()+num2.length()的数组。</p>
<p>接下来求结果，基本思路是一个数一个数之间的相乘。</p>
<p>注意传入的字符的位的位置，低位，比如个位，在下标很大的地方，而高位，比如百位，在下标很小的地方，所以循环可以选择从后面开始。</p>
<p>此外，还要注意保存结果的位置，因为低位保存在右边，也就是int数组下标大的位置，(没错，数字的个位、十位、百位的计位方式刚好和数组的0,1,2,3相反，真的很容易晕掉，晕掉了就怀疑人生了……)。总之最后表现出的结果就是posLow的值反而是比posHigh大1的。</p>
<p>每当两个数之间相乘，就让计算的结果的位数往前错开1，具体内容就是，低位的<code>powLow</code>放到<code>j+i+1</code>的位置，高位<code>posHigh</code>放到<code>i+j</code>的位置。然后要计算与mul的和的情况，mul用于保存每次相乘计算之后的结果。</p>
<p>确定了posLow和posHigh之后，针对mul的操作有三步：mul与result[posLow]的位直接相加得到新的mul结果，然后将低位和高位保存到result里面对应的位置上</p>
<p>如果计算的结果前面有0，则需要干掉这些0然后返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// corner case</span></span><br><span class="line">        <span class="keyword">int</span> len1 = num1.length(), len2 = num2.length();</span><br><span class="line">        <span class="keyword">if</span>(len1 == <span class="number">0</span> || len2 == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="comment">// 存储结果</span></span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[len1 + len2];</span><br><span class="line">        <span class="comment">// 两个for循环嵌套，为了从num1和num2中依次取一位，然后依次做乘法</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len1 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = len2 - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="comment">// 从num1和num2中依次取一位做乘法</span></span><br><span class="line">                <span class="comment">// 取出来单个char后减去'0'，自动转换成ASCII码的计算，得到int值</span></span><br><span class="line">                <span class="keyword">int</span> mul = (num1.charAt(i) - <span class="string">'0'</span>) * (num2.charAt(j) - <span class="string">'0'</span>);</span><br><span class="line">                <span class="comment">// posLow和posHigh相差1，这两个数表示取出来的数每次相乘之后</span></span><br><span class="line">                <span class="comment">// 要填的result的位置</span></span><br><span class="line">                <span class="keyword">int</span> posLow = i+j+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> posHigh = i+j;</span><br><span class="line">                <span class="comment">// 两数相乘之后还要加上再之前计算所得到的进位，才是当前计算的最终结果</span></span><br><span class="line">                mul += result[posLow];</span><br><span class="line">                result[posLow] = mul % <span class="number">10</span>;</span><br><span class="line">                result[posHigh] += mul / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理结果，用长度可变的StringBuilder</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">// 忽略所有leading zero，只有当前位不为0而且</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> res : result) &#123;</span><br><span class="line">            <span class="comment">// 如果sb为空而且此时res为0，那么此时res就是leading 0,要跳过</span></span><br><span class="line">            <span class="keyword">if</span>(!(sb.length() == <span class="number">0</span> &amp;&amp; res == <span class="number">0</span>)) sb.append(res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果最后算结果是0，那么直接返回0，解决了乘数是0的case</span></span><br><span class="line">        <span class="keyword">return</span> (sb.length() == <span class="number">0</span>) ? <span class="string">"0"</span> : sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(len1 * len2)</p>
<h2 id="93-Restore-IP-Addresses-复原IP地址-Mid"><a href="#93-Restore-IP-Addresses-复原IP地址-Mid" class="headerlink" title="93.Restore IP Addresses(复原IP地址)(Mid)"></a><a href="https://leetcode-cn.com/problems/restore-ip-addresses/" target="_blank" rel="noopener">93.Restore IP Addresses(复原IP地址)(Mid)</a></h2><p>Given a string containing only digits, restore it by returning all possible valid IP address combinations.</p>
<p><strong>Example:</strong></p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Input:</span> <span class="string">"25525511135"</span></span><br><span class="line"><span class="symbol">Output:</span> [<span class="string">"255.255.11.135"</span>, <span class="string">"255.255.111.35"</span>]</span><br></pre></td></tr></table></figure>

<hr>
<p>解：方法一，暴力解决。但是这个暴力的解法本身也是非常巧妙的，枚举所有可能的情况。因为Input本身就不复杂，所以情况并不会非常非常多。</p>
<p>暴力法是一种面试的时候完全可以考虑使用的方法(如果只考虑把题目解出来……)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">restoreIpAddresses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        StringBuilder ip = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">1</span>; a &lt; <span class="number">4</span>; a++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> b = <span class="number">1</span>; b &lt; <span class="number">4</span>; b++) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">1</span>; c &lt; <span class="number">4</span>; c++) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> d = <span class="number">1</span>; d &lt; <span class="number">4</span>; d++) &#123;</span><br><span class="line">                                                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         * 1、保障下面subString不会越界</span></span><br><span class="line"><span class="comment">                         * 2、保障截取的字符串与输入字符串长度相同</span></span><br><span class="line"><span class="comment">                         * //1、2比较好理解，3比较有意思</span></span><br><span class="line"><span class="comment">                         * 3、不能保障截取的字符串转成int后与输入字符串长度相同</span></span><br><span class="line"><span class="comment">                         * 如：字符串010010，a=1，b=1，c=1，d=3，对应字符串0，1，0，010</span></span><br><span class="line"><span class="comment">                         * 转成int后seg1=0，seg2=1，seg3=0，seg4=10</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        <span class="keyword">if</span>(a + b + c + d == s.length()) &#123;</span><br><span class="line">                            <span class="keyword">int</span> n1 = Integer.parseInt(s.substring(<span class="number">0</span>,a));</span><br><span class="line">                            <span class="keyword">int</span> n2 = Integer.parseInt(s.substring(a,a+b));</span><br><span class="line">                            <span class="keyword">int</span> n3 = Integer.parseInt(s.substring(a+b,a+b+c));</span><br><span class="line">                            <span class="keyword">int</span> n4 = Integer.parseInt(s.substring(a+b+c));</span><br><span class="line">                            <span class="comment">// 四个段数值满足0~255</span></span><br><span class="line">                            <span class="keyword">if</span>(n1 &lt;= <span class="number">255</span> &amp;&amp; n2 &lt;= <span class="number">255</span> &amp;&amp; n3 &lt;= <span class="number">255</span> &amp;&amp; n4 &lt;= <span class="number">255</span>) &#123;</span><br><span class="line">                                ip.append(n1).append(<span class="string">'.'</span>)</span><br><span class="line">                                    .append(n2).append(<span class="string">'.'</span>)</span><br><span class="line">                                    .append(n3).append(<span class="string">'.'</span>)</span><br><span class="line">                                    .append(n4);</span><br><span class="line">                                <span class="comment">// 保障截取的字符串转成int后与输入字符串长度相同</span></span><br><span class="line">                                <span class="comment">// 这个判断用于处理特殊情况，即比如输入为 010010，分割成0,1,0,10</span></span><br><span class="line">                                <span class="keyword">if</span>(ip.length() == s.length()+<span class="number">3</span>) result.add(ip.toString());</span><br><span class="line">                                ip.delete(<span class="number">0</span>,ip.length());</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，递归回溯</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">restoreIpAddresses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> &amp;&amp; s.length() &gt; <span class="number">12</span>) <span class="keyword">return</span> result;</span><br><span class="line">        restoreHelper(result, s, <span class="string">""</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restoreHelper</span><span class="params">(List&lt;String&gt; result, String s, String current, <span class="keyword">int</span> field)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// field:0, 1, 2, 3, 4 means all done</span></span><br><span class="line">        <span class="comment">// 用field判断当前有几段，即几个field，满了4段即为IP地址的格式</span></span><br><span class="line">        <span class="keyword">if</span>(field == <span class="number">4</span> &amp;&amp; s.length() == <span class="number">0</span>) result.add(current.substring(<span class="number">1</span>)); <span class="comment">// remove the prefixed "."</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(field == <span class="number">4</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> ;<span class="comment">//not valid combination</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            restoreHelper(result, s.substring(<span class="number">1</span>), current + <span class="string">"."</span> + s.substring(<span class="number">0</span>,<span class="number">1</span>), field + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(<span class="number">0</span>) != <span class="string">'0'</span> &amp;&amp; s.length() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                restoreHelper(result, s.substring(<span class="number">2</span>), current + <span class="string">"."</span> + s.substring(<span class="number">0</span>,<span class="number">2</span>),field + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(s.length() &gt; <span class="number">2</span> &amp;&amp; Integer.valueOf(s.substring(<span class="number">0</span>,<span class="number">3</span>)) &lt;= <span class="number">255</span>) </span><br><span class="line">                    restoreHelper(result, s.substring(<span class="number">3</span>),current+<span class="string">"."</span>+s.substring(<span class="number">0</span>,<span class="number">3</span>),field+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong>重点看暴力法</p>
<h2 id="415-Add-Strings-字符串相加-Easy"><a href="#415-Add-Strings-字符串相加-Easy" class="headerlink" title="415.Add Strings(字符串相加)(Easy)"></a><a href="https://leetcode-cn.com/problems/add-strings/" target="_blank" rel="noopener">415.Add Strings(字符串相加)(Easy)</a></h2><p>Given two non-negative integers <code>num1</code> and <code>num2</code> represented as string, return the sum of <code>num1</code> and <code>num2</code>.</p>
<p><strong>Note:</strong></p>
<ol>
<li>The length of both <code>num1</code> and <code>num2</code> is &lt; 5100.</li>
<li>Both <code>num1</code> and <code>num2</code> contains only digits 0-9.</li>
<li>Both <code>num1</code> and <code>num2</code> does not contain any leading zero.</li>
<li>You must not use any built-in BigInteger library or convert the inputs to integer directly.</li>
</ol>
<hr>
<p>解：这道题内核很类似整数反转的过程，主要是提取出每一位的数字，然后计算，加法的话用carry记录是否有进位(加法进位只可能是0或者1)，然后利用除以10得到十位，求余10得到个位。把字符转换成具体数字的操作也很简单，将char减去’0’即可。</p>
<p>这里每次计算都依次放入结果，用StirngBuilder进行保存。但是每次append()之后都是放在了末尾，最后返回结果的时候要reverse()一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">int</span> len1 = num1.length(), len2 = num2.length();</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len1 - <span class="number">1</span>, j = len2 - <span class="number">1</span>; i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>; i--,j--) &#123;</span><br><span class="line">            <span class="keyword">int</span> charNum1 = i &gt;= <span class="number">0</span> ? num1.charAt(i)-<span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> charNum2 = j &gt;= <span class="number">0</span> ? num2.charAt(j)-<span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> sum = charNum1 + charNum2 + carry;</span><br><span class="line">            <span class="keyword">int</span> val = sum % <span class="number">10</span>;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            result.append(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry != <span class="number">0</span>) result.append(carry);</span><br><span class="line">        <span class="keyword">return</span> result.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="937-Reorder-Data-In-Log-Files-重新排列日志文件-Easy"><a href="#937-Reorder-Data-In-Log-Files-重新排列日志文件-Easy" class="headerlink" title="937.Reorder Data In Log Files(重新排列日志文件)(Easy)"></a><a href="https://leetcode-cn.com/problems/reorder-data-in-log-files/" target="_blank" rel="noopener">937.Reorder Data In Log Files(重新排列日志文件)(Easy)</a></h2><p>You have an array of <code>logs</code>. Each log is a space delimited string of words.</p>
<p>For each log, the first word in each log is an alphanumeric <em>identifier</em>. Then, either:</p>
<ul>
<li>Each word after the identifier will consist only of lowercase letters, or;</li>
<li>Each word after the identifier will consist only of digits.</li>
</ul>
<p>We will call these two varieties of logs <em>letter-logs</em> and <em>digit-logs</em>. It is guaranteed that each log has at least one word after its identifier.</p>
<p>Reorder the logs so that all of the letter-logs come before any digit-log. The letter-logs are ordered lexicographically ignoring identifier, with the identifier used in case of ties. The digit-logs should be put in their original order.</p>
<p>Return the final order of the logs.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="string">logs</span> <span class="string">=</span> <span class="string">["dig1</span> <span class="number">8</span> <span class="number">1</span> <span class="number">5</span> <span class="number">1</span><span class="string">","</span><span class="string">let1</span> <span class="string">art</span> <span class="string">can","dig2</span> <span class="number">3</span> <span class="number">6</span><span class="string">","</span><span class="string">let2</span> <span class="string">own</span> <span class="string">kit</span> <span class="string">dig","let3</span> <span class="string">art</span> <span class="string">zero"]</span></span><br><span class="line"><span class="attr">Output:</span> <span class="string">["let1</span> <span class="string">art</span> <span class="string">can","let3</span> <span class="string">art</span> <span class="string">zero","let2</span> <span class="string">own</span> <span class="string">kit</span> <span class="string">dig","dig1</span> <span class="number">8</span> <span class="number">1</span> <span class="number">5</span> <span class="number">1</span><span class="string">","</span><span class="string">dig2</span> <span class="number">3</span> <span class="number">6</span><span class="string">"]</span></span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ol>
<li><code>0 &lt;= logs.length &lt;= 100</code></li>
<li><code>3 &lt;= logs[i].length &lt;= 100</code></li>
<li><code>logs[i]</code> is guaranteed to have an identifier, and a word after the identifier.</li>
</ol>
<hr>
<p>解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> String[] reorderLogFiles(String[] logs) &#123;</span><br><span class="line">        </span><br><span class="line">        Comparator&lt;String&gt; myComp = <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> s1SpaceIndex = s1.indexOf(<span class="string">' '</span>);</span><br><span class="line">                <span class="keyword">int</span> s2SpaceIndex = s2.indexOf(<span class="string">' '</span>);</span><br><span class="line">                <span class="keyword">char</span> s1FirstCharacter = s1.charAt(s1SpaceIndex+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">char</span> s2FirstCharacter = s2.charAt(s2SpaceIndex+<span class="number">1</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (s1FirstCharacter &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s2FirstCharacter &lt;= <span class="string">'9'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (s2FirstCharacter &lt;= <span class="string">'9'</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">int</span> preCompute = s1.substring(s1SpaceIndex+<span class="number">1</span>).compareTo(s2.substring(s2SpaceIndex+<span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span> (preCompute == <span class="number">0</span>) <span class="keyword">return</span> s1.substring(<span class="number">0</span>,s1SpaceIndex).compareTo(s2.substring(<span class="number">0</span>,s2SpaceIndex));</span><br><span class="line">                <span class="keyword">return</span> preCompute;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(logs, myComp);</span><br><span class="line">        <span class="keyword">return</span> logs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-Longest-Substring-Without-Repeating-Characters-无重复字符的最长子串-Mid"><a href="#3-Longest-Substring-Without-Repeating-Characters-无重复字符的最长子串-Mid" class="headerlink" title="3.Longest Substring Without Repeating Characters(无重复字符的最长子串)(Mid)"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3.Longest Substring Without Repeating Characters(无重复字符的最长子串)(Mid)</a></h2><p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">Input: <span class="string">"abcabcbb"</span></span><br><span class="line">Output: <span class="number">3</span> </span><br><span class="line">Explanation: The answer <span class="keyword">is</span> <span class="string">"abc"</span>, <span class="keyword">with</span> <span class="keyword">the</span> <span class="built_in">length</span> <span class="keyword">of</span> <span class="number">3.</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">Input: <span class="string">"bbbbb"</span></span><br><span class="line">Output: <span class="number">1</span></span><br><span class="line">Explanation: The answer <span class="keyword">is</span> <span class="string">"b"</span>, <span class="keyword">with</span> <span class="keyword">the</span> <span class="built_in">length</span> <span class="keyword">of</span> <span class="number">1.</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Input: <span class="string">"pwwkew"</span></span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is <span class="string">"wke"</span>, with the length of 3. </span><br><span class="line">            <span class="built_in"> Note </span>that the answer must be a substring, <span class="string">"pwke"</span> is a subsequence <span class="keyword">and</span> <span class="keyword">not</span> a substring.</span><br></pre></td></tr></table></figure>

<hr>
<p>解：<strong>解法一：暴力法</strong></p>
<p>找到所有子串，然后每一个子串都一个一个地去判断是否有重复的字符。</p>
<p>要分析这个方法的时间复杂度，首先我们需要弄清楚一些问题，假设字符串长度为n，那么它有多少个非空子串？</p>
<p>答案是 n*(n+1)/2 个。</p>
<p>怎么计算出来的？</p>
<ul>
<li>长度为1的子串，有n个</li>
<li>长度为2的子串，有n-1个</li>
<li>长度为3的子串，有n-2个</li>
</ul>
<p>…</p>
<ul>
<li>长度为k的子串，有n-k+1个</li>
<li>当k=n时，n-k+1=1，即长度为n的子串就是1个</li>
</ul>
<p>所有情况相加，可以得到：<br>n+(n-1)+(n-2)+(n-3)+…+2+1 = n(n+1)/2<br>算上空字符串，一共有：(n(n+1)/2) + 1</p>
<p>在这里可以进行对比，子串和子序列的区别。比如，对于长度为n的字符串，一共有多少子序列？</p>
<p>答案是2^n</p>
<p>怎么计算得到的？</p>
<ul>
<li><p>子序列不同于子串</p>
</li>
<li><p>子序列中的元素不需要相互挨着</p>
</li>
<li><p>长度为1的子序列有n个，即：C(1,n)</p>
</li>
<li><p>长度为2的子序列有C(2,n)个</p>
</li>
<li><p>长度为3的子序列有C(3,n)个</p>
</li>
</ul>
<p>…</p>
<ul>
<li>长度为k的子序列有C(k,n)个</li>
<li>所有子序列的个数(包括空序列)为：C(0,n) + C(1,n) + C(2,n) + C(3,n) + … + C(n,n) = 2^n</li>
</ul>
<p>这里有关统计字符串的子串和子序列的过程和方法，和结果，务必熟悉和记下来，对于分析各种问题能有帮助。</p>
<p>如果对所有的子串进行判断，从每个子串里寻找最长且没有重复字符的，复杂度为：O(n* (n+1)/2 * n) = O(n^3)</p>
<p>当然，这不是最好的办法。</p>
<p><strong>解法二：线性法</strong></p>
<ul>
<li>把每次遍历到的字符放入到一个哈希集合中，这样每次判断当前遍历过的内容中是否包含下一个要遍历的字符的时候，用哈希表的contains方法，时间复杂度为O(1),比不放到哈希表中的O(n)的速度能够得到提高。</li>
</ul>
<p>具体解法：</p>
<ul>
<li>定义一个哈希集合set</li>
<li>从给定字符串的头开始，每次检查当前字符是否在集合内。如果不在，说明该字符不会造成冲突和重复，将其加入到集合中，并统计当前集合长度，或许为最长子串</li>
</ul>
<p>如果出现了重复的子串，处理方法是定义两个指针，i为慢指针，j为快指针。</p>
<p>当 j 遇到一个重复出现的字符时，我们从慢指针开始一个一个地将 i 指针指向的字符从集合中删除，然后判断是否可以把新字符加入到集合而不会重复。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义一个哈希集合set,初始化结果max为0</span></span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 利用快慢指针i(慢)和j(快)扫描一遍字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; j &lt; s.length(); j++) &#123;</span><br><span class="line">            <span class="comment">// 如果快指针指向的字符已经出现在哈希集合中,不断尝试将慢指针指向的字符从哈希集合中删除</span></span><br><span class="line">            <span class="keyword">while</span>(set.contains(s.charAt(j))) &#123;</span><br><span class="line">                set.remove(s.charAt(i));</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 当快指针的字符终于能加入到哈希集合的时候，更新结果max</span></span><br><span class="line">            set.add(s.charAt(j));</span><br><span class="line">            max = Math.max(max, set.size());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历完毕后，返回结果max</span></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度分析：O(n)。使用了快慢指针策略，字符串最多被遍历两次。快指针会被添加到哈希表集合，慢指针遇到的字符会从哈希集合中删除。哈希集合操作时间为O(1)，因此整个算法复杂度为：n * O(1) + n*O(1) = O(n)</li>
<li>空间复杂度分析：O(n)。由于使用到哈希集合，最坏的情况下，即给定的字符串没有任何重复的字符，我们需要把每个字符都加入集合。</li>
</ul>
<p><strong>解法三：优化的线性法</strong></p>
<p>基于方法二的线性法。也就是，如果我们在遍历过程中遇到了set已经有的字符的时候，如何不让慢指针一步一步移动，而是直接移动到重复元素的后面呢？这样可以大大减少比较次数。</p>
<p>这样一来我们需要能够记录每个字符出现的下标位置，可以用哈希表记录，因为查找过程时间复杂度也是O(1)</p>
<p>而且此时，我们不能像之前一样去数哈希集合的元素作为max的结果。比如可能出现一种情况，就是当前快指针j遍历到的元素在之前已经出现过了，那么此时不能让i又跳回到前面去呀！所以i的值需要有max计算得到：i = Math.max(i, map.get(s.charAt(j) + 1));</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义一个哈希表map用来记录上次某字符出现的位置,初始化结果max为0</span></span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 利用快慢指针i(慢)和j(快)扫描一遍字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; j &lt; s.length(); j++) &#123;</span><br><span class="line">            <span class="comment">// 如果发现快指针所对应的字符已经出现过，慢指针就进行跳跃</span></span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(s.charAt(j))) &#123;</span><br><span class="line">                i = Math.max(i, map.get(s.charAt(j)) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 把快指针所对应的字符添加到哈希表中，更新结果max</span></span><br><span class="line">            map.put(s.charAt(j), j);</span><br><span class="line">            max = Math.max(max, j - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历完毕后，返回结果max</span></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-String-to-Integer-字符串转换整数-atoi-Mid"><a href="#8-String-to-Integer-字符串转换整数-atoi-Mid" class="headerlink" title="8.String to Integer (字符串转换整数 (atoi)(Mid)"></a><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">8.String to Integer (字符串转换整数 (atoi)(Mid)</a></h2><p>Implement <code>atoi</code> which converts a string to an integer.</p>
<p>The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.</p>
<p>The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</p>
<p>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.</p>
<p>If no valid conversion could be performed, a zero value is returned.</p>
<p><strong>Note:</strong></p>
<ul>
<li>Only the space character <code>&#39; &#39;</code> is considered as whitespace character.</li>
<li>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^(31), 2^(31) − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Input:</span> <span class="string">"42"</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="number">42</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Inpu<span class="variable">t:</span> <span class="string">"	-42"</span></span><br><span class="line">Outpu<span class="variable">t:</span> -<span class="number">42</span></span><br><span class="line">Explanation: The <span class="keyword">first</span> non-whitespace character <span class="keyword">is</span> <span class="string">'-'</span>, which <span class="keyword">is</span> the minus <span class="keyword">sign</span>.</span><br><span class="line">             Then take <span class="keyword">as</span> many numerical digits <span class="keyword">as</span> possible, which gets <span class="number">42</span>.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Input</span>: "4193 with words"</span><br><span class="line">Output: <span class="number">4193</span></span><br><span class="line">Explanation: <span class="keyword">Conversion</span> stops at digit <span class="string">'3'</span> <span class="keyword">as</span> the next <span class="type">character</span> <span class="keyword">is</span> <span class="keyword">not</span> a numerical digit.</span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Input</span>: "words and 987"</span><br><span class="line">Output: <span class="number">0</span></span><br><span class="line">Explanation: The first non-whitespace <span class="type">character</span> <span class="keyword">is</span> <span class="string">'w'</span>, which <span class="keyword">is</span> <span class="keyword">not</span> a numerical </span><br><span class="line">             digit <span class="keyword">or</span> a +/- sign. Therefore <span class="keyword">no</span> <span class="keyword">valid</span> <span class="keyword">conversion</span> could be performed.</span><br></pre></td></tr></table></figure>

<p><strong>Example 5:</strong></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Input</span>: "-91283472332"</span><br><span class="line">Output: <span class="number">-2147483648</span></span><br><span class="line">Explanation: The number "-91283472332" <span class="keyword">is</span> <span class="keyword">out</span> <span class="keyword">of</span> the range <span class="keyword">of</span> a <span class="number">32</span>-<span class="type">bit</span> signed <span class="type">integer</span>.</span><br><span class="line">             Thefore INT_MIN (−<span class="number">231</span>) <span class="keyword">is</span> returned.</span><br></pre></td></tr></table></figure>

<hr>
<p>解：atoi，实际上意思是：ASCII to Integer。</p>
<p>我们可以把题目需求分为两部分，数字字符之前的部分和数字字符之后的部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        str = str.trim();<span class="comment">//干掉所有首和尾的空格</span></span><br><span class="line">        <span class="keyword">if</span>(str.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1表示正数、-1表示负数</span></span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//idx依次指向每一个Character</span></span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span> c = str.charAt(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">'+'</span>) &#123;</span><br><span class="line">            sign = <span class="number">1</span>;</span><br><span class="line">            idx++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'-'</span>) &#123;</span><br><span class="line">            sign = -<span class="number">1</span>;</span><br><span class="line">            idx++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//int可能存不下，用long存</span></span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = idx;i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!Character.isDigit(str.charAt(i))) &#123; <span class="comment">//当遍历的str的第i个不为数字时跳出</span></span><br><span class="line">                <span class="comment">//无形中处理了一种异常情况：打头的是字母的时候，直接返回0</span></span><br><span class="line">                <span class="keyword">return</span> (<span class="keyword">int</span>)sum * sign;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若当前遍历到的为数字，则累加到sum中</span></span><br><span class="line">            sum = sum * <span class="number">10</span> + str.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">            <span class="comment">//处理sum大于Integer.MAX_VALUE这个边界条件</span></span><br><span class="line">            <span class="keyword">if</span>(sign == <span class="number">1</span> &amp;&amp; sum &gt; Integer.MAX_VALUE) &#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//处理sum小于Integer.MIN_VALUE这个边界条件</span></span><br><span class="line">            <span class="keyword">if</span>(sign == -<span class="number">1</span> &amp;&amp; (-<span class="number">1</span>) * sum &lt; Integer.MIN_VALUE) &#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) sum * sign;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="14-Longest-Common-Prefix-最长公共前缀-Easy"><a href="#14-Longest-Common-Prefix-最长公共前缀-Easy" class="headerlink" title="14.Longest Common Prefix(最长公共前缀)(Easy)"></a><a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">14.Longest Common Prefix(最长公共前缀)(Easy)</a></h2><p>Write a function to find the longest common prefix string amongst an array of strings.</p>
<p>If there is no common prefix, return an empty string <code>&quot;&quot;</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Input:</span> [<span class="string">"flower"</span>,<span class="string">"flow"</span>,<span class="string">"flight"</span>]</span><br><span class="line"><span class="symbol">Output:</span> <span class="string">"fl"</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Input: [<span class="string">"dog"</span>,<span class="string">"racecar"</span>,<span class="string">"car"</span>]</span><br><span class="line">Output: <span class="string">""</span></span><br><span class="line">Explanation: There is <span class="literal">no</span> common<span class="built_in"> prefix </span>among the input strings.</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<p>All given inputs are in lowercase letters <code>a-z</code>.</p>
<hr>
<p>解：利用水平扫描法进行遍历，首先遍历第1、2个元素，找到共同的前缀、然后将找到的共同的前缀再利用起来，往后找，直到前缀prefix为空了为止，直接返回空字符串。</p>
<p>注意这里很巧妙地使用了Java的<code>indexOf()</code>方法，其作用是：查找一个字符串中，第一次出现指定字符的位置。即<code>indexOf(int, ch)</code>.<font color=#FF0000>注意，这个位置是从0开始计数的</font>。如果没有搜索到，返回-1.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//特判</span></span><br><span class="line">        <span class="keyword">if</span>(strs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="comment">//从strs的第一个元素开始作为前缀遍历</span></span><br><span class="line">        String prefix = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//从第二个开始比遍历每一个字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            <span class="comment">//这里很巧妙地利用了indexOf这个函数，起始值必须是0才行，因为前缀从头开始</span></span><br><span class="line">            <span class="comment">//如果不是0，那么可能是-1，即无法匹配，则进入循环</span></span><br><span class="line">            <span class="keyword">while</span>(strs[i].indexOf(prefix) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//截取prefix，从最后往前截取，长度每次减1</span></span><br><span class="line">                prefix = prefix.substring(<span class="number">0</span>, prefix.length() - <span class="number">1</span>);</span><br><span class="line">                <span class="comment">//当截取的长度到了0，代表此时prefix为空字符串，即无法匹配到结果</span></span><br><span class="line">                <span class="keyword">if</span>(prefix.isEmpty()) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="28-Implement-strStr-实现strStr-Easy"><a href="#28-Implement-strStr-实现strStr-Easy" class="headerlink" title="28.Implement strStr()(实现strStr())(Easy)"></a><a href="https://leetcode-cn.com/problems/implement-strstr/" target="_blank" rel="noopener">28.Implement strStr()(实现strStr())(Easy)</a></h2><p>Implement <a href="http://www.cplusplus.com/reference/cstring/strstr/" target="_blank" rel="noopener">strStr()</a>.</p>
<p>Return the index of the first occurrence of needle in haystack, or <strong>-1</strong> if needle is not part of haystack.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Input:</span> haystack = <span class="string">"hello"</span>, needle = <span class="string">"ll"</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Input:</span> haystack = <span class="string">"aaaaa"</span>, needle = <span class="string">"bba"</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p><strong>Clarification:</strong></p>
<p>What should we return when <code>needle</code> is an empty string? This is a great question to ask during an interview.</p>
<p>For the purpose of this problem, we will return 0 when <code>needle</code> is an empty string. This is consistent to C’s <a href="http://www.cplusplus.com/reference/cstring/strstr/" target="_blank" rel="noopener">strstr()</a> and Java’s <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)" target="_blank" rel="noopener">indexOf()</a>.</p>
<hr>
<p>解：首先注意最后的Clarification(说明)中的内容，当needle为空的时候，我们应该返回什么？这是一个好问题，我们这里返回的是0,(匹配不到才返回-1)，这个和java中的<code>indexOf()</code>和C语言中的<code>strstr()</code>返回的结果相同。</p>
<p>方法一：暴力法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = haystack.length();</span><br><span class="line">        <span class="keyword">int</span> len2 = needle.length();</span><br><span class="line">        <span class="keyword">if</span>(len1 &lt; len2) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len2 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1 - len2 + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(haystack.substring(i, i+len2).equals(needle)) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O((m-n)n)，m是主字符串、n是模式字符串</p>
<p>方法二：KMP算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String S, String T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (T == <span class="keyword">null</span> || T.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[T.length()];</span><br><span class="line">        getNext(T, next);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; S.length() &amp;&amp; j &lt; T.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == -<span class="number">1</span> || S.charAt(i) == T.charAt(j)) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == T.length()) <span class="keyword">return</span> i - j;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getNext</span><span class="params">(String t, <span class="keyword">int</span>[] next)</span> </span>&#123;</span><br><span class="line">        next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; t.length() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == -<span class="number">1</span> || t.charAt(i) == t.charAt(j)) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">                next[i] = j;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="151-Reverse-Words-in-a-String-反转字符串里的单词-Mid"><a href="#151-Reverse-Words-in-a-String-反转字符串里的单词-Mid" class="headerlink" title="151.Reverse Words in a String(反转字符串里的单词)(Mid)"></a><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/" target="_blank" rel="noopener">151.Reverse Words in a String(反转字符串里的单词)(Mid)</a></h2><p>Given an input string, reverse the string word by word.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Input:</span> <span class="string">"the sky is blue"</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="string">"blue is sky the"</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Input:</span> <span class="string">"  hello world!  "</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="string">"world! hello"</span></span><br><span class="line"><span class="symbol">Explanation:</span> Your reversed string should not contain leading <span class="keyword">or</span> trailing spaces.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">Input: <span class="string">"a good   example"</span></span><br><span class="line">Output: <span class="string">"example good a"</span></span><br><span class="line">Explanation: You need <span class="built_in">to</span> reduce multiple spaces between <span class="literal">two</span> <span class="keyword">words</span> <span class="built_in">to</span> <span class="keyword">a</span> single <span class="literal">space</span> <span class="keyword">in</span> <span class="keyword">the</span> reversed <span class="keyword">string</span>.</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ul>
<li>A word is defined as a sequence of non-space characters.</li>
<li>Input string may contain leading or trailing spaces. However, your reversed string should not contain leading or trailing spaces.</li>
<li>You need to reduce multiple spaces between two words to a single space in the reversed string.</li>
</ul>
<p><strong>Follow up:</strong></p>
<p>For C programmers, try to solve it <em>in-place</em> in <em>O</em>(1) extra space.</p>
<hr>
<p>解：<a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/solution/fan-zhuan-zi-fu-chuan-li-de-dan-ci-by-leetcode-sol/" target="_blank" rel="noopener">详细题解可以参考这篇文章</a></p>
<p>这道题主要考察两点：</p>
<ol>
<li>能否形成有效的算法</li>
<li>能否处理边界条件</li>
</ol>
<p>方法一：利用Java语言库中的trim()、split()、reverse()、join()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 除去开头和末尾的空白字符</span></span><br><span class="line">        s = s.trim();</span><br><span class="line">        <span class="comment">// 正则匹配连续的空白字符作为分隔符分割</span></span><br><span class="line">        List&lt;String&gt; wordList = Arrays.asList(s.split(<span class="string">"\\s+"</span>));</span><br><span class="line">        Collections.reverse(wordList);</span><br><span class="line">        <span class="keyword">return</span> String.join(<span class="string">" "</span>,wordList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(N)，其中N为输入字符串的长度</li>
<li>空间复杂度：O(N)，用来存储字符串分割之后的结果</li>
</ul>
<p>方法二：自己编写反转函数，先将经过trim()之后的字符串中每一个字符都倒着放入一个字符串里，此时整个字符串时翻转的，但是每个单词里面也都是翻转的。所以再需要将每一个单词进行一次翻转，即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">trimSpaces</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 去掉字符串开头的空白字符</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; s.charAt(left) == <span class="string">' '</span>) ++left;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去掉字符串末尾的空白字符</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; s.charAt(right) == <span class="string">' '</span>) --right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将字符串间多余的空白字符去除</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(left);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c != <span class="string">' '</span>) sb.append(c);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sb.charAt(sb.length() - <span class="number">1</span>) != <span class="string">' '</span>) sb.append(c);</span><br><span class="line"></span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(StringBuilder sb, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">char</span> tmp = sb.charAt(left);</span><br><span class="line">            sb.setCharAt(left++, sb.charAt(right));</span><br><span class="line">            sb.setCharAt(right--, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseEachWord</span><span class="params">(StringBuilder sb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = sb.length();</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (start &lt; n) &#123;</span><br><span class="line">            <span class="comment">// 循环至单词的末尾</span></span><br><span class="line">            <span class="keyword">while</span> (end &lt; n &amp;&amp; sb.charAt(end) != <span class="string">' '</span>) ++end;</span><br><span class="line">            <span class="comment">// 翻转单词</span></span><br><span class="line">            reverse(sb, start, end - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 更新start，去找下一个单词</span></span><br><span class="line">            start = end + <span class="number">1</span>;</span><br><span class="line">            ++end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = trimSpaces(s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 翻转字符串</span></span><br><span class="line">        reverse(sb, <span class="number">0</span>, sb.length() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 翻转每个单词</span></span><br><span class="line">        reverseEachWord(sb);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(N),N为输入字符串的长度</li>
<li>空间复杂度：Java和Python需要O(N)的空间来存储字符串，而C++只需要O(1)的额外空间来存放若干变量。</li>
</ul>
<p>方法三：用双端队列，每遍历到一个字符串，就放入到队尾即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 去掉字符串开头的空白字符</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; s.charAt(left) == <span class="string">' '</span>) ++left;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去掉字符串末尾的空白字符</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; s.charAt(right) == <span class="string">' '</span>) --right;</span><br><span class="line"></span><br><span class="line">        Deque&lt;String&gt; d = <span class="keyword">new</span> ArrayDeque();</span><br><span class="line">        StringBuilder word = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(left);</span><br><span class="line">            <span class="keyword">if</span> ((word.length() != <span class="number">0</span>) &amp;&amp; (c == <span class="string">' '</span>)) &#123;</span><br><span class="line">                <span class="comment">// 将单词 push 到队列的头部</span></span><br><span class="line">                d.offerFirst(word.toString());</span><br><span class="line">                word.setLength(<span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c != <span class="string">' '</span>) &#123;</span><br><span class="line">                word.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line">        d.offerFirst(word.toString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> String.join(<span class="string">" "</span>, d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(N)，其中N为输入字符串的长度</li>
<li>空间复杂度：O(N)，双端队列存储单词需要O(N)的空间</li>
</ul>
]]></content>
      <categories>
        <category>Algorithms Note</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Sort</title>
    <url>/2020/01/13/LeetCode-Practice-by-Categories-Sort/</url>
    <content><![CDATA[<blockquote>
<p>所谓爱一个人，不是宽裕了想要给予，而是恳切地必须给予。<br>所谓爱一个人，不是喜欢对方的体温，而是要跟对方的体温越来越接近。所谓爱一个人，是即便对方一直折磨你，你想要的一直讨厌对方，但怎么也讨厌不起来。所谓爱一个人，真的是一件难事。所谓爱，不是不讨厌，而是绝对不能讨厌的意思。<br>——《请回答1988》</p>
</blockquote>
<p>由浅入深介绍和分析各种排序算法，重点给出快排和归并排序的实现思路。</p>
<a id="more"></a>

<p>国内面试中经常会问到排序方面问题。如果开放性强的话，可能直接问你有关排序，可以畅所欲言。但是考察得更多的应该还是排序的的思路和代码，尤其是快排、归并。</p>
<p>首先，排序分为比较类排序和非比较类排序，如下图所示：</p>
<p><img src="https://s2.ax1x.com/2020/02/13/1O9RkF.png" alt="1O9RkF.png"></p>
<h2 id="如何理解比较类排序和非比较类排序？"><a href="#如何理解比较类排序和非比较类排序？" class="headerlink" title="如何理解比较类排序和非比较类排序？"></a><strong>如何理解比较类排序和非比较类排序？</strong></h2><ol>
<li>比较类排序： 通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn), 因此也称为非线性时间比较类排序。</li>
</ol>
<ul>
<li>在高级语言里，大家直接调用系统的排序函数的时候，你可以传入一个参数：comparator(java语言，其他语言可能叫做cmp之类的函数)。也就是说，它比较的对象不一定必须是实数或者int之类的类型，可以是任何结构体或者类的对象。你只需要给它传入一个可以比较两个object之间的前后关系的类型，都可以通过排序算法得到。</li>
</ul>
<p>像这种通过比较来决定元素间的相对次序，数学上已经证明，时间复杂度不会超过O(logn)，而我们经常用到的，都是这种比较类排序。</p>
<ol start="2">
<li>非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也成为线性时间非比较类排序。</li>
</ol>
<ul>
<li>一般对于整型元素来做的，也就是说可以用线性时间来完成。它可以突破基于比较排序的时间下界，以线性时间完成。</li>
</ul>
<p><strong>但是非比较类排序的缺点是</strong>：一般只能用于整型相关的数据类型。也就是说对于一些比如字符串的排序，或者对象之间的排序，非比较类排序是无能为力的。而且非比较类排序一般需要辅助的内存空间。</p>
<p>非比较类排序基本都是把结果放入到数组中，统计不同元素出现的次数来排序。</p>
<p>常用的排序算法的复杂度分析和稳定性，如下表：</p>
<p><img src="https://s2.ax1x.com/2020/02/14/1jSh4g.png" alt="1jSh4g.png"></p>
<p>从重要程度来说，更重要的是比较类排序，因为它是泛型的，也是工业编程中用得最多的。</p>
<hr>
<p><strong>初级排序</strong>：O(n^2)</p>
<ol>
<li>选择排序(Selection Sort)</li>
</ol>
<p>每次选择最小值，然后放到待排序数组的起始位置。</p>
<ol start="2">
<li>插入排序(Insertion Sort)</li>
</ol>
<p>从前到后逐步构建有序序列;对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<ol start="3">
<li>冒泡排序(Bubble Sort)</li>
</ol>
<p>嵌套循环，每次查看相邻的元素，如果逆序，则交换。</p>
<p>这三种初级排序没有太大差别，其实是异曲同工的原理。</p>
<p><font color=#FF0000>而面试中，考察技术能力的时候，他考察的一般也都是O(nlogn)的排序，所以准备过程中也应该尽量多花时间去看时间复杂度为O(nlogn)的排序算法。</font>主要是三个：堆排序、快速排序、归并排序。</p>
<hr>
<h2 id="高级排序-——-O-N-logN"><a href="#高级排序-——-O-N-logN" class="headerlink" title="高级排序 —— O(N*logN)"></a><strong>高级排序</strong> —— O(N*logN)</h2><h3 id="快速排序-Quick-Sort"><a href="#快速排序-Quick-Sort" class="headerlink" title="快速排序(Quick Sort)"></a><strong>快速排序(Quick Sort)</strong></h3><p>数组取标杆pivot，将比pivot小的元素放到pivot左边，比它大的元素放在它的右边，然后依次对左边和右边的子数组继续快排；以达到整个序列有序。</p>
<p>快排用到了<strong>分治</strong>的思想，首先，如果想要把排序的时间复杂度从O(n^2)降到O(N logN)，那么分治毫无疑问是要考虑的问题。</p>
<p><font color=#FF0000>快排的方法：拿到一个pivot的位置，将所有小于pivot的元素移动到左边去，大于pivot的移动到右边去，且分别对左右侧再进行递归，调用快排。</font>可以通过主定理，证明整个递归下来的时间复杂度为O(N logN)。</p>
<p>快排的样例代码：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] <span class="built_in">array</span>, <span class="keyword">int</span> <span class="built_in">begin</span>, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">end</span> &lt;= <span class="built_in">begin</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> pivot = partition(<span class="built_in">array</span>, <span class="built_in">begin</span>, <span class="built_in">end</span>);</span><br><span class="line">    quickSort(<span class="built_in">array</span>, <span class="built_in">begin</span>, pivot - <span class="number">1</span>);</span><br><span class="line">    quickSort(<span class="built_in">array</span>, pivot + <span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> <span class="built_in">begin</span>, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// pivot: 标杆位置，counter: 小于a[pivot]的元素的个数</span></span><br><span class="line">    <span class="keyword">int</span> pivot = <span class="built_in">end</span>, counter = <span class="built_in">begin</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">begin</span>; i &lt; <span class="built_in">end</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; a[pivot]) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = a[counter]; a[counter] = a[i]; a[i] = temp;</span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> temp = a[pivot]; a[pivot] = a[counter]; a[counter] = temp;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>稍微复杂的过程是partition，它做的是，返回一个下标pivot，且能够保证pivot之前的元素都小于pivot，pivot之后的元素都大于pivot。(但是需要注意，每次partition只能保证pivot前面的是小于它的，后面是大于它的，前面和后面不能保证是有序的)</p>
<p>这段代码其实是非常考验基本功的。</p>
<p>实现过程中，我们可以申请一个新的数组，通过比较，把小的元素放到数组的左边，大的元素放到数组的右边。但是如果不能申请一个新的数组，那么这段代码是非常巧妙的。</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (int i = <span class="keyword">begin</span>; i &lt; <span class="keyword">end</span>; i++) <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    if (a[i] &lt; a[pivot]) &#123;</span></span><br><span class="line"><span class="comment">        int temp = a[counter]; a[counter] = a[i]; a[i] = temp;</span></span><br><span class="line"><span class="comment">        counter++;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一开始把pivot定义在传入的数组的最后的位置，然后根据情况改变pivot的位置。counter用于统计小于a[pivot]的元素的个数。这里的关键是，只要a[i] &lt; a[pivot]，说明a[counter]要和a[i]交换位置。</p>
<p>这里一开始我也没能理解，但是用纸笔模拟了一下之后，发现真的很巧妙。一开始counter和i都是begin，是从相同的地方开始的，然后counter用于指在最后一个小于a[pivot]的元素上，i的值来进行循环，如果碰到比末尾的pivot值大的值，就跳过（因为这个是要留给counter进行交换的,counter此时的作用是把大的元素和后面的i位置的，而且比a[pivot]小元素进行交换），i只要碰到了小于a[pivot]的，就让前面的counter和这个小于a[pivot]的元素交换，从而让大的元素移到后面去，然后把counter往后移，如果此时a[counter]的元素是大于a[pivot]的，那么此时counter所指的元素是为了进行下次交换的。保证counter前面的所有值都是小于a[pivot]的。</p>
<p>一直这样下去，直到begin和end都遍历完了，然后交换a[pivot]和a[counter]，由此一来，绝对可以保证a[piovot]成为一个分水岭，pivot成为一个标杆，a[pivot]左边所有的元素都会是小于a[pivot]的，右边都是大于a[pivot]的。</p>
<p>快排就是这样，大家写的时候，就是把这一段记好，多写几次，多写几次，记住关键的pivot和counter以及它们的作用。</p>
<p><strong>但是需要注意快排的缺陷</strong>：如果一个数组本身已经排好序了，那么每一轮排序的时候都会以最后一个数字作为比较的标准，此时快排的效率退化成了O(n^2)。所以，在面试中只要碰到了和排序有关的问题，一定要问清楚具体环境，有哪些条件约束，在得到足够多的信息之后再选择最合适的排序算法。</p>
<h3 id="归并排序-Merge-Sort"><a href="#归并排序-Merge-Sort" class="headerlink" title="归并排序(Merge Sort)"></a><strong>归并排序(Merge Sort)</strong></h3><p>归并排序也用到了<strong>分治</strong>的思想。</p>
<p>归并具体流程：</p>
<ol>
<li>把待排序的数组从中间一分为二，注意这个分只是从中间直接”劈开”，不用做任何交换元素的操作。</li>
<li>对这两个子序列先分别调用归并排序，这样可以保证左边的子序列和右边的子序列在自己的片段区间中是有序的。</li>
<li>将两个排好序的子序列合并。</li>
</ol>
<p>归并和快排刚好相反，可以把归并排序看做是快排的逆向操作。为什么？</p>
<p>具体做法不同。归并：先把数组一分为二，在左边和右边都分别调用了排序方法排好序之后，再把左右排好序的两个子数组合并成一个。</p>
<p>快排：先用partition排好序从而找到pivot的位置，然后再用pivot进行大小的”分隔”，和归并排序是完全相反的操作。</p>
<p>然后看代码，首先是mergeSort的主函数部分：</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">public static void mergeSort(<span class="built_in">int</span>[] array, <span class="built_in">int</span> <span class="built_in">left</span>, <span class="built_in">int</span> <span class="built_in">right</span>) &#123;</span><br><span class="line">    <span class="built_in">if</span> (<span class="built_in">right</span> &lt;= <span class="built_in">left</span>) return;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">mid</span> = (<span class="built_in">left</span> + <span class="built_in">right</span>) &gt;&gt; <span class="number">1</span>; // (<span class="built_in">left</span> + <span class="built_in">right</span>) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    mergeSort(array, <span class="built_in">left</span>, <span class="built_in">mid</span>);</span><br><span class="line">    mergeSort(array, <span class="built_in">mid</span> + <span class="number">1</span>, <span class="built_in">right</span>);</span><br><span class="line">    merge(array, <span class="built_in">left</span>, <span class="built_in">mid</span>, <span class="built_in">right</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先直接从中间一分为二地”劈开”, 得到mid，然后递归，每次都切分一次。最后在每次递归的终止的地方将切分并且排好序的两部分合并。</p>
<p>然后对于merge的逻辑怎么写，之前写过的，把两个有序的链表怎么合并，那里已经知道用O(n)就可以解决。</p>
<p>在这里的情况是，给你一个数组，它的两半部分全部都是排好序的，你怎么把它合并起来？你也可以想象，给你两个数组，这两个数组都是排好序的，怎么把它合并起来。</p>
<p>这种程序题目，逻辑相对来说比较简单，但是对于基础编码功底要求很高。</p>
<p>经过挑选出来的合并的代码，应该是最精简，最漂亮的代码。</p>
<p>如果之前没写过这段代码，多多少少是要花一些功夫的。</p>
<p>应当把这种，<strong>把两个有序的数组合并在一起（或者在这里称之为归并）</strong>，的方法，当成一个代码的模板，记在脑子里。最好能够灵活运用。这是提高你最基础的内容的很重要的一个部分。</p>
<p>merge方法部分：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> static <span class="type">void</span> merge(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right) &#123;</span><br><span class="line">        <span class="type">int</span>[] <span class="keyword">temp</span> = <span class="built_in">new</span> <span class="type">int</span>[right - left + <span class="number">1</span>]; // 中间数组</span><br><span class="line">        <span class="type">int</span> i = left, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">temp</span>[k++] = arr[i] &lt;= arr[j] ? arr[i++] : arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid)   <span class="keyword">temp</span>[k++] = arr[i++];</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= right) <span class="keyword">temp</span>[k++] = arr[j++];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">0</span>; p &lt; <span class="keyword">temp</span>.length; p++) &#123;</span><br><span class="line">            arr[left + p] = <span class="keyword">temp</span>[p];</span><br><span class="line">        &#125;</span><br><span class="line">        // 也可以用 <span class="keyword">System</span>.arraycopy(a, start1, b, start2, length)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这段代码具体在做什么呢？</p>
<p>首先，从left到mid和从mid到right都已经有序了。把这两个子序列合并在一起。</p>
<p>你可以想象为，有两个数组，第一个数组从left到mid，第二个数组是从mid到right。这两个数组分别是有序的，怎样合并起来。</p>
<p>首先，要申请一段额外的内存空间（归并排序必须要申请一块额外的内存空间出来）</p>
<p><code>int[] temp = new int[right - left + 1]; // 中间数组</code></p>
<p>需要的大小也没什么好说的，很多申请数组的大小都是要有这么一个+1的内容。</p>
<p>接下来，定义了两个下标i和j, i就是left，j是mid+1，也就是，i表示第一个数组的起始位置，j表示第二个数组的起始位置。k指的是temp这个数组里面已经填入的元素的个数。</p>
<p>关于合并：<font color=#FF0000>在看了这段之后，一定要养成一个习惯：要合并两个有序的数组，它永远是这种三段式写法：</font></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">i</span> &lt;= mid &amp;&amp; <span class="built_in">j</span> &lt;= right) &#123;</span><br><span class="line">    temp[k++] = arr[<span class="built_in">i</span>] &lt;= arr[<span class="built_in">j</span>] ? arr[<span class="built_in">i</span>++] : arr[<span class="built_in">j</span>++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">i</span> &lt;= mid)   temp[k++] = arr[<span class="built_in">i</span>++];</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">j</span> &lt;= right) temp[k++] = arr[<span class="built_in">j</span>++];</span><br></pre></td></tr></table></figure>

<p>具体分析：</p>
<p>第一个while：保证i没有循环完且j也没有循环完（所以有i&lt;=mid和j&lt;=right），然后比较a[i]和a[j]中的较小者，把较小者拿出来放到temp[k]里面去。同时，用了a[i]，就让i++（因为要再去用下一个元素了），用了a[j]，就让j++（同理），然后放入到temp[k]之后，毫无疑问k也要k++。</p>
<p>上面的这一大段逻辑，就三行写完，很是巧妙：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">i</span> &lt;= mid &amp;&amp; <span class="built_in">j</span> &lt;= right) &#123;</span><br><span class="line">    temp[k++] = arr[<span class="built_in">i</span>] &lt;= arr[<span class="built_in">j</span>] ? arr[<span class="built_in">i</span>++] : arr[<span class="built_in">j</span>++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color=#FF0000>但是，强调，这句话不是奇技淫巧！对于编程写得比较多的人，这句话是经常用的！</font></p>
<p>所以要习惯于写这么一句话。这句话的逻辑是非常清晰的，而且简明扼要。它做得事情就是，比较a[i]和a[j]中的较小者，取出来之后，把较小者赋值给temp[k]，同时a[i]或者a[j]谁被用到，就让下标加一用于下次使用，然后k也要移动用于下一次使用。</p>
<p>这个循环写完之后，可以保证一点，就是i全部走完子数组，或者j全部走完了子数组。</p>
<p>接下来要做的，如果i没有走完，那么把i的剩余部分赋值到temp[k]里面去，或者j没有走完的话，把j剩余部分复制到temp[k]里面去。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">i</span> &lt;= mid)   temp[k++] = arr[<span class="built_in">i</span>++];</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">j</span> &lt;= right) temp[k++] = arr[<span class="built_in">j</span>++];</span><br></pre></td></tr></table></figure>

<p>在这两个while循环也写完之后，你可以发现，整个数组已经完成了归并，放到了temp[]里面了。</p>
<p>因为我们在merge这个函数里面是要对arr[]进行排序，所以我们要再把temp里面的所有元素再拷贝回array里面去。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> p = <span class="number">0</span>; p &lt; temp.length; p++) &#123;</span><br><span class="line">    arr[left + p] = temp[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 也可以用 System.arraycopy(a, start1, b, start2, length)</span></span><br></pre></td></tr></table></figure>

<p>对于归并排序的代码，希望大家多多练习，把这段代码写得更细腻。</p>
<p>以及，<font color=#FF0000>把这段很能体现编程内力的代码可以在白板上写出来，面试官肯定会刮目相看的。</font></p>
<hr>
<h3 id="给出一个时间复杂度为O-n-的排序算法？"><a href="#给出一个时间复杂度为O-n-的排序算法？" class="headerlink" title="给出一个时间复杂度为O(n)的排序算法？"></a>给出一个时间复杂度为O(n)的排序算法？</h3><p>理论上是不太合理的，但是如果这么问，那么我们一定要多问问题，问清楚O(n)排序算法的环境和背景。比如要给一个公司的几万名员工按照年龄进行排序，那么，首先，年龄的范围可以定位18-99，这是个有限大小的范围，我们可以申请这么大的数组(但是空间复杂度为O(1)，因为是确定的。)然后遍历一遍所有员工，每次在年龄对应的下标上加1，即可完成按照年龄的排序了。</p>
<h3 id="为什么要考虑排序算法是否稳定？"><a href="#为什么要考虑排序算法是否稳定？" class="headerlink" title="为什么要考虑排序算法是否稳定？"></a>为什么要考虑排序算法是否稳定？</h3><p>实际上，如果只是考虑简单地对数字进行排序，那么稳定性是毫无意义的。一个例子是在促销活动中，经过降价的产品应该排在没降价产品的前面，因为降价产品本身价格是比没降价产品价格高的，所以这样的排序才有意义。</p>
<p>再举个例子，一次考试之后，分数不同的同学按照分数进行排序，分数相同的同学，按照上次考试的分数排序。</p>
<p>再举个例子，一个班的同学，已经按照学号排好序了。现在要按照身高排序。如果是稳定排序排好之后，身高相同的同学，还是按照学号顺序的。</p>
<p>总之，其实就是<strong>有两个排序关键字的时候，稳定排序可以让第一个关键字排序的结果服务于第二个关键字排序中数值相等的那些数</strong>。</p>
<h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><p>归并 和 快排 具有相似性，但步骤顺序相反。</p>
<ul>
<li>归并：线排序左右子数组，然后合并两个有序子数组。</li>
<li>快排：先调配出左右子数组，然后对左右子数组进行合并。</li>
</ul>
<p>快排先调配左右子数组，就是让左边的数组的所有元素都小于右边数组的所有元素（中间的元素为pivot，就是pivot左边的所有元素都小于pivot，右边的所有元素都大于pivot）。但是左、右的元素在这个时候仍然还是无序的，那么然后对于左、右子数组分别调用排序的函数进行分治。</p>
<p><font color=#FF0000>快排和归并排序都讲完了，这两个是高级排序的面试的重点，一定要细细品味，多过遍数。</font></p>
<ul>
<li><strong>堆排序(Merge Sort)</strong></li>
</ul>
<p>堆插入时间复杂度为O(logN)，取堆顶，最大/小值，时间复杂度为O(1)。但是取完元素之后需要进行Heapify，所以要额外乘上O(n)的时间复杂度，整个的时间复杂度为O(N*logN)</p>
<p>堆排序的过程：</p>
<ol>
<li>对元素依次建立最小堆</li>
<li>依次取堆顶元素，并删除</li>
</ol>
<p>堆本身是一种很有意思的数据结构，使用数组存储一个树状结构，通过自身的规律，可以用简单的公式获取到当前某个节点的父节点或者左右孩子节点(注意起始坐标是0还是1，公式有区别)。</p>
<p>关键点就是，每次你在调整之前，儿子节点如果大于父亲节点，两者就交换，一直到当前节点小于其他祖宗节点。</p>
<p><strong>非比较类排序</strong></p>
<ul>
<li>计数排序(Counting Sort)</li>
</ul>
<p>计数排序要求输入的数据必须是有确定范围的整数。将输入的数据值转化为键存储在额外开辟的数组空间中；然后依次把计数大于1的填充回原数组。<font color=#FF0000>总之，你的元素必须是整数，而且元素值不能太大，否则浪费空间。</font></p>
<ul>
<li>桶排序(Bucket Sort)</li>
</ul>
<p>工作原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序(有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序)。</p>
<ul>
<li>基数排序(Radix Sort)</li>
</ul>
<p>按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。<font color=#FF0000>先按照个位进行排序，也就是放到0,1,2…9的位置，把低位先排好序。然后再排十位，再按照0-9的值排上去。然后百位，以此类推。这样一来，排序的数组只需要存储0-9的数字，这是比较巧妙的地方。但是基数排序也是有一个短板，就是只能存储整数，不能存储小数的值。<br></font></p>
<h2 id="215-Kth-Largest-Element-in-an-Array-数组中的第K个最大元素-Mid"><a href="#215-Kth-Largest-Element-in-an-Array-数组中的第K个最大元素-Mid" class="headerlink" title="215. Kth Largest Element in an Array(数组中的第K个最大元素)(Mid)"></a><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">215. Kth Largest Element in an Array(数组中的第K个最大元素)(Mid)</a></h2><p>Find the <strong>k</strong>th largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>] <span class="keyword">and</span> k = <span class="number">2</span></span><br><span class="line">Output: <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>] <span class="keyword">and</span> k = <span class="number">4</span></span><br><span class="line">Output: <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong><br>You may assume k is always valid, 1 ≤ k ≤ array’s length.</p>
<hr>
<p>解：</p>
<p>方法一：暴力，直接先排序再找到第k大的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//sort后默认从小到大</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length - k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(nlogn)</li>
<li>空间复杂度：O(1)</li>
</ul>
<p>但是这个时间复杂度不能让人满意。</p>
<p>方法二：用堆来辅助，可以用一个大顶堆，然后poll() k次，就能找到数组中第k大的了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//默认小顶堆</span></span><br><span class="line">        <span class="comment">// PriorityQueue&lt;Integer&gt; heap = new PriorityQueue&lt;Integer&gt;(</span></span><br><span class="line">        <span class="comment">//     (a,b) -&gt;(a - b) //这个其实不用写，因为默认就是小根堆</span></span><br><span class="line">        <span class="comment">// );</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(); <span class="comment">//直接一行搞定即可</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            heap.add(num);</span><br><span class="line">            <span class="keyword">if</span>(heap.size() &gt; k) &#123;</span><br><span class="line">                heap.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heap.poll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(Nlogk)，比直接用排序好一些</li>
<li>空间复杂度：O(k)，大小为k的堆，用于存储数据</li>
</ul>
<p>方法三：<strong>快速选择法</strong>——借助快速排序的思想</p>
<p>但是，这道题是Mid，Mid如果能用这两个时间复杂度为O(nlogn)的方法能解决，那就不是Mid的难度啦！这里想考察的其实和面试中经常会问到Top K问题中常用的解法之一：基于快排的Partition法，或者叫做<strong>快速选择法</strong>。</p>
<p>有关Top K问题可以参考这篇文章：<a href="https://mp.weixin.qq.com/s/bMDy8_Kwr1MKpL6-NrSYFQ" target="_blank" rel="noopener">如何在10亿数中找出前1000大的数</a></p>
<p>首先，我们选择一个枢轴(pivot)，并在线性时间内定义其在排序数组中的位置。这可以通过 <em>划分算法</em> 的帮助来完成。</p>
<blockquote>
<p>为了实现划分，沿着数组移动，将每个元素与枢轴进行比较，并将小于枢轴的所有元素移动到枢轴的左侧。</p>
</blockquote>
<p>这样，在输出的数组中，枢轴达到其合适位置。所有小于枢轴的元素都在其左侧，所有大于或等于的元素都在其右侧。</p>
<p>这样，数组就被分成了两部分。如果是快速排序算法，会在这里递归地对两部分进行快速排序，时间复杂度为 O(N logN)。</p>
<p>而在这里，由于知道要找的第 N - k 小的元素在哪部分中，我们不需要对两部分都做处理，这样就将平均时间复杂度下降到 O(N)。</p>
<p>最终的算法十分直接了当 :</p>
<p>随机选择一个枢轴。</p>
<p>使用划分算法将枢轴放在数组中的合适位置 pos。将小于枢轴的元素移到左边，大于等于枢轴的元素移到右边。</p>
<p>比较 pos 和 N - k 以决定在哪边继续递归处理。</p>
<blockquote>
<p>! 注意，本算法也适用于有重复的数组</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.length;</span><br><span class="line">        <span class="comment">//Kth number is (N-K)th smallest</span></span><br><span class="line">        <span class="comment">// 就是把题目的第k大变成了第k小，k从1开始，若为第1大，则最后返回的是选择之后最后一个与元素</span></span><br><span class="line">        <span class="comment">//比如有9个元素，则第6大就是选择之后第4小的元素，即(size-k)为选择后的第k小</span></span><br><span class="line">        <span class="keyword">return</span> quickSelect(nums, <span class="number">0</span>, size - <span class="number">1</span>, size - k);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">quickSelect</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> k_smallest)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        / returns the k-th smallest of nums within left...right</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//递归结束条件，left和right重合了</span></span><br><span class="line">        <span class="keyword">if</span>(left == right) <span class="comment">//If the list contains only one element,</span></span><br><span class="line">            <span class="keyword">return</span> nums[left]; <span class="comment">//return that element</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//select a random pivot_index</span></span><br><span class="line">        <span class="comment">// 随机产生一个数轴进行快速选择操作</span></span><br><span class="line">        Random random_num = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> pivot_index = left + random_num.nextInt(right - left);</span><br><span class="line">        </span><br><span class="line">        pivot_index = partition(nums, left, right, pivot_index);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//the pivot is on (N-k)th smallest position</span></span><br><span class="line">        <span class="keyword">if</span>(k_smallest == pivot_index)</span><br><span class="line">            <span class="keyword">return</span> nums[k_smallest];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(k_smallest &lt; pivot_index)</span><br><span class="line">            <span class="comment">//这里还是用了快排的分治思想</span></span><br><span class="line">            <span class="keyword">return</span> quickSelect(nums, left, pivot_index - <span class="number">1</span>,k_smallest);</span><br><span class="line">        <span class="comment">//go right side</span></span><br><span class="line">        <span class="keyword">return</span> quickSelect(nums,pivot_index + <span class="number">1</span>, right, k_smallest);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> pivot_index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[pivot_index];</span><br><span class="line">        <span class="comment">//1. move pivot to end</span></span><br><span class="line">        swap(nums, pivot_index, right);</span><br><span class="line">        <span class="keyword">int</span> store_index = left;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2.move all smaller elements to the left</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; pivot) &#123;</span><br><span class="line">                swap(nums, store_index, i);</span><br><span class="line">                store_index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.move pivot to its final place</span></span><br><span class="line">        swap(nums, store_index,right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> store_index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[a];</span><br><span class="line">        nums[a] = nums[b];</span><br><span class="line">        nums[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：平均情况O（N），最坏情况O(N^2)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h2 id="973-K-Closest-Points-to-Origin-最接近原点的K个点-Mid"><a href="#973-K-Closest-Points-to-Origin-最接近原点的K个点-Mid" class="headerlink" title="973. K Closest Points to Origin(最接近原点的K个点)(Mid)"></a><a href="https://leetcode-cn.com/problems/k-closest-points-to-origin/" target="_blank" rel="noopener">973. K Closest Points to Origin(最接近原点的K个点)(Mid)</a></h2><p>We have a list of <code>points</code> on the plane. Find the <code>K</code> closest points to the origin <code>(0, 0)</code>.</p>
<p>(Here, the distance between two points on a plane is the Euclidean distance.)</p>
<p>You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in.)</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: points = [[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">-2</span>,<span class="number">2</span>]], K = <span class="number">1</span></span><br><span class="line">Output: [[<span class="number">-2</span>,<span class="number">2</span>]]</span><br><span class="line">Explanation: </span><br><span class="line">The distance between (<span class="number">1</span>, <span class="number">3</span>) <span class="keyword">and</span> the origin <span class="keyword">is</span> sqrt(<span class="number">10</span>).</span><br><span class="line">The distance between (<span class="number">-2</span>, <span class="number">2</span>) <span class="keyword">and</span> the origin <span class="keyword">is</span> sqrt(<span class="number">8</span>).</span><br><span class="line">Since sqrt(<span class="number">8</span>) &lt; sqrt(<span class="number">10</span>), (<span class="number">-2</span>, <span class="number">2</span>) <span class="keyword">is</span> closer to the origin.</span><br><span class="line">We only want the closest K = <span class="number">1</span> points <span class="keyword">from</span> the origin, so the answer <span class="keyword">is</span> just [[<span class="number">-2</span>,<span class="number">2</span>]].</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: points = [[<span class="number">3</span>,<span class="number">3</span>],[<span class="number">5</span>,<span class="number">-1</span>],[<span class="number">-2</span>,<span class="number">4</span>]], K = <span class="number">2</span></span><br><span class="line">Output: [[<span class="number">3</span>,<span class="number">3</span>],[<span class="number">-2</span>,<span class="number">4</span>]]</span><br><span class="line">(The answer [[<span class="number">-2</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">3</span>]] would also be accepted.)</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ol>
<li><code>1 &lt;= K &lt;= points.length &lt;= 10000</code></li>
<li><code>-10000 &lt; points[i][0] &lt; 10000</code></li>
<li><code>-10000 &lt; points[i][1] &lt; 10000</code></li>
</ol>
<hr>
<p>解：<strong>方法一</strong>，直接使用排序。但是因为各个语言的内置sort算法都为快排，所以时间复杂度为O(NlogN)</p>
<p>在计算过程中因为只需要计算到原点之间的距离然后排序，所以可以直接计算每个坐标到0的距离的平方即可。计算之后把排好序的距离对应的点放入到结果数组中即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] kClosest(<span class="keyword">int</span>[][] points, <span class="keyword">int</span> K) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = points.length;</span><br><span class="line">        <span class="keyword">int</span>[] distances = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="comment">//先计算并且找到第K近的距离</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len; i++) &#123;</span><br><span class="line">            distances[i] = calc(points[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(distances);</span><br><span class="line">        <span class="comment">//保存第k大的距离值，后面只要距离值小于这个，就都要返回</span></span><br><span class="line">        <span class="keyword">int</span> distanceK = distances[K-<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[][] result = <span class="keyword">new</span> <span class="keyword">int</span>[K][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//time用来表示当前遍历到了多少，最多不能超过K个</span></span><br><span class="line">        <span class="keyword">int</span> time = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(calc(points[i]) &lt;= distanceK) &#123;</span><br><span class="line">                result[time++] = points[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span>[] point)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> point[<span class="number">0</span>] * point[<span class="number">0</span>] + point[<span class="number">1</span>] * point[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(NlogN)</li>
<li>空间复杂度：O(N)</li>
</ul>
<p><strong>方法二</strong>：堆排序。时间复杂度和第一个方法一样，因为这里对于前K个返回的元素，最后都是有序的，因为有这个排序的过程，所以时间复杂度最后都是O(nlogn)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] kClosest(<span class="keyword">int</span>[][] points, <span class="keyword">int</span> K) &#123;</span><br><span class="line">        <span class="comment">// 默认小顶堆，即大小为K的堆，最后遍历完了所有元素都是前K小的</span></span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(</span><br><span class="line">            (a,b) -&gt; a[<span class="number">0</span>]*a[<span class="number">0</span>] + a[<span class="number">1</span>]*a[<span class="number">1</span>] - b[<span class="number">0</span>]*b[<span class="number">0</span>] - b[<span class="number">1</span>]*b[<span class="number">1</span>]</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] point : points) &#123;</span><br><span class="line">            heap.add(point);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] result = <span class="keyword">new</span> <span class="keyword">int</span>[K][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; K ;i++) &#123;</span><br><span class="line">            result[i] = heap.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在实际LeetCode提交过程中，这个方法二更慢……</p>
<p><strong>方法三</strong>：分治法。这个分治过程很相似快排每一轮的partition：随机取一个pivot，将数组中所有比pivot小的数放到pivot左边，比pivot大的数放到pivot右边。然后如果pivot左边的数数量小于K，则继续在右边中找数。</p>
<p>这里的快速排序无需使整个数组有序，只需要筛选出最小的 K 个值即可。</p>
<p>假设第一次排序后，哨兵值 pivot 将原数组分为两个部分：</p>
<p>左侧部分，元素值均小于 pivot，假设下标范围是 [begin, i - 1]，长度为 left_length<br>右侧部分，元素值均大于或等于 pivot，假设下标范围是 [i + 1, end]，长度为 right_length<br>此时：</p>
<p>如果 left_length &gt;= K，最小的 K 个值均在左侧，因此下轮递归只需对左侧部分进行排序<br>如果 left_length &lt; K，我们已经获得了 left_length 个最小值，因此下轮递归只需对右侧部分进行排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">int</span>[][] kClosest(<span class="keyword">int</span>[][] points, <span class="keyword">int</span> K) &#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = points.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            # 计算欧几里得距离</span><br><span class="line">            <span class="keyword">int</span> index = patition(points, start, end);</span><br><span class="line">            <span class="keyword">if</span> (index == K) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; K) &#123;</span><br><span class="line">                start = index + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                end = index - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(points, K);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">patition</span><span class="params">(<span class="keyword">int</span>[][] points, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = start;</span><br><span class="line">        <span class="keyword">int</span> j = end + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = distance(points[i][<span class="number">0</span>], points[i][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (distance(points[++i][<span class="number">0</span>], points[i][<span class="number">1</span>]) &lt; mid &amp;&amp; i &lt; end);</span><br><span class="line">            <span class="keyword">while</span> (distance(points[--j][<span class="number">0</span>], points[j][<span class="number">1</span>]) &gt; mid &amp;&amp; j &gt; start);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(points, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(points, start, j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">distance</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * a + b * b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[][] points, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = points[a];</span><br><span class="line">        points[a] = points[b];</span><br><span class="line">        points[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="56-Merge-Intervals-合并区间-Mid"><a href="#56-Merge-Intervals-合并区间-Mid" class="headerlink" title="56. Merge Intervals(合并区间)(Mid)"></a><a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">56. Merge Intervals(合并区间)(Mid)</a></h2><p>Given a collection of intervals, merge all overlapping intervals.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">6</span>],[<span class="number">8</span>,<span class="number">10</span>],[<span class="number">15</span>,<span class="number">18</span>]]</span><br><span class="line">Output: [[<span class="number">1</span>,<span class="number">6</span>],[<span class="number">8</span>,<span class="number">10</span>],[<span class="number">15</span>,<span class="number">18</span>]]</span><br><span class="line">Explanation: Since <span class="built_in">int</span>ervals [<span class="number">1</span>,<span class="number">3</span>] <span class="keyword">and</span> [<span class="number">2</span>,<span class="number">6</span>] overlaps, merge them <span class="built_in">int</span>o [<span class="number">1</span>,<span class="number">6</span>].</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">5</span>]]</span><br><span class="line">Output: [[<span class="number">1</span>,<span class="number">5</span>]]</span><br><span class="line">Explanation: Intervals [<span class="number">1</span>,<span class="number">4</span>] <span class="keyword">and</span> [<span class="number">4</span>,<span class="number">5</span>] are considered overlapping.</span><br></pre></td></tr></table></figure>

<hr>
<p>解：注意这里用到的排序的写法，Arrays.sort()里面用了Lambda表达式</p>
<p>先按首位置进行排序;</p>
<p>接下来,如何判断两个区间是否重叠呢?比如 a = [1,4],b = [2,3]</p>
<p>当 a[1] &gt;= b[0] 说明两个区间有重叠.</p>
<p>但是如何把这个区间找出来呢?</p>
<p>左边位置一定是确定，就是 a[0]，而右边位置是 max(a[1], b[1])</p>
<p>所以,我们就能找出整个区间为:[1,4]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (intervals == <span class="keyword">null</span> || intervals.length == <span class="number">0</span>) <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][]);</span><br><span class="line">        Arrays.sort(intervals, (a, b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; intervals.length) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = intervals[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> right = intervals[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (i &lt; intervals.length - <span class="number">1</span> &amp;&amp; intervals[i + <span class="number">1</span>][<span class="number">0</span>] &lt;= right) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                right = Math.max(right, intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left, right&#125;);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithms Note</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Bitwise Operation</title>
    <url>/2020/01/13/LeetCode-Practice-by-Categories-Bitwise-Operation/</url>
    <content><![CDATA[<blockquote>
<p>勤学如春起之苗，不见其增，日有所长。——陶潜</p>
</blockquote>
<p>包含大量LeetCode位运算相关题目及其解决思路和具体代码。</p>
<a id="more"></a>

<h1 id="137-Single-Number-II-只出现一次的数字II-MId"><a href="#137-Single-Number-II-只出现一次的数字II-MId" class="headerlink" title="137.Single Number II(只出现一次的数字II)(MId)"></a><a href="https://leetcode-cn.com/problems/single-number-ii/" target="_blank" rel="noopener">137.Single Number II(只出现一次的数字II)(MId)</a></h1><p>Given a <strong>non-empty</strong> array of integers, every element appears <em>three</em> times except for one, which appears exactly once. Find that single one.</p>
<p><strong>Note:</strong></p>
<p>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">Output: <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">99</span>]</span><br><span class="line">Output: <span class="number">99</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：LeetCode上260、136、137这三道题都是有关统计数字出现次数的问题，其中136最简单，因为除了一个数字，其他数字都出现2次(或者偶数次)，那么完美符合用异或的情况。</p>
<p>一个数字异或它本身之后为0；0异或任何数字都为那个数字本身，所以136对每个数字求异或之后即可得到目标数字。过程在这里省略。</p>
<p>136题的代码：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> singleNumber(<span class="built_in">int</span>[] nums) &#123;</span><br><span class="line">        <span class="built_in">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> num : nums) &#123;</span><br><span class="line">            result = result^num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到本题，因为除了1个数字只出现1次，其他所有数字都出现3次，所以这道题不能用单纯的异或来计算了。</p>
<p>方法一：Map。这个方法开辟了新的空间，只能说可行，但是在空间复杂度上遜于位运算。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="built_in">map</span>.<span class="built_in">put</span>(num, <span class="built_in">map</span>.getOrDefault(num,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> key : <span class="built_in">map</span>.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.<span class="built_in">get</span>(key) == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> key;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：位运算，参考<a href="https://leetcode-cn.com/problems/single-number-ii/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--31/" target="_blank" rel="noopener">这篇题解</a></p>
<p>如果我们把每个数字都用二进制形式列出来，会发现出现了3次的数字的每一列之和都会是3的倍数。之所以有的列不是3的倍数，是因为出现了1次的数字的那一位1单独贡献了次数。</p>
<p>所以，所有出现次数不是3的倍数的列全部写成1，出现1次数是3倍数的列写0，就能找到这个出现了1次的数。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> singleNumber(<span class="built_in">int</span>[] nums) &#123;</span><br><span class="line">        <span class="built_in">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 整数数组，遍历32位</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 考虑每一位个数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="comment">//获取nums[j]的第i位值(0或1),如果其为1，count++</span></span><br><span class="line">                <span class="comment">// 利用位运算经典公式(x &gt;&gt; n) &amp; 1</span></span><br><span class="line">                <span class="keyword">if</span>((nums[j] &gt;&gt; i &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    <span class="comment">// 这里可以变通，如果题目改一下，除了一个数字出现一次，</span></span><br><span class="line">                    <span class="comment">// 其他的都出现5次，求一样的东西，把3换成5即可</span></span><br><span class="line">                    count %= <span class="number">3</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若当前count不为3的倍数，利用位运算经典操作将这一位赋值给result</span></span><br><span class="line">            <span class="comment">// 仅将第i位置为1,其他都为0。因为只有一个出现1次的数字，所以count不是0就是1</span></span><br><span class="line">            <span class="keyword">if</span>(count != <span class="number">0</span>) &#123;</span><br><span class="line">                result = result | (count &lt;&lt; i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法三：LeetCode上高票答案</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">public int singleNumber(int[] A) &#123;</span><br><span class="line">    int <span class="built_in">ones</span> = <span class="number">0</span>, twos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(int <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; A.<span class="built_in">length</span>; <span class="built_in">i</span>++)&#123;</span><br><span class="line">        <span class="built_in">ones</span> = (<span class="built_in">ones</span> ^ A[<span class="built_in">i</span>]) &amp; ~twos;</span><br><span class="line">        twos = (twos ^ A[<span class="built_in">i</span>]) &amp; ~<span class="built_in">ones</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ones</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="260-Single-Number-III-只出现一次的数字III-MId"><a href="#260-Single-Number-III-只出现一次的数字III-MId" class="headerlink" title="260.Single Number III(只出现一次的数字III)(MId)"></a><a href="https://leetcode-cn.com/problems/single-number-iii/" target="_blank" rel="noopener">260.Single Number III(只出现一次的数字III)(MId)</a></h1><p>Given an array of numbers <em>nums</em>, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input:  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">Output: [<span class="number">3</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ol>
<li>The order of the result is not important. So in the above example, [5, 3] is also correct.</li>
<li>Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?</li>
</ol>
<hr>
<p>解：题目大意是，只有两个数出现了1次，其他数都出现2次，我们要找到这个数。</p>
<p>这道题是136的变化，出现1次的数字从1个变到了2个，其他数字出现次数没变，还是2次。</p>
<p>核心思想是把nums分成两部分，怎么分呢？</p>
<p>先将所有数异或一下，最后得到的是两个目标值异或的结果。因为这两个数都只出现了1次，所以他俩异或的结果一定不是0，而且异或之后，他俩不同的位的地方都会为1.</p>
<p>然后获取他俩异或结果的最低位1，利用位运算经典公式：x&amp;(-x)——和负数与的时候，负数要取反加1</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>[] singleNumber(<span class="built_in">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">// 保存最后一个非零位</span></span><br><span class="line">        <span class="built_in">int</span> mask = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 求出目标的两个数字的异或结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> num : nums) &#123;</span><br><span class="line">            mask ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录异或之后最低的非零位的位置</span></span><br><span class="line">        <span class="built_in">int</span> lastOnePos = mask &amp; (-mask);</span><br><span class="line">        <span class="comment">// 最终返回的结果</span></span><br><span class="line">        <span class="built_in">int</span>[] result = new <span class="built_in">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 重新遍历一遍nums，如果最低位与之前的最低位一样都是1，则划为一个数组</span></span><br><span class="line">        <span class="comment">// 如果不一样，划为另一个数组</span></span><br><span class="line">        <span class="comment">// 因为目标两个数都只出现了一次，所以根据这个划分可以得到各自包含他们俩的两个数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>((num &amp; lastOnePos) == <span class="number">0</span>) &#123;</span><br><span class="line">                result[<span class="number">0</span>] ^= num;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result[<span class="number">1</span>] ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
]]></content>
      <categories>
        <category>Algorithms Note</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Dynamic Programming</title>
    <url>/2020/01/13/LeetCode-Practice-by-Categories-Dynamic-Programming/</url>
    <content><![CDATA[<blockquote>
<p>每个人都是自己命运的主宰——斯蒂尔斯</p>
</blockquote>
<p>LeetCode大量动态规划相关题目，其解决思路和具体代码。</p>
<a id="more"></a>

<p>动态规划不是空中楼阁。</p>
<p>dynamic programming最常用的场景就是当你的结果存在大量重复的过程的时候，可以用DP利用你在过程中得到的结果。</p>
<h2 id="70-Climbing-stairsl-爬楼梯-Easy"><a href="#70-Climbing-stairsl-爬楼梯-Easy" class="headerlink" title="70. Climbing-stairsl(爬楼梯)(Easy)"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. Climbing-stairsl(爬楼梯)(Easy)</a></h2><p>You are climbing a stair case. It takes n steps to reach to the top.</p>
<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>
<p>Note: Given <em>n</em> will be a positive integer.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">Output:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">Explanation:</span> <span class="string">There</span> <span class="string">are</span> <span class="string">two</span> <span class="string">ways</span> <span class="string">to</span> <span class="string">climb</span> <span class="string">to</span> <span class="string">the</span> <span class="string">top.</span></span><br><span class="line"><span class="number">1</span><span class="string">.</span> <span class="number">1</span> <span class="string">step</span> <span class="string">+</span> <span class="number">1</span> <span class="string">step</span></span><br><span class="line"><span class="number">2</span><span class="string">.</span> <span class="number">2</span> <span class="string">steps</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">Output:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">Explanation:</span> <span class="string">There</span> <span class="string">are</span> <span class="string">three</span> <span class="string">ways</span> <span class="string">to</span> <span class="string">climb</span> <span class="string">to</span> <span class="string">the</span> <span class="string">top.</span></span><br><span class="line"><span class="number">1</span><span class="string">.</span> <span class="number">1</span> <span class="string">step</span> <span class="string">+</span> <span class="number">1</span> <span class="string">step</span> <span class="string">+</span> <span class="number">1</span> <span class="string">step</span></span><br><span class="line"><span class="number">2</span><span class="string">.</span> <span class="number">1</span> <span class="string">step</span> <span class="string">+</span> <span class="number">2</span> <span class="string">steps</span></span><br><span class="line"><span class="number">3</span><span class="string">.</span> <span class="number">2</span> <span class="string">steps</span> <span class="string">+</span> <span class="number">1</span> <span class="string">step</span></span><br></pre></td></tr></table></figure>
<hr>
<p>解：爬楼梯很经典，变型也很多。首先结论是，单纯的这道题，通过数学归纳的思路(或者说递归的思路)，不难发现其实结果就是前两个元素为1,2的斐波那契数列。(斐波那契数列为509题，因为类似这里就不记录了，链接<a href="https://leetcode-cn.com/problems/fibonacci-number/" target="_blank" rel="noopener">点击这里</a>)</p>
<p>方法一：递归，可以画出递归树发现，因为每个层级都会在上一层的数量基础上多出2倍的节点，所以时间复杂度为O(2^n)，指数级别，不可以接受。而且实际测试中在N为44的时候会出现超时。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> climbStairs(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> climbHelper(<span class="number">0</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> climbHelper(<span class="built_in">int</span> curr, <span class="built_in">int</span> target) &#123;</span><br><span class="line">        <span class="comment">// terminator</span></span><br><span class="line">        <span class="comment">// 跨过了目标阶梯，不算入方法</span></span><br><span class="line">        <span class="keyword">if</span>(curr &gt; target) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 刚好攀登到某个位置</span></span><br><span class="line">        <span class="keyword">if</span>(curr == target) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> climbHelper(curr + <span class="number">1</span>, target) + climbHelper(curr + <span class="number">2</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>方法二：基于递归，加上备忘录，进行有记忆的递归，可以把之前计算过的结果保存下来，有很好的剪枝效果。因为有记录所有的过程，所以子问题的数量就是f(1),f(2)…，为O(n),而且每个子问题解决的时间为O(n)</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> climbStairs(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="comment">// 基于暴力递归，进行有记忆的递归，把每一步的结果存储在mem数组之中，每当有函数被再次调用，就直接从memo数组返回结果，减少计算次数</span></span><br><span class="line">        <span class="built_in">int</span>[] memo = new <span class="built_in">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> climbHelper(<span class="number">0</span>,n,memo);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> climbHelper(<span class="built_in">int</span> curr, <span class="built_in">int</span> target, <span class="built_in">int</span>[] memo) &#123;</span><br><span class="line">        <span class="comment">// terminator</span></span><br><span class="line">        <span class="comment">// 跨过了目标阶梯，不算入方法</span></span><br><span class="line">        <span class="keyword">if</span>(curr &gt; target) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 刚好攀登到某个位置</span></span><br><span class="line">        <span class="keyword">if</span>(curr == target) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果当前N阶梯数量已经计算过，直接从memo返回</span></span><br><span class="line">        <span class="keyword">if</span>(memo[curr] &gt; <span class="number">0</span>) <span class="keyword">return</span> memo[curr];</span><br><span class="line">        </span><br><span class="line">        memo[curr] =  climbHelper(curr + <span class="number">1</span>, target, memo) + climbHelper(curr + <span class="number">2</span>, target, memo);</span><br><span class="line">        <span class="keyword">return</span> memo[curr];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>方法三：常规动态规划，时间复杂度为O(n)，空间复杂度也为O(n)</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> climbStairs(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// dp[i]表示爬到第i阶共有的爬法</span></span><br><span class="line">        <span class="built_in">int</span>[] dp = new <span class="built_in">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>; dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法四：基于常规动态规划的优化。在空间复杂度上可以提升到O(1)。实际上在一开始的时间复杂度的基础上都可以进行空间的优化，比如O(n)可以优化到O(1),O(m*n)可以优化到O(n)。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> climbStairs(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> f1 = <span class="number">1</span>, f2 = <span class="number">2</span>, f3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            f3 = f1 + f2;</span><br><span class="line">            f1 = f2;</span><br><span class="line">            f2 = f3;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="322-Coin-Change-零钱兑换-Mid"><a href="#322-Coin-Change-零钱兑换-Mid" class="headerlink" title="322. Coin Change(零钱兑换)(Mid)"></a><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">322. Coin Change(零钱兑换)(Mid)</a></h2><p>You are given coins of different denominations and a total amount of money <em>amount</em>. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return <code>-1</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="string">coins</span> <span class="string">=</span> <span class="string">[1,</span> <span class="number">2</span><span class="string">,</span> <span class="number">5</span><span class="string">],</span> <span class="string">amount</span> <span class="string">=</span> <span class="number">11</span></span><br><span class="line"><span class="attr">Output:</span> <span class="number">3</span> </span><br><span class="line"><span class="attr">Explanation:</span> <span class="number">11</span> <span class="string">=</span> <span class="number">5</span> <span class="string">+</span> <span class="number">5</span> <span class="string">+</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="string">coins</span> <span class="string">=</span> <span class="string">[2],</span> <span class="string">amount</span> <span class="string">=</span> <span class="number">3</span></span><br><span class="line"><span class="attr">Output:</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>


<p><strong>Note:</strong></p>
<p>You may assume that you have an infinite number of each kind of coin.</p>
<hr>
<p>解：这道题其实和之前的爬楼梯问题是异曲同工之处，可以看成每次可以走coins数组里面的步伐，最后要到达amount的高度，有多少种走法。当然这里有点变化，就是比如112和121，在爬楼梯问题是不同方法，而在这里coin change则是相同的，一种方法。但是写DP方程的话差不多了。</p>
<p>方法一：暴力法，用递归的方式。</p>
<p><img src="https://s2.ax1x.com/2020/02/21/3uunUK.png" alt="3uunUK.png"></p>
<p>题目变成：在状态树中找到叶子节点为0的，并且层数最小的。<br>可以用树的广度优先遍历，直到碰到数值为0的节点，当前层数就是最小硬币数，就是我们的答案。</p>
<p>但是这个方法会存在指数级别的时间复杂度。</p>
<p>方法二：DP</p>
<p>a. subproblems</p>
<p>b. DP array：f(n) = min{f(n-k), for k in [1,2,5]} + 1, 遍历可以选择的面值的数组，直到n被减到0为止，然后取得到的硬币数的最小值。加一是因为一开始的n-k没有被算入，后面补上。</p>
<p>c. DP方程</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// amount + 1 是无法到达的，以此判断最后是否不能到达amount</span></span><br><span class="line">        <span class="keyword">int</span> max = amount+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// dp数组的下标是当前金额，里面的值是需要的硬币的个数，初始化是不可达的max</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line">        <span class="comment">// 初始化dp,初始化考虑只有面值为1的硬币，需要max个</span></span><br><span class="line">        Arrays.fill(dp,max);</span><br><span class="line">        <span class="comment">// 当拿到的amount是0的时候，需要0个硬币，类似爬楼梯，初始化就在0级台阶</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 外层，遍历所有下标的元素，也就是当前凑到的面值数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">            <span class="comment">// 每次都从coins里面取元素出来，比如coins是[1,2,5]，每次在要凑下标</span></span><br><span class="line">            <span class="comment">// 值的时候，都会把1,2,5取出来进行值的拼凑</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; coins.length; j++) &#123;</span><br><span class="line">                <span class="comment">// 如果当前coins里面取出来的值比下标小，才能用。否则比如你下标是3，</span></span><br><span class="line">                <span class="comment">// 即当前要凑到3的值，但当前conis里面硬币值是10，那肯定不用这个</span></span><br><span class="line">                <span class="keyword">if</span>(coins[j] &lt;= i) &#123;</span><br><span class="line">                    <span class="comment">// 用DP方程进行递推</span></span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[i-coins[j]] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果最后一个没有被修改，则没办法组成这个金额。否则返回最后amount下标的值</span></span><br><span class="line">        <span class="keyword">return</span> dp[amount] == max ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态规划一般脱离递归，直接由循环迭代完成计算。</p>
<p>动态规划问题最难的就是写出状态转移方程。</p>
<p>时间复杂度：O(m*n)</p>
<h2 id="343-Integer-Break-整数拆分-Mid"><a href="#343-Integer-Break-整数拆分-Mid" class="headerlink" title="343. Integer Break(整数拆分)(Mid)"></a><a href="https://leetcode-cn.com/problems/integer-break/" target="_blank" rel="noopener">343. Integer Break(整数拆分)(Mid)</a></h2><p>Given a positive integer n, break it into the sum of <strong>at least</strong> two positive integers and maximize the product of those integers. Return the maximum product you can get.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">Output:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">Explanation:</span> <span class="number">2</span> <span class="string">=</span> <span class="number">1</span> <span class="string">+</span> <span class="number">1</span><span class="string">,</span> <span class="number">1</span> <span class="string">×</span> <span class="number">1</span> <span class="string">=</span> <span class="number">1</span><span class="string">.</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">Output:</span> <span class="number">36</span></span><br><span class="line"><span class="attr">Explanation:</span> <span class="number">10</span> <span class="string">=</span> <span class="number">3</span> <span class="string">+</span> <span class="number">3</span> <span class="string">+</span> <span class="number">4</span><span class="string">,</span> <span class="number">3</span> <span class="string">×</span> <span class="number">3</span> <span class="string">×</span> <span class="number">4</span> <span class="string">=</span> <span class="number">36</span><span class="string">.</span></span><br></pre></td></tr></table></figure>

<p><strong>Note</strong>:You may assume that <em>n</em> is not less than 2 and not larger than 58</p>
<p><strong>注</strong>：这道题和剑指offer上第14，剪绳子，题目不同，但是考察内容非常类似。链接可以<a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/" target="_blank" rel="noopener">点击这里</a></p>
<hr>
<p>解：这道题可以用纯数学思路和动态规划两种方法解决</p>
<p>方法一：纯数学，其实就是通过分析之后用贪心法。可以用数学归纳法证明，目标是拆分成多个3的乘积，并且能拆分成2*2就不拆分成 1 * 3。</p>
<p>详细内容可以参考<a href="https://leetcode-cn.com/problems/integer-break/solution/343-zheng-shu-chai-fen-tan-xin-by-jyd/" target="_blank" rel="noopener">这篇题解</a></p>
<p>简而言之，要尽可能把数字拆分成3或者3的倍数。但是按照题目要求，至少要剪一次，至少要两段，所以边界条件值(n小于等于3的时候)可以考虑返回n-1.</p>
<p>因为拆分成2比拆分成3乘积更小，所以3优先级大于2,2大于1</p>
<p>然后要求出n除以3的整数部分a和余数部分b(即<code>n=3*a+b</code>)，要分成三种情况：</p>
<ol>
<li>当b=0时，直接返回3^a;</li>
<li>当b=1时，要将一个1+3转换成2+2，因为2*2 &gt; 1 * 3，因此返回 3^(a-1) * 4;</li>
<li>当b=2时，返回3^n*2即可</li>
</ol>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">3</span>) <span class="keyword">return</span> n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> a = n / <span class="number">3</span>, b = n % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>,a);</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">1</span>) <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>, a-<span class="number">1</span>) * <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>,a) * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度为O(1)，仅有求整、取余、次方计算操作</li>
<li>空间复杂度：O(1)，只需要变量a和b和常数大小的额外空间</li>
</ul>
<h2 id="221-Maximal-Square-最大正方形-Mid"><a href="#221-Maximal-Square-最大正方形-Mid" class="headerlink" title="221.  Maximal Square(最大正方形)(Mid)"></a><a href="https://leetcode-cn.com/problems/maximal-square/" target="_blank" rel="noopener">221.  Maximal Square(最大正方形)(Mid)</a></h2><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area.</p>
<p><strong>Example:</strong></p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Input</span>: </span><br><span class="line"></span><br><span class="line">1 0 1 0 0</span><br><span class="line">1 0 1 1 1</span><br><span class="line">1 1 1 1 1</span><br><span class="line">1 0 0 1 0</span><br><span class="line"></span><br><span class="line"><span class="attribute">Output</span>: 4</span><br></pre></td></tr></table></figure>

<hr>
<p>解：别误读了题意，输入只是二维matrix，要找Square而已！</p>
<p>这道题看上去和”Stack-Queue”系列的84、85题好像很类似，但是做法和思路完全不同，而且也比那两道题更简单……主要的原因是正方形比矩形性质好用太多，直接用动态规划的思想即可。</p>
<p>发现规律：申请一个dp[][][]二维数组，通过找规律和观察，可以发现，如果某个位置的值为1，那么这个位置上的值取决于它的<font color=#FF0000>上面、左上角、左边</font>三个值的最小值加1.</p>
<p>然后每次都检查当前存储的值是否可以替换掉之前的maxSquare值即可。</p>
<p>因为最后求的是area，所以直接返回<code>maxSquare*maxSquare</code>即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 注意rows和cols的值，别弄反了</span></span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length, cols = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// 最大边长</span></span><br><span class="line">        <span class="keyword">int</span> maxSquare = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 申请dp数组，大小比行和列都多1，这样可以防止处理的时候越界</span></span><br><span class="line">        <span class="comment">// 申请的时候多申请1，这道题可以不用考虑边界情况，直接把</span></span><br><span class="line">        <span class="comment">// 原本的数组重新"填"到dp数组里，值是当前能组成的最大Square</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[rows + <span class="number">1</span>][cols + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i - <span class="number">1</span>][j - <span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    <span class="comment">// 取当前左、上、左上三个方向的最小值，再加1</span></span><br><span class="line">                    <span class="comment">// Math.min函数一次最多只能有两个参数，要注意</span></span><br><span class="line">                    dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>],Math.min(dp[i][j - <span class="number">1</span>],dp[i - <span class="number">1</span>][j])) + <span class="number">1</span>;</span><br><span class="line">                    maxSquare = Math.max(maxSquare, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSquare * maxSquare;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="303-Range-Sum-Query-Immutable-区域和检索-数组不可变-Easy"><a href="#303-Range-Sum-Query-Immutable-区域和检索-数组不可变-Easy" class="headerlink" title="303.Range Sum Query-Immutable(区域和检索-数组不可变)(Easy)"></a><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/" target="_blank" rel="noopener">303.Range Sum Query-Immutable(区域和检索-数组不可变)(Easy)</a></h2><p>Given an integer array <em>nums</em>, find the sum of the elements between indices i and j (<em>i</em> ≤ <em>j</em>), inclusive.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Given nums = [<span class="number">-2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">-5</span>, <span class="number">2</span>, <span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">sumRange(<span class="number">0</span>, <span class="number">2</span>) -&gt; <span class="number">1</span></span><br><span class="line">sumRange(<span class="number">2</span>, <span class="number">5</span>) -&gt; <span class="number">-1</span></span><br><span class="line">sumRange(<span class="number">0</span>, <span class="number">5</span>) -&gt; <span class="number">-3</span></span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ol>
<li>You may assume that the array does not change.</li>
<li>There are many calls to sumRange function.</li>
</ol>
<hr>
<p>解：动态规划的思路解决，预先将所有的相加可能的结果计算出来并存储起来，然后调用它来找到即可。注意下标问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sums[];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        sums = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        sums[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length; i++) &#123;</span><br><span class="line">            sums[i+<span class="number">1</span>]  = sums[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sums[j+<span class="number">1</span>] - sums[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumArray obj = new NumArray(nums);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.sumRange(i,j);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>注意，先把所有计算结果保存起来，每次访问的话只需要O(1)，否则每次访问再计算，会导致时间复杂度太高。</p>
<h2 id="53-Maximum-Subarray-最大子序和"><a href="#53-Maximum-Subarray-最大子序和" class="headerlink" title="53.Maximum Subarray(最大子序和)"></a>53.<a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">Maximum Subarray(最大子序和)</a></h2><p>Given an integer array <code>nums</code>, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>],</span><br><span class="line">Output: <span class="number">6</span></span><br><span class="line">Explanation: [<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>] has the largest sum = <span class="number">6.</span></span><br></pre></td></tr></table></figure>

<p><strong>Follow up:</strong></p>
<p>If you have figured out the O(<em>n</em>) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p>
<hr>
<p>解：动态规划，定义数组dp[n.length]，其中dp[i]表示当前第i个元素可以得到的最大和，递推公式关键在于dp[i]为nums[i]与dp[i-1]+nums[i]之间的最大值，因为每次两种选择，直接加入nums[i]，或者从之前dp[i]和都小于0，需要重新从nums[i]开始算起。而在过程中需要记录当前能得到的最大的子序和max，最后返回max即可。</p>
<p>为什么要有一个max记录最大值？状态都放在dp[i]不就行了？——不可以，答案很可能是子序和，所以要有一个单独的变量保存结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="comment">// dp[i]表示第i位置到上一个计算起点的最大子序和的值</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span> result = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 比较巧妙，如果dp[i-1]&lt;0，那么肯定丢弃dp[i-1]能让dp[i]更大</span></span><br><span class="line">            <span class="comment">// 反之同理，如果dp[i-1] &gt; 0，那么加上dp[i-1]能让dp[i]更大</span></span><br><span class="line">            dp[i] = nums[i] + (dp[i-<span class="number">1</span>] &gt; <span class="number">0</span> ? dp[i-<span class="number">1</span>] : <span class="number">0</span>);</span><br><span class="line">            result = Math.max(dp[i], result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>300.<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">Longest Increasing Subsequence(最长上升子序列)</a></p>
<p>Given an unsorted array of integers, find the length of longest increasing subsequence.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">10</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">101</span>,<span class="number">18</span>]</span><br><span class="line">Output: <span class="number">4</span> </span><br><span class="line">Explanation: The longest increasing subsequence <span class="keyword">is</span> [<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">101</span>], therefore the length <span class="keyword">is</span> <span class="number">4.</span></span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ul>
<li>There may be more than one LIS combination, it is only necessary for you to return the length.</li>
<li>Your algorithm should run in O(n^ 2) complexity.</li>
</ul>
<p><strong>Follow up:</strong> Could you improve it to O(<em>n</em> log <em>n</em>) time complexity?</p>
<hr>
<p>解：这道题非常重要，如果面试中出现了，现场想基本是想不到的。</p>
<p>方法一：暴力，时间是指数级别O(2^n)，因为要以每个数为中心，然后右边只要碰到比它大的就要继续往后探索。比如当前为2，碰到5要继续让5往后分叉，到7,7还要继续往后，等等。</p>
<p><strong>方法二</strong>：动态规划，记录dp[i]的结果，自底向上思考，定义dp[i]为以当前第i位数字为结尾能够组成的LIS，则最后返回的结果是<code>max(k=1,2...n)dp[k]</code>。</p>
<p>一开始我们把dp数组所有元素填上1，因为每个元素一定能用自己组成一个结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        Arrays.fill(dp,<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i ;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    <span class="comment">//dp[i]每次的选择有两个：用dp[j]或者不用。</span></span><br><span class="line">                    <span class="comment">//如果用dp[j]里面的值，则在dp[j]基础上加1</span></span><br><span class="line">                    <span class="comment">//如果不用，说明用nums[i]组成的子序列更长，直接用dp[i]即可</span></span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//每次以i为轴，记录每轮最大的结果，保存到result中</span></span><br><span class="line">                result = Math.max(result,dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)</p>
<p>空间复杂度：O(n)</p>
<p>但是实际上，单纯用动态规划的时间复杂度太高了，面试的时候面试官不会满意的。</p>
<p><strong>方法三</strong>：最优解，用binary search，二分查找来解决，时间复杂度可以到O(NlogN)</p>
<p>之前用dp的时候是自底向上的思路，那么如果我们正向来思考呢？</p>
<p>我们从左往右遍历，自己构建出来这个目标结果数组。每遍历到一个数，我们就判断这个数应该在我们最长上升子序列的哪个部分，然后更新这个部分。每次构造的数字实际上只能有三种情况：<strong>放到结果数组的第一位、插入到第中间、放到最后</strong>——只有放在最后，长度才+1。而如果放在中间，则只有新来的数比之前中间的小，才能让整体上升序列更长。</p>
<p>所以总结来说，可以观察到，<strong>如果出现新的最大值，整个数组长度会+1，如果遇到新的最大值比当前最大值小，那么就会更新dp的最大值因为后面出现的最大值一定可以被加到之前的连续上升subsequence当中，因为最后一个元素能更小的话这个边界肯定是最优的</strong>。所以这样我们最后得到的dp数据可能不对，但是长度肯定没错。</p>
<p><strong>具体解法</strong>：</p>
<p>首先我们可以用Java的Arrays类中的binarySearch()方法进行二分搜索。该方法返回要搜索元素的索引值。</p>
<p>介绍一下binarySearch()方法：</p>
<p><code>binarySearch(Object[] a,int fromIndex, int toIndex, Object key)</code></p>
<p>a:要搜索的数组</p>
<p>fromIndex：指定范围的开始处索引(包含)</p>
<p>toIndex：指定范围的结束处索引(不包含)</p>
<p>key：要搜索的值</p>
<p>Note:Arrays.binarySearch() method returns index of the search key, if it is contained in the array, else it returns (-(insertion point) - 1). The insertion point is the point at which the key would be inserted into the array; the index of the first element greater than the key, or a.length if all elements in the array are less than the specified key.</p>
<p>如果要搜索的元素key在指定的范围内，则返回搜索值的索引；否则返回<strong>-1</strong>或<strong>“-“(插入点)</strong>，所谓插入点的值就是第一个比关键字大的元素在数组中的位置索引，<font color=#FF0000>而且这个位置索引从1开始</font>，或者如果整个数组所有元素都比这个key小，那么返回的是-(a.length+1)。返回-1的情况是一开始查找的数组中也没有元素(即数组长度为0)的边界情况。</p>
<p><a href="https://www.cnblogs.com/qingergege/p/5658292.html" target="_blank" rel="noopener">有关binarySearch()的介绍可以参考这篇文章</a></p>
<p><a href="https://www.youtube.com/watch?v=nNPy623huVU" target="_blank" rel="noopener">这道题解法讲解可以参考这个视频</a></p>
<p>注意这个函数是被重载的，在这里只介绍这种参数形式。</p>
<p>用binarySearch()优化之后的dp方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;            </span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="comment">//范围是0~len，每次查找的元素是x</span></span><br><span class="line">            <span class="keyword">int</span> index = Arrays.binarySearch(dp, <span class="number">0</span>, len, num);</span><br><span class="line">            <span class="keyword">if</span>(index &lt; <span class="number">0</span>) &#123; <span class="comment">//没有重复元素。之后会直接返回插入点，若没找到，</span></span><br><span class="line">                <span class="comment">//插入点是从1开始最后又加上负号的值，所以i要先加1再取负才是新元素应该在</span></span><br><span class="line">                <span class="comment">//dp数组中的具体位置</span></span><br><span class="line">                index = -(index + <span class="number">1</span>);<span class="comment">//一开始插入的时候，实际坐标其实是-(-1+1)=0</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找到插入点后将元素x插入递增数组dp对应位置</span></span><br><span class="line">            dp[index] = num;</span><br><span class="line">            <span class="keyword">if</span>(index == len) <span class="comment">//若插入的位置在最后，len++，这也是唯一会让len增加的情况</span></span><br><span class="line">                len++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(NlogN)</li>
<li>空间复杂度：O(n)</li>
</ul>
<p>但是如果面试中面试官不允许使用Arrays.binarySearch，则可以我们自己手写一个二分查找的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] tails = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>, right = len;</span><br><span class="line">            <span class="comment">//手写二分查找算法，找到插入的位置left</span></span><br><span class="line">            <span class="keyword">while</span>(left != right) &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(tails[mid] &lt; num)</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            tails[left] = num;</span><br><span class="line">            <span class="keyword">if</span>(left == len) </span><br><span class="line">                len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指offer-62-圆圈中最后剩下的数字-Easy"><a href="#剑指offer-62-圆圈中最后剩下的数字-Easy" class="headerlink" title="剑指offer 62.圆圈中最后剩下的数字(Easy)"></a><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/" target="_blank" rel="noopener">剑指offer 62.圆圈中最后剩下的数字(Easy)</a></h2><p>0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p>
<p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p>
<p><strong>示例 1</strong>：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: n = <span class="number">5</span>, m = <span class="number">3</span></span><br><span class="line">输出: <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: n = <span class="number">10</span>, m = <span class="number">17</span></span><br><span class="line">输出: <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>限制</strong>：</p>
<ul>
<li><code>1 &lt;= n &lt;= 10^5</code></li>
<li><code>1 &lt;= m &lt;= 10^6</code></li>
</ul>
<hr>
<p>解：<strong>方法一</strong>：用双向链表(或者用单向链表模拟双向链表)来删除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// idx为每次删除元素的位置</span></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// n为环中剩余的元素数量而不是下标，所以n最后要为1</span></span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// idx为当前要删除的元素的下标</span></span><br><span class="line">            idx = (idx + m - <span class="number">1</span>) % n;</span><br><span class="line">            list.remove(idx);</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：因为看到ArrayList中的源码，删除操作需要遍历一遍链表，所以整个时间复杂度趋近于O(mn)或O(n^2)</li>
<li>空间复杂度：O(n)</li>
</ul>
<p><strong>方法二</strong>：这是非常经典的约瑟夫环问题，考虑最后剩余的1个圆环的位置，发现有规律！直接用数学方法解决，通过每轮删除元素的下标的值，如果从0开始倒着推，可以找到如下规律：</p>
<p>第一轮是 [0, 1, 2, 3, 4] ，所以是 [0, 1, 2, 3, 4] 这个数组的多个复制。这一轮 2 删除了。</p>
<p>第二轮开始时，从 3 开始，所以是 [3, 4, 0, 1] 这个数组的多个复制。这一轮 0 删除了。</p>
<p>第三轮开始时，从 1 开始，所以是 [1, 3, 4] 这个数组的多个复制。这一轮 4 删除了。</p>
<p>第四轮开始时，还是从 1 开始，所以是 [1, 3] 这个数组的多个复制。这一轮 1 删除了。</p>
<p>最后剩下的数字是 3。</p>
<p>图中的绿色的线指的是新的一轮的开头是怎么指定的，每次都是固定地向前移位 mm 个位置。</p>
<p>然后我们从最后剩下的 3 倒着看，我们可以反向推出这个数字在之前每个轮次的位置。</p>
<p>最后剩下的 3 的下标是 0。</p>
<p>第四轮反推，补上 m 个位置，然后模上当时的数组大小 2，位置是(0 + 3) % 2 = 1。</p>
<p>第三轮反推，补上 m 个位置，然后模上当时的数组大小 3，位置是(1 + 3) % 3 = 1。</p>
<p>第二轮反推，补上 m 个位置，然后模上当时的数组大小 4，位置是(1 + 3) % 4 = 0。</p>
<p>第一轮反推，补上 m 个位置，然后模上当时的数组大小 5，位置是(0 + 3) % 5 = 3。</p>
<p>所以最终剩下的数字的下标就是3。因为数组是从0开始的，所以最终的答案就是3。</p>
<p>总结一下反推的过程，就是 (当前index + m) % 上一轮剩余数字的个数。</p>
<p>所以公式为：<code>最终被删元素下标 = (当前index + m) % 上一轮剩余数字的个数</code></p>
<p><img src="https://i.loli.net/2020/04/15/eDzSvToHIdGrtA5.png" alt="约瑟夫环递推公式.png"></p>
<p>用代码来写就比较容易了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">1</span> || m &lt; <span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//最后一轮剩两个人，从2开始反推</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            result = (result + m) % i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<p>无理论是时间复杂度还是空间复杂度都优于用环形链表模拟圆环的经典解法(后者时间复杂度O(mn)、空间复杂度O(n))。有关约瑟夫环递推公式推理可以参考LeetCode题解，重点是自底向上地反推。</p>
<h2 id="剑指offer-63-LC121-股票的最大利润-Mid"><a href="#剑指offer-63-LC121-股票的最大利润-Mid" class="headerlink" title="剑指offer 63/LC121.股票的最大利润(Mid)"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">剑指offer 63/LC121.股票的最大利润(Mid)</a></h2><p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p>
<p>If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
<p>Note that you cannot sell a stock before you buy one.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">Output: <span class="number">5</span></span><br><span class="line">Explanation: Buy on day <span class="number">2</span> (price = <span class="number">1</span>) <span class="keyword">and</span> sell on day <span class="number">5</span> (price = <span class="number">6</span>), profit = <span class="number">6</span><span class="number">-1</span> = <span class="number">5.</span></span><br><span class="line">             Not <span class="number">7</span><span class="number">-1</span> = <span class="number">6</span>, as selling price needs to be larger than buying price.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">Output: <span class="number">0</span></span><br><span class="line">Explanation: In <span class="keyword">this</span> <span class="keyword">case</span>, no transaction <span class="keyword">is</span> done, i.e. max profit = <span class="number">0.</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：这道题可以牵扯出买卖股票的一系列问题(121,122,123,188,309,714)，这里暂时只介绍121这道最基础的情况。</p>
<p>由于不用考虑交易的次数和交易冷冻时期，所以这道题场景比较简单，只需要定义一个二维数组即可，大小为dp [len] [2]，其中第二位只可能有两种情况，0或1,0代表当前没有股友股票，1代表当前持有股票。</p>
<p>需要注意考虑边界情况，即第一天如果没有股票，则收益为0；如果有股票，则可以看做是新买入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = prices.length;</span><br><span class="line">        <span class="comment">//dp[][]表示第i天是否持有股票时候的利润</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//第1天不持有股票，利润是0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//第1天就持有股票，必须买入，故此时利润是-prices[0]</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">//第i天买入股票或卖出股票</span></span><br><span class="line">            <span class="comment">//0代表不持有，有两种：</span></span><br><span class="line">            <span class="comment">//第i天不买入也不卖出，或者卖出。</span></span><br><span class="line">            <span class="comment">//前者利润和i-1天不持有股票一样</span></span><br><span class="line">            <span class="comment">//后者利润是i-1天持有股票的利润加上股票的价值</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i]);</span><br><span class="line">            <span class="comment">//1为第i天持有股票时候的利润，也是两种情况：</span></span><br><span class="line">            <span class="comment">//一个是第i-1天拥有股票，那么这一天的收益和前一天拥有股票时收益相同</span></span><br><span class="line">            <span class="comment">//一个是第i-1天没有股票，则要新买入，收益是"-股票价格"</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(-prices[i], dp[i-<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最大利润的情况一定是最后一天不持有股票的时候的盈利值</span></span><br><span class="line">        <span class="keyword">return</span> dp[len-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithms Note</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Search</title>
    <url>/2020/01/13/LeetCode-Practice-by-Categories-Search/</url>
    <content><![CDATA[<blockquote>
<p>轻财足以聚人，律己足以服人，量宽足以得人，身先足以率人。——陈继儒</p>
</blockquote>
<p>LeetCode搜索相关题目，其解决思路和具体代码。内容也包括二分查找。</p>
<a id="more"></a>

<p>在树的章节中已经包括了很多有关DFS和BFS的题目，比如，非常经典和重要的，树的层次遍历(102)和树的一些遍历。之前重复的在这里先不再写了。</p>
<h2 id="74-Search-a-2D-Matrix-搜索二维矩阵-Mid"><a href="#74-Search-a-2D-Matrix-搜索二维矩阵-Mid" class="headerlink" title="74. Search a 2D Matrix(搜索二维矩阵)(Mid)"></a><a href="https://leetcode-cn.com/problems/search-a-2d-matrix/" target="_blank" rel="noopener">74. Search a 2D Matrix(搜索二维矩阵)(Mid)</a></h2><p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p>
<ul>
<li>Integers in each row are sorted from left to right.</li>
<li>The first integer of each row is greater than the last integer of the previous row.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">matrix = [</span><br><span class="line">  [<span class="number">1</span>,   <span class="number">3</span>,  <span class="number">5</span>,  <span class="number">7</span>],</span><br><span class="line">  [<span class="number">10</span>, <span class="number">11</span>, <span class="number">16</span>, <span class="number">20</span>],</span><br><span class="line">  [<span class="number">23</span>, <span class="number">30</span>, <span class="number">34</span>, <span class="number">50</span>]</span><br><span class="line">]</span><br><span class="line">target = <span class="number">3</span></span><br><span class="line">Output: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">matrix = [</span><br><span class="line">  [<span class="number">1</span>,   <span class="number">3</span>,  <span class="number">5</span>,  <span class="number">7</span>],</span><br><span class="line">  [<span class="number">10</span>, <span class="number">11</span>, <span class="number">16</span>, <span class="number">20</span>],</span><br><span class="line">  [<span class="number">23</span>, <span class="number">30</span>, <span class="number">34</span>, <span class="number">50</span>]</span><br><span class="line">]</span><br><span class="line">target = <span class="number">13</span></span><br><span class="line">Output: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：这道题和下一道题几乎是兄弟模样，但是比240更简单，主要因为properties的第二条——他在保证了每一行为递增的之外，还保证下一行的第一个元素一定大于上一行的最后一个。</p>
<p>经典的二分查找的思想，把整个二维数组当成是一个排好序的数组对待即可。</p>
<p>需要注意的一个很有用的公式：</p>
<ul>
<li>把m*n的二维矩阵转换成一个数组：matrix[x][y] =&gt; array[x * n + y]</li>
<li>把一个array转换成m*n的二维矩阵：array[x] =&gt; matrix[x/n][x%n]</li>
</ul>
<p>抓住了上面这个转换机制，就抓住了关键</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// corner case</span></span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// start为开始的位置，end为当前终止的位置</span></span><br><span class="line">        <span class="comment">// rows为行数，cols为列数</span></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, rows = matrix.length, cols = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> end = rows * cols - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start &lt;= end) &#123;</span><br><span class="line">            <span class="comment">// 找到当前中间位置的元素mid</span></span><br><span class="line">            <span class="keyword">int</span> mid = (end + start) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 最关键的是用start和end与二维矩阵matrix之间的转换公式</span></span><br><span class="line">            <span class="comment">// 二维矩阵转换中最重要的是列数，这个和定义二维数组的时候，可以没有</span></span><br><span class="line">            <span class="comment">// 行数，但是必须声明列数的道理是一样的</span></span><br><span class="line">            <span class="keyword">if</span>(matrix[mid / cols][mid % cols] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果当前mid比target小，那么target一定在mid右边，就要把start右移</span></span><br><span class="line">            <span class="comment">// vice versa</span></span><br><span class="line">            <span class="keyword">if</span>(matrix[mid / cols][mid % cols] &lt; target) &#123;</span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：标准的二分查找，时间复杂度为O(log(m*n))</li>
<li>空间复杂度：O(1)</li>
</ul>
<h2 id="240-Search-a-2D-Matrix-II-搜索二维矩阵-Mid"><a href="#240-Search-a-2D-Matrix-II-搜索二维矩阵-Mid" class="headerlink" title="240. Search a 2D Matrix II(搜索二维矩阵)(Mid)"></a><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/" target="_blank" rel="noopener">240. Search a 2D Matrix II(搜索二维矩阵)(Mid)</a></h2><p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p>
<ul>
<li>Integers in each row are sorted in ascending from left to right.</li>
<li>Integers in each column are sorted in ascending from top to bottom.</li>
</ul>
<p><strong>Example:</strong></p>
<p>Consider the following matrix:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,   <span class="number">4</span>,  <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>],</span><br><span class="line">  [<span class="number">2</span>,   <span class="number">5</span>,  <span class="number">8</span>, <span class="number">12</span>, <span class="number">19</span>],</span><br><span class="line">  [<span class="number">3</span>,   <span class="number">6</span>,  <span class="number">9</span>, <span class="number">16</span>, <span class="number">22</span>],</span><br><span class="line">  [<span class="number">10</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">17</span>, <span class="number">24</span>],</span><br><span class="line">  [<span class="number">18</span>, <span class="number">21</span>, <span class="number">23</span>, <span class="number">26</span>, <span class="number">30</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>Given target = <code>5</code>, return <code>true</code>.</p>
<p>Given target = <code>20</code>, return <code>false</code>.</p>
<hr>
<p>解：和74的区别是，此题输入的数组下一行的首元素和上一行相比不是递增的，而是在行和列这两个方向上是递增的，这样一来解题思路和上一题就完全不同了。上一题因为存储方式和二维矩阵与数组的转换方式有吻合之处所以可以用二分法，这里也可以，但是没有上一题那么容易解了。</p>
<p>但是不难发现，因为在行和列这两个方向是递增的，所以右上角成为了突破口。右上角的元素如果大于target，那么再次查找target的时候可以排除之前的一列；如果右上角元素小于target，那么再次查找的时候可以排除之前元素的这一行。</p>
<p>写法一：从右上角开始突破。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// corner case</span></span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 从右上角开始</span></span><br><span class="line">        <span class="comment">// start our pointer fron top-right</span></span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>, col = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(col &gt;= <span class="number">0</span> &amp;&amp; row &lt;= matrix.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[row][col] == target) &#123; <span class="comment">// found it</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(matrix[row][col] &lt; target) &#123;</span><br><span class="line">                row++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                col--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理，其实从左下角开始也可以，可以把左下角当做搜索的突破口，若当前元素小于target，那么下次从当前元素的右边开始，剔除掉当前元素在的列；如果当前元素大于target,下次从当前元素上一个开始，剔除掉当前元素在的行。</p>
<p>写法二：从左下角开始突破</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// corner case</span></span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 从左下角开始</span></span><br><span class="line">        <span class="comment">// start our pointer fron bottom-left</span></span><br><span class="line">        <span class="keyword">int</span> col = <span class="number">0</span>, row = matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(row &gt;= <span class="number">0</span> &amp;&amp; col &lt;= matrix[<span class="number">0</span>].length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[row][col] == target) <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// found it</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(matrix[row][col] &lt; target) &#123;</span><br><span class="line">                col++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                row--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(m + n)。时间复杂度分析的关键是注意到在每次迭代（我们不返回 true）时，行或列都会精确地递减/递增一次。由于行只能减少 mm 次，而列只能增加 nn 次，因此在导致 while 循环终止之前，循环不能运行超过 n+mn+m 次。因为所有其他的工作都是常数，所以总的时间复杂度在矩阵维数之和中是线性的。</p>
</li>
<li><p>空间复杂度：O(1)。因为这种方法都只需要处理几个指针，所以内存占用是恒定的。</p>
</li>
</ul>
<h2 id="127-Word-Ladder-单词接龙-Mid"><a href="#127-Word-Ladder-单词接龙-Mid" class="headerlink" title="127. Word Ladder(单词接龙)(Mid)"></a><a href="https://leetcode-cn.com/problems/word-ladder/" target="_blank" rel="noopener">127. Word Ladder(单词接龙)(Mid)</a></h2><p>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary’s word list, find the length of shortest transformation sequence from <em>beginWord</em> to <em>endWord</em>, such that:</p>
<ol>
<li>Only one letter can be changed at a time.</li>
<li>Each transformed word must exist in the word list. Note that <em>beginWord</em> is not a <em>transformed</em> word.</li>
</ol>
<p><strong>Note:</strong></p>
<ul>
<li>Return 0 if there is no such transformation sequence.</li>
<li>All words have the same length.</li>
<li>All words contain only lowercase alphabetic characters.</li>
<li>You may assume no duplicates in the word list.</li>
<li>You may assume beginWord and endWord are non-empty and are not the same.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">beginWord = <span class="string">"hit"</span>,</span><br><span class="line">endWord = <span class="string">"cog"</span>,</span><br><span class="line">wordList = [<span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span>,<span class="string">"cog"</span>]</span><br><span class="line"></span><br><span class="line">Output: <span class="number">5</span></span><br><span class="line"></span><br><span class="line">Explanation: As one shortest transformation <span class="keyword">is</span> <span class="string">"hit"</span><span class="function"> -&gt;</span> <span class="string">"hot"</span><span class="function"> -&gt;</span> <span class="string">"dot"</span><span class="function"> -&gt;</span> <span class="string">"dog"</span><span class="function"> -&gt;</span> <span class="string">"cog"</span>,</span><br><span class="line"><span class="keyword">return</span> its length <span class="number">5.</span></span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">Input:</span></span><br><span class="line">beginWord = <span class="string">"hit"</span></span><br><span class="line">endWord = <span class="string">"cog"</span></span><br><span class="line">wordList = [<span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span>]</span><br><span class="line"></span><br><span class="line"><span class="section">Output: 0</span></span><br><span class="line"></span><br><span class="line"><span class="section">Explanation: The endWord "cog" is not in wordList, therefore no possible transformation.</span></span><br></pre></td></tr></table></figure>
<hr>
<p>解：<strong>这道题是面试中经常会出现的问题</strong>。一般思路，可以使用初级搜索，即单向BFS。但是这里着重介绍使用双向BFS的方法，从beginWord和endWord中更小的那个开始扩散。为什么这样扩散比单向扩散效率更高？</p>
<p>因为同时从beginWord和endWord开始，然后每次从更短的一段开始继续搜索，那么因为是更小的Set，所以辐射的内容会更少，如果需要剪枝或者回溯，代价也可以更小。</p>
<p>比如，打仗的时候一方总会派出侦察兵，这些侦察兵往往身上负重很轻，因为这样他们才可以移动迅速，累赘小。而如果他们被抓了，需要被放弃，那么少量的武器，也能成为更小的损失和代价。</p>
<p>实际上，双向BFS是属于<strong>高级搜索</strong>的范畴的。对于初级搜索(BFS和DFS)，一般来说优化的思路有两个：<strong>一是让搜索过程去掉重复以及尽早剪枝</strong>，<strong>二是</strong>让它在搜索方向上加强。</p>
<p>事实上，双向BFS在高级搜索中用得比较多，而且代码并不难。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!wordList.contains(endWord)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 用Set代替Queue进行BFS, 是为了更方便查询单词是否在wordList中</span></span><br><span class="line">        <span class="comment">// 如果不用哈希，直接的list查询时间复杂度为O(n),使用Set之后时间复杂度为O(1)</span></span><br><span class="line">        Set&lt;String&gt; wordListSet = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// beginSet是从beginWord开始扩散的，endSet是从endWord开始扩散的</span></span><br><span class="line">        Set&lt;String&gt; beginSet = <span class="keyword">new</span> HashSet&lt;&gt;(), endSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里和单向BFS中一开始往queue中加入元素的操作类似,加入初始元素</span></span><br><span class="line">        <span class="comment">// 可以看出，beginSet和endSet本质没有先后顺序,先扩散小的可以更快收敛</span></span><br><span class="line">        beginSet.add(beginWord);</span><br><span class="line">        endSet.add(endWord);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 转换次数，这是细节，由于beingWord != endWord, 所以至少一步</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// visited 表示这个BFS节点是否已经被访问过了</span></span><br><span class="line">        Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// BFS start here</span></span><br><span class="line">        <span class="keyword">while</span>( !beginSet.isEmpty() ) &#123;</span><br><span class="line">            <span class="comment">// 扩散的时候优先选择小的Set</span></span><br><span class="line">            <span class="comment">// 如果beginSet更小，就扩散它</span></span><br><span class="line">            <span class="comment">// 否则如果beginSet更大，交换这两个Set,还是小的Set开始扩散</span></span><br><span class="line">            <span class="comment">// 核心：控制当前循环从哪个方向进行bfs；让begin指向size更小的集合，这样不会一直从一个方向BFS</span></span><br><span class="line">            <span class="keyword">if</span>(beginSet.size() &gt; endSet.size()) &#123;</span><br><span class="line">                Set&lt;String&gt; set = beginSet;</span><br><span class="line">                beginSet = endSet;</span><br><span class="line">                endSet = set;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// neighbor 这个set表示每一次要扩散的set的内容</span></span><br><span class="line">            Set&lt;String&gt; neighbor = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            <span class="comment">// 模板中这里会开始控制次数的for循环，但这里的HashSet和模板的queue是一样的含义,只是更方便查找</span></span><br><span class="line">            <span class="keyword">for</span>(String word : beginSet) &#123;</span><br><span class="line">                <span class="comment">// 对每一个单词，变化它的字符位</span></span><br><span class="line">                <span class="keyword">char</span>[] chs = word.toCharArray();</span><br><span class="line">                <span class="comment">// 用字母表遍历当前chs的每一个字母</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">char</span> c = <span class="string">'a'</span>; c &lt;= <span class="string">'z'</span>; c++) &#123;</span><br><span class="line">                        <span class="comment">// 保存chs的当前位置的字母</span></span><br><span class="line">                        <span class="keyword">char</span> old = chs[i];</span><br><span class="line">                        <span class="comment">// 然后替换成当前遍历到的字母表的字母</span></span><br><span class="line">                        chs[i] = c;</span><br><span class="line">                        <span class="comment">// 转换回String，从而使用endSet中的contains方法</span></span><br><span class="line">                        <span class="comment">// 否则不能对char[]使用contains方法</span></span><br><span class="line">                        String target = String.valueOf(chs);</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 因为endSet是从endWord那边扩散过来的，如果我们替换过程中产生的target也在</span></span><br><span class="line">                        <span class="comment">// 这个Set里，说明从begin扩散过来的Set和从end扩散过来的set，在这里相交了</span></span><br><span class="line">                        <span class="comment">// 这个相交的word就是target</span></span><br><span class="line">                        <span class="keyword">if</span>(endSet.contains(target)) &#123;</span><br><span class="line">                            <span class="keyword">return</span> len + <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 如果当时没找到target，则继续扩散其他的target,且把target追加到下一次</span></span><br><span class="line">                        <span class="comment">// 要扩散的set里面去，这里的neighbor set就是后面要扩散的set</span></span><br><span class="line">                        <span class="keyword">if</span>(!visited.contains(target) &amp;&amp; wordListSet.contains(target)) &#123;</span><br><span class="line">                            neighbor.add(target);</span><br><span class="line">                            <span class="comment">// 标记target 为 visited, 表示访问过了</span></span><br><span class="line">                            visited.add(target);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 把单词本身还原</span></span><br><span class="line">                        chs[i] = old;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理完beign中的元素之后，让begin指向begin中的元素的邻居</span></span><br><span class="line">            beginSet = neighbor;</span><br><span class="line">            <span class="comment">// 路径长度++</span></span><br><span class="line">            len ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有转换的路径</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="126-单词接龙-II-Hard"><a href="#126-单词接龙-II-Hard" class="headerlink" title="126. (单词接龙 II)(Hard)"></a><a href="https://leetcode-cn.com/problems/word-ladder-ii/" target="_blank" rel="noopener">126. (单词接龙 II)(Hard)</a></h2><h2 id="433-Minimum-Genetic-Mutation-最小基因变化-Mid"><a href="#433-Minimum-Genetic-Mutation-最小基因变化-Mid" class="headerlink" title="433. Minimum Genetic Mutation(最小基因变化)(Mid)"></a><a href="https://leetcode-cn.com/problems/minimum-genetic-mutation/" target="_blank" rel="noopener">433. Minimum Genetic Mutation(最小基因变化)(Mid)</a></h2><p>A gene string can be represented by an 8-character long string, with choices from <code>&quot;A&quot;, &quot;C&quot;, &quot;G&quot;, &quot;T&quot;</code>.</p>
<p>Suppose we need to investigate about a mutation (mutation from “start” to “end”), where ONE mutation is defined as ONE single character changed in the gene string.</p>
<p>For example, <code>&quot;AACCGGTT&quot; -&gt; &quot;AACCGGTA&quot;</code> is 1 mutation.</p>
<p>Also, there is a given gene “bank”, which records all the valid gene mutations. A gene must be in the bank to make it a valid gene string.</p>
<p>Now, given 3 things - start, end, bank, your task is to determine what is the minimum number of mutations needed to mutate from “start” to “end”. If there is no such a mutation, return -1.</p>
<p><strong>Note:</strong></p>
<ol>
<li>Starting point is assumed to be valid, so it might not be included in the bank.</li>
<li>If multiple mutations are needed, all mutations during in the sequence must be valid.</li>
<li>You may assume start and end string is not the same.</li>
</ol>
<p><strong>Exmaple 1:</strong></p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">start:</span> <span class="string">"AACCGGTT"</span></span><br><span class="line"><span class="symbol">end:</span>   <span class="string">"AACCGGTA"</span></span><br><span class="line"><span class="symbol">bank:</span> [<span class="string">"AACCGGTA"</span>]</span><br><span class="line"></span><br><span class="line"><span class="symbol">return:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">start:</span> <span class="string">"AACCGGTT"</span></span><br><span class="line"><span class="symbol">end:</span>   <span class="string">"AAACGGTA"</span></span><br><span class="line"><span class="symbol">bank:</span> [<span class="string">"AACCGGTA"</span>, <span class="string">"AACCGCTA"</span>, <span class="string">"AAACGGTA"</span>]</span><br><span class="line"></span><br><span class="line"><span class="symbol">return:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">start:</span> <span class="string">"AAAAACCC"</span></span><br><span class="line"><span class="symbol">end:</span>   <span class="string">"AACCCCCC"</span></span><br><span class="line"><span class="symbol">bank:</span> [<span class="string">"AAAACCCC"</span>, <span class="string">"AAACCCCC"</span>, <span class="string">"AACCCCCC"</span>]</span><br><span class="line"></span><br><span class="line"><span class="symbol">return:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：这道题实际和单词接龙属于一种类型的题目，都是通过BFS解决状态图搜索问题。</p>
<h2 id="200-Number-of-Islands-岛屿数量-Mid"><a href="#200-Number-of-Islands-岛屿数量-Mid" class="headerlink" title="200. Number of Islands(岛屿数量)(Mid)"></a><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">200. Number of Islands(岛屿数量)(Mid)</a></h2><p>Given a 2d grid map of <code>&#39;1&#39;</code>s (land) and <code>&#39;0&#39;</code>s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span></span><br><span class="line"><span class="number">11110</span></span><br><span class="line"><span class="number">11010</span></span><br><span class="line"><span class="number">11000</span></span><br><span class="line"><span class="number">00000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Output:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span></span><br><span class="line"><span class="number">11000</span></span><br><span class="line"><span class="number">11000</span></span><br><span class="line"><span class="number">00100</span></span><br><span class="line"><span class="number">00011</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Output:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：参考油管上Kevin大神的代码，思路非常清晰。</p>
<p>这道题在面试中经常会考到，主要思想是利用dfs，每碰到一个”1”，都将其周围的所有”1”击沉掉，也就是全部重新设置为0，然后总的岛屿数量加1，这样持续下去可以每次将一块岛击沉。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// error checking</span></span><br><span class="line">        <span class="keyword">if</span>(grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">int</span> numIslands = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    numIslands += dfs(grid, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numIslands;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 沉岛法,将i和j相邻的所有为1的点全部置为0</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// terminator，分别对应上下左右四个方向的超比边界情况</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= grid.length || j &lt; <span class="number">0</span> || j &gt;= grid[i].length || grid[i][j] == <span class="string">'0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//sink</span></span><br><span class="line">        grid[i][j] = <span class="string">'0'</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// down</span></span><br><span class="line">        dfs(grid, i+<span class="number">1</span>, j);</span><br><span class="line">        <span class="comment">// right</span></span><br><span class="line">        dfs(grid, i, j+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// up</span></span><br><span class="line">        dfs(grid, i-<span class="number">1</span>, j);</span><br><span class="line">        <span class="comment">// left</span></span><br><span class="line">        dfs(grid, i, j-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="153-Find-Minimum-in-Rotated-Sorted-Array-寻找旋转排序数组中的最小值-Mid"><a href="#153-Find-Minimum-in-Rotated-Sorted-Array-寻找旋转排序数组中的最小值-Mid" class="headerlink" title="153. Find Minimum in Rotated Sorted Array(寻找旋转排序数组中的最小值)(Mid)"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">153. Find Minimum in Rotated Sorted Array(寻找旋转排序数组中的最小值)(Mid)</a></h2><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e.,  <code>[0,1,2,4,5,6,7]</code> might become  <code>[4,5,6,7,0,1,2]</code>).</p>
<p>Find the minimum element.</p>
<p>You may assume no duplicate exists in the array.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>] </span><br><span class="line">Output: <span class="number">1</span></span><br></pre></td></tr></table></figure>


<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">Output: <span class="number">0</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：用二分搜索解决，在二分搜索的过程中，我们每次找到区间的中点，然后根据某些条件去决定去区间的左边还是右边继续搜索。</p>
<p>重点是数组已经被旋转过了，所以简单的二分搜索不可行。</p>
<p>通过分析可以发现，旋转之后的数组两头总会存在头部元素比尾部元素大的情况，直到到了之前旋转的元素才会变化，我们可以把这个地方成为变化点：</p>
<p><img src="https://pic.leetcode-cn.com/a78a34cc8145ef5b51b59b1482238c6fa940ecfb67bf424cb839d197d4c72eba-153-3.png" alt="变化点"></p>
<p>有关”变化点”的特点：</p>
<blockquote>
<p>所有变化点左侧元素 &gt; 数组第一个元素<br>所有变化点右侧元素 &lt; 数组第一个元素</p>
</blockquote>
<p>可以说这个是我们定义的新的”二分查找”</p>
<p>具体算法流程：</p>
<ol>
<li>找到数组中间元素mid</li>
<li>如果<code>中间元素 &gt; 数组第一个元素</code>，我们需要在<code>mid</code>右边搜索变化点</li>
<li>如果<code>中间元素 &lt; 数组第一个元素</code>，我们需要在<code>mid</code>左边搜索变化点</li>
<li>当我们找到变化点时停止搜索，当以下条件满足任意一个即可：</li>
</ol>
<ul>
<li><p>nums[mid] &gt; nums[mid + 1]，因此 mid+1 是最小值。</p>
</li>
<li><p>nums[mid - 1] &gt; nums[mid]，因此 mid 是最小值。</p>
</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> findMin(<span class="built_in">int</span>[] nums) &#123;</span><br><span class="line">        <span class="built_in">int</span> len = nums.length;</span><br><span class="line">        <span class="comment">// corner case</span></span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> left = <span class="number">0</span>, right = len<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[left] &lt; nums[right]) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// binary search</span></span><br><span class="line">        <span class="keyword">while</span>(right &gt;= left) &#123;</span><br><span class="line">            <span class="built_in">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[mid + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[mid - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[mid];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[<span class="number">0</span>]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把代码简化一点：</p>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> findMin(<span class="built_in">int</span>[] nums) &#123;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">len</span> = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">len</span> == <span class="number">0</span> || nums == <span class="literal">null</span>) &#123;</span><br><span class="line">            return <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = <span class="built_in">len</span> - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>) &#123;</span><br><span class="line">            <span class="built_in">int</span> <span class="built_in">mid</span> = (<span class="built_in">left</span> + <span class="built_in">right</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">mid</span> &gt; <span class="number">0</span> &amp;&amp; nums[<span class="built_in">mid</span>] &lt; nums[<span class="built_in">mid</span> - <span class="number">1</span>]) &#123;</span><br><span class="line">                return nums[<span class="built_in">mid</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[<span class="built_in">left</span>] &lt;= nums[<span class="built_in">mid</span>] &amp;&amp; nums[<span class="built_in">mid</span>] &gt; nums[<span class="built_in">right</span>]) &#123;</span><br><span class="line">                <span class="built_in">left</span> = <span class="built_in">mid</span> + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">right</span> = <span class="built_in">mid</span> - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return nums[<span class="built_in">left</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(logN)，和二分搜索一样</li>
<li>空间复杂度：O(1)</li>
</ul>
<h2 id="154-Find-Minimum-in-Rotated-Sorted-Array-寻找旋转排序数组中的最小值-II-Hard"><a href="#154-Find-Minimum-in-Rotated-Sorted-Array-寻找旋转排序数组中的最小值-II-Hard" class="headerlink" title="154. Find Minimum in Rotated Sorted Array(寻找旋转排序数组中的最小值 II)(Hard)"></a><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">154. Find Minimum in Rotated Sorted Array(寻找旋转排序数组中的最小值 II)(Hard)</a></h2><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e.,  <code>[0,1,2,4,5,6,7]</code> might become  <code>[4,5,6,7,0,1,2]</code>).</p>
<p>Find the minimum element.</p>
<p>The array may contain duplicates.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">Output: <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">Output: <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>Note:</p>
<ul>
<li>This is a follow up problem to Find Minimum in Rotated Sorted Array.</li>
<li>Would allow duplicates affect the run-time complexity? How and why?</li>
</ul>
<hr>
<p>写在前面：这可以算是代码最简单的Hard题之一。</p>
<p>这道题是上一题153的延伸题目，而且和剑指offer面试题11相同。(重点在于考虑可能会有重复元素)</p>
<p>解：注意这里只能用mid位置的值去和nums[right]去比较，不能用mid位置的值和nums[left]比较，因为做比较的目的是判断 mm 在哪个排序数组中。但在 <code>numbers[m] &gt; numbers[i]</code>情况下，无法判断 m 在哪个排序数组中。本质是因为 j 初始值肯定在右排序数组中； i 初始值无法确定在哪个排序数组中。</p>
<p>举例：当 i = 0, j = 4, m = 2 时，有 numbers[m] &gt; numbers[i] ，以下两示例得出不同结果。<br>numbers = [1, 2, 3, 4 ,5] 旋转点 x = 0 ： m 在右排序数组（此示例只有右排序数组）；<br>numbers = [3, 4, 5, 1 ,2]旋转点 x=3 ： m 在左排序数组。</p>
<p>所以循环比较nums[mid]和nums[right]</p>
<ol>
<li>当 <code>numbers[m] &gt; numbers[j]</code>时： m 一定在 左排序数组中，即旋转点 x 一定在 <code>[m + 1, j]</code> 闭区间内，因此执行 <code>i = m + 1</code>；</li>
<li>当 <code>numbers[m] &lt; numbers[j]</code> 时： m 一定在 右排序数组 中，即旋转点 xx 一定在<code>[i, m]</code> 闭区间内，因此执行 <code>j = m</code>；</li>
<li>当 <code>numbers[m] == numbers[j]</code> 时： 无法判断 m 在哪个排序数组中，即无法判断旋转点 x 在 <code>[i, m]</code> 还是 <code>[m + 1, j]</code> 区间中。解决方案： 执行 <code>j = j - 1</code>缩小判断范围</li>
</ol>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> findMin(<span class="built_in">int</span>[] nums) &#123;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">len</span> = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">len</span> == <span class="number">0</span> || nums == <span class="literal">null</span>) return <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = <span class="built_in">len</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>) &#123;</span><br><span class="line">            <span class="built_in">int</span> <span class="built_in">mid</span> = (<span class="built_in">left</span> + <span class="built_in">right</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[<span class="built_in">mid</span>] &gt; nums[<span class="built_in">right</span>]) &#123;</span><br><span class="line">                <span class="built_in">left</span> = <span class="built_in">mid</span> + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[<span class="built_in">mid</span>] &lt; nums[<span class="built_in">right</span>])&#123;</span><br><span class="line">                <span class="built_in">right</span> = <span class="built_in">mid</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">right</span>--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nums[<span class="built_in">left</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(logN),但是在特例下(比如所有元素都相等的情况)，会退化到O(N)</li>
<li>空间复杂度：O(1),left,right,mid指针都是常数大小的空间</li>
</ul>
<h2 id="79-Word-Search-单词搜索-Mid"><a href="#79-Word-Search-单词搜索-Mid" class="headerlink" title="79. Word Search (单词搜索)(Mid)"></a><a href="https://leetcode-cn.com/problems/word-search/" target="_blank" rel="noopener">79. Word Search (单词搜索)(Mid)</a></h2><p>Given a 2D board and a word, find if the word exists in the grid.</p>
<p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>
<p><strong>Example:</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">board =</span><br><span class="line">[</span><br><span class="line">  [<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'E'</span>],</span><br><span class="line">  [<span class="string">'S'</span>,<span class="string">'F'</span>,<span class="string">'C'</span>,<span class="string">'S'</span>],</span><br><span class="line">  [<span class="string">'A'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Given <span class="keyword">word</span> = <span class="string">"ABCCED"</span>, <span class="keyword">return</span> <span class="literal">true</span>.</span><br><span class="line">Given <span class="keyword">word</span> = <span class="string">"SEE"</span>, <span class="keyword">return</span> <span class="literal">true</span>.</span><br><span class="line">Given <span class="keyword">word</span> = <span class="string">"ABCB"</span>, <span class="keyword">return</span> <span class="literal">false</span>.</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>board</code> and <code>word</code> consists only of lowercase and uppercase English letters.</li>
<li><code>1 &lt;= board.length &lt;= 200</code></li>
<li><code>1 &lt;= board[i].length &lt;= 200</code></li>
<li><code>1 &lt;= word.length &lt;= 10^3</code></li>
</ul>
<hr>
<p>解：这道题用递归或者叫回溯来解决。每次只要当前字符和word的第一个字母相同，就开始使用函数dfs进行DFS搜索，每次搜索的方向是上、下、左、右四个，只有找到了才返回true</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">String</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">word</span>.length() == <span class="number">0</span> || <span class="keyword">word</span> == null) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="keyword">word</span>.charAt(<span class="number">0</span>) &amp;&amp; dfs(board,i,j,<span class="number">0</span>,<span class="keyword">word</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board,<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> count, <span class="keyword">String</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="keyword">word</span>.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理边界条件，分别是:go above the board(处在边界上面，下同)(i &lt; 0)、go below the board(i &gt;= board.length)</span></span><br><span class="line">        <span class="comment">// go left the board(j &lt; 0)、go right the board (j &gt;= board[i].length)、</span></span><br><span class="line">        <span class="comment">// 或者就是当前字母不匹配word的单词：board[i][j] != word.charAt(count)</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= board.length || j &lt; <span class="number">0</span> || j &gt;= board[i].length || board[i][j] != <span class="keyword">word</span>.charAt(count)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span> temp = board[i][j]; <span class="comment">// 记录当前i,j位置的字符</span></span><br><span class="line">        board[i][j] = <span class="string">' '</span>; <span class="comment">// 访问过的地方置空，防止重复访问</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span> found = dfs(board,i+<span class="number">1</span>,j,count+<span class="number">1</span>,<span class="keyword">word</span>)</span><br><span class="line">            || dfs(board,i<span class="number">-1</span>,j,count+<span class="number">1</span>,<span class="keyword">word</span>)</span><br><span class="line">            || dfs(board,i,j+<span class="number">1</span>,count+<span class="number">1</span>,<span class="keyword">word</span>)</span><br><span class="line">            || dfs(board,i,j<span class="number">-1</span>,count+<span class="number">1</span>,<span class="keyword">word</span>);</span><br><span class="line">        <span class="comment">// 因为之前每次查找的时候都清空了当前位置元素，所以再找的时候要把值赋回去。因为你不能确保第一次就找到，可能一个字母</span></span><br><span class="line">        <span class="comment">// 要在四个方向都各自查找一次才行，如果之前被置空了而且不管了，那么再找的时候其为空，那就无论如何也不可能找到了，就出错了</span></span><br><span class="line">        board[i][j] = temp;</span><br><span class="line">        <span class="keyword">return</span> found;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：如果整个board元素数量是N,那时间复杂度就是O(N)</li>
<li>空间复杂度：因为调用了递归，可能坏的情况是要每一个元素都建立一个变量，所以空间复杂度应该是O(n)</li>
</ul>
<h2 id="剑指offer面试题13-机器人的运动范围-Mid"><a href="#剑指offer面试题13-机器人的运动范围-Mid" class="headerlink" title="剑指offer面试题13.机器人的运动范围(Mid)"></a><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/" target="_blank" rel="noopener">剑指offer面试题13.机器人的运动范围(Mid)</a></h2><p>地上有一个m行n列的方格，从坐标 <code>[0,0]</code> 到坐标 <code>[m-1,n-1]</code> 。一个机器人从坐标 <code>[0, 0]</code> 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>
<p><strong>示例1：</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入：m = <span class="number">2</span>, n = <span class="number">3</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>示例2：</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入：m = <span class="number">3</span>, n = <span class="number">1</span>, k = <span class="number">0</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n,m &lt;= 100</code></li>
<li><code>0 &lt;= k &lt;= 20</code></li>
</ul>
<hr>
<p>解：这道题和上面的79单词搜索比较类似，都可以用DFS，或者叫回溯的思想。</p>
<p>DFS通过递归，先朝着一个防线搜索到底，再回溯至上一个节点，沿另一个方向搜索，以此类推。在访问过程中可以用到剪枝：遇到数位和超出目标值(k)、或者某位已经访问过，则立即返回，可以称之为<code>可行性剪枝</code></p>
<p>具体做法：</p>
<ul>
<li><strong>递归参数</strong>：可以把m,n,k定义到类外面成为类变量而不是方法变量来减少需要传入的参数值；要传入当前在矩阵中的索引i和j、记录某节点是否被访问过的visited</li>
<li><strong>终止条件</strong>：1.行或者列索引越界(和79机器人、200岛屿相同)、2.数位和si和sj的和超出目标值k、3.当前元素已经访问过</li>
<li><strong>递归工作</strong>：<ul>
<li>标记当前单元格为已访问，即将(i,j)存入Set <code>visited</code>中，代表此单元格已被访问过。</li>
<li>搜索下一个单元格：计算当前元素的<strong>下、右</strong>两个方向元素的数位和，并开启下层递归。</li>
</ul>
</li>
<li>回溯返回值：返回 <code>1 + 右方搜索的可达解总数 + 下方搜索的可达解总数</code>，代表从本单元格递归搜索的可达解总数。</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int</span> m,n,k;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> movingCount(<span class="built_in">int</span> m, <span class="built_in">int</span> n, <span class="built_in">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">this</span>.m = m;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">        <span class="keyword">this</span>.k = k;</span><br><span class="line">        <span class="comment">// visited记录当前位置是否被访问过</span></span><br><span class="line">        <span class="built_in">bool</span>ean[][] visited = new <span class="built_in">bool</span>ean[m][n];</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, visited);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> dfs(<span class="built_in">int</span> i, <span class="built_in">int</span> j, <span class="built_in">bool</span>ean[][] visited) &#123;</span><br><span class="line">        <span class="comment">// terminator</span></span><br><span class="line">        <span class="keyword">if</span>(add(i,j) &gt; k || i &lt; <span class="number">0</span> || i &gt;= m || j &lt; <span class="number">0</span> || j &gt;= n || visited[i][j]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当前位置满足条件而且没被访问过，所以进行访问。</span></span><br><span class="line">        <span class="comment">// 访问之后将visited置true</span></span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> result = <span class="number">0</span>;</span><br><span class="line">        result = <span class="number">1</span> + dfs(i + <span class="number">1</span>,j ,visited) + dfs(i ,j + <span class="number">1</span> ,visited);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> add(<span class="built_in">int</span> i, <span class="built_in">int</span> j) &#123;</span><br><span class="line">        <span class="built_in">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i != <span class="number">0</span>) &#123;</span><br><span class="line">            result += i%<span class="number">10</span>;</span><br><span class="line">            i /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j != <span class="number">0</span>) &#123;</span><br><span class="line">            result += j%<span class="number">10</span>;</span><br><span class="line">            j /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="17-Letter-Combinations-of-a-Phone-Number-电话号码的字母组合-Mid"><a href="#17-Letter-Combinations-of-a-Phone-Number-电话号码的字母组合-Mid" class="headerlink" title="17. Letter Combinations of a Phone Number(电话号码的字母组合)(Mid)"></a><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">17. Letter Combinations of a Phone Number(电话号码的字母组合)(Mid)</a></h2><p>Given a string containing digits from <code>2-9</code> inclusive, return all possible letter combinations that the number could represent.</p>
<p>A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png" alt=""></p>
<p><strong>Example:</strong></p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Input:</span> <span class="string">"23"</span></span><br><span class="line"><span class="symbol">Output:</span> [<span class="string">"ad"</span>, <span class="string">"ae"</span>, <span class="string">"af"</span>, <span class="string">"bd"</span>, <span class="string">"be"</span>, <span class="string">"bf"</span>, <span class="string">"cd"</span>, <span class="string">"ce"</span>, <span class="string">"cf"</span>].</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong><br>Although the above answer is in lexicographical order(字典序), your answer could be in any order you want.</p>
<hr>
<p>解：这道题是比较经典的搜索问题。深搜和广搜都可以。</p>
<p>方法一：</p>
<h2 id="994-Rotting-Oranges-腐烂的橘子-Mid"><a href="#994-Rotting-Oranges-腐烂的橘子-Mid" class="headerlink" title="994. Rotting Oranges (腐烂的橘子)(Mid)"></a><a href="https://leetcode-cn.com/problems/rotting-oranges/" target="_blank" rel="noopener">994. Rotting Oranges (腐烂的橘子)(Mid)</a></h2><p>In a given grid, each cell can have one of three values:</p>
<ul>
<li>the value <code>0</code> representing an empty cell;</li>
<li>the value <code>1</code> representing a fresh orange;</li>
<li>the value <code>2</code> representing a rotten orange.</li>
</ul>
<p>Every minute, any fresh orange that is adjacent (4-directionally) to a rotten orange becomes rotten.</p>
<p>Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return <code>-1</code> instead.</p>
<p><strong>Example 1:</strong></p>
<p><strong><img src="https://assets.leetcode.com/uploads/2019/02/16/oranges.png" alt="img"></strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [[<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">Output: <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [[<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">Output: <span class="number">-1</span></span><br><span class="line">Explanation:  The orange <span class="keyword">in</span> the bottom left corner (row <span class="number">2</span>, column <span class="number">0</span>) <span class="keyword">is</span> never rotten, because rotting only happens <span class="number">4</span>-directionally.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="string">[[0,2]]</span></span><br><span class="line"><span class="attr">Output:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">Explanation:</span>  <span class="string">Since</span> <span class="string">there</span> <span class="string">are</span> <span class="string">already</span> <span class="literal">no</span> <span class="string">fresh</span> <span class="string">oranges</span> <span class="string">at</span> <span class="string">minute</span> <span class="number">0</span><span class="string">,</span> <span class="string">the</span> <span class="string">answer</span> <span class="string">is</span> <span class="string">just</span> <span class="number">0</span><span class="string">.</span></span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ol>
<li><code>1 &lt;= grid.length &lt;= 10</code></li>
<li><code>1 &lt;= grid[0].length &lt;= 10</code></li>
<li><code>grid[i][j]</code> is only <code>0</code>, <code>1</code>, or <code>2</code>.</li>
</ol>
<hr>
<p>解：首先这道题应该用DFS还是BFS呢？</p>
<p>因为最后的结果可以理解是从腐烂的橘子开始向外扩散，每分钟向周围扩散一层，扩散完所有橘子所需要的最小时间。用BFS的思路可以很好契合，这是一个BFS的最短路径搜索问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">orangesRotting</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//count表示新鲜橘子的数量</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//遍历二维数组，找出所有新鲜橘子和腐烂的橘子</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[i].length; j++) &#123;</span><br><span class="line">                <span class="comment">//新鲜橘子计数</span></span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(grid[i][j] == <span class="number">2</span>) &#123; <span class="comment">//腐烂橘子放入queue开始BFS</span></span><br><span class="line">                    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//round表示腐烂橘子的轮数，或者叫分钟数</span></span><br><span class="line">        <span class="keyword">int</span> round = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果有新鲜橘子，并且队列不为空，开始围绕队列中橘子开始遍历</span></span><br><span class="line">        <span class="comment">//直到上下左右都触及边界，或者被感染的橘子已经遍历完</span></span><br><span class="line">        <span class="keyword">while</span>(count &gt; <span class="number">0</span> &amp;&amp; !queue.isEmpty()) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//BFS层数+1</span></span><br><span class="line">            round++;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//拿到当前层级腐烂橘子的数量，放在这里是因为每个层级</span></span><br><span class="line">            <span class="comment">//队列都会更新</span></span><br><span class="line">            <span class="keyword">int</span> n = queue.size();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//遍历当前层级的队列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="comment">//踢出队列，或者说是拿到一个腐烂的橘子</span></span><br><span class="line">                <span class="keyword">int</span>[] orange = queue.poll();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//恢复橘子坐标</span></span><br><span class="line">                <span class="keyword">int</span> row = orange[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> col = orange[<span class="number">1</span>];</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//该橘子的上邻点，判断是否越界并且是否是健康的橘子</span></span><br><span class="line">                <span class="keyword">if</span>(row &gt;= <span class="number">1</span> &amp;&amp; grid[row-<span class="number">1</span>][col] == <span class="number">1</span>) &#123;<span class="comment">//是健康的橘子且不越界</span></span><br><span class="line">                    <span class="comment">//感染这个橘子</span></span><br><span class="line">                    grid[row-<span class="number">1</span>][col] = <span class="number">2</span>;</span><br><span class="line">                    <span class="comment">//好橘子的数量减1</span></span><br><span class="line">                    count--;</span><br><span class="line">                    <span class="comment">//把感染的橘子放进队列，当做缓存，下次使用</span></span><br><span class="line">                    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;row-<span class="number">1</span>, col&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//该橘子的下邻点，和上面类似</span></span><br><span class="line">                <span class="keyword">if</span>(row &lt; grid.length-<span class="number">1</span> &amp;&amp; grid[row+<span class="number">1</span>][col] == <span class="number">1</span>) &#123;</span><br><span class="line">                    grid[row+<span class="number">1</span>][col] = <span class="number">2</span>;</span><br><span class="line">                    count--;</span><br><span class="line">                    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;row+<span class="number">1</span>, col&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//该橘子的左邻点，和上面类似</span></span><br><span class="line">                <span class="keyword">if</span>(col &gt;= <span class="number">1</span> &amp;&amp; grid[row][col-<span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                    grid[row][col-<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">                    count--;</span><br><span class="line">                    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;row, col-<span class="number">1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//该橘子的右邻点，和上面类似</span></span><br><span class="line">                <span class="keyword">if</span>(col &lt; grid[<span class="number">0</span>].length-<span class="number">1</span> &amp;&amp; grid[row][col+<span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                    grid[row][col+<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">                    count--;</span><br><span class="line">                    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;row, col+<span class="number">1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//若遍历完了还存在新鲜的橘子，则返回-1</span></span><br><span class="line">        <span class="comment">//否则返回round</span></span><br><span class="line">        <span class="keyword">if</span>(count != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> round;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="33-Search-in-Rotated-Sorted-Array-搜索旋转排序数组-Mid"><a href="#33-Search-in-Rotated-Sorted-Array-搜索旋转排序数组-Mid" class="headerlink" title="33. Search in Rotated Sorted Array (搜索旋转排序数组)(Mid)"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">33. Search in Rotated Sorted Array (搜索旋转排序数组)(Mid)</a></h2><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., <code>[0,1,2,4,5,6,7]</code> might become <code>[4,5,6,7,0,1,2]</code>).</p>
<p>You are given a target value to search. If found in the array return its index, otherwise return <code>-1</code>.</p>
<p>You may assume no duplicate exists in the array.</p>
<p>Your algorithm’s runtime complexity must be in the order of <em>O</em>(log <em>n</em>).</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: nums = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], target = <span class="number">0</span></span><br><span class="line">Output: <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: nums = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], target = <span class="number">3</span></span><br><span class="line">Output: <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：二分查找进行旋转。利用”整个数组是部分有序”的这么一个特质。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 暴力：还原O(logN) -&gt; 升序 -&gt; 二分:O(logN) (写、总结)，概括就是要用二分查找去找到数组汇总被某个元素劈断的位置</span></span><br><span class="line"><span class="comment">// 2. 正解：二分查找</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high) &#123;</span><br><span class="line">            mid = (low + high) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) &#123; <span class="comment">//找到了</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//前半部分有序,注意此处用小于等于</span></span><br><span class="line">            <span class="keyword">if</span>(nums[low] &lt;= nums[mid]) &#123;</span><br><span class="line">                <span class="comment">//target在前半部分</span></span><br><span class="line">                <span class="keyword">if</span>(target &gt;= nums[low] &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                    high = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    low = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//mid的前半部分无序</span></span><br><span class="line">                <span class="keyword">if</span>(target &lt;= nums[high] &amp;&amp; target &gt; nums[mid]) &#123;</span><br><span class="line">                    low = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    high = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-Median-of-Two-Sorted-Arrays-寻找两个有序数组的中位数-Hard"><a href="#4-Median-of-Two-Sorted-Arrays-寻找两个有序数组的中位数-Hard" class="headerlink" title="4.Median of Two Sorted Arrays(寻找两个有序数组的中位数)(Hard)"></a><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays" target="_blank" rel="noopener">4.Median of Two Sorted Arrays(寻找两个有序数组的中位数)(Hard)</a></h2><p>There are two sorted arrays <strong>nums1</strong> and <strong>nums2</strong> of size m and n respectively.</p>
<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
<p>You may assume <strong>nums1</strong> and <strong>nums2</strong> cannot be both empty.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">nums1 = [<span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">nums2 = [<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">The median <span class="keyword">is</span> <span class="number">2.0</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">nums1 = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">nums2 = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">The median <span class="keyword">is</span> (<span class="number">2</span> + <span class="number">3</span>)/<span class="number">2</span> = <span class="number">2.5</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：</p>
<p>油管上有关这道题的非常好的讲解：<a href="https://www.youtube.com/watch?v=CMjAo8_8JYM" target="_blank" rel="noopener">“Median of two sorted Arrays”: A Google Software Engineering Interview Question PART 1</a></p>
<p>解法一：暴力法</p>
<ul>
<li>利用归并排序的思想将它们合并成一个长度为m+n的有序数组</li>
<li>合并的时间复杂度为 m+n，从中选取中位数</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] mergedArray = mergeTwoSortedArray(nums1,nums2);</span><br><span class="line">        <span class="keyword">int</span> n = mergedArray.length;</span><br><span class="line">        <span class="comment">// 先排好序，再返回中位数</span></span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//若排好序的数组为偶数个，则取中间两个的平均数</span></span><br><span class="line">            <span class="keyword">return</span> (mergedArray[(n-<span class="number">1</span>) / <span class="number">2</span>] + mergedArray[n/<span class="number">2</span>]) / <span class="number">2.0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//总元素个数为奇数个，则选取中间那个</span></span><br><span class="line">            <span class="keyword">return</span> mergedArray[n/<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] mergeTwoSortedArray(<span class="keyword">int</span>[] nums1,<span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] merged = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length + nums2.length];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//两个array同时扫描</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums1.length &amp;&amp; j &lt; nums2.length) &#123;</span><br><span class="line">            merged[k++] = nums1[i] &lt; nums2[j] ? nums1[i++] : nums2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums1.length) &#123;</span><br><span class="line">            merged[k++] = nums1[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; nums2.length) &#123;</span><br><span class="line">            merged[k++] = nums2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> merged;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>整体时间复杂度为O(m+n)，要大于题目要求的O(log(m+n))，不符合要求</li>
<li>空间复杂度：O(m+n)</li>
</ul>
<p>可以自然地想到要用Binary Search</p>
<p>解法二：切分法，比较偏重数学</p>
<p>这种方法需要考虑m+n为奇数还是偶数。假设m+n=L，</p>
<ul>
<li>如果L为奇数，即两个数组元素总个数为奇数，则中位数为第：int(L/2)+1小的数。</li>
<li>如果L为偶数，则中位数为第 int(L/2) 小于int(L/2)+1小的数求和的平均值。</li>
</ul>
<p>所以我们的问题转变成了，在两个有序数组中寻找第k小的数，f(k)</p>
<ul>
<li>当L为奇数时，若令 k=L/2，则结果为f(k+1)</li>
<li>当L为偶数时，结果为：(f(k) + f(k+1))/2</li>
</ul>
<p>那么接下来的问题是，怎么从两个排好序的数组中找到第k小的数呢？</p>
<p>假设nums1[] = {a0, a1, a2, a3, a4}、nums2[] = {b0, b1, b2, b3}<br>举例，如果从nums1和nums2中分别取出k1和k2个元素：</p>
<p><img src="https://s2.ax1x.com/2020/02/17/3iuZt0.png" alt="3iuZt0.png"></p>
<ol>
<li>a2=b1，这种算是最舒服的情况了,此时a2或者b1就是我们要找的第k小的数。因为此时我们如果把a0, a1, a2, b0, b1按照大小顺序合并在一起，那么a2和b1肯定排在最后，a0, a1 和b0都排在前面，不需要考虑这三个的大小关系。</li>
<li>a2&lt;b1， 这种情况开始不舒服了，我们无法肯定a2和b1是第五小的数。但是这种情况下我们可以确定，第五小的数一定不会是a0, a1, a2中的一个，同时也不会是b2和b3中的一个。所以，整个的搜索范围可以缩小为：{a3, a4, b0, b1}</li>
<li>a2&gt;b1，我们同样无法肯定a2和b1是第五小的数。但是这种情况下我们可以确定，第五小的数不可能是b0, b1和a3, a4。所以这种情况下，整个搜索范围可以缩小为：{a0, a1, a2, b2, b3}</li>
</ol>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据两个字符串长度的总和判断如何调用递归函数以及返回结果</span></span><br><span class="line">        <span class="keyword">int</span> m = nums1.length, n = nums2.length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> k = (m + n) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>((m+n) % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 当总长度为奇数时，返回正中间的数</span></span><br><span class="line">            <span class="keyword">return</span> findKth(nums1, <span class="number">0</span>, m-<span class="number">1</span>, nums2, <span class="number">0</span>, n-<span class="number">1</span>, k+<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当总长度为偶数时，返回两个数的平均值</span></span><br><span class="line">            <span class="keyword">return</span> (findKth(nums1, <span class="number">0</span>, m-<span class="number">1</span>, nums2, <span class="number">0</span>, n-<span class="number">1</span>, k) + </span><br><span class="line">                    findKth(nums1, <span class="number">0</span>, m-<span class="number">1</span>, nums2, <span class="number">0</span>, n-<span class="number">1</span>, k+<span class="number">1</span>)) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进入findKth,这个函数目的是寻找第k小的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findKth</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> start1, <span class="keyword">int</span> end1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> start2, <span class="keyword">int</span> end2, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = end1 - start1 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n = end2 - start2 + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果nums1数组的长度大于nums2数组的长度，将二者互换，加快程序结束的速度</span></span><br><span class="line">        <span class="keyword">if</span>(m &gt; n) &#123;</span><br><span class="line">            <span class="keyword">return</span> findKth(nums2, start2, end2, nums1, start1, end1, k);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当nums1数组长度为0的时候，直接返回nums2数组中第k小的数</span></span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums2[start2 + k - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当k == 1时，返回两个数组中的最小值</span></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.min(nums1[start1], nums2[start2]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 分别选两个数组的中间数</span></span><br><span class="line">        <span class="keyword">int</span> na = Math.min(k/<span class="number">2</span>, m);</span><br><span class="line">        <span class="keyword">int</span> nb = k - na;</span><br><span class="line">        <span class="keyword">int</span> va = nums1[start1 + na -<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> vb = nums2[start2 + nb -<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 比较下两者的大小</span></span><br><span class="line">        <span class="comment">// 如果相等，表明中位数已经找到，返回该值即可</span></span><br><span class="line">        <span class="keyword">if</span>(va == vb) &#123;</span><br><span class="line">            <span class="keyword">return</span> va;</span><br><span class="line">            <span class="comment">// 如果不相等，进行剪枝处理</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(va &lt; vb) &#123;</span><br><span class="line">            <span class="keyword">return</span> findKth(nums1, start1 + na, end1, nums2,start2,  start2 + nb - <span class="number">1</span>, k - na);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> findKth(nums1, start1, start1 + na - <span class="number">1</span>, nums2, start2 + nb, end2, k - nb);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解法三：二分查找</p>
<p>首先，我们需要利用两个数组已经是有序的这么一个性质，从A和B这两个数组中找到分割点，那么剩下的数字个数就是符合二分查找的数字数量。</p>
<p>我们需要把握住一个特质：分割完之后，我们需要让A和B两个数组符合这个要求：A的分割点左边数组的最大值要小于B的分割点右边的最小值，而且B的分割点左边数组的最大值要小于A的分割点右边的最小值(<font color=#FF0000>这个条件很至关重要，满足了这个条件，就算找到了目标分割线。</font>)。样例如下图：</p>
<p><img src="https://i.loli.net/2020/04/24/2KalmBA3N8TLZbg.png" alt="04题二分查找的示意图.png"></p>
<p>因为题目提到了要求时间复杂度小于O(log(m+n))一下，所以自然想到二分查找。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lenA = A.length, lenB = B.length;</span><br><span class="line">        <span class="comment">//如果A不是较短的，则交换位置。因为下面的操作默认A是较短的数组</span></span><br><span class="line">        <span class="comment">//为什么选较短的？——选短的，二分查找也能更快。</span></span><br><span class="line">        <span class="keyword">if</span>(lenA &gt; lenB) &#123;</span><br><span class="line">            <span class="keyword">return</span> findMedianSortedArrays(B,A);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//特殊情况，如果A和B中短的数组是空的，那么直接返回另一个数组的中位数即可</span></span><br><span class="line">        <span class="keyword">if</span>(lenA == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((<span class="keyword">double</span>) B[(lenB - <span class="number">1</span>) / <span class="number">2</span>] + (<span class="keyword">double</span>) B[lenB / <span class="number">2</span>]) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//新数组总长度为len</span></span><br><span class="line">        <span class="keyword">int</span> len = lenA + lenB;</span><br><span class="line">        <span class="comment">//上面已经提到，整个过程只对数组A进行binary search，所以只定义A的Start和End来维护</span></span><br><span class="line">        <span class="comment">//每次binary search的范围</span></span><br><span class="line">        <span class="keyword">int</span> AStartK = <span class="number">0</span>, AEndK = lenA;</span><br><span class="line">        <span class="comment">// cutA记录数组分割的左边元素个数、cutB记录分割的左边元素个数</span></span><br><span class="line">        <span class="keyword">int</span> cutA, cutB;</span><br><span class="line">        <span class="keyword">while</span>(AStartK &lt;= AEndK) &#123;</span><br><span class="line">            cutA = (AStartK + AEndK) / <span class="number">2</span>;</span><br><span class="line">            cutB = len / <span class="number">2</span> - cutA;</span><br><span class="line">            <span class="comment">//L1=Integer.MIN_VALUE和L2=Integer.MIN_VALUE这两种情况肯定是不同时出现的，这样在后面Math.max(L1, L2)那里就可以让另外一个不等于Integer.MIN_VALUE的稳定当选</span></span><br><span class="line">            <span class="keyword">double</span> L1 = (cutA == <span class="number">0</span>) ? Integer.MIN_VALUE : A[cutA - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">double</span> L2 = (cutB == <span class="number">0</span>) ? Integer.MIN_VALUE : B[cutB - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">//R1和R2同理</span></span><br><span class="line">            <span class="keyword">double</span> R1 = (cutA == lenA) ? Integer.MAX_VALUE : A[cutA];</span><br><span class="line">            <span class="keyword">double</span> R2 = (cutB == lenB) ? Integer.MAX_VALUE : B[cutB];</span><br><span class="line">            <span class="keyword">if</span>(L1 &gt; R2) &#123;</span><br><span class="line">                AEndK = cutA - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(L2 &gt; R1) &#123;</span><br><span class="line">                AStartK = cutA + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(len % <span class="number">2</span> == <span class="number">0</span>) &#123; <span class="comment">//如果合并之后数组元素个数为偶数</span></span><br><span class="line">                    <span class="comment">//则要取L1和L2的最大值与R1、R2的最小值的平均数</span></span><br><span class="line">                    <span class="keyword">return</span> (Math.max(L1, L2) + Math.min(R1,R2)) / <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果合并后元素个数为奇数，则直接在L1和L2中更小的即可</span></span><br><span class="line">                    <span class="keyword">return</span> Math.min(R1,R2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(logm)，m为较短的数组的长度</li>
<li>空间复杂度：O(1)</li>
</ul>
]]></content>
      <categories>
        <category>Algorithms Note</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Tree+Recursion</title>
    <url>/2020/01/13/LeetCode-Practice-by-Categories-Tree/</url>
    <content><![CDATA[<blockquote>
<p>世界上最快乐的事，莫过于为理想而奋斗——苏格拉底</p>
</blockquote>
<p>LeetCode树、递归相关题目，其解决思路和具体代码。</p>
<a id="more"></a>

<p>首先可以使用递归来解决的问题，一般具有如下特点： 1. 该问题可以被分解成若干个重复的子问题； 2. 该问题与它分解出的子问题可以使用相同的算法来解决； 3. 有明确的终止条件。</p>
<p>树这种数据结构的特点和上述三个特点高度一致，一棵树的每个非叶子节点的子节点也都是一棵树，都是树自然可以使用相同的算法来处理，因为没有环所以天然具有终止条件。 另外一方面，树本身是一种非线性的数据结构，循环遍历不易。当然循环遍历也是可以做，树是一种特殊的图，我们完全可以使用图的广度优先遍历算法一层一层的循环遍历整棵树。 综上，我们一般还是选择递归的方式来解决树的问题。</p>
<p>因为树的操作的特性，很多题目可以用递归相关轻易解决，比如树的前中后序遍历。但是非递归的方式同样重要。</p>
<p>除了树，还有分治，回溯和递归相关题目。分治和回溯本质就是递归，递归和回溯是特殊的递归。</p>
<p>有关树的时间复杂度和空间复杂度分析，可以参考下面这张图：</p>
<p><img src="https://s2.ax1x.com/2020/01/19/1CsVMT.png" alt="1CsVMT.png"></p>
<p>可以发现，因为二叉树每层最多两个元素，按照层级扩散，所以与树相关的结构平均下来的时间复杂度大多是 <code>O(logN)</code> 级别的。</p>
<p>针对递归，一般人们的认识是递归的时间复杂度非常高。但是具体说来，递归算法的时间复杂度如何计算呢？——<strong>子问题个数乘以解决一个子问题需要的时间。</strong></p>
<h2 id="94-Binary-Tree-Inorder-Traversal-二叉树中序遍历-Mid"><a href="#94-Binary-Tree-Inorder-Traversal-二叉树中序遍历-Mid" class="headerlink" title="94. Binary Tree Inorder Traversal(二叉树中序遍历)(Mid)"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. Binary Tree Inorder Traversal(二叉树中序遍历)(Mid)</a></h2><p>Given a binary tree, return the inorder traversal of its nodes’ values.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="literal">null</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">   <span class="number">1</span></span><br><span class="line">    \</span><br><span class="line">     <span class="number">2</span></span><br><span class="line">    /</span><br><span class="line">   <span class="number">3</span></span><br><span class="line"></span><br><span class="line">Output: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>


<p><strong>Follow up:</strong> Recursive solution is trivial(简单), could you do it iteratively?</p>
<hr>
<p>解：方法一，递归，时间复杂度较高。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        travelHelper(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">travelHelper</span><span class="params">(TreeNode root, List&lt;Integer&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        travelHelper(root.left, result);</span><br><span class="line">        result.add(root.val);</span><br><span class="line">        travelHelper(root.right, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，非递归，用一个栈解决。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode root0 = root;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(root0 != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span>(root0 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(root0);</span><br><span class="line">                root0 = root0.left;</span><br><span class="line">            &#125;</span><br><span class="line">                <span class="comment">// 此时符合 !stack.isEmpty() 条件</span></span><br><span class="line">                <span class="comment">// root指针移动到回当前节点的父亲节点</span></span><br><span class="line">                root0 = stack.pop();</span><br><span class="line">                <span class="comment">// 中序遍历，此时直接访问节点结果即可</span></span><br><span class="line">                result.add(root0.val);</span><br><span class="line">                <span class="comment">// 已经完成了某个节点的根、左孩子遍历，最后访问右孩子</span></span><br><span class="line">                root0 = root0.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注：</strong>额外定义了一个root0，避免操作之后整棵树找不到了的情况。面试过程中只是为了完成遍历，不定义root0问题也不大。</p>
<h2 id="144-Binary-Tree-Preorder-Traversal-二叉树的前序遍历-Mid"><a href="#144-Binary-Tree-Preorder-Traversal-二叉树的前序遍历-Mid" class="headerlink" title="144. Binary Tree Preorder Traversal (二叉树的前序遍历)(Mid)"></a><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">144. Binary Tree Preorder Traversal (二叉树的前序遍历)(Mid)</a></h2><p>Given a binary tree, return the preorder traversal of its nodes’ values.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="literal">null</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">   <span class="number">1</span></span><br><span class="line">    \</span><br><span class="line">     <span class="number">2</span></span><br><span class="line">    /</span><br><span class="line">   <span class="number">3</span></span><br><span class="line"></span><br><span class="line">Output: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p>
<hr>
<p>解：方法一，递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        preHelper(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preHelper</span><span class="params">(TreeNode root, List&lt;Integer&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// terminator</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        result.add(root.val);</span><br><span class="line">        preHelper(root.left, result);</span><br><span class="line">        preHelper(root.right, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，非递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// corner case</span></span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                <span class="comment">// 先序遍历，碰到节点就访问，再访问孩子节点</span></span><br><span class="line">                result.add(root.val);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 此时root左孩子没有节点了</span></span><br><span class="line">            <span class="comment">// 回溯访问当前root的父节点</span></span><br><span class="line">            root = stack.pop();</span><br><span class="line">            <span class="comment">// 最后访问root的右孩子</span></span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注：</strong>额外定义了一个root0，避免操作之后整棵树找不到了的情况。面试过程中只是为了完成遍历，不定义root0问题也不大。</p>
<p>非递归也可以这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode temp = stack.pop();</span><br><span class="line">            <span class="comment">// // 先序遍历，碰到节点就访问，再访问孩子节点</span></span><br><span class="line">            result.add(temp.val);</span><br><span class="line">            <span class="comment">// 因为用的是栈，所以后访问的right节点先入栈，后访问的左孩子后入栈</span></span><br><span class="line">            <span class="keyword">if</span>(temp.right != <span class="keyword">null</span>) stack.push(temp.right);</span><br><span class="line">            <span class="keyword">if</span>(temp.left != <span class="keyword">null</span>) stack.push(temp.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="145-Binary-Tree-Postorder-Traversal-二叉树的后序遍历-Hard"><a href="#145-Binary-Tree-Postorder-Traversal-二叉树的后序遍历-Hard" class="headerlink" title="145. Binary Tree Postorder Traversal (二叉树的后序遍历)(Hard)"></a><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">145. Binary Tree Postorder Traversal (二叉树的后序遍历)(Hard)</a></h2><p>Given a binary tree, return the postorder traversal of its nodes’ values.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="literal">null</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">   <span class="number">1</span></span><br><span class="line">    \</span><br><span class="line">     <span class="number">2</span></span><br><span class="line">    /</span><br><span class="line">   <span class="number">3</span></span><br><span class="line"></span><br><span class="line">Output: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p>
<hr>
<p>解：方法一，递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        postHelper(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHelper</span><span class="params">(TreeNode root, List&lt;Integer&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        postHelper(root.left, result);</span><br><span class="line">        postHelper(root.right, result);</span><br><span class="line">        result.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，利用通过LinkedList构造的List&lt;&gt;可以用addFirst()方法。因为后序遍历访问节点的顺序刚好和前序相反，所以在同样地方访问节点然后加入到结果集合的头部即可。此外这个方法因为完全模拟前序的相反的结果</p>
<p>需要注意：如果要用LinkedList的addFirst()方法，在定义result的时候左边就要是LinkedList这个实现类型，而不是用List接口，用接口的话不能自动实现addFirst()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode temp = stack.pop();</span><br><span class="line">            result.addFirst(temp.val);</span><br><span class="line">            <span class="keyword">if</span>(temp.left != <span class="keyword">null</span>) stack.push(temp.left);</span><br><span class="line">            <span class="keyword">if</span>(temp.right != <span class="keyword">null</span>) stack.push(temp.right);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这个看起来很巧妙(确实也很巧妙，利用后序遍历和前序遍历相反的规律)的方法有Bug，即如果树存在比较复杂的拓扑依赖，这种方法会报出错(但是面试用这个方法应该问题不大)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(root);</span><br><span class="line">        TreeNode cur=root;</span><br><span class="line">        TreeNode pre=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            cur=stack.peek();</span><br><span class="line">            <span class="keyword">if</span>(cur.left==<span class="keyword">null</span>&amp;&amp;cur.right==<span class="keyword">null</span>||(pre!=<span class="keyword">null</span>&amp;&amp;(pre==cur.left||pre==cur.right)))&#123;</span><br><span class="line">                result.add(cur.val); <span class="comment">//deal with topological dependency</span></span><br><span class="line">                stack.pop();</span><br><span class="line">                pre=cur;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    stack.push(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    stack.push(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="102-Binary-tree-level-order-traversal-二叉树的层序遍历-Mid"><a href="#102-Binary-tree-level-order-traversal-二叉树的层序遍历-Mid" class="headerlink" title="102. Binary tree level order traversal(二叉树的层序遍历)(Mid)"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">102. Binary tree level order traversal(二叉树的层序遍历)(Mid)</a></h2><p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).</p>
<p>For example:<br><code>Given binary tree [3,9,20,null,null,15,7],</code></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>return its level order traversal as:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">20</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<hr>
<p>解：这道题，在整个硅谷的面试题中，出现次数也是能够排在前三的位置，非常重要。</p>
<p>方法一，递归，DFS。层序遍历用深搜其实有一点”反人类”，但是有助于理解和面试时候的表现。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Definition for </span>a<span class="markdown"> binary tree node.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>public class TreeNode &#123;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>int val;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>TreeNode left;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>TreeNode right;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>TreeNode(int x) &#123; val = x; &#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>&#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> */</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    public <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        levelHelper(result, root ,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public <span class="keyword">void</span> levelHelper(<span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;Integer&gt;&gt; result, TreeNode root, <span class="built_in">int</span> height) &#123;</span><br><span class="line">        <span class="comment">// terminator</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// process current logic</span></span><br><span class="line">        <span class="keyword">if</span>(height &gt;= result.size()) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> LinkedList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="keyword">get</span>(height).add(root.val);</span><br><span class="line">        levelHelper(result, root.left, height + <span class="number">1</span>);</span><br><span class="line">        levelHelper(result, root.right, height + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，使用队列，使用BFS遍历的模板。</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">class Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; result = <span class="literal">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">Queue</span>&lt;TreeNode&gt; <span class="built_in">queue</span> = <span class="literal">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="built_in">queue</span>.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">queue</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 循环里面要定义三个变量</span></span><br><span class="line">            </span><br><span class="line">			<span class="comment">// 每次循环队列长度都会变化，需要每次都更新</span></span><br><span class="line">            int levelLength = <span class="built_in">queue</span>.size();</span><br><span class="line">            <span class="comment">// 需要临时保存当前层的所有元素</span></span><br><span class="line">            <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; currLevel = <span class="literal">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            for(int i = <span class="number">0</span>; i &lt; levelLength; i++) &#123;</span><br><span class="line">                TreeNode currNode = <span class="built_in">queue</span>.poll();</span><br><span class="line">                currLevel.add(currNode.val);</span><br><span class="line">                <span class="keyword">if</span>(currNode.left != <span class="built_in">null</span>) <span class="built_in">queue</span>.add(currNode.left);</span><br><span class="line">                <span class="keyword">if</span>(currNode.right != <span class="built_in">null</span>) <span class="built_in">queue</span>.add(currNode.right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(currLevel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="103-Binary-Tree-Zigzag-Level-Order-Traversal-二叉树的锯齿形层序遍历-Mid"><a href="#103-Binary-Tree-Zigzag-Level-Order-Traversal-二叉树的锯齿形层序遍历-Mid" class="headerlink" title="103. Binary Tree Zigzag Level Order Traversal(二叉树的锯齿形层序遍历)(Mid)"></a><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">103. Binary Tree Zigzag Level Order Traversal(二叉树的锯齿形层序遍历)(Mid)</a></h2><p>Given a binary tree, return the <em>zigzag level order</em> traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p>
<p>For example:<br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>return its zigzag level order traversal as:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">20</span>,<span class="number">9</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<hr>
<p>解：上一道102已经解决了层次遍历的问题，可以基于上一题使用队列实现BFS的思想。但是这里需要判断锯齿(或者称为之字型)，用变量zigzag记录当前从右向左添加还是从左向右添加元素。zigzag为false，表示从左到右。zigzag为true，表示从右到左。初始的时候为从左到右，即zigzag初始值为false。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">boolean</span> zigzag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; currLevel = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> currLength = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; currLength; i++) &#123;</span><br><span class="line">                TreeNode currNode = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(zigzag) &#123;</span><br><span class="line">                    currLevel.add(<span class="number">0</span>, currNode.val);</span><br><span class="line">                &#125; <span class="keyword">else</span> currLevel.add(currNode.val);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(currNode.left != <span class="keyword">null</span>) queue.add(currNode.left);</span><br><span class="line">                <span class="keyword">if</span>(currNode.right != <span class="keyword">null</span>) queue.add(currNode.right);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            result.add(currLevel);</span><br><span class="line">            zigzag = !zigzag;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>linkedList的add方法，两参数的重构方法中第一个参数为index：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">	<span class="built_in">add</span>(int index, E <span class="keyword">element</span>)</span><br><span class="line">Inserts <span class="keyword">the</span> specified <span class="keyword">element</span> <span class="keyword">at</span> <span class="keyword">the</span> specified position <span class="keyword">in</span> this list.</span><br></pre></td></tr></table></figure>

<h2 id="515-Find-Largest-Value-in-Each-Tree-Row-在每个树中找最大值-Mid"><a href="#515-Find-Largest-Value-in-Each-Tree-Row-在每个树中找最大值-Mid" class="headerlink" title="515. Find Largest Value in Each Tree Row(在每个树中找最大值)(Mid)"></a><a href="https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/#/description" target="_blank" rel="noopener">515. Find Largest Value in Each Tree Row(在每个树中找最大值)(Mid)</a></h2><p>You need to find the largest value in each row of a binary tree.</p>
<p><strong>Example :</strong></p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Input</span>: </span><br><span class="line"></span><br><span class="line">          1</span><br><span class="line">         / \</span><br><span class="line">        3   2</span><br><span class="line">       / \   \  </span><br><span class="line">      5   3   9 </span><br><span class="line"></span><br><span class="line"><span class="attribute">Output</span>: [1, 3, 9]</span><br></pre></td></tr></table></figure>

<hr>
<p>解：因为需要按照层次记录最大值，所以和层次遍历题目有类似之处。</p>
<p>方法一：DFS。深搜大多利用递归，写一个递归函数，直接利用计算机帮你维护的栈即可。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; largest<span class="constructor">Values(TreeNode <span class="params">root</span>)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">if</span>(root<span class="operator"> == </span>null) return result;</span><br><span class="line">        largest<span class="constructor">Helper(<span class="params">result</span>, <span class="params">root</span>, 0)</span>;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void largest<span class="constructor">Helper(List&lt;Integer&gt; <span class="params">result</span>, TreeNode <span class="params">root</span>, <span class="params">int</span> <span class="params">height</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root<span class="operator"> == </span>null) return ;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// expand list size</span></span><br><span class="line">        <span class="keyword">if</span>(height<span class="operator"> == </span>result.size<span class="literal">()</span>) &#123;</span><br><span class="line">            result.add(root.<span class="keyword">val</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.set(height, <span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>max(result.get(height), root.<span class="keyword">val</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        largest<span class="constructor">Helper(<span class="params">result</span>, <span class="params">root</span>.<span class="params">left</span>, <span class="params">height</span> + 1)</span>;</span><br><span class="line">        largest<span class="constructor">Helper(<span class="params">result</span>, <span class="params">root</span>.<span class="params">right</span>, <span class="params">height</span> + 1)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：BFS。和树部分102题层次遍历大体结构相同。</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">class Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; largestValues(TreeNode root) &#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; result = <span class="literal">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">Queue</span>&lt;TreeNode&gt; <span class="built_in">queue</span> = <span class="literal">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>.offer(root);</span><br><span class="line">        int <span class="keyword">max</span> = <span class="built_in">Integer</span>.MIN_VALUE;</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">queue</span>.isEmpty()) &#123;</span><br><span class="line">            int levelSize = <span class="built_in">queue</span>.size();</span><br><span class="line">            for(int i = <span class="number">0</span>; i &lt; levelSize; i++) &#123;</span><br><span class="line">                TreeNode currNode = <span class="built_in">queue</span>.poll();</span><br><span class="line">                <span class="keyword">max</span> = Math.<span class="keyword">max</span>(<span class="keyword">max</span>, currNode.val);</span><br><span class="line">                <span class="keyword">if</span>(currNode.left != <span class="built_in">null</span>) <span class="built_in">queue</span>.add(currNode.left);</span><br><span class="line">                <span class="keyword">if</span>(currNode.right != <span class="built_in">null</span>) <span class="built_in">queue</span>.add(currNode.right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(<span class="keyword">max</span>);</span><br><span class="line">            <span class="keyword">max</span> = <span class="built_in">Integer</span>.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="590-N-ary-Tree-Postorder-Traversal-N叉树的后序遍历-Easy"><a href="#590-N-ary-Tree-Postorder-Traversal-N叉树的后序遍历-Easy" class="headerlink" title="590. N-ary Tree Postorder Traversal (N叉树的后序遍历)(Easy)"></a><a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/" target="_blank" rel="noopener">590. N-ary Tree Postorder Traversal (N叉树的后序遍历)(Easy)</a></h2><p>Given an n-ary tree, return the postorder traversal of its nodes’ values.</p>
<p><em>Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).</em></p>
<p><strong>Follow up:</strong></p>
<p>Recursive solution is trivial, could you do it iteratively?</p>
<p><strong>Example 1:</strong><br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/narytreeexample.png" alt=""></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: root = [<span class="number">1</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">Output: [<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong><br><img src="https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png" alt=""></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: root = [<span class="number">1</span>,<span class="literal">null</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="literal">null</span>,<span class="number">8</span>,<span class="literal">null</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">11</span>,<span class="literal">null</span>,<span class="number">12</span>,<span class="literal">null</span>,<span class="number">13</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">14</span>]</span><br><span class="line">Output: [<span class="number">2</span>,<span class="number">6</span>,<span class="number">14</span>,<span class="number">11</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">12</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">13</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li>The height of the n-ary tree is less than or equal to 1000</li>
<li>The total number of nodes is between [0, 10^4]</li>
</ul>
<hr>
<p>解：利用LinkedList的addFirst()遍历树。。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">// Definition for a <span class="keyword">Node</span>.<span class="title"></span></span><br><span class="line"><span class="title">class</span> <span class="keyword">Node</span> <span class="title">&#123;</span></span><br><span class="line"><span class="title">    public</span> int val;</span><br><span class="line">    public List<span class="tag">&lt;Node&gt;</span> children;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">Node</span><span class="title">() &#123;&#125;</span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">    public</span> <span class="keyword">Node</span><span class="title">(int</span> _val) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">Node</span><span class="title">(int</span> _val, List<span class="tag">&lt;Node&gt;</span> _children) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        children = _children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List<span class="tag">&lt;Integer&gt;</span> postorder(<span class="keyword">Node</span> <span class="title">root</span>) &#123;</span><br><span class="line">        LinkedList<span class="tag">&lt;Integer&gt;</span> result = new LinkedList<span class="tag">&lt;&gt;</span>();</span><br><span class="line">        if(root == null) return result;</span><br><span class="line">        Stack<span class="tag">&lt;Node&gt;</span> stack = new Stack<span class="tag">&lt;&gt;</span>();</span><br><span class="line">        stack.add(root);</span><br><span class="line">        </span><br><span class="line">        while(!stack.empty()) &#123;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            result.addFirst(root.val);</span><br><span class="line">            for(<span class="keyword">Node</span> <span class="title">node</span> : root.children) &#123;</span><br><span class="line">                stack.add(<span class="keyword">node</span><span class="title">);</span></span><br><span class="line"><span class="title">            &#125;</span></span><br><span class="line"><span class="title">        &#125;</span></span><br><span class="line"><span class="title">        return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="589-N-ary-Tree-Preorder-Traversal-N叉树的前序遍历-Easy"><a href="#589-N-ary-Tree-Preorder-Traversal-N叉树的前序遍历-Easy" class="headerlink" title="589. N-ary Tree Preorder Traversal (N叉树的前序遍历)(Easy)"></a><a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/" target="_blank" rel="noopener">589. N-ary Tree Preorder Traversal (N叉树的前序遍历)(Easy)</a></h2><p>Given an n-ary tree, return the preorder traversal of its nodes’ values.</p>
<p><em>Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).</em></p>
<p><strong>Follow up:</strong><br>Recursive solution is trivial, could you do it iteratively?</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/narytreeexample.png" alt=""></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: root = [<span class="number">1</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">Output: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong><br><img src="https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png" alt=""></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: root = [<span class="number">1</span>,<span class="literal">null</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="literal">null</span>,<span class="number">8</span>,<span class="literal">null</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">11</span>,<span class="literal">null</span>,<span class="number">12</span>,<span class="literal">null</span>,<span class="number">13</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">14</span>]</span><br><span class="line">Output: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">14</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">13</span>,<span class="number">10</span>]</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li>The height of the n-ary tree is less than or equal to 1000</li>
<li>The total number of nodes is between [0, 10^4]</li>
</ul>
<hr>
<p>解：使用DFS非递归模板。把子树从后往前添加到栈里面，弹出的时候刚好相反，从前往后的顺序弹出。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">// Definition for a <span class="keyword">Node</span>.<span class="title"></span></span><br><span class="line"><span class="title">class</span> <span class="keyword">Node</span> <span class="title">&#123;</span></span><br><span class="line"><span class="title">    public</span> int val;</span><br><span class="line">    public List<span class="tag">&lt;Node&gt;</span> children;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">Node</span><span class="title">() &#123;&#125;</span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">    public</span> <span class="keyword">Node</span><span class="title">(int</span> _val) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">Node</span><span class="title">(int</span> _val, List<span class="tag">&lt;Node&gt;</span> _children) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        children = _children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List<span class="tag">&lt;Integer&gt;</span> preorder(<span class="keyword">Node</span> <span class="title">root</span>) &#123;</span><br><span class="line">        List<span class="tag">&lt;Integer&gt;</span> result = new LinkedList<span class="tag">&lt;&gt;</span>();</span><br><span class="line">        if(root == null) return result;</span><br><span class="line">        </span><br><span class="line">        Stack<span class="tag">&lt;Node&gt;</span> stack = new Stack<span class="tag">&lt;&gt;</span>();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        </span><br><span class="line">        while(!stack.empty()) &#123;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            result.add(root.val);</span><br><span class="line">            for(int i = root.children.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                stack.add(root.children.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="429-N-ary-Tree-Level-Order-Traversal-N叉树的层序遍历-Mid"><a href="#429-N-ary-Tree-Level-Order-Traversal-N叉树的层序遍历-Mid" class="headerlink" title="429. N-ary Tree Level Order Traversal(N叉树的层序遍历)(Mid)"></a><a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/" target="_blank" rel="noopener">429. N-ary Tree Level Order Traversal(N叉树的层序遍历)(Mid)</a></h2><p>Given an n-ary tree, return the level order traversal of its nodes’ values.</p>
<p><em>Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).</em></p>
<p><strong>Example 1:</strong><br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/narytreeexample.png" alt=""></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: root = [<span class="number">1</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">Output: [[<span class="number">1</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>]]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong><br><img src="https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png" alt=""></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: root = [<span class="number">1</span>,<span class="literal">null</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="literal">null</span>,<span class="number">8</span>,<span class="literal">null</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">11</span>,<span class="literal">null</span>,<span class="number">12</span>,<span class="literal">null</span>,<span class="number">13</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">14</span>]</span><br><span class="line">Output: [[<span class="number">1</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>],[<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>],[<span class="number">14</span>]]</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li>The height of the n-ary tree is less than or equal to 1000</li>
<li>The total number of nodes is between [0, 10^4]</li>
</ul>
<hr>
<p>解：和层序遍历思路相同，只是需要注意N叉树的遍历在内层要多一个循环去遍历所有节点的子节点。</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public List&lt;Node&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, List&lt;Node&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">class Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; levelOrder(Node root) &#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; result = <span class="literal">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">Queue</span>&lt;Node&gt; <span class="built_in">queue</span> = <span class="literal">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="built_in">queue</span>.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">queue</span>.isEmpty()) &#123;</span><br><span class="line">            int currLength = <span class="built_in">queue</span>.size();</span><br><span class="line">            <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; currLevel = <span class="literal">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            for(int i = <span class="number">0</span>; i &lt; currLength; i++) &#123;</span><br><span class="line">                Node currNode = <span class="built_in">queue</span>.poll();</span><br><span class="line">                currLevel.add(currNode.val);</span><br><span class="line">                for(Node node : currNode.children) &#123;</span><br><span class="line">                    <span class="built_in">queue</span>.add(node);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(currLevel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="70-Climbing-stairsl-爬楼梯-Easy"><a href="#70-Climbing-stairsl-爬楼梯-Easy" class="headerlink" title="70. Climbing-stairsl(爬楼梯)(Easy)"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. Climbing-stairsl(爬楼梯)(Easy)</a></h2><p>You are climbing a stair case. It takes n steps to reach to the top.</p>
<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>
<p>Note: Given <em>n</em> will be a positive integer.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">Output:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">Explanation:</span> <span class="string">There</span> <span class="string">are</span> <span class="string">two</span> <span class="string">ways</span> <span class="string">to</span> <span class="string">climb</span> <span class="string">to</span> <span class="string">the</span> <span class="string">top.</span></span><br><span class="line"><span class="number">1</span><span class="string">.</span> <span class="number">1</span> <span class="string">step</span> <span class="string">+</span> <span class="number">1</span> <span class="string">step</span></span><br><span class="line"><span class="number">2</span><span class="string">.</span> <span class="number">2</span> <span class="string">steps</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">Output:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">Explanation:</span> <span class="string">There</span> <span class="string">are</span> <span class="string">three</span> <span class="string">ways</span> <span class="string">to</span> <span class="string">climb</span> <span class="string">to</span> <span class="string">the</span> <span class="string">top.</span></span><br><span class="line"><span class="number">1</span><span class="string">.</span> <span class="number">1</span> <span class="string">step</span> <span class="string">+</span> <span class="number">1</span> <span class="string">step</span> <span class="string">+</span> <span class="number">1</span> <span class="string">step</span></span><br><span class="line"><span class="number">2</span><span class="string">.</span> <span class="number">1</span> <span class="string">step</span> <span class="string">+</span> <span class="number">2</span> <span class="string">steps</span></span><br><span class="line"><span class="number">3</span><span class="string">.</span> <span class="number">2</span> <span class="string">steps</span> <span class="string">+</span> <span class="number">1</span> <span class="string">step</span></span><br></pre></td></tr></table></figure>
<hr>
<p>解：爬楼梯很经典，变型也很多。首先结论是，单纯的这道题，通过数学归纳的思路(或者说递归的思路)，不难发现其实结果就是前两个元素为1,2的斐波那契数列。(斐波那契数列为509题，因为类似这里就不记录了，链接<a href="https://leetcode-cn.com/problems/fibonacci-number/" target="_blank" rel="noopener">点击这里</a>)</p>
<p>方法一：递归，可以画出递归树发现，因为每个层级都会在上一层的数量基础上多出2倍的节点，所以时间复杂度为O(2^n)，指数级别，不可以接受。而且实际测试中在N为44的时候会出现超时。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> climbStairs(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> climbHelper(<span class="number">0</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> climbHelper(<span class="built_in">int</span> curr, <span class="built_in">int</span> target) &#123;</span><br><span class="line">        <span class="comment">// terminator</span></span><br><span class="line">        <span class="comment">// 跨过了目标阶梯，不算入方法</span></span><br><span class="line">        <span class="keyword">if</span>(curr &gt; target) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 刚好攀登到某个位置</span></span><br><span class="line">        <span class="keyword">if</span>(curr == target) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> climbHelper(curr + <span class="number">1</span>, target) + climbHelper(curr + <span class="number">2</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>方法二：基于递归，加上备忘录，进行有记忆的递归，可以把之前计算过的结果保存下来，有很好的剪枝效果。因为有记录所有的过程，所以子问题的数量就是f(1),f(2)…，为O(n),而且每个子问题解决的时间为O(n)</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> climbStairs(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="comment">// 基于暴力递归，进行有记忆的递归，把每一步的结果存储在mem数组之中，每当有函数被再次调用，就直接从memo数组返回结果，减少计算次数</span></span><br><span class="line">        <span class="built_in">int</span>[] memo = new <span class="built_in">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> climbHelper(<span class="number">0</span>,n,memo);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> climbHelper(<span class="built_in">int</span> curr, <span class="built_in">int</span> target, <span class="built_in">int</span>[] memo) &#123;</span><br><span class="line">        <span class="comment">// terminator</span></span><br><span class="line">        <span class="comment">// 跨过了目标阶梯，不算入方法</span></span><br><span class="line">        <span class="keyword">if</span>(curr &gt; target) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 刚好攀登到某个位置</span></span><br><span class="line">        <span class="keyword">if</span>(curr == target) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果当前N阶梯数量已经计算过，直接从memo返回</span></span><br><span class="line">        <span class="keyword">if</span>(memo[curr] &gt; <span class="number">0</span>) <span class="keyword">return</span> memo[curr];</span><br><span class="line">        </span><br><span class="line">        memo[curr] =  climbHelper(curr + <span class="number">1</span>, target, memo) + climbHelper(curr + <span class="number">2</span>, target, memo);</span><br><span class="line">        <span class="keyword">return</span> memo[curr];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>方法三：常规动态规划，时间复杂度为O(n)，空间复杂度也为O(n)</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> climbStairs(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// dp[i]表示爬到第i阶共有的爬法</span></span><br><span class="line">        <span class="built_in">int</span>[] dp = new <span class="built_in">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>; dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法四：基于常规动态规划的优化。在空间复杂度上可以提升到O(1)。实际上在一开始的时间复杂度的基础上都可以进行空间的优化，比如O(n)可以优化到O(1),O(m*n)可以优化到O(n)。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> climbStairs(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> f1 = <span class="number">1</span>, f2 = <span class="number">2</span>, f3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            f3 = f1 + f2;</span><br><span class="line">            f1 = f2;</span><br><span class="line">            f2 = f3;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="22-Generate-Parentheses-括号生成-Mid"><a href="#22-Generate-Parentheses-括号生成-Mid" class="headerlink" title="22. Generate Parentheses (括号生成)(Mid)"></a><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">22. Generate Parentheses (括号生成)(Mid)</a></h2><p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p>
<p>For example, given <em>n = 3</em>, a solution set is:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="string">"((()))"</span>,</span><br><span class="line">  <span class="string">"(()())"</span>,</span><br><span class="line">  <span class="string">"(())()"</span>,</span><br><span class="line">  <span class="string">"()(())"</span>,</span><br><span class="line">  <span class="string">"()()()"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<hr>
<p>解：<strong>方法一</strong>，这道题是用递归+剪枝可以轻松解决的典型题目。</p>
<p>可以想象一共有2n个位置来填补括号。然后给上括号的填补条件即可得到符合要求的括号对。</p>
<p>什么条件呢？必须明确，n为几，就一定会有几个左括号和右括号。<strong>其中左括号加入的条件，是不超过n。而添加左括号的条件是没有的，也就是随时可以加。而右括号添加有条件，就是左括号个数要大于右括号个数才能添加。</strong></p>
<p>也就是说，左括号的条件时：left &lt; n; 右括号的条件是：left &gt; right &amp;&amp; right &lt; n。当然，因为Left&lt;n了，right&lt;left,所以右括号的条件中可以不用写right &lt; n了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 经典的剪枝问题</span></span><br><span class="line">    <span class="comment">// 方法一，递归</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        _generate( <span class="number">0</span>, <span class="number">0</span>, n, <span class="string">""</span>,result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">_generate</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> n, String s, List&lt;String&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// terminator</span></span><br><span class="line">        <span class="keyword">if</span> (left == n &amp;&amp; right == n) &#123;</span><br><span class="line">            result.add(s);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// drill down</span></span><br><span class="line">        <span class="comment">//运用剪枝思想，分别针对左括号和右括号的放置条件来剪枝</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 左括号只要数量小于n，随便放</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; n)</span><br><span class="line">            _generate(left+<span class="number">1</span>, right, n, s + <span class="string">"("</span>, result);</span><br><span class="line">        <span class="comment">// 右括号数量要比左括号少，而且少于n。但是因为本身就存在left &lt; n的条件，所以写left &lt; right 即可</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt; right)</span><br><span class="line">            _generate(left, right + <span class="number">1</span>, n, s + <span class="string">")"</span>, result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度上，因为每个子问题处理的时间为O(1)，一共的子问题数量是O(2n)，也就是<strong>O(n)</strong></p>
<p><img src="https://s2.ax1x.com/2020/02/11/1Tttpt.png" alt="1Tttpt.png"></p>
<p><strong>方法二：</strong>动态规划。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义dp为list方便调用</span></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; dp = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        dp.add(Collections.singletonList(<span class="string">""</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// i表示i对括号</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            List&lt;String&gt; curr = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="comment">//j表示在i循环的内部循环，每次可能的括号对数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span>(String first : dp.get(j)) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(String second : dp.get(i-j-<span class="number">1</span>)) &#123;</span><br><span class="line">                        curr.add(<span class="string">"("</span> + first + <span class="string">")"</span> + second);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp.add(curr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.get(dp.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="226-Invert-binary-tree-反转二叉树-Mid"><a href="#226-Invert-binary-tree-反转二叉树-Mid" class="headerlink" title="226. Invert-binary-tree(反转二叉树)(Mid)"></a><a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">226. Invert-binary-tree(反转二叉树)(Mid)</a></h2><p>Invert a binary tree.</p>
<p><strong>Example:</strong></p>
<p>Input:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">     <span class="number">4</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">2</span>     <span class="number">7</span></span><br><span class="line"> / \   / \</span><br><span class="line"><span class="number">1</span>   <span class="number">3</span> <span class="number">6</span>   <span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>Output:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">     <span class="number">4</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">7</span>     <span class="number">2</span></span><br><span class="line"> / \   / \</span><br><span class="line"><span class="number">9</span>   <span class="number">6</span> <span class="number">3</span>   <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>Trivia:<br>This problem was inspired by this original tweet by Max Howell:</p>
<blockquote>
<p>Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so f*** off.</p>
</blockquote>
<hr>
<p>解：方法一，DFS，用递归实现。</p>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * <span class="keyword">public</span> <span class="keyword">class</span> TreeNode &#123;</span><br><span class="line"> *     <span class="built_in">int</span> val;</span><br><span class="line"> *     TreeNode <span class="built_in">left</span>;</span><br><span class="line"> *     TreeNode <span class="built_in">right</span>;</span><br><span class="line"> *     TreeNode(<span class="built_in">int</span> x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) return <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        TreeNode <span class="built_in">left</span> = root.<span class="built_in">left</span>, <span class="built_in">right</span> = root.<span class="built_in">right</span>;</span><br><span class="line">        root.<span class="built_in">left</span> = invertTree(<span class="built_in">right</span>);</span><br><span class="line">        root.<span class="built_in">right</span> = invertTree(<span class="built_in">left</span>);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，非递归，BFS，用队列实现。本质上是针对层次进行翻转，故可以在层次遍历的基础上把每一层的两个子树交换即可。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree <span class="keyword">node</span>.<span class="title"></span></span><br><span class="line"><span class="title"> * public</span> class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">        if(root == null) return null;</span><br><span class="line">        </span><br><span class="line">        Queue<span class="tag">&lt;TreeNode&gt;</span> queue = new LinkedList<span class="tag">&lt;&gt;</span>();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        while(!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode <span class="keyword">node</span> <span class="title">= queue</span>.poll();</span><br><span class="line">            TreeNode tempNode = <span class="keyword">node</span>.<span class="title">left</span>;</span><br><span class="line">            <span class="keyword">node</span>.<span class="title">left</span> = <span class="keyword">node</span>.<span class="title">right</span>;</span><br><span class="line">            <span class="keyword">node</span>.<span class="title">right</span> = tempNode;</span><br><span class="line">            </span><br><span class="line">            if(<span class="keyword">node</span>.<span class="title">left</span> != null) queue.add(<span class="keyword">node</span>.<span class="title">left</span>);</span><br><span class="line">            if(<span class="keyword">node</span>.<span class="title">right</span> != null) queue.add(<span class="keyword">node</span>.<span class="title">right</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="98-Validate-Binary-Search-Tree-验证二叉搜索树-Mid"><a href="#98-Validate-Binary-Search-Tree-验证二叉搜索树-Mid" class="headerlink" title="98. Validate Binary Search Tree(验证二叉搜索树)(Mid)"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree" target="_blank" rel="noopener">98. Validate Binary Search Tree(验证二叉搜索树)(Mid)</a></h2><p>Given a binary tree, determine if it is a valid binary search tree (BST).</p>
<p>Assume a BST is defined as follows:</p>
<ul>
<li>The left subtree of a node contains only nodes with keys less than the node’s key.</li>
<li>The right subtree of a node contains only nodes with keys greater than the node’s key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">    <span class="number">2</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">1</span>   <span class="number">3</span></span><br><span class="line"></span><br><span class="line">Input: [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">Output: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">    <span class="number">5</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">1</span>   <span class="number">4</span></span><br><span class="line">     / \</span><br><span class="line">    <span class="number">3</span>   <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Input</span>: [<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">3</span>,<span class="number">6</span>]</span><br><span class="line">Output: <span class="keyword">false</span></span><br><span class="line">Explanation: The root nod<span class="string">e's value is 5 but its right child'</span>s <span class="keyword">value</span> <span class="keyword">is</span> <span class="number">4.</span></span><br></pre></td></tr></table></figure>
<hr>
<p>解：<strong>验证是否为二叉搜索树</strong>是一道经常考的题目，root0.val为当前遍历的节点，inorderVal为上一个节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span> inorderVal = -Double.MAX_VALUE;</span><br><span class="line">        TreeNode root0 = root;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() || root0 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span>(root0 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(root0);</span><br><span class="line">                root0 = root0.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root0 = stack.pop();</span><br><span class="line">            <span class="comment">// BST中序遍历一定是递增的，不是递增的序列就一定不是BST</span></span><br><span class="line">            <span class="keyword">if</span>(root0.val &lt;= inorderVal) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            inorderVal = root0.val;</span><br><span class="line">            root0 = root0.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>，在LeetCode平台上，输入的root为空，最终返回的也是true。</p>
<ul>
<li>时间复杂度 : O(N)。每个结点访问一次。</li>
<li>空间复杂度 : O(N)。我们跟进了整棵树。</li>
</ul>
<h2 id="验证二叉搜索树-2019快手秋招工程A卷"><a href="#验证二叉搜索树-2019快手秋招工程A卷" class="headerlink" title="验证二叉搜索树(2019快手秋招工程A卷)"></a>验证二叉搜索树(2019快手秋招工程A卷)</h2><p>给定一棵满二叉树，判定该树是否为二叉搜索树，是的话打印True，不是的话打印False</p>
<p>说明：<br>a. 二叉搜索树（Binary Search Tree），它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉搜索树。<br>b. 满二叉树，除最后一层无任何子节点外，每一层上的所有结点都有两个子结点二叉树<br>c. 树内节点数不超过 10000，非空节点值为大于0小于65536的整数，空树或空节点输入为None</p>
<p><strong>输入描述：</strong></p>
<blockquote>
<p>从根节点开始，逐层输入每个节点的值，空树或空节点输入为None</p>
<p>比如：10,5,15,3,7,13,18</p>
</blockquote>
<p><strong>输出描述：</strong></p>
<blockquote>
<p>是二叉搜索树的话打印True，不是的话打印False</p>
</blockquote>
<p><strong>示例1</strong></p>
<p>输入：10,5,15,3,7,13,18</p>
<p>输出：True</p>
<hr>
<p>解：这道题虽然目的和LeetCode98相同，但是不能直接用中序遍历，需要自己构建一颗树，或者直接用二叉树层次结构父节点和子节点的index关系来做。(所有企业笔试都需要自己构建输入输出，这点需要比较注意。但是其实也不难，写几次就知道了。)</p>
<p>这道题问题在于处理输入，如果只是单纯判断某一棵树是不是为二叉搜素树，判断其中序遍历结果是否为递增的即可。但是这里输入不是一棵树，而且输入可能会有空(用None)表示。</p>
<p>但是好消息是，题目已经明确说给定的会是一颗满二叉树或者干脆为None值，方便我们处理。</p>
<p>所以这里需要利用树的父节点和子节点的下标关系来进行比较(和一开始我们讨论的堆建树过程差不多)。重点是父节点下标和子节点下标之间的关系：第i个节点，它的左孩子为 tree[2 * i]、右孩子为tree[2*i+1]</p>
<p>也可以自己建立树，通过输入的结果进行层序遍历，依次赋值</p>
<h2 id="114-Flatten-Binary-Tree-to-Linked-List-二叉树展开为链表-Mid"><a href="#114-Flatten-Binary-Tree-to-Linked-List-二叉树展开为链表-Mid" class="headerlink" title="114. Flatten Binary Tree to Linked List(二叉树展开为链表)(Mid)"></a><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">114. Flatten Binary Tree to Linked List(二叉树展开为链表)(Mid)</a></h2><p>Given a binary tree, flatten it to a linked list in-place.</p>
<p>For example, given the following tree:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">5</span></span><br><span class="line"> / \   \</span><br><span class="line"><span class="number">3</span>   <span class="number">4</span>   <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>The flattened tree should look like:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"> \</span><br><span class="line">  <span class="number">2</span></span><br><span class="line">   \</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">4</span></span><br><span class="line">       \</span><br><span class="line">        <span class="number">5</span></span><br><span class="line">         \</span><br><span class="line">          <span class="number">6</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：本题详细题解<a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--26/" target="_blank" rel="noopener">参考这篇文章</a></p>
<p>首先需要注意，<strong>这棵树是二叉树，不是二叉搜索树</strong>，所以不要想用中序遍历得到递增的遍历结果。</p>
<p>结合题目意思，可以看到，把二叉树展开成链表，实际上就是把二叉树变成原先先序遍历的结果的链表。但是因为要in-place，所以原则上只能在原先二叉树上进行操作。</p>
<p>方法一：不考虑原地(in-place)的操作，先序遍历整棵树，把它们放到一个数组里，然后利用TreeNode依次构建新的树，时间复杂度和空间复杂度都是O(n)。当然，因为不遵从in-place，这种方法可能不行。</p>
<p>方法二：同样用先序遍历，具体流程是：</p>
<ol>
<li>将左子树插入到右子树的地方</li>
<li>将原来的右子树接到左子树的最右边节点</li>
<li>考虑新的右子树的根节点，一直重复上边的过程，直到新的右子树为null</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> void flatten(<span class="type">TreeNode</span> root) &#123;</span><br><span class="line">        <span class="keyword">while</span>(root != null) &#123;</span><br><span class="line">            <span class="comment">// 左子树为null的话直接考虑下一个节点</span></span><br><span class="line">            <span class="keyword">if</span>(root.<span class="keyword">left</span> == null) &#123;</span><br><span class="line">                root = root.<span class="keyword">right</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 找当前节点左子树最右边的节点</span></span><br><span class="line">                <span class="type">TreeNode</span> pre = root.<span class="keyword">left</span>;</span><br><span class="line">                <span class="keyword">while</span>(pre.<span class="keyword">right</span> != null) &#123;</span><br><span class="line">                    pre = pre.<span class="keyword">right</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将原来的右子树接到左子树的最右边节点</span></span><br><span class="line">                pre.<span class="keyword">right</span> = root.<span class="keyword">right</span>;</span><br><span class="line">                <span class="comment">// 将左子树插入到右子树的地方</span></span><br><span class="line">                root.<span class="keyword">right</span> = root.<span class="keyword">left</span>;</span><br><span class="line">                root.<span class="keyword">left</span> = null;</span><br><span class="line">                <span class="comment">// 考虑下一节点</span></span><br><span class="line">                root = root.<span class="keyword">right</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法三：递归</p>
<p>虽然要求In-place，但是意思不是时间复杂度必须O(1)，而是直接在原来节点上改变指向，对空间复杂度没有要求，所以可以用递归解的。</p>
<p>递归解法实际上是通过二叉树的<strong>右指针</strong>，组成一个链表。</p>
<p>按照题意最后链表的顺序是先序遍历的结果，那么我们可以就按照先序遍历，然后每遍历一个节点，就让上一个遍历的节点的右指针更新为当前节点。</p>
<p>但是这样的话有一个很绝望的问题，就是，如果直接这么做，上一个节点的右孩子就会丢失。比如题目给的样例，先序遍历顺序是<code>1,2,3,4,5,6</code>，那么如果遍历到2，把1的右指针指向2，那么1本身的右孩子(也就是5)会丢失，即没有指针指向5了。</p>
<p>解决方法就是后序遍历，然后每次让当前节点右指针指向上一个节点。比如访问5，让5的右指针指向6.遍历4，让4的右指针指向5.这样一来就没有指针丢失的问题了，因为更新当前右指针的时候，当前节点的右孩子已经访问过了。</p>
<p>可以用一个全局变量pre，每次更新当前节点的右指针为pre，左指针为null。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Definition for </span>a<span class="markdown"> binary tree node.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>public class TreeNode &#123;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>int val;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>TreeNode left;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>TreeNode right;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>TreeNode(int x) &#123; val = x; &#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>&#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> */</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    private TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    public <span class="keyword">void</span> flatten(TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// terminator</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="comment">// 先访问右孩子，这样改变右指针的时候右孩子不会丢失</span></span><br><span class="line">        flatten(root.right);</span><br><span class="line">        flatten(root.left);</span><br><span class="line">        root.right = pre; <span class="comment">// 相当于保存root的右孩子</span></span><br><span class="line">        root.left = <span class="keyword">null</span>; <span class="comment">// 左孩子指针要置空，不然会出循环</span></span><br><span class="line">        pre = root; <span class="comment">// 将pre往前移1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码虽然简洁，但是还是比较难想的。一个记忆技巧可以是，首先找到所有结点的最右孩子节点，然后每次都先访问右孩子，让pre指向root.right,然后清空左孩子节点，最后把pre往前移动即可。</p>
<h2 id="104-Maximum-depth-of-binary-tree-二叉树的最大深度-Easy"><a href="#104-Maximum-depth-of-binary-tree-二叉树的最大深度-Easy" class="headerlink" title="104. Maximum-depth-of-binary-tree(二叉树的最大深度)(Easy)"></a><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree" target="_blank" rel="noopener">104. Maximum-depth-of-binary-tree(二叉树的最大深度)(Easy)</a></h2><p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<p><strong>Note:</strong>A leaf is a node with no children.</p>
<p><strong>Example:</strong><br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>return its depth = 3.</p>
<hr>
<p>解：方法一，递归</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Definition for </span>a<span class="markdown"> binary tree node.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>public class TreeNode &#123;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>int val;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>TreeNode left;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>TreeNode right;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>TreeNode(int x) &#123; val = x; &#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>&#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> */</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    public <span class="built_in">int</span> maxDepth(TreeNode root) &#123;</span><br><span class="line">        <span class="comment">//虽然是树的遍历，但是用DFS可以不需要写递归辅助函数</span></span><br><span class="line">        <span class="comment">//不需要记录任何节点的信息，这是这道题可以用简短代码解决的主要原因</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归退出条件，到叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> leftDepthMax = maxDepth(root.left);</span><br><span class="line">        <span class="built_in">int</span> rightDepthMax = maxDepth(root.right);</span><br><span class="line">        <span class="comment">// 计算出来的max是以某个节点为根节点的数的最大深度</span></span><br><span class="line">        <span class="comment">// max = java.lang.Math.max(leftMaxDepth，rightMaxDepth) + 1;</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(leftDepthMax, rightDepthMax) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写得漂亮一些，可以用一行解决：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public <span class="built_in">int</span> max<span class="constructor">Depth(TreeNode <span class="params">root</span>)</span> &#123;</span><br><span class="line">        return root<span class="operator"> == </span>null ? <span class="number">0</span> : <span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>max(max<span class="constructor">Depth(<span class="params">root</span>.<span class="params">left</span>)</span>,max<span class="constructor">Depth(<span class="params">root</span>.<span class="params">right</span>)</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度：我们每个结点只访问一次，因此时间复杂度为 O(N)，<br>其中 N 是结点的数量。</li>
<li>空间复杂度：在最糟糕的情况下，树是完全不平衡的，例如每个结点只剩下左子结点，递归将会被调用 N 次（树的高度），因此保持调用栈的存储将是 O(N)。但在最好的情况下（树是完全平衡的），树的高度将是 log(N)。因此，在这种情况下的空间复杂度将是 O(log(N))。</li>
</ul>
<p>方法二，迭代，用BFS层次遍历的方法，遍历完之后层数就是最大深度：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == null) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        Queue&lt;TreeNode&gt; <span class="built_in">queue</span> = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="built_in">queue</span>.add(root);</span><br><span class="line">        <span class="keyword">int</span> maxDepth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">queue</span>.isEmpty()) &#123;</span><br><span class="line">            maxDepth ++;</span><br><span class="line">            <span class="keyword">int</span> currLength = <span class="built_in">queue</span>.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; currLength; i++) &#123;</span><br><span class="line">                TreeNode node = <span class="built_in">queue</span>.poll();</span><br><span class="line">                <span class="keyword">if</span>(node.left != null) <span class="built_in">queue</span>.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != null) <span class="built_in">queue</span>.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxDepth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<p><strong>注：</strong>综合下来这道题用递归解法时间和空间复杂度都更优，因为平衡二叉树的情况下栈的调用次数只有log(n)。</p>
<h2 id="111-Minimum-depth-of-binary-tree-二叉树的最小深度-Mid"><a href="#111-Minimum-depth-of-binary-tree-二叉树的最小深度-Mid" class="headerlink" title="111. Minimum-depth-of-binary-tree(二叉树的最小深度)(Mid)"></a><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree" target="_blank" rel="noopener">111. Minimum-depth-of-binary-tree(二叉树的最小深度)(Mid)</a></h2><p>Given a binary tree, find its minimum depth.</p>
<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>
<p><strong>Note:</strong> A leaf is a node with no children.</p>
<p><strong>Example:</strong><br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>return its minimum depth = 2.</p>
<hr>
<p>解：递归是最直接的方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> int minDepth(<span class="type">TreeNode</span> root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == null) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        int <span class="keyword">left</span> = minDepth(root.<span class="keyword">left</span>);</span><br><span class="line">        int <span class="keyword">right</span> = minDepth(root.<span class="keyword">right</span>);</span><br><span class="line">        <span class="comment">//1.如果左孩子和右孩子有为空的情况，直接返回 left + right + 1</span></span><br><span class="line">        <span class="comment">//2.如果都不为空，返回较小深度+1</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">left</span> == <span class="number">0</span> || <span class="keyword">right</span> == <span class="number">0</span>) ? <span class="keyword">left</span> + <span class="keyword">right</span> + <span class="number">1</span>: <span class="type">Math</span>.<span class="built_in">min</span>(<span class="keyword">left</span>,<span class="keyword">right</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：我们访问每个节点一次，时间复杂度为 O(N) ，其中 N 是节点个数。</li>
<li>空间复杂度：最坏情况下，整棵树是非平衡的，例如每个节点都只有一个孩子，递归会调用 N （树的高度）次，因此栈的空间开销是 O(N) 。但在最好情况下，树是完全平衡的，高度只有 log(N)，因此在这种情况下空间复杂度只有 O(log(N)) 。</li>
</ul>
<h2 id="297-Serialize-and-deserialize-binary-tree-二叉树的序列化与反序列化-Hard"><a href="#297-Serialize-and-deserialize-binary-tree-二叉树的序列化与反序列化-Hard" class="headerlink" title="297. Serialize-and-deserialize-binary-tree(二叉树的序列化与反序列化)(Hard)"></a><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener">297. Serialize-and-deserialize-binary-tree(二叉树的序列化与反序列化)(Hard)</a></h2><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p>
<p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>
<p><strong>示例：</strong></p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">你可以将以下二叉树：</span><br><span class="line"></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">3</span></span><br><span class="line">     / \</span><br><span class="line">    <span class="number">4</span>   <span class="number">5</span></span><br><span class="line"></span><br><span class="line">序列化为 <span class="string">"[1,2,3,null,null,4,5]"</span></span><br></pre></td></tr></table></figure>
<p><strong>提示</strong>: 这与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p>
<p><strong>说明：</strong>不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。</p>
<hr>
<p>解：可以看出来，序列化和反序列化在实际中应用非常广泛也非常的重要。如果没有序列化，数据结构无法存储到文件和内存里面，通过网络的传输效率也会很低。</p>
<p>因为需要完成序列化和反序列化两个函数，所以需要两个思路：序列化的思想是利用dfs的先序遍历得到一个完整的序列，遇到了null直接存储null即可。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化的思想：利用dfs的preorder遍历得到一个完整的序列，遇到null的地方可以直接存储null，反序列化的时候可以根据标识操作</span></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serializeHelper(root, <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">String</span> <span class="title">serializeHelper</span><span class="params">(TreeNode root, <span class="keyword">String</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == null) &#123;</span><br><span class="line">            str += <span class="string">"null,"</span>;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// preorder add node</span></span><br><span class="line">        str += root.val + <span class="string">","</span>;</span><br><span class="line">        str = serializeHelper(root.left, str);</span><br><span class="line">        str = serializeHelper(root.right, str);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 反序列化的思想：利用list结构，每次返回list的首元素，作为上一个节点的左节点和右节点，然后依次删除掉list的首元素</span></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(<span class="keyword">String</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">String</span>[] data_ = data.split(<span class="string">","</span>);</span><br><span class="line">        List&lt;<span class="keyword">String</span>&gt; <span class="built_in">list</span> = <span class="keyword">new</span> LinkedList&lt;&gt;(Arrays.asList(data_));</span><br><span class="line">        <span class="keyword">return</span> desHelper(<span class="built_in">list</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">desHelper</span><span class="params">(List&lt;<span class="keyword">String</span>&gt; <span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">list</span>.<span class="built_in">get</span>(<span class="number">0</span>).equals(<span class="string">"null"</span>)) &#123;</span><br><span class="line">            <span class="built_in">list</span>.<span class="built_in">remove</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> null;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把String元素转换成int</span></span><br><span class="line">        <span class="keyword">int</span> val = Integer.valueOf(<span class="built_in">list</span>.<span class="built_in">get</span>(<span class="number">0</span>));</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        <span class="built_in">list</span>.<span class="built_in">remove</span>(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        root.left = desHelper(<span class="built_in">list</span>);</span><br><span class="line">        root.right = desHelper(<span class="built_in">list</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec = new Codec();</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：在序列化和反序列化函数中，我们只访问每个节点一次，因此时间复杂度为 O(n)，其中 n 是节点数，即树的大小。</li>
<li>空间复杂度：在序列化和反序列化函数中，我们将整棵树保留在开头或结尾，因此，空间复杂性为 O(n)。</li>
</ul>
<h2 id="236-Lowest-common-ancestor-of-a-binary-tree-二叉树的最近公共祖先-Mid"><a href="#236-Lowest-common-ancestor-of-a-binary-tree-二叉树的最近公共祖先-Mid" class="headerlink" title="236. Lowest-common-ancestor-of-a-binary-tree(二叉树的最近公共祖先)(Mid)"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">236. Lowest-common-ancestor-of-a-binary-tree(二叉树的最近公共祖先)(Mid)</a></h2><p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>
<p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”</p>
<p>Given the following binary tree:  root = [3,5,1,6,2,0,8,null,null,7,4]</p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt=""></p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: root = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">7</span>,<span class="number">4</span>], p = <span class="number">5</span>, q = <span class="number">1</span></span><br><span class="line">Output: <span class="number">3</span></span><br><span class="line">Explanation: The LCA of nodes <span class="number">5</span> <span class="keyword">and</span> <span class="number">1</span> <span class="keyword">is</span> <span class="number">3.</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: root = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">7</span>,<span class="number">4</span>], p = <span class="number">5</span>, q = <span class="number">4</span></span><br><span class="line">Output: <span class="number">5</span></span><br><span class="line">Explanation: The LCA of nodes <span class="number">5</span> <span class="keyword">and</span> <span class="number">4</span> <span class="keyword">is</span> <span class="number">5</span>, since a node can be a descendant of itself according to the LCA definition.</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ul>
<li>All of the nodes’ values will be unique.</li>
<li>p and q are different and both values will exist in the binary tree.</li>
</ul>
<hr>
<p>解：递归代码简单而且时间空间复杂度和迭代相同。</p>
<p>递归的base case:递归过程中如果root 是null,则返回null；如果递归到了子过程，比如(5, 5, 8)，则忽略其他内容返回传入的头结点(5)，同理如果到了(5, 8, 5)，同样忽略其他节点返回5。<br>这个逻辑可以用一行代码概括：</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span><span class="built_in">(root</span> == null ||<span class="built_in"> root</span> == p ||<span class="built_in"> root</span> == q) <span class="keyword">return</span><span class="built_in"> root</span>;</span><br></pre></td></tr></table></figure>
<p>之后进行递归调用，每次drill down 根节点的左孩子和右孩子。递归过程一般有四种：</p>
<ol>
<li>递归的时候总会传入整个结构的根节点。拿题目给的树为例，如果递归到了(2, 6, 0),即p和q都不为根节点的左子树和右子树节点，则返回null。(但是编写代码过程中貌似到不了这种情况，在递归过程中已经过滤掉了)。</li>
<li>传入的p和q中没有根节点右孩子节点，比如(3, 5, 4)，此时返回左子树靠上节点：5</li>
<li>传入的p和q中没有根节点左孩子节点，比如(3, 1, 0)， 此时返回右子树靠上节点：1</li>
<li>传入的p和q分别为根节点的左孩子节点和右孩子节点，比如(3, 6, 8)，返回根节点：3</li>
</ol>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Definition for </span>a<span class="markdown"> binary tree node.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>public class TreeNode &#123;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>int val;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>TreeNode left;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>TreeNode right;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>TreeNode(int x) &#123; val = x; &#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>&#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> */</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">        <span class="comment">// terminator</span></span><br><span class="line">        <span class="comment">// base cases</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || root == p || root == q)  <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">// 一路 drill down</span></span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="comment">// 第四种情况，左孩子和右孩子都有，则返回根节点</span></span><br><span class="line">        <span class="keyword">if</span>(left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>)   <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">// 概括第二和第三种情况</span></span><br><span class="line">        <span class="keyword">return</span> left != <span class="keyword">null</span> ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(N)，N 是二叉树中的节点数，最坏情况下，我们需要访问二叉树的所有节点。</li>
<li>空间复杂度：O(N)，这是因为递归堆栈使用的最大空间位 N,斜二叉树的高度可以是 N。</li>
</ul>
<h2 id="105-Construct-binary-tree-from-preorder-and-inorder-traversal-从前序与中序遍历序列构造二叉树-Mid"><a href="#105-Construct-binary-tree-from-preorder-and-inorder-traversal-从前序与中序遍历序列构造二叉树-Mid" class="headerlink" title="105. Construct-binary-tree-from-preorder-and-inorder-traversal(从前序与中序遍历序列构造二叉树)(Mid)"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal" target="_blank" rel="noopener">105. Construct-binary-tree-from-preorder-and-inorder-traversal(从前序与中序遍历序列构造二叉树)(Mid)</a></h2><p>Given preorder and inorder traversal of a tree, construct the binary tree.</p>
<p><strong>Note:</strong><br>You may assume that duplicates do not exist in the tree.</p>
<p>For example, given</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">preorder = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">inorder = [<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure>
<p>Return the following binary tree:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure>
<hr>
<p>解：这个题解过程在大学期间的数据结构课程应当有掌握。先序遍历的顺序总是根节点的顺序。我们可以根据先序遍历过程中遍历过的点逐渐判断哪些是根节点，然后中序遍历数组中在根节点左边的就是左子树，在右边的就是这个根节点的子树。</p>
<p>首先，preorder中的第一个元素一定是树的根，这个根又将inorder序列分成了左右两棵子树。现在我们只需要将先序遍历的数组中删除根元素，然后重复这个过程处理左右两棵子树。</p>
<p>解法一，直接使用上述原理，利用递归进行。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode buildTree(<span class="built_in">int</span>[] preorder, <span class="built_in">int</span>[] inorder) &#123;</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>, <span class="number">0</span>, inorder.length - <span class="number">1</span>, preorder, inorder);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 需要标记先序开始的地方和中序的序列.不需要preend是因为可以用preorder.length-1来标识</span></span><br><span class="line">    <span class="comment">// 每次递归的子问题需要用类似size的变量构造左子树和右子树</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode helper(<span class="built_in">int</span> preStart, <span class="built_in">int</span> inStart, <span class="built_in">int</span> inEnd, <span class="built_in">int</span>[] preorder, <span class="built_in">int</span>[] inorder) &#123;</span><br><span class="line">        <span class="comment">// 当前遍历的为null的条件</span></span><br><span class="line">        <span class="keyword">if</span> (preStart &gt; preorder.length - <span class="number">1</span> || inStart &gt; inEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// root 为当前遍历的根节点</span></span><br><span class="line">        TreeNode root = new TreeNode(preorder[preStart]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//知道了根节点之后可以推出左子树和右子树有哪些序列</span></span><br><span class="line">        <span class="comment">// 下面6行代码用于找到当前的根节点在中序遍历的什么位置</span></span><br><span class="line">        <span class="built_in">int</span> inIndex = <span class="number">0</span>; <span class="comment">// Index of current root in inorder</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = inStart; i &lt;= inEnd; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == root.val) &#123;</span><br><span class="line">                inIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归构造左子树。preStart+1是下一个左子树开始的节点。</span></span><br><span class="line">        <span class="comment">// 之前循环已经找到了当前root的位置并且用inIndex记录好了，所以左子树索引就是inIndex-1</span></span><br><span class="line">        root.left = helper(preStart + <span class="number">1</span>, inStart, inIndex - <span class="number">1</span>, preorder, inorder);</span><br><span class="line">        <span class="comment">// 递归构造右子树</span></span><br><span class="line">        root.right = helper(preStart + inIndex - inStart + <span class="number">1</span>, inIndex + <span class="number">1</span>, inEnd, preorder, inorder);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解法二，因为在递归过程中每次都要遍历中序遍历的数组去寻找，所以可以利用HashMap，把inorder[]，即中序遍历数组的每一个元素的值和下标存起来，这样可以直接用当前先序的值获取中序数组的下标位置了。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public TreeNode build<span class="constructor">Tree(<span class="params">int</span>[] <span class="params">preorder</span>, <span class="params">int</span>[] <span class="params">inorder</span>)</span> &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">        </span><br><span class="line">        for(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">            map.put(inorder<span class="literal">[<span class="identifier">i</span>]</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        TreeNode root = <span class="constructor">Helper(<span class="params">preorder</span>, 0, <span class="params">preorder</span>.<span class="params">length</span> - 1, <span class="params">inorder</span>, 0, <span class="params">inorder</span>.<span class="params">length</span> - 1, <span class="params">map</span>)</span>;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public TreeNode <span class="constructor">Helper(<span class="params">int</span>[] <span class="params">preorder</span>, <span class="params">int</span> <span class="params">preStart</span>, <span class="params">int</span> <span class="params">preEnd</span>, <span class="params">int</span>[] <span class="params">inorder</span>, <span class="params">int</span> <span class="params">inStart</span>, <span class="params">int</span> <span class="params">inEnd</span>, Map&lt;Integer, Integer&gt; <span class="params">map</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(preStart &gt; preEnd<span class="operator"> || </span>inStart &gt; inEnd) return null;</span><br><span class="line">        </span><br><span class="line">        TreeNode root = <span class="keyword">new</span> <span class="constructor">TreeNode(<span class="params">preorder</span>[<span class="params">preStart</span>])</span>;</span><br><span class="line">        <span class="built_in">int</span> inRoot = map.get(root.<span class="keyword">val</span>);</span><br><span class="line">        <span class="built_in">int</span> numsLeft = inRoot - inStart;</span><br><span class="line">        </span><br><span class="line">        root.left = <span class="constructor">Helper(<span class="params">preorder</span>, <span class="params">preStart</span> + 1, <span class="params">preStart</span> + <span class="params">numsLeft</span>, <span class="params">inorder</span>, <span class="params">inStart</span>, <span class="params">inRoot</span> - 1,<span class="params">map</span>)</span>;</span><br><span class="line">        root.right = <span class="constructor">Helper(<span class="params">preorder</span>, <span class="params">preStart</span> + <span class="params">numsLeft</span> + 1, <span class="params">preEnd</span>, <span class="params">inorder</span>, <span class="params">inRoot</span> + 1, <span class="params">inEnd</span>,<span class="params">map</span>)</span>;</span><br><span class="line">        </span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用HashMap可以大大提高效率，因为哈希表平均情况下查找效率为O(1)</p>
<ul>
<li>时间复杂度:O(n)，可用主定理计算得到</li>
<li>空间复杂度:O(n),存储整棵树的开销</li>
</ul>
<h2 id="剑指offer面试题54-二叉搜索树的第k大节点"><a href="#剑指offer面试题54-二叉搜索树的第k大节点" class="headerlink" title="剑指offer面试题54.二叉搜索树的第k大节点"></a>剑指offer面试题54.二叉搜索树的第k大节点</h2><p>给定一棵二叉搜索树，请找出其中第k大的节点。</p>
<p><strong>示例1：</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: root = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">2</span>], k = <span class="number">1</span></span><br><span class="line">   <span class="number">3</span></span><br><span class="line">  / \</span><br><span class="line"> <span class="number">1</span>   <span class="number">4</span></span><br><span class="line">  \</span><br><span class="line">   <span class="number">2</span></span><br><span class="line">输出: <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><strong>示例2：</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: root = [<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">1</span>], k = <span class="number">3</span></span><br><span class="line">       <span class="number">5</span></span><br><span class="line">      / \</span><br><span class="line">     <span class="number">3</span>   <span class="number">6</span></span><br><span class="line">    / \</span><br><span class="line">   <span class="number">2</span>   <span class="number">4</span></span><br><span class="line">  /</span><br><span class="line"> <span class="number">1</span></span><br><span class="line">输出: <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>限制：</p>
<p>1 ≤ k ≤ 二叉搜索树元素个数</p>
<hr>
<p>解：二叉搜索树的中序遍历能够保证结果是从小到大的。现在如果要第k大，即要找从大到小的。我们可以改变访问树的节点的顺序：本来中序遍历是左孩子、根节点、右孩子。我们可以把左孩子和右孩子的访问顺序改变一下，这样结果就是从大到小的了，用flag做记录，到了k之后记录当前值即可。</p>
<p>中序遍历代码可以用94题的中序遍历代码模板。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Definition for </span>a<span class="markdown"> binary tree node.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>public class TreeNode &#123;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>int val;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>TreeNode left;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>TreeNode right;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>TreeNode(int x) &#123; val = x; &#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>&#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> */</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    public <span class="built_in">int</span> kthLargest(TreeNode root, <span class="built_in">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// 中序遍历即可</span></span><br><span class="line">        <span class="comment">// if(root == null) return 0;</span></span><br><span class="line">        <span class="built_in">int</span> flag = <span class="number">0</span>, result = <span class="number">0</span>;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            flag++;</span><br><span class="line">            <span class="keyword">if</span>(flag == k) &#123;</span><br><span class="line">                result = root.val;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="50-Pow-x-n-Mid"><a href="#50-Pow-x-n-Mid" class="headerlink" title="50. Pow(x ,n)(Mid)"></a><a href="https://leetcode-cn.com/problems/powx-n/" target="_blank" rel="noopener">50. Pow(x ,n)(Mid)</a></h2><p>实现 <em>pow(x, n)</em> ，即计算 x 的 n 次幂函数。<br>Implement pow(x, n), which calculates x raised to the power n (x^n).</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="number">2.00000</span><span class="string">,</span> <span class="number">10</span></span><br><span class="line"><span class="attr">Output:</span> <span class="number">1024.00000</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="number">2.10000</span><span class="string">,</span> <span class="number">3</span></span><br><span class="line"><span class="attr">Output:</span> <span class="number">9.26100</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: <span class="number">2.00000</span>, <span class="number">-2</span></span><br><span class="line">Output: <span class="number">0.25000</span></span><br><span class="line">Explanation: <span class="number">2</span>^(<span class="number">-2</span>) = <span class="number">1</span>/(<span class="number">2</span>^<span class="number">2</span>) = <span class="number">1</span>/<span class="number">4</span> = <span class="number">0.25</span></span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ul>
<li>-100.0 &lt; x &lt; 100.0</li>
<li><em>n</em> is a 32 bit signed integer, within the range [−2^31, 2^(31 − 1)]</li>
</ul>
<hr>
<p>解：面试中碰到，首先需要和面试官确定一些事情(经常需要做的)：是否允许调用库函数？更重要的是，x和n的取值范围？x和n是否可以取0，正负值之类的。</p>
<p>其实我们在小学初中就学过某个数的几次方，就是把它乘几个自己，但是在高等数学中不是这么做的，在这里就进行一下计算。</p>
<p>方法一：暴力，求Pow就直接乘出来，时间复杂度为O(n)，提一嘴就行。</p>
<p>方法二，利用回溯和二分查找。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> myPow(<span class="built_in">double</span> x, <span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="comment">// 需要注意，如果输入的x大于1，同时n非常小，那么需要四舍五入输出0</span></span><br><span class="line">        <span class="comment">// 少了这一个判断，新增的一个用例无法通过：</span></span><br><span class="line">        <span class="comment">// 2.00000</span></span><br><span class="line">        <span class="comment">//-2147483648</span></span><br><span class="line">        <span class="keyword">if</span>(n == Integer.MIN_VALUE &amp;&amp; x &gt; <span class="number">1</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 递归出口</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 针对n为负数的处理</span></span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            n = -n;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (n % <span class="number">2</span> == <span class="number">0</span>) ? myPow(x * x, n / <span class="number">2</span>) : x * myPow(x * x, n / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<p><font color=#FF0000><strong>下面八道题为利用回溯解决的几个经典问题：求子集、排列问题、组合问题。此外还加上了分割回文串问题。虽然不是数字的list了，但是也是对List&lt;List<String>&gt;的操作以及回溯法的使用。</strong></font></p>
<p>参考LeetCode国际站回答： <a href="https://leetcode.com/problems/permutations/discuss/18239/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partioning)" target="_blank" rel="noopener">点击这里</a> 这些问题可以利用相同的一套解题模板，具体思路过程是：选择-&gt;拓展-&gt;剔除。</p>
<p>还有一点，这几道题最后返回的结果都是List&lt;List&lt;&gt;&gt;()类型的，即list里面装了list，如果不熟练，可能新手写起来都会存在困惑和错误。需要注意因为List不是基本数据类型，每次添加到result中时都需要new出来新的对象才可以，这也是对操作java中的list集合对象的熟练程度的考察。</p>
<p>此外，在过程中每次都是使用result.add(new ArrayList&lt;&gt;(curList))，是因为curList在回溯过程中每次都会被改变，我们需要记录当前curList的结果而不能让后面的curList的内容改变当前curList的结果。</p>
<h2 id="77-Combinations-组合-Mid"><a href="#77-Combinations-组合-Mid" class="headerlink" title="77. Combinations(组合)(Mid)"></a><a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/" target="_blank" rel="noopener">77. Combinations(组合)(Mid)</a></h2><p>Given two integers n and k, return all possible combinations of k numbers out of 1 … <em>n</em>.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: n = <span class="number">4</span>, k = <span class="number">2</span></span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">2</span>,<span class="number">4</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">4</span>],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<hr>
<p>解：这道题是很典型的用分治，回溯。这个题目递归最重要的两件事：递归终止条件和递归里面的for循环做的事情。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combine(<span class="built_in">int</span> n, <span class="built_in">int</span> k) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span><span class="operator"> || </span>k &lt;= <span class="number">0</span>) return results;</span><br><span class="line">        combine<span class="constructor">Helper(<span class="params">n</span>, <span class="params">k</span>, 1, <span class="params">results</span>, <span class="params">new</span> ArrayList&lt;Integer&gt;()</span>);</span><br><span class="line">        return results;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// st_num 为当前回合从哪个数开始取值。比如一开始从1到n所有的值都可以取</span></span><br><span class="line">    <span class="comment">// curSeq为当前List的状态</span></span><br><span class="line">    public void combine<span class="constructor">Helper(<span class="params">int</span> <span class="params">n</span>, <span class="params">int</span> <span class="params">k</span>, <span class="params">int</span> <span class="params">st_num</span>, List&lt;List&lt;Integer&gt;&gt; <span class="params">results</span>, List&lt;Integer&gt; <span class="params">curSeq</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// terminator ，k位都生成了,size满足条件之后把curSeq加入到results中</span></span><br><span class="line">        <span class="keyword">if</span>(k<span class="operator"> == </span><span class="number">0</span>) results.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt; (curSeq));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            for(<span class="built_in">int</span> i = st_num; i &lt;= n; i++) &#123;</span><br><span class="line">                curSeq.add(i);</span><br><span class="line">                <span class="comment">// 每次drill down循环次数为k-1</span></span><br><span class="line">                combine<span class="constructor">Helper(<span class="params">n</span>, <span class="params">k</span>-1, <span class="params">i</span> + 1, <span class="params">results</span>, <span class="params">curSeq</span>)</span>;</span><br><span class="line">                <span class="comment">// 和数组一样，list下标从0开始</span></span><br><span class="line">                curSeq.remove(curSeq.size<span class="literal">()</span>-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="39-Combination-Sum-组合总和-Mid"><a href="#39-Combination-Sum-组合总和-Mid" class="headerlink" title="39. Combination Sum(组合总和)(Mid)"></a><a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">39. Combination Sum(组合总和)(Mid)</a></h2><p>Given a <strong>set</strong> of candidate numbers (<code>candidates</code>) (<strong>without duplicates</strong>) and a target number (<code>target</code>), find all unique combinations in <code>candidates</code> where the candidate numbers sums to <code>target</code>.</p>
<p>The <strong>same</strong> repeated number may be chosen from <code>candidates</code> unlimited number of times.</p>
<p><strong>Note:</strong></p>
<ul>
<li>All numbers (including <code>target</code>) will be positive integers.</li>
<li>The solution set must not contain duplicate combinations.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: candidates = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>], target = <span class="number">7</span>,</span><br><span class="line">A solution <span class="keyword">set</span> <span class="keyword">is</span>:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">7</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: candidates = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>], target = <span class="number">8</span>,</span><br><span class="line">A solution <span class="keyword">set</span> <span class="keyword">is</span>:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<hr>
<p>解：需要注意的是只要和为target，candidates里面的元素每一个都可以被无限次选择。</p>
<p>看起来和上一道，77组合问题，有相似之处，但是解决起来复杂比较多，因为既需要考虑和是否为target，同时candidates里面的元素可以无限次数选择，加大了难度。</p>
<p>但是可以套用解决这几道回溯(写递归)问题的一系列问题的模板。</p>
<p>首先排序，用于剪枝。不排序也可以通过，但是先排序能够提升最后的空间和时间复杂度。</p>
<p>这样只要当前值比剩余的target大了，后面都是递增的，则可以break跳出了。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combination<span class="constructor">Sum(<span class="params">int</span>[] <span class="params">candidates</span>, <span class="params">int</span> <span class="params">target</span>)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">if</span>(target<span class="operator"> == </span><span class="number">0</span><span class="operator"> || </span>candidates<span class="operator"> == </span>null<span class="operator"> || </span>candidates.length<span class="operator"> == </span><span class="number">0</span>) return result;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span>sort(candidates);</span><br><span class="line">        <span class="constructor">Helper(<span class="params">result</span>, <span class="params">candidates</span>, <span class="params">target</span>, <span class="params">new</span> ArrayList&lt;&gt;()</span>, <span class="number">0</span>);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// start为当前使用的元素在candidates中的位置。因为可以重复使用，所以下一次传入的是i而不是i+1</span></span><br><span class="line">    public void <span class="constructor">Helper(List&lt;List&lt;Integer&gt;&gt; <span class="params">result</span>, <span class="params">int</span>[] <span class="params">candidates</span>, <span class="params">int</span> <span class="params">remain</span>, List&lt;Integer&gt; <span class="params">curList</span>, <span class="params">int</span> <span class="params">start</span>)</span> &#123;</span><br><span class="line">         <span class="keyword">if</span>(remain &lt; <span class="number">0</span>) return ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(remain<span class="operator"> == </span><span class="number">0</span>) result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(curList));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 从当前的 start 到数组的最后一个数来进行判断</span></span><br><span class="line">            for(<span class="built_in">int</span> i = start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">                curList.add(candidates<span class="literal">[<span class="identifier">i</span>]</span>);</span><br><span class="line">                <span class="constructor">Helper(<span class="params">result</span>, <span class="params">candidates</span>, <span class="params">remain</span> - <span class="params">candidates</span>[<span class="params">i</span>], <span class="params">curList</span>, <span class="params">i</span>)</span>; <span class="comment">// The start is not i+1 because we can reuse same element</span></span><br><span class="line">                curList.remove(curList.size<span class="literal">()</span> - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的for循环中的三行内容为回溯常用的写法，在curList中，先curList.add()加进去，再递归处理得到结果，再从curList中移除掉。</p>
<p>回溯的过程是怎样的呢？举个例子，如果candidates为<code>[1,2,3,4,5]</code>, target为7，一开始加入的结果是[1,2,3]，然后为[1,2,3,4]的时候，此时remain &lt; 0，所以return 回到curList为[1,2,3]的时候，此时需要执行curList.remove(curList.size() - 1)，即curList又变成[1,2]，然后再放入4, curList变成[1,2,4]，再往后执行，以此类推。</p>
<p>时间复杂度：组合问题，指数级的，O(2^n)。因为最终是从所有candidates的组合中选择出符合要求的，所有的情况是2^n的，所以整体时间复杂度就是O(2^n)。</p>
<h2 id="40-Combination-Sum-II-组合总和-II-Mid"><a href="#40-Combination-Sum-II-组合总和-II-Mid" class="headerlink" title="40. Combination Sum II (组合总和 II)(Mid)"></a><a href="https://leetcode-cn.com/problems/combination-sum-ii/" target="_blank" rel="noopener">40. Combination Sum II (组合总和 II)(Mid)</a></h2><p>Given a collection of candidate numbers (<code>candidates</code>) and a target number (<code>target</code>), find all unique combinations in <code>candidates</code> where the candidate numbers sums to <code>target</code>.</p>
<p>Each number in <code>candidates</code> may only be used <strong>once</strong> in the combination.</p>
<p><strong>Note:</strong></p>
<ul>
<li>All numbers (including <code>target</code>) will be positive integers.</li>
<li>The solution set must not contain duplicate combinations.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: candidates = [<span class="number">10</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">5</span>], target = <span class="number">8</span>,</span><br><span class="line">A solution <span class="keyword">set</span> <span class="keyword">is</span>:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>, <span class="number">7</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="number">6</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">1</span>, <span class="number">6</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: candidates = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>], target = <span class="number">5</span>,</span><br><span class="line">A solution <span class="keyword">set</span> <span class="keyword">is</span>:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">5</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<hr>
<p>解：39题的变题。和39相比的区别是，给的candidates数组可能包含重复元素、结果的list中不能有重复元素。</p>
<p>在去重思路上有一点变化。首先结果中不能重复使用candidates中的元素，所以在递归中start元素要变成i+1。此外，因为candidates中可以有重复元素，所以也要避免重复使用相同元素，在for循环中加一个判断。其他相同。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combination<span class="constructor">Sum2(<span class="params">int</span>[] <span class="params">candidates</span>, <span class="params">int</span> <span class="params">target</span>)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">if</span>(target<span class="operator"> == </span><span class="number">0</span><span class="operator"> || </span>candidates<span class="operator"> == </span>null<span class="operator"> || </span>candidates.length<span class="operator"> == </span><span class="number">0</span>) return result;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span>sort(candidates);</span><br><span class="line">        <span class="constructor">Helper(<span class="params">result</span>, <span class="params">candidates</span>, <span class="params">target</span>, <span class="params">new</span> ArrayList&lt;&gt;()</span>, <span class="number">0</span>);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void <span class="constructor">Helper(List&lt;List&lt;Integer&gt;&gt; <span class="params">result</span>, <span class="params">int</span>[] <span class="params">candidates</span>, <span class="params">int</span> <span class="params">remain</span>, List&lt;Integer&gt; <span class="params">curList</span>, <span class="params">int</span> <span class="params">start</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(remain &lt; <span class="number">0</span>) return ;</span><br><span class="line">        <span class="keyword">if</span>(remain<span class="operator"> == </span><span class="number">0</span>) result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(curList));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            for(<span class="built_in">int</span> i = start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">                <span class="comment">// 很重要的去掉重复解的步骤，这一行代码就可以实现</span></span><br><span class="line">                <span class="comment">// 逻辑写成i != start也可以</span></span><br><span class="line">                <span class="keyword">if</span>(i &gt; start<span class="operator"> &amp;&amp; </span>candidates<span class="literal">[<span class="identifier">i</span>]</span><span class="operator"> == </span>candidates<span class="literal">[<span class="identifier">i</span>-<span class="number">1</span>]</span>) continue; <span class="comment">// skip duplicates</span></span><br><span class="line">                curList.add(candidates<span class="literal">[<span class="identifier">i</span>]</span>);</span><br><span class="line">                <span class="constructor">Helper(<span class="params">result</span>, <span class="params">candidates</span>, <span class="params">remain</span> - <span class="params">candidates</span>[<span class="params">i</span>], <span class="params">curList</span>, <span class="params">i</span>+1)</span>;</span><br><span class="line">                curList.remove(curList.size<span class="literal">()</span> - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：指数级的，O(2^n)，推理方法和39题相同。</p>
<h2 id="46-Permutations-全排列-Mid"><a href="#46-Permutations-全排列-Mid" class="headerlink" title="46. Permutations(全排列)(Mid)"></a><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">46. Permutations(全排列)(Mid)</a></h2><p>Given a collection of distinct integers, return all possible permutations.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<hr>
<p>解：这是一个典型的用递归解决的问题</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="built_in">public</span> List&lt;List&lt;<span class="type">Integer</span>&gt;&gt; permute(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;<span class="type">Integer</span>&gt;&gt; result = <span class="built_in">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        permuteHelper(result, <span class="built_in">new</span> ArrayList&lt;<span class="type">Integer</span>&gt;(),  nums);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> permuteHelper(List&lt;List&lt;<span class="type">Integer</span>&gt;&gt; result, List&lt;<span class="type">Integer</span>&gt; curList, <span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(curList.size() == nums.length) &#123;</span><br><span class="line">            result.<span class="keyword">add</span>(<span class="built_in">new</span> ArrayList&lt;&gt;(curList));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(curList.contains(nums[i])) <span class="keyword">continue</span>; // element already <span class="keyword">exists</span>, skip</span><br><span class="line">                curList.<span class="keyword">add</span>(nums[i]);</span><br><span class="line">                permuteHelper(result,curList,nums);</span><br><span class="line">                curList.remove(curList.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以想象，每一位都是从nums[0]开始，递归完(nums[0],nums[1],nums[2])之后，从list中remove掉nums[2]，发现会掉入if(curList.contains(nums[i]))的条件，所以会紧接着remove掉nums[1]。再之后会尝试往curList中加入nums[2],因为此时nums[0]和nums[2]都已经在list中有了，所以会在continue之后加入nums[1]，再continue一次，然后以nums[0]作为第一个元素的list的答案就结束了，后面第一个元素变成nums[1]，再进行递归。</p>
<p>之前有一个不清楚的困扰，就是为什么result.add(curList)会返回空的list，必须result.add(new ArrayList&lt;&gt;(curList))才可以返回有值的结果。后来发现应该是单纯的add能加入的只能是基本数据类型，而要加入的curList是引用类型，需要new 以curList为内容的list才能加入。也可以理解为，在递归过程中curList总会变化，所以每次新加的是为了记录当前curList的内容的值，需要new才可以。</p>
<p>这道题是非常经典的一道题，这种递归的写法对于初学者可能会比较难思考的，建议多重复几遍，参考我上面这两段文字，更利于理解。</p>
<h2 id="47-Permutations-ii-全排列-II-Mid"><a href="#47-Permutations-ii-全排列-II-Mid" class="headerlink" title="47. Permutations-ii(全排列 II)(Mid)"></a><a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">47. Permutations-ii(全排列 II)(Mid)</a></h2><p>Given a collection of numbers that might contain duplicates, return all possible unique permutations.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<hr>
<p>解：47是46的变题。输入的nums可能存在重复的元素，实际上，重复的元素也是最重要的考量因素。</p>
<p>有了重复元素之后，整个逻辑和46就已经完全不同了。如果仍然使用46的contains去在循环过程中剔除掉，那么根本凑不足排列的元素数量。所以在往curList里面添加元素的过程中的逻辑需要改变。</p>
<p>在遍历每个元素的过程中，我们也要考虑去重，同一个元素不能被多次使用。而对于这道题，相等的元素也不能被多次使用。</p>
<p>具体到实现上，因为nums[]没说排好序了，所以为了方便根据前后元素进行判重，所以相比46题需要先排序。此外，因为nums[]中存在重复元素，需要判断当前元素是否使用的情况，所以要定义一个boolean数组:used。</p>
<p><font color=#FF0000><strong>为什么用一个boolean数组可以对去重复情况有效？</strong></font>因为经过推演可以发现这样一个规律：每次重复的结果出现的情况都是：<strong>重复的元素中，前面的不取，后面的取</strong>。其他情况比如前面和后面都取、前面取后面不取、前面后面都不取，这些都不会是重复的情况。读者可以自行举例推演验证。</p>
<p>为了方便记忆，实际上，used数组成为了循环内部判断的条件，不再需要使用curList.contains()方法。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; permute<span class="constructor">Unique(<span class="params">int</span>[] <span class="params">nums</span>)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length<span class="operator"> == </span><span class="number">0</span><span class="operator"> || </span>nums<span class="operator"> == </span>null) return result;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span>sort(nums);</span><br><span class="line">        permute<span class="constructor">UniqueHelper(<span class="params">result</span>, <span class="params">nums</span>, <span class="params">new</span> ArrayList&lt;&gt;()</span>, <span class="keyword">new</span> boolean<span class="literal">[<span class="identifier">nums</span>.<span class="identifier">length</span>]</span>);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// used 每一位都记录nums的某一个数字是否用过了   </span></span><br><span class="line">    public void permute<span class="constructor">UniqueHelper(List&lt;List&lt;Integer&gt;&gt; <span class="params">result</span>, <span class="params">int</span>[] <span class="params">nums</span>, List&lt;Integer&gt; <span class="params">curList</span>, <span class="params">boolean</span>[] <span class="params">used</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(curList.size<span class="literal">()</span><span class="operator"> == </span>nums.length) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(curList));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            for(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">                <span class="comment">// 相比46题，continue的条件有点复杂</span></span><br><span class="line">                <span class="comment">// 如果第i个已经被用过了，即used[i]为true，则直接跳过本轮</span></span><br><span class="line">                <span class="comment">// 如果当前第i个没有用过，那么同时满足三个条件，本轮也跳过。分别是：</span></span><br><span class="line">                <span class="comment">// 不是第一轮了，即i &gt; 0; nums[]中当前元素为重复; 当前元素的前一个元素目前没有被用，即</span></span><br><span class="line">                <span class="comment">// 正要把第i个之前有重复的元素推到最前面的时候</span></span><br><span class="line">                <span class="keyword">if</span>(used<span class="literal">[<span class="identifier">i</span>]</span><span class="operator"> || </span>i &gt; <span class="number">0</span><span class="operator"> &amp;&amp; </span>nums<span class="literal">[<span class="identifier">i</span>]</span><span class="operator"> == </span>nums<span class="literal">[<span class="identifier">i</span>-<span class="number">1</span>]</span><span class="operator"> &amp;&amp; </span>!used<span class="literal">[<span class="identifier">i</span>-<span class="number">1</span>]</span>) continue;</span><br><span class="line">                used<span class="literal">[<span class="identifier">i</span>]</span> = <span class="literal">true</span>;</span><br><span class="line">                curList.add(nums<span class="literal">[<span class="identifier">i</span>]</span>);</span><br><span class="line">                permute<span class="constructor">UniqueHelper(<span class="params">result</span>, <span class="params">nums</span>, <span class="params">curList</span>, <span class="params">used</span>)</span>;</span><br><span class="line">                used<span class="literal">[<span class="identifier">i</span>]</span> = <span class="literal">false</span>;</span><br><span class="line">                curList.remove(curList.size<span class="literal">()</span> - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="78-Subsets-子集-Mid"><a href="#78-Subsets-子集-Mid" class="headerlink" title="78. Subsets(子集)(Mid)"></a><a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">78. Subsets(子集)(Mid)</a></h2><p>Given a set of <strong>distinct</strong> integers, <em>nums</em>, return all possible subsets (the power set).</p>
<p><strong>Note</strong>: The solution set must not contain duplicate subsets.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>],</span><br><span class="line">  [<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<hr>
<p>解：方法一：给的nums都是不同的元素，都没有排序过，返回的list总会包含[]，这几点需要注意。</p>
<p>这也是非常典型的用回溯完成的题目。和之前几个需要考虑和为target的或者每个集合里面必须有所有数字的排列来说，其实终止条件比较简单。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; subsets(<span class="built_in">int</span><span class="literal">[]</span> nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length<span class="operator"> == </span><span class="number">0</span><span class="operator"> || </span>nums<span class="operator"> == </span>null) return result;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span>sort(nums);</span><br><span class="line">        <span class="constructor">Helper(<span class="params">result</span>, <span class="params">nums</span>, <span class="params">new</span> ArrayList&lt;&gt;()</span>, <span class="number">0</span>);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void <span class="constructor">Helper(List&lt;List&lt;Integer&gt;&gt; <span class="params">result</span>, <span class="params">int</span>[] <span class="params">nums</span>, List&lt;Integer&gt; <span class="params">curList</span>, <span class="params">int</span> <span class="params">start</span>)</span> &#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(curList));</span><br><span class="line">        for(<span class="built_in">int</span> i = start; i &lt; nums.length; i++) &#123;</span><br><span class="line">            curList.add(nums<span class="literal">[<span class="identifier">i</span>]</span>);</span><br><span class="line">            <span class="constructor">Helper(<span class="params">result</span>, <span class="params">nums</span>, <span class="params">curList</span>, <span class="params">i</span> + 1)</span>;</span><br><span class="line">            curList.remove(curList.size<span class="literal">()</span> - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：考虑每一位可以选某个元素或者不选，相当于填空。</p>
<h2 id="90-Subsets-II-子集II-Mid"><a href="#90-Subsets-II-子集II-Mid" class="headerlink" title="90. Subsets II(子集II)(Mid)"></a><a href="https://leetcode.com/problems/subsets-ii/" target="_blank" rel="noopener">90. Subsets II(子集II)(Mid)</a></h2><p>Given a collection of integers that might contain duplicates, <strong>nums</strong>, return all possible subsets (the power set).</p>
<p><strong>Note</strong>: The solution set must not contain duplicate subsets.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<hr>
<p>解：与78题相比，Input可以有重复元素。具体写法上主要是for里面需要增加循环终止的条件，因为相同的元素只能使用一次，再次使用产生的结果会是重复的。具体做法也和之前一样，排好序之后，当前循环变量(i)不为start之后(条件为i &gt; start或者i!=start都可以)，只要 <code>nums[i] == nums[i-1]</code>，就continue。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; subsets<span class="constructor">WithDup(<span class="params">int</span>[] <span class="params">nums</span>)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums<span class="operator"> == </span>null<span class="operator"> || </span>nums.length<span class="operator"> == </span><span class="number">0</span>) return result;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span>sort(nums);</span><br><span class="line">        <span class="constructor">Helper(<span class="params">result</span>, <span class="params">nums</span>, <span class="params">new</span> ArrayList&lt;&gt;()</span>, <span class="number">0</span>);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void <span class="constructor">Helper(List&lt;List&lt;Integer&gt;&gt; <span class="params">result</span>, <span class="params">int</span>[] <span class="params">nums</span>, List&lt;Integer&gt; <span class="params">curList</span>, <span class="params">int</span> <span class="params">start</span>)</span> &#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(curList));</span><br><span class="line">        for(<span class="built_in">int</span> i = start; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; start<span class="operator"> &amp;&amp; </span>nums<span class="literal">[<span class="identifier">i</span>]</span><span class="operator"> == </span>nums<span class="literal">[<span class="identifier">i</span>-<span class="number">1</span>]</span>) continue;</span><br><span class="line">            curList.add(nums<span class="literal">[<span class="identifier">i</span>]</span>);</span><br><span class="line">            <span class="constructor">Helper(<span class="params">result</span>, <span class="params">nums</span>, <span class="params">curList</span>, <span class="params">i</span> + 1)</span>;</span><br><span class="line">            curList.remove(curList.size<span class="literal">()</span> - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="131-Palindrome-Partitioning-分割回文串-Mid"><a href="#131-Palindrome-Partitioning-分割回文串-Mid" class="headerlink" title="131. Palindrome Partitioning(分割回文串)(Mid)"></a><a href="https://leetcode-cn.com/problems/palindrome-partitioning/" target="_blank" rel="noopener">131. Palindrome Partitioning(分割回文串)(Mid)</a></h2><p>Given a string s, partition s such that every substring of the partition is a palindrome.</p>
<p>Return all possible palindrome partitioning of s.</p>
<p><strong>Example:</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Input</span>: <span class="string">"aab"</span></span><br><span class="line"><span class="symbol">Output</span>:</span><br><span class="line">[</span><br><span class="line">  [<span class="string">"aa"</span>,<span class="string">"b"</span>],</span><br><span class="line">  [<span class="string">"a"</span>,<span class="string">"a"</span>,<span class="string">"b"</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<hr>
<p>解：判断是否为回文串的部分可以单独定义成一个函数。一头一尾两个指针扫描，必须相等才能是回文串。利用自增自减简化写法。只有符合要求才放入curList</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;<span class="keyword">String</span>&gt;&gt; partition(<span class="keyword">String</span> s) &#123;</span><br><span class="line">        List&lt;List&lt;<span class="keyword">String</span>&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        backtrack(result, <span class="keyword">new</span> ArrayList&lt;&gt;(), s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;<span class="keyword">String</span>&gt;&gt; result, List&lt;<span class="keyword">String</span>&gt; curList, <span class="keyword">String</span> s, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == s.length())</span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(curList));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; s.length(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(isPalindrome(s, start, i)) &#123;</span><br><span class="line">                    curList.add(s.substring(start, i+<span class="number">1</span>));</span><br><span class="line">                    backtrack(result, curList, s, i+<span class="number">1</span>);</span><br><span class="line">                    curList.<span class="built_in">remove</span>(curList.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">String</span> s, <span class="keyword">int</span> <span class="built_in">begin</span>, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">begin</span> &lt; <span class="built_in">end</span>)</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(<span class="built_in">begin</span>++) != s.charAt(<span class="built_in">end</span>--)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="307-Range-Sum-Query-Mutable-区域和检索-数组可修改-Mid"><a href="#307-Range-Sum-Query-Mutable-区域和检索-数组可修改-Mid" class="headerlink" title="307.Range Sum Query-Mutable(区域和检索-数组可修改)(Mid)"></a><a href="https://leetcode-cn.com/problems/range-sum-query-mutable/" target="_blank" rel="noopener">307.Range Sum Query-Mutable(区域和检索-数组可修改)(Mid)</a></h2><p>Given an integer array <em>nums</em>, find the sum of the elements between indices <em>i</em> and <em>j (i ≤ j)</em>, inclusive.</p>
<p>The <em>update(i, val)</em> function modifies nums by updating the element at index <em>i</em> to <em>val</em>.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Given nums = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">sumRange(<span class="number">0</span>, <span class="number">2</span>) -&gt; <span class="number">9</span></span><br><span class="line">update(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">sumRange(<span class="number">0</span>, <span class="number">2</span>) -&gt; <span class="number">8</span></span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ol>
<li>The array is only modifiable by the update function.</li>
<li>You may assume the number of calls to update and sumRange function is distributed evenly.</li>
</ol>
<hr>
<p>解：简而言之，这道题简直就是为了考线段树(Segment Tree)而出的。这道题非常符合线段树的使用场景，详细可参考<a href="https://www.geeksforgeeks.org/segment-tree-set-1-sum-of-given-range/" target="_blank" rel="noopener">这篇文章</a></p>
<p>参考LeetCode国际站高票代码：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> NumArray &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> SegmentTreeNode &#123;</span><br><span class="line">        <span class="built_in">int</span> start, <span class="keyword">end</span>;</span><br><span class="line">        SegmentTreeNode left, right;</span><br><span class="line">        <span class="built_in">int</span> sum;</span><br><span class="line">        </span><br><span class="line">        <span class="constructor">SegmentTreeNode(<span class="params">int</span> <span class="params">start</span>, <span class="params">int</span> <span class="params">end</span>)</span> &#123;</span><br><span class="line">            this.start = start;</span><br><span class="line">            this.<span class="keyword">end</span> = <span class="keyword">end</span>;</span><br><span class="line">            this.left = null;</span><br><span class="line">            this.right = null;</span><br><span class="line">            this.sum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SegmentTreeNode root = null;</span><br><span class="line">    </span><br><span class="line">    public <span class="constructor">NumArray(<span class="params">int</span>[] <span class="params">nums</span>)</span> &#123;</span><br><span class="line">        root = build<span class="constructor">Tree(<span class="params">nums</span>, 0, <span class="params">nums</span>.<span class="params">length</span> - 1)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">private</span> SegmentTreeNode build<span class="constructor">Tree(<span class="params">int</span>[] <span class="params">nums</span>, <span class="params">int</span> <span class="params">start</span>, <span class="params">int</span> <span class="params">end</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; <span class="keyword">end</span>) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            SegmentTreeNode ret = <span class="keyword">new</span> <span class="constructor">SegmentTreeNode(<span class="params">start</span>, <span class="params">end</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (start<span class="operator"> == </span><span class="keyword">end</span>) &#123;</span><br><span class="line">                ret.sum = nums<span class="literal">[<span class="identifier">start</span>]</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">int</span> mid = start  + (<span class="keyword">end</span> - start)<span class="operator"> / </span><span class="number">2</span>;             </span><br><span class="line">                ret.left = build<span class="constructor">Tree(<span class="params">nums</span>, <span class="params">start</span>, <span class="params">mid</span>)</span>;</span><br><span class="line">                ret.right = build<span class="constructor">Tree(<span class="params">nums</span>, <span class="params">mid</span> + 1, <span class="params">end</span>)</span>;</span><br><span class="line">                ret.sum = ret.left.sum + ret.right.sum;</span><br><span class="line">            &#125;         </span><br><span class="line">            return ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void update(<span class="built_in">int</span> i, <span class="built_in">int</span> <span class="keyword">val</span>) &#123;</span><br><span class="line">        update(root, i, <span class="keyword">val</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     void update(SegmentTreeNode root, <span class="built_in">int</span> pos, <span class="built_in">int</span> <span class="keyword">val</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.start<span class="operator"> == </span>root.<span class="keyword">end</span>) &#123;</span><br><span class="line">           root.sum = <span class="keyword">val</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">int</span> mid = root.start + (root.<span class="keyword">end</span> - root.start)<span class="operator"> / </span><span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (pos &lt;= mid) &#123;</span><br><span class="line">                 update(root.left, pos, <span class="keyword">val</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 update(root.right, pos, <span class="keyword">val</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            root.sum = root.left.sum + root.right.sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="built_in">int</span> sum<span class="constructor">Range(<span class="params">int</span> <span class="params">i</span>, <span class="params">int</span> <span class="params">j</span>)</span> &#123;</span><br><span class="line">        return sum<span class="constructor">Range(<span class="params">root</span>, <span class="params">i</span>, <span class="params">j</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public <span class="built_in">int</span> sum<span class="constructor">Range(SegmentTreeNode <span class="params">root</span>, <span class="params">int</span> <span class="params">start</span>, <span class="params">int</span> <span class="params">end</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.<span class="keyword">end</span><span class="operator"> == </span><span class="keyword">end</span><span class="operator"> &amp;&amp; </span>root.start<span class="operator"> == </span>start) &#123;</span><br><span class="line">            return root.sum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">int</span> mid = root.start + (root.<span class="keyword">end</span> - root.start)<span class="operator"> / </span><span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">end</span> &lt;= mid) &#123;</span><br><span class="line">                return sum<span class="constructor">Range(<span class="params">root</span>.<span class="params">left</span>, <span class="params">start</span>, <span class="params">end</span>)</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (start &gt;= mid+<span class="number">1</span>) &#123;</span><br><span class="line">                return sum<span class="constructor">Range(<span class="params">root</span>.<span class="params">right</span>, <span class="params">start</span>, <span class="params">end</span>)</span>;</span><br><span class="line">            &#125;  <span class="keyword">else</span> &#123;    </span><br><span class="line">                return sum<span class="constructor">Range(<span class="params">root</span>.<span class="params">right</span>, <span class="params">mid</span>+1, <span class="params">end</span>)</span> + sum<span class="constructor">Range(<span class="params">root</span>.<span class="params">left</span>, <span class="params">start</span>, <span class="params">mid</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumArray obj = new NumArray(nums);</span></span><br><span class="line"><span class="comment"> * obj.update(i,val);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.sumRange(i,j);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="252-Meeting-rooms-II-会议室II-Mid"><a href="#252-Meeting-rooms-II-会议室II-Mid" class="headerlink" title="252.Meeting rooms II (会议室II)(Mid)"></a><a href="https://leetcode-cn.com/problems/meeting-rooms-ii/" target="_blank" rel="noopener">252.Meeting rooms II (会议室II)(Mid)</a></h2><p>给定一个会议时间安排的数组，每个会议时间都会包括开始和结束的时间 <code>[[s1,e1],[s2,e2],...]</code> (si &lt; ei)，为避免会议冲突，同时要考虑充分利用会议室资源，请你计算至少需要多少间会议室，才能满足这些会议安排。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [[<span class="number">0</span>, <span class="number">30</span>],[<span class="number">5</span>, <span class="number">10</span>],[<span class="number">15</span>, <span class="number">20</span>]]</span><br><span class="line">输出: <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [[<span class="number">7</span>,<span class="number">10</span>],[<span class="number">2</span>,<span class="number">4</span>]]</span><br><span class="line">输出: <span class="number">1</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：这道题是252(Meeting rooms)的进阶版，但是这道题做出来就够了，两者思路一样。</p>
<p>我们可以开两个数组，把所有开始时间放到开始时间(startTime)数组，结束时间放到结束时间(endTime)数组，然后把两个数组排序。排序之后虽然两个数组的开始时间和结束时间不对应了，但是不影响最后数值结果。</p>
<p>为什么？可以用一个房间出入的例子。一个房间可能有A、B、C出入房间，但是我们不需要直接特定时间是谁进和出房间，只需要管人数就行了。</p>
<p>我们不在乎某一个会议几点开始和几点结束，我们只关心排好序的数组中是否有冲突。</p>
]]></content>
      <categories>
        <category>Algorithms Note</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Hash Table</title>
    <url>/2020/01/13/LeetCode-Practice-by-Categories-Hash-Table/</url>
    <content><![CDATA[<blockquote>
<p>合理安排时间，等于节约时间。——培根</p>
</blockquote>
<p>LeetCode哈希表、相关题目，其解决思路和具体代码。以及有关java语言哈希表的解析。</p>
<a id="more"></a>

<h2 id="242-Valid-Anagram-有效的字母异位词-Easy"><a href="#242-Valid-Anagram-有效的字母异位词-Easy" class="headerlink" title="242. Valid Anagram(有效的字母异位词)(Easy)"></a><a href="https://leetcode-cn.com/problems/valid-anagram/" target="_blank" rel="noopener">242. Valid Anagram(有效的字母异位词)(Easy)</a></h2><p>Given two strings s and t , write a function to determine if t is an anagram of s.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">Input:</span> s = <span class="string">"anagram"</span>, t = <span class="string">"nagaram"</span></span><br><span class="line"><span class="string">Output:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">Input:</span> s = <span class="string">"rat"</span>, t = <span class="string">"car"</span></span><br><span class="line"><span class="string">Output:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong><br>You may assume the string contains only lowercase alphabets.</p>
<p><strong>Follow up:</strong><br>What if the inputs contain unicode characters? How would you adapt your solution to such case?</p>
<hr>
<p>解：这道题可以直接把传入的两个字符串转换成字符数组，按照字典序排序后比较是否相等。这种方法不需要用到哈希表，但是类库自带的快排整体速度不如哈希表(这道题实际上使用到哈希表的思想，我们自己定义一个哈希映射)的查询速度快。</p>
<p>方法一：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public boolean is<span class="constructor">Anagram(String <span class="params">s</span>, String <span class="params">t</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length<span class="literal">()</span> != t.length<span class="literal">()</span>) return <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">char</span><span class="literal">[]</span> s1 = s.<span class="keyword">to</span><span class="constructor">CharArray()</span>;</span><br><span class="line">        <span class="built_in">char</span><span class="literal">[]</span> t1 = t.<span class="keyword">to</span><span class="constructor">CharArray()</span>;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span>sort(s1);</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span>sort(t1);</span><br><span class="line">        return <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span>equals(s1,t1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：使用哈希映射思想，定义一个我们自己的哈希表，遍历s和t，每次把s中遍历到的字母的ASICC码计算并且加起来，再减去t中对应的值。遍历一遍下来，如果有一个字母的对应的出现次数不为0，则整个传入数据不为字母异位词。此方法中new了一个大小为26的数组，其中每一个元素代表一个字母的出现次数，所以最后只要有一个不为0，输入就不为字母异位词。</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isAnagram(String s, String t) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() != t.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] <span class="keyword">count</span> = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">char</span>[] s1 = s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] t1 = t.toCharArray();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s1.length; i++) &#123;</span><br><span class="line">            <span class="keyword">count</span>[s1[i] - <span class="string">'a'</span>]++;</span><br><span class="line">            <span class="keyword">count</span>[t1[i] - <span class="string">'a'</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">count</span>[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>，如果不先将s和t 进行toCharArray转换，而直接用charAt()判断位置然后进行哈希映射，整体执行效率会很慢。上面的用时可以击败90%以上，但是下面这段代码一般只能击败60%，试验了多次。</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isAnagram(String s, String t) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() != t.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] <span class="keyword">count</span> = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s.length() ;i++) &#123;</span><br><span class="line">            <span class="keyword">count</span>[s.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">            <span class="keyword">count</span>[t.charAt(i) - <span class="string">'a'</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> counter : <span class="keyword">count</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(counter != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="49-Group-Anagram-字母异位词分组-Mid"><a href="#49-Group-Anagram-字母异位词分组-Mid" class="headerlink" title="49. Group Anagram(字母异位词分组)(Mid)"></a><a href="https://leetcode-cn.com/problems/group-anagrams/" target="_blank" rel="noopener">49. Group Anagram(字母异位词分组)(Mid)</a></h2><p>Given an array of strings, group anagrams together.</p>
<p><strong>Example:</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Input</span>: [<span class="string">"eat"</span>, <span class="string">"tea"</span>, <span class="string">"tan"</span>, <span class="string">"ate"</span>, <span class="string">"nat"</span>, <span class="string">"bat"</span>],</span><br><span class="line"><span class="symbol">Output</span>:</span><br><span class="line">[</span><br><span class="line">  [<span class="string">"ate"</span>,<span class="string">"eat"</span>,<span class="string">"tea"</span>],</span><br><span class="line">  [<span class="string">"nat"</span>,<span class="string">"tan"</span>],</span><br><span class="line">  [<span class="string">"bat"</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ul>
<li>All inputs will be in lowercase.</li>
<li>The order of your output does not matter.</li>
</ul>
<hr>
<p>解：使用排序解决判断是否为异位词的部分。</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;<span class="keyword">String</span>&gt;&gt; groupAnagrams(<span class="keyword">String</span>[] strs) &#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.length == <span class="number">0</span> || strs == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;List&lt;<span class="keyword">String</span>&gt;&gt;();</span><br><span class="line">        Map&lt;<span class="keyword">String</span>, List&lt;<span class="keyword">String</span>&gt;&gt; <span class="built_in">map</span> = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">String</span> s : strs) &#123;</span><br><span class="line">            <span class="built_in">char</span>[] ca = s.toCharArray();</span><br><span class="line">            Arrays.<span class="built_in">sort</span>(ca);</span><br><span class="line">            <span class="keyword">String</span> keyStr = <span class="keyword">String</span>.valueOf(ca);</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">map</span>.containsKey(keyStr)) <span class="built_in">map</span>.put(keyStr, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            <span class="built_in">map</span>.<span class="built_in">get</span>(keyStr).<span class="built_in">add</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;List&lt;<span class="keyword">String</span>&gt;&gt; (<span class="built_in">map</span>.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="1-Two-Sum-两数之和-Easy"><a href="#1-Two-Sum-两数之和-Easy" class="headerlink" title="1. Two Sum(两数之和)(Easy)"></a><a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">1. Two Sum(两数之和)(Easy)</a></h2><p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have <strong><em>exactly</em></strong> one solution, and you may not use the same element twice.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Given nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span>,</span><br><span class="line"></span><br><span class="line">Because nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span>,</span><br><span class="line"><span class="keyword">return</span> [<span class="number">0</span>, <span class="number">1</span>].</span><br></pre></td></tr></table></figure>

<hr>
<p>解：保持数组中的每个元素与其索引相互对应的最好方式是什么？当然是基于数组的哈希表。利用哈希表先把内容存储起来，这样一来查找的过程只需要O(1)了。</p>
<p>这个map中，key是nums元素的值，value是该元素的下标。因为要找到a+b = target,所以 a = target - b，所以查找 target-a 在不在数组里面即可。</p>
<p>注意</p>
<ol>
<li>这里是把元素当做key，该元素的位置当做value。</li>
<li>虽然看起来 <code>map.put(nums[i], i)</code> 这句放在循环体里的前面和后面都可以，但是其实是不能放在前面的，否则如果某个元素的值是target的二分之一，先把它添加进map之后再比较，会直接比较到它自己。换句话说，必须先比较，再put进map。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                result[<span class="number">0</span>] = i;</span><br><span class="line">                result[<span class="number">1</span>] = map.get(target - nums[i]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 注意这里put不能放在判断前面，必须先比较再放入。否则如果某个元素是target的一半，先添加再比较的话，会比较到它自己。</span></span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="347-Top-K-Frequent-Elements-前K个高频元素-Mid"><a href="#347-Top-K-Frequent-Elements-前K个高频元素-Mid" class="headerlink" title="347. Top K Frequent Elements (前K个高频元素)(Mid)"></a><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">347. Top K Frequent Elements (前K个高频元素)(Mid)</a></h2><p>Given a non-empty array of integers, return the <strong><em>k\</em></strong> most frequent elements.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>], k = <span class="number">2</span></span><br><span class="line">Output: [<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: nums = [<span class="number">1</span>], k = <span class="number">1</span></span><br><span class="line">Output: [<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ul>
<li>You may assume <em>k</em> is always valid, 1 ≤ <em>k</em> ≤ number of unique elements.</li>
<li>Your algorithm’s time complexity <strong>must be</strong> better than O(<em>n</em> log <em>n</em>), where <em>n</em> is the array’s size.</li>
</ul>
<hr>
<p>解：<a href="https://leetcode-cn.com/problems/top-k-frequent-elements/solution/leetcode-di-347-hao-wen-ti-qian-k-ge-gao-pin-yuan-/" target="_blank" rel="noopener">具体解法可以参考这篇文章</a></p>
<p>这里有好用的两种方法，都用到了HashMap。</p>
<p>方法一**：堆排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span> || nums == <span class="keyword">null</span> || k == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个Integer为元素值，第二个为对应的频次</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(num))</span><br><span class="line">                map.put(num, map.get(num)+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                map.put(num, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 构建小顶堆</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(</span><br><span class="line">            (a,b) -&gt; map.get(a)-map.get(b)</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> key : map.keySet()) &#123;</span><br><span class="line">            <span class="comment">// 起步阶段，还没有存满k个元素</span></span><br><span class="line">            <span class="keyword">if</span>(heap.size() &lt; k)</span><br><span class="line">                heap.add(key);</span><br><span class="line">            <span class="comment">// 如果新遍历的元素的频次大于优先队列中频次最小的元素，则要把</span></span><br><span class="line">            <span class="comment">//最小的元素进行替换</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(map.get(key) &gt; map.get(heap.peek())) &#123;</span><br><span class="line">                    heap.poll();</span><br><span class="line">                    heap.add(key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!heap.isEmpty())</span><br><span class="line">            result.add(heap.poll());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(nlogk)，注意不是O(nlogn)，n是数组长度，首先过一遍数组并且统计，这个操作时间复杂度为O(n)，然后遍历用于存储元素频率的map，如果元素的频率大于最小堆中顶部的元素，则将顶部的元素删除并将该元素加入堆中，这里维护堆的数目是 kk，所以这一系列操作的时间复杂度是 O(nlogk) 的；因此，总的时间复杂度是 O(nlog⁡k)。</li>
<li>空间复杂度：O(n)，最坏情况下（每个元素都不同），map 需要存储 <em>n</em> 个键值对，优先队列需要存储 k 个元素，因此，空间复杂度是 O(n)。</li>
</ul>
<p><strong>方法二</strong>：桶排序</p>
<p>首先依旧使用哈希表统计频率，统计完成后，创建一个数组，将频率作为数组下标，对于出现频率不同的数字集合，存入对应的数组下标即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基于桶排序求解「前 K 个高频元素」</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="comment">// 使用字典，统计每个元素出现的次数，元素为键，元素出现的次数为值</span></span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(num)) &#123;</span><br><span class="line">               map.put(num, map.get(num) + <span class="number">1</span>);</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(num, <span class="number">1</span>);</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//桶排序</span></span><br><span class="line">        <span class="comment">//将频率作为数组下标，对于出现频率不同的数字集合，存入对应的数组下标</span></span><br><span class="line">        List&lt;Integer&gt;[] list = <span class="keyword">new</span> List[nums.length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> key : map.keySet())&#123;</span><br><span class="line">            <span class="comment">// 获取出现的次数作为下标</span></span><br><span class="line">            <span class="keyword">int</span> i = map.get(key);</span><br><span class="line">            <span class="keyword">if</span>(list[i] == <span class="keyword">null</span>)&#123;</span><br><span class="line">               list[i] = <span class="keyword">new</span> ArrayList();</span><br><span class="line">            &#125; </span><br><span class="line">            list[i].add(key);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 倒序遍历数组获取出现顺序从大到小的排列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = list.length - <span class="number">1</span>;i &gt;= <span class="number">0</span> &amp;&amp; res.size() &lt; k;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list[i] == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            res.addAll(list[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，n 表示数组的长度。首先，遍历一遍数组统计元素的频率，这一系列操作的时间复杂度是 O(n)；桶的数量为 n + 1，所以桶排序的时间复杂度为 O(n)O(n)；因此，总的时间复杂度是 O(n)。</li>
<li>空间复杂度：O(n)</li>
</ul>
]]></content>
      <categories>
        <category>Algorithms Note</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Stack, Queue</title>
    <url>/2020/01/08/LeetCode-Practice-by-Categories-Stack-Queue/</url>
    <content><![CDATA[<blockquote>
<p>衡量一个人真正的品德，是看他在知道没有人看见的时候做些什么 —— 孟德斯鸠</p>
</blockquote>
<p>分析讨论栈、队列、优先队列、双端队列以及相关LeetCode题目。</p>
<a id="more"></a>

<p><font color=#FF0000>java中，队列Queue是一种特殊的线性表，实例化的时候用链表(new LinkedList&lt;&gt;())、栈Stack有单独的类，实例化的时候使用Stack(new Stack&lt;&gt;())。 队列因为用LinkedList实现,一般操作size()方法。而栈可以使用empty()或者isEmpty()判空(empty()和isEmpty()没有本质区别，一般可以通用)</p>
<p>事实上，普通的栈和队列在工作中基本不会使用，而用得比较多的是双端队列。比如本文中曾经在239题中使用了java库中的双端队列，并用Array实现：<code>Deque&lt;Integer&gt; dq = new ArrayDeque&lt;&gt;();</code><br></font> </p>
<h2 id="20-Valid-Parentheses-有效的括号-Easy"><a href="#20-Valid-Parentheses-有效的括号-Easy" class="headerlink" title="20.Valid Parentheses(有效的括号)(Easy)"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">20.Valid Parentheses(有效的括号)(Easy)</a></h2><p>Given a string containing just the characters <code>&#39;(&#39;, &#39;)&#39;, &#39;{&#39;, &#39;}&#39;, &#39;[&#39;</code> and<code>&#39;]&#39;</code>, determine if the input string is valid.</p>
<p>An input string is valid if:</p>
<ol>
<li>Open brackets must be closed by the same type of brackets.</li>
<li>Open brackets must be closed in the correct order.</li>
</ol>
<p>Note that an empty string is also considered valid.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">Input:</span> <span class="string">"()"</span></span><br><span class="line"><span class="string">Output:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">Input:</span> <span class="string">"()[]&#123;&#125;"</span></span><br><span class="line"><span class="string">Output:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">Input:</span> <span class="string">"(]"</span></span><br><span class="line"><span class="string">Output:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">Input:</span> <span class="string">"([)]"</span></span><br><span class="line"><span class="string">Output:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 5:</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">Input:</span> <span class="string">"&#123;[]&#125;"</span></span><br><span class="line"><span class="string">Output:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：想要符合闭合的括号的标准，用一个栈保存和左括号对应的右括号。每次碰到左括号就入栈对应的右括号，碰到右括号就判断是否和当前栈顶元素相同。</p>
<p>注意有两个判空，一个是碰到右括号，如果此时栈为空，那么不能pop()(会报错)，如果此时栈为空则不为有效括号。另一个情况是所有括号都遍历完了，此时如果栈不为空，则不是有效括号。所以在遍历完s之后需要返回stack.isEmpty()。</p>
<p>需要注意最后一个判断因为有pop()操作，所以必须把pop()放在后面才行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'('</span>) &#123;</span><br><span class="line">                stack.push(<span class="string">')'</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'['</span>) &#123;</span><br><span class="line">                stack.push(<span class="string">']'</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'&#123;'</span>) &#123;</span><br><span class="line">                stack.push(<span class="string">'&#125;'</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(stack.isEmpty() || stack.pop() != c) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="155-Min-Stack-最小栈-Easy"><a href="#155-Min-Stack-最小栈-Easy" class="headerlink" title="155.Min Stack(最小栈)(Easy)"></a><a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">155.Min Stack(最小栈)(Easy)</a></h2><p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p>
<ul>
<li>push(x) – Push element x onto stack.</li>
<li>pop() – Removes the element on top of the stack.</li>
<li>top() – Get the top element.</li>
<li>getMin() – Retrieve the minimum element in the stack.</li>
</ul>
<p><strong>Example:</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">MinStack minStack = new MinStack()<span class="comment">;</span></span><br><span class="line">minStack.push(-<span class="number">2</span>)<span class="comment">;</span></span><br><span class="line">minStack.push(<span class="number">0</span>)<span class="comment">;</span></span><br><span class="line">minStack.push(-<span class="number">3</span>)<span class="comment">;</span></span><br><span class="line">minStack.getMin()<span class="comment">;   --&gt; Returns -3.</span></span><br><span class="line">minStack.pop()<span class="comment">;</span></span><br><span class="line">minStack.top()<span class="comment">;      --&gt; Returns 0.</span></span><br><span class="line">minStack.getMin()<span class="comment">;   --&gt; Returns -2.</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：java语言本身已经定义好了一种传统作用的Stack，这道题有什么意义呢？事实上这道题就是要实现一个可以获得最小元素的栈。</p>
<p>换个角度看，要能够在常数时间内检索到最小元素的栈，是不是有点像优先队列？——其实不一样，它还是一个先入后出的栈。它只是能让你在常规时间中探索到最小元素，而不是取的时候每次都取最小元素。它的api本身和栈一模一样，只是多了一个功能，能够探测到最小元素。</p>
<p>给出两种方法，分别用两个栈和一个栈实现。</p>
<p>解法一：用两个栈实现，一个数据栈，一个辅助栈。这种写法注意了健壮性，考虑了栈为空的情况。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据栈和辅助栈同步,后面每个操作两个栈都进行相同操作</span></span><br><span class="line">    Stack&lt;Integer&gt; data;</span><br><span class="line">    Stack&lt;Integer&gt; helper;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化两个栈</span></span><br><span class="line">        data = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        helper = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        data.push(x);</span><br><span class="line">        <span class="keyword">if</span>(helper.isEmpty() || helper.<span class="built_in">peek</span>() &gt;= x) &#123;</span><br><span class="line">            helper.push(x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            helper.push(helper.<span class="built_in">peek</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!data.isEmpty()) &#123;</span><br><span class="line">            data.pop();</span><br><span class="line">            helper.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!data.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> data.<span class="built_in">peek</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"栈中元素为空，此操作非法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!helper.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> helper.<span class="built_in">peek</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"栈中元素为空，此操作非法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>解法二：用一个栈解决。解法一开辟了一个helper栈去保存最小值，实际上我们可以用一个变量,min,去保存这个最小值。<br>这里有两个问题：</p>
<ol>
<li>min保存了当前的最小值，如果min更新了，那么如何保存之前的最小值呢？——把之前的min在新元素之前入栈，也就是说来了新的更小的元素，旧的最小的元素需要再次入栈以求保存。</li>
<li>如果当前出栈的是最小值，我们在出栈当前元素之余，还需要再出栈一次，并且把这一次出栈的值赋给min。因为最小的元素入栈前会把之前最小的元素入栈，所以这样做就把旧的最小元素保存下来了。</li>
</ol>
<p>详细题解：<a href="https://leetcode-cn.com/problems/min-stack/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-38/" target="_blank" rel="noopener">点击这里</a></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">min</span> = Integer.MAX_VALUE;</span><br><span class="line">    Stack&lt;Integer&gt; <span class="built_in">stack</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span> = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// only push the old minimum value when the current</span></span><br><span class="line">        <span class="comment">// minimum value changes after pushing the new value x</span></span><br><span class="line">        <span class="keyword">if</span>(x &lt;= <span class="built_in">min</span>) &#123;</span><br><span class="line">            <span class="built_in">stack</span>.push(<span class="built_in">min</span>);</span><br><span class="line">            <span class="built_in">min</span> = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">stack</span>.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// if pop operation could result in the changing of the current minimum value,</span></span><br><span class="line">        <span class="comment">// pop twice and change the current minimum value to the last minimum value</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">stack</span>.pop() == <span class="built_in">min</span>) <span class="built_in">min</span> = <span class="built_in">stack</span>.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>.<span class="built_in">peek</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="641-Design-Circular-Deque-设计循环双端队列-Mid"><a href="#641-Design-Circular-Deque-设计循环双端队列-Mid" class="headerlink" title="641.Design Circular Deque(设计循环双端队列)(Mid)"></a><a href="https://leetcode-cn.com/problems/design-circular-deque/" target="_blank" rel="noopener">641.Design Circular Deque(设计循环双端队列)(Mid)</a></h2><p>Design your implementation of the circular double-ended queue (deque).</p>
<p>Your implementation should support following operations:</p>
<ul>
<li><code>MyCircularDeque(k)</code>: Constructor, set the size of the deque to be k.</li>
<li><code>insertFront()</code>: Adds an item at the front of Deque. Return true if the operation is successful.</li>
<li><code>insertLast()</code>: Adds an item at the rear of Deque. Return true if the operation is successful.</li>
<li><code>deleteFront()</code>: Deletes an item from the front of Deque. Return true if the operation is successful.</li>
<li><code>deleteLast()</code>: Deletes an item from the rear of Deque. Return true if the operation is successful.</li>
<li><code>getFront()</code>: Gets the front item from the Deque. If the deque is empty, return -1.</li>
<li><code>getRear()</code>: Gets the last item from Deque. If the deque is empty, return -1.</li>
<li><code>isEmpty()</code>: Checks whether Deque is empty or not. </li>
<li><code>isFull()</code>: Checks whether Deque is full or not.</li>
</ul>
<p><strong>Example:</strong></p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">MyCircularDeque circularDeque = new MycircularDeque(<span class="number">3</span>); <span class="regexp">//</span> set the size to be <span class="number">3</span></span><br><span class="line">circularDeque.insertLast(<span class="number">1</span>);			<span class="regexp">//</span> <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">circularDeque.insertLast(<span class="number">2</span>);			<span class="regexp">//</span> <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">circularDeque.insertFront(<span class="number">3</span>);			<span class="regexp">//</span> <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">circularDeque.insertFront(<span class="number">4</span>);			<span class="regexp">//</span> <span class="keyword">return</span> <span class="keyword">false</span>, the queue is full</span><br><span class="line">circularDeque.getRear();  			<span class="regexp">//</span> <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">circularDeque.isFull();				<span class="regexp">//</span> <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">circularDeque.deleteLast();			<span class="regexp">//</span> <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">circularDeque.insertFront(<span class="number">4</span>);			<span class="regexp">//</span> <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">circularDeque.getFront();			<span class="regexp">//</span> <span class="keyword">return</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ul>
<li>All values will be in the range of [0, 1000].</li>
<li>The number of operations will be in the range of [1, 1000].</li>
<li>Please do not use the built-in Deque library.</li>
</ul>
<hr>
<p>解：使用链表完成这个API的设计。</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> MyCircularDeque &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> DoubleListNode &#123;</span><br><span class="line">        DoubleListNode pre;</span><br><span class="line">        DoubleListNode <span class="keyword">next</span>;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">public</span> DoubleListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">size</span>;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    DoubleListNode head;</span><br><span class="line">    DoubleListNode tail;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Initialize your data structure here. Set the size of the deque to be k. */</span></span><br><span class="line">    <span class="keyword">public</span> MyCircularDeque(<span class="keyword">int</span> k) &#123;</span><br><span class="line">        head = <span class="keyword">new</span> DoubleListNode(-<span class="number">1</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> DoubleListNode(-<span class="number">1</span>);</span><br><span class="line">        head.pre = tail;</span><br><span class="line">        tail.<span class="keyword">next</span> = head;</span><br><span class="line">        <span class="keyword">this</span>.k = k;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">size</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Adds an item at the front of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> insertFront(<span class="keyword">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">size</span> == k) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        DoubleListNode node = <span class="keyword">new</span> DoubleListNode(value);</span><br><span class="line">        node.<span class="keyword">next</span> = head;</span><br><span class="line">        node.pre = head.pre;</span><br><span class="line">        head.pre.<span class="keyword">next</span> = node;</span><br><span class="line">        head.pre = node;</span><br><span class="line">        <span class="keyword">size</span>++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Adds an item at the rear of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> insertLast(<span class="keyword">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">size</span> == k) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        DoubleListNode node = <span class="keyword">new</span> DoubleListNode(value);</span><br><span class="line">        node.<span class="keyword">next</span> = tail.<span class="keyword">next</span>;</span><br><span class="line">        tail.<span class="keyword">next</span>.pre = node;</span><br><span class="line">        tail.<span class="keyword">next</span> = node;</span><br><span class="line">        node.pre = tail;</span><br><span class="line">        <span class="keyword">size</span>++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Deletes an item from the front of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> deleteFront() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">size</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        head.pre.pre.<span class="keyword">next</span> = head;</span><br><span class="line">        head.pre = head.pre.pre;</span><br><span class="line">        <span class="keyword">size</span>--;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Deletes an item from the rear of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> deleteLast() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">size</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        tail.<span class="keyword">next</span>.<span class="keyword">next</span>.pre = tail;</span><br><span class="line">        tail.<span class="keyword">next</span> = tail.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">        <span class="keyword">size</span>--;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front item from the deque. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> getFront() &#123;</span><br><span class="line">        <span class="keyword">return</span> head.pre.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the last item from the deque. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> getRear() &#123;</span><br><span class="line">        <span class="keyword">return</span> tail.<span class="keyword">next</span>.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Checks whether the circular deque is empty or not. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">size</span> == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Checks whether the circular deque is full or not. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isFull() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">size</span> == k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyCircularDeque object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyCircularDeque obj = new MyCircularDeque(k);</span></span><br><span class="line"><span class="comment"> * boolean param_1 = obj.insertFront(value);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.insertLast(value);</span></span><br><span class="line"><span class="comment"> * boolean param_3 = obj.deleteFront();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.deleteLast();</span></span><br><span class="line"><span class="comment"> * int param_5 = obj.getFront();</span></span><br><span class="line"><span class="comment"> * int param_6 = obj.getRear();</span></span><br><span class="line"><span class="comment"> * boolean param_7 = obj.isEmpty();</span></span><br><span class="line"><span class="comment"> * boolean param_8 = obj.isFull();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="225-Implement-Stack-using-Queues-用队列实现栈-Easy"><a href="#225-Implement-Stack-using-Queues-用队列实现栈-Easy" class="headerlink" title="225.Implement Stack using Queues(用队列实现栈)(Easy)"></a><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/" target="_blank" rel="noopener">225.Implement Stack using Queues(用队列实现栈)(Easy)</a></h2><p>Implement the following operations of a stack using queues.</p>
<ul>
<li>push(x) – Push element x onto stack.</li>
<li>pop() – Removes the element on top of the stack.</li>
<li>top() – Get the top element.</li>
<li>empty() – Return whether the stack is empty.</li>
</ul>
<p><strong>Example:</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MyStack <span class="built_in">stack</span> = <span class="keyword">new</span> MyStack();</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>.push(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">stack</span>.push(<span class="number">2</span>);  </span><br><span class="line"><span class="built_in">stack</span>.top();   <span class="comment">// returns 2</span></span><br><span class="line"><span class="built_in">stack</span>.pop();   <span class="comment">// returns 2</span></span><br><span class="line"><span class="built_in">stack</span>.empty(); <span class="comment">// returns false</span></span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ul>
<li>You must use only standard operations of a queue – which means only <code>push to back, peek/pop from front, size</code>, and <code>is empty</code> operations are valid.</li>
<li>Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.</li>
<li>You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).</li>
</ul>
<hr>
<p>解：想要用队列实现栈，常规想法可以使用两个队列，在每次出栈操作的时候，把元素临时保存到第二个队列中，在第一个队列还剩一个元素的时候把这个元素取出，从而实现类似栈的”后入先出”操作。</p>
<p>但是存在空间复杂度更优的方法，就是使用一个队列。具体操作方法是，每次入队都把整个队列循环弹出和新增元素，使得新添加的元素总在队列的前面，由此一来这个队列实际操作与栈无异。**关键步骤就是在于入队列时候的操作：<code>queue.add(queue.remove())</code>(remove()在队列为空的时候会抛出NoSuchElementException异常，poll()会返回null，其他没有区别)</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    Queue&lt;Integer&gt; <span class="built_in">queue</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="built_in">queue</span> = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>.add(x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">queue</span>.<span class="built_in">size</span>()<span class="number">-1</span>; i++)</span><br><span class="line">            <span class="built_in">queue</span>.add(<span class="built_in">queue</span>.<span class="built_in">remove</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">queue</span>.<span class="built_in">remove</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">queue</span>.<span class="built_in">peek</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">queue</span>.<span class="built_in">size</span>() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>


<h2 id="232-Implement-Queue-using-Stacks-用栈实现队列-Easy"><a href="#232-Implement-Queue-using-Stacks-用栈实现队列-Easy" class="headerlink" title="232.Implement Queue using Stacks(用栈实现队列)(Easy)"></a><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/" target="_blank" rel="noopener">232.Implement Queue using Stacks(用栈实现队列)(Easy)</a></h2><p>Implement the following operations of a queue using stacks.</p>
<ul>
<li>push(x) – Push element x to the back of queue.</li>
<li>pop() – Removes the element from in front of queue.</li>
<li>peek() – Get the front element.</li>
<li>empty() – Return whether the queue is empty.</li>
</ul>
<p><strong>Example:</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">MyQueue <span class="built_in">queue</span> = <span class="keyword">new</span> MyQueue();</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>.push(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">queue</span>.push(<span class="number">2</span>);  </span><br><span class="line"><span class="built_in">queue</span>.<span class="built_in">peek</span>();  <span class="comment">// returns 1</span></span><br><span class="line"><span class="built_in">queue</span>.pop();   <span class="comment">// returns 1</span></span><br><span class="line"><span class="built_in">queue</span>.empty(); <span class="comment">// returns false</span></span><br></pre></td></tr></table></figure>
<p><strong>Notes:</strong></p>
<ul>
<li>You must use only standard operations of a stack – which means only <code>push to top, peek/pop from top, size, and is empty</code> operations are valid.</li>
<li>Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.</li>
<li>You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).</li>
</ul>
<hr>
<p>解：和之前用队列实现栈类似，可以用两个栈实现一个队列。但是由于栈只有一个出入口，所以不能用一个栈实现队列(队列中出队再入队可以实现倒置，栈不行).</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要两个栈才能实现队列</span></span><br><span class="line">    Stack&lt;Integer&gt; input;</span><br><span class="line">    Stack&lt;Integer&gt; output;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        input = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        output = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        input.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">peek</span>();</span><br><span class="line">        <span class="keyword">return</span> output.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(output.empty())</span><br><span class="line">            <span class="keyword">while</span>( !input.empty() )</span><br><span class="line">                output.push(input.pop());</span><br><span class="line">        <span class="keyword">return</span> output.<span class="built_in">peek</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input.empty() &amp;&amp; output.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.peek();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>


<h2 id="239-Sliding-Window-Maximum-滑动窗口最大值-Hard"><a href="#239-Sliding-Window-Maximum-滑动窗口最大值-Hard" class="headerlink" title="239.Sliding Window Maximum(滑动窗口最大值)(Hard)"></a><a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">239.Sliding Window Maximum(滑动窗口最大值)(Hard)</a></h2><p>Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: nums = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">-1</span>,<span class="number">-3</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>], <span class="keyword">and</span> k = <span class="number">3</span></span><br><span class="line">Output: [<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>] </span><br><span class="line">Explanation: </span><br><span class="line"></span><br><span class="line">Window position                Max</span><br><span class="line">---------------               -----</span><br><span class="line">[<span class="number">1</span>  <span class="number">3</span>  <span class="number">-1</span>] <span class="number">-3</span>  <span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">3</span></span><br><span class="line"> <span class="number">1</span> [<span class="number">3</span>  <span class="number">-1</span>  <span class="number">-3</span>] <span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">3</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span> [<span class="number">-1</span>  <span class="number">-3</span>  <span class="number">5</span>] <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">5</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  <span class="number">-1</span> [<span class="number">-3</span>  <span class="number">5</span>  <span class="number">3</span>] <span class="number">6</span>  <span class="number">7</span>       <span class="number">5</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  <span class="number">-1</span>  <span class="number">-3</span> [<span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>] <span class="number">7</span>       <span class="number">6</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  <span class="number">-1</span>  <span class="number">-3</span>  <span class="number">5</span> [<span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>]      <span class="number">7</span></span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong><br>You may assume k is always valid, 1 ≤ k ≤ input array’s size for non-empty array.</p>
<p><strong>Follow up:</strong><br>Could you solve it in linear time?</p>
<hr>
<p>解：<strong>所有滑动窗口的题目，想到用队列解决。</strong></p>
<p>方法一：暴力求解。枚举窗口的起点位置，因为窗口长度是k,所以枚举起点是0，终点是 length-1 。写一个二重循环，最后时间复杂度是O(n*k)。</p>
<p>方法二：这里用到单调队列(实际就是所谓的双端队列)，可以达到线性的时间复杂度。</p>
<p><font color=#FF0000>双端队列可以操作队列里面的头元素和尾元素，一些API见下图：</font><br><img src="https://s2.ax1x.com/2020/01/11/lIIZSs.png" alt="JDK8 Deque API"></p>
<p>我们通过双端队列维护的一个”单调队列”，从左到右为递减。所以每次对比元素都是peekLast()，弹出元素也是pollLast()</p>
<p>我们用双向队列可以在O(N)时间内解决这题。当我们遇到新的数时，将新的数和双向队列的末尾比较，如果末尾比新数小，则把末尾扔掉，直到该队列的末尾比新数大或者队列为空的时候才住手。这样，我们可以保证队列里的元素是从头到尾降序的，由于队列里只有窗口内的数，所以他们其实就是窗口内第一大，第二大，第三大…的数。保持队列里只有窗口内数的方法和上个解法一样，也是每来一个新的把窗口最左边的扔掉，然后把新的加进去。然而由于我们在加新数的时候，已经把很多没用的数给扔了，这样队列头部的数并不一定是窗口最左边的数。这里的技巧是，我们队列中存的是那个数在原数组中的下标，这样我们既可以直到这个数的值，也可以知道该数是不是窗口最左边的数。这里为什么时间复杂度是O(N)呢？因为每个数只可能被操作最多两次，一次是加入队列的时候，一次是因为有别的更大数在后面，所以被扔掉，或者因为出了窗口而被扔掉。(引用<a href="https://segmentfault.com/a/1190000003903509" target="_blank" rel="noopener">这篇文章</a>)</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>[] maxSlidingWindow(<span class="built_in">int</span>[] nums, <span class="built_in">int</span> k) &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(nums.length == <span class="number">0</span> || k &lt;= <span class="number">0</span>) <span class="keyword">return</span> nums;</span><br><span class="line">		<span class="built_in">int</span> len = nums.length;</span><br><span class="line">		<span class="comment">// 可以自己举个例子，推得这个result大小应该为len-k+1</span></span><br><span class="line">		<span class="built_in">int</span>[] result = new <span class="built_in">int</span>[len - k + <span class="number">1</span>];</span><br><span class="line">		<span class="comment">// store index</span></span><br><span class="line">		<span class="comment">// 注意，dq用于保存数组下标</span></span><br><span class="line">		Deque&lt;Integer&gt; dq = new ArrayDeque&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">			<span class="comment">//这里不需要循环，用一个判断就可 </span></span><br><span class="line">			<span class="comment">//因为我们最多只能在一轮中弹出一个超出范围的元素。（一轮我们只接受一个元素，所以我们最多弹出一个元素）。</span></span><br><span class="line">			<span class="comment">// dq 用于保存数组下标，这也是一个技巧</span></span><br><span class="line">			<span class="keyword">if</span>( !dq.isEmpty() &amp;&amp; dq.peekFirst() == i-k) &#123;</span><br><span class="line">				<span class="comment">// 双端队列中 poll() 相当于 pollFirst(),皮一下</span></span><br><span class="line">				dq.poll();</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 新加入的元素必须比前面的小，否则前面比它小的元素都要出队</span></span><br><span class="line">			<span class="keyword">while</span>(!dq.isEmpty() &amp;&amp; nums[i] &gt;= nums[dq.peekLast()]) &#123;</span><br><span class="line">				dq.pollLast();</span><br><span class="line">			&#125;</span><br><span class="line">			dq.offer(i);</span><br><span class="line">			<span class="comment">// dq是有序的，队列头总是最大的元素，只要下标在范围内，直接peek()即可</span></span><br><span class="line">			<span class="keyword">if</span>(i-k+<span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">				result[i-k+<span class="number">1</span>] = nums[dq.peek()];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<h2 id="621-Task-Scheduler-任务调度-Mid"><a href="#621-Task-Scheduler-任务调度-Mid" class="headerlink" title="621.Task Scheduler(任务调度)(Mid)"></a><a href="https://leetcode-cn.com/problems/task-scheduler/" target="_blank" rel="noopener">621.Task Scheduler(任务调度)(Mid)</a></h2><p>Given a char array representing tasks CPU need to do. It contains capital letters A to Z where different letters represent different tasks. Tasks could be done without original order. Each task could be done in one interval. For each interval, CPU could finish one task or just be idle.</p>
<p>However, there is a non-negative cooling interval <strong>n</strong> that means between two <strong>same tasks</strong>, there must be at least n intervals that CPU are doing different tasks or just be idle.</p>
<p>You need to return the <strong>least</strong> number of intervals the CPU will take to finish all the given tasks.</p>
<p><strong>Example:</strong></p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">Input: tasks = [<span class="string">"A"</span>,<span class="string">"A"</span>,<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"B"</span>,<span class="string">"B"</span>], n = <span class="number">2</span></span><br><span class="line">Output: <span class="number">8</span></span><br><span class="line">Explanation: A -&gt; B -&gt; idle -&gt; A -&gt; B -&gt; idle -&gt; A -&gt; B.</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ol>
<li>The number of tasks is in the range [1, 10000].</li>
<li>The integer n is in the range [0, 100].</li>
</ol>
<hr>
<p>解：</p>
<ol>
<li>因为所有任务都是大写字母，所以可以申请大小为26的数组来保存任务类型个数。</li>
<li>对数组进行排序，按照出现的次数进行排序，优先记录出现次数多的任务。根据题意，时间至少为：retCount = (count - 1) * (n + 1) + 1 =&gt;A-&gt;X-&gt;X-&gt;A-&gt;X-&gt;X-&gt;A(X为其他任务或者待命)</li>
<li>再排序下一个任务，如果下一个任务B个数和最大任务数一致，则retCount++ ==&gt; A-&gt;B-&gt;X-&gt;A-&gt;B-&gt;X-&gt;A-&gt;B</li>
<li>如果空位都插满之后还有任务，那就随便在这些间隔里面插入就可以，因为间隔长度肯定会大于n，在这种情况下就是任务的总数是最小所需时间</li>
</ol>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> leastInterval(char[] tasks, <span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="comment">// corner case</span></span><br><span class="line">        <span class="keyword">if</span>(tasks.length &lt;= <span class="number">1</span> || n &lt; <span class="number">1</span>) <span class="keyword">return</span> tasks.length;</span><br><span class="line">        <span class="comment">// 步骤1</span></span><br><span class="line">        <span class="built_in">int</span>[] counts = new <span class="built_in">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; tasks.length; i++) &#123;</span><br><span class="line">            counts[tasks[i] - <span class="string">'A'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//步骤2</span></span><br><span class="line">        Arrays.sort(counts);</span><br><span class="line">        <span class="built_in">int</span> maxCount = counts[<span class="number">25</span>];</span><br><span class="line">        <span class="built_in">int</span> retCount = (maxCount - <span class="number">1</span>) * (n + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">24</span>;</span><br><span class="line">        <span class="comment">// 步骤3</span></span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; counts[i] == maxCount) &#123;</span><br><span class="line">            retCount++;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//步骤4</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(retCount, tasks.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他参考题解：<a href="https://leetcode-cn.com/problems/task-scheduler/solution/python-xiang-jie-by-jalan/" target="_blank" rel="noopener">参考这篇文章</a></p>
<h2 id="84-Largest-Rectangle-in-Histogram-柱状图中最大的矩形-Hard"><a href="#84-Largest-Rectangle-in-Histogram-柱状图中最大的矩形-Hard" class="headerlink" title="84.Largest Rectangle in Histogram(柱状图中最大的矩形)(Hard)"></a><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">84.Largest Rectangle in Histogram(柱状图中最大的矩形)(Hard)</a></h2><p>Given <em>n</em> non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram.png" alt="eg"></p>
<p>Above is a histogram where width of each bar is 1, given height = <code>[2,1,5,6,2,3]</code>.</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram_area.png" alt="eg"></p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">Output: <span class="number">10</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：方法一：暴力法，枚举所有可能的柱子对。每次遍历的时候都基于当前的第i个柱子，向右用j扫描一遍。这样可以确保每一个都扫描扫过。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 方法一，暴力O(n^2)</span></span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>, len = heights.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 每次重新循环，minHeight都要更新</span></span><br><span class="line">            <span class="keyword">int</span> minHeight = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; len; j++) &#123;</span><br><span class="line">                minHeight = Math.min(minHeight, heights[j]);</span><br><span class="line">                maxArea = Math.max(maxArea, minHeight * (j - i + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(n)</li>
</ul>
<p>方法二，时间复杂度为O(n)的方法，利用Stack进行,具体来说，是一个<strong>单调栈</strong>。</p>
<p>它是怎么做的呢？</p>
<p>遍历的过程中，因为是从左开始遍历的，所以其实如果用一个有序的栈，其实是可以用O(1)得到某根柱子的左边界的。注意这里说的是左边界，右边界仍然需要遍历，因为右边还没遍历，没法一下子知道右边界。但是这是合理的，因为如果你不继续往右边界遍历，你永远也不知道右边界在哪里。</p>
<p>这个办法是维护一个栈，这个栈的元素是从<strong>小到大（对于栈，从小到大是从栈底到栈顶是从小到大排列的）</strong>进行排列的。因为这样排列，可以有效知道它的左边界在什么地方。</p>
<p><strong>不得不说，这个算法需要后面不断反复地看</strong>，才能熟悉他它因为它的逻辑其实是比较复杂和精妙的。</p>
<p>栈的初始值为-1，也是巧妙的一点。</p>
<p>为了保证栈是从小到大的，每次入栈都进行一次判断， 必须比当前栈顶元素大，才能进栈，否则要把那个栈元素出栈。</p>
<p>进栈的时候要保留它的下标，因为后面计算的时候好计算它的宽度。</p>
<p><font color=#FF0000>栈里面任何一个元素的左边界，都是它在栈里面的下一个元素。也就是说，如果一个元素要出栈了，它的左边界就是它在栈里的下一个元素，它的右边界就是比它小的那个元素，换句话说，哪个元素触发了另一个元素要被弹出栈，触发它的那个元素，就是被弹出元素的右边界。由此一来，当前被弹出元素的左边界和右边界都有了，通过公式计算得到的就是被以被弹出元素为中心能围成的最大矩形面积。</font></p>
<p>比如一个元素3，让9,5,4三个元素都出栈了，那么3就是9,5,4这三个元素的右边界</p>
<p>如果一个元素想要加入栈，但是它比栈顶元素要大，那么它不能是前一个元素的右边界，所以要把它保存到栈里面，直到下一个入栈的元素比栈里面它的上一个元素要小，那么开始出栈操作，因为找到了边界了。</p>
<p>扫描到哪里，谁更小，谁就是整个栈操作的颠覆者。</p>
<ul>
<li>实质是求每个柱子可以向左右两边延伸的距离<ul>
<li>向左：由于栈是单调递增的，因此以当前柱子为中心向左延展时，不能超过当前栈的上一个元素(最近的比它小的元素)</li>
<li>向右：由于遇到非单调递增的元素时才开始弹出，所以当前位置的高度小于每个弹出的元素。因此，向右延展时，不能超过当前位置</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// corner case</span></span><br><span class="line">        <span class="keyword">if</span>(heights == <span class="keyword">null</span> || heights.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 方法二，栈,O(n)</span></span><br><span class="line">        <span class="comment">// 主要目标是求能够覆盖当前第i个柱子的最大矩形，即为第i个矩形的"专属面积"</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 栈里面存放heights数组的下标，取元素的时候为：heights[stack.pop()]</span></span><br><span class="line">        stack.push(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>, len = heights.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 只有遍历的heights[i]比当前stack里面的栈顶元素大，才能跳过while循环，直接入栈</span></span><br><span class="line">            <span class="keyword">while</span>(stack.peek() != -<span class="number">1</span> &amp;&amp; heights[stack.peek()] &gt;= heights[i])</span><br><span class="line">                <span class="comment">// 若当前遍历的heights[i]比栈顶元素小，则栈顶元素出栈，计算此时面积</span></span><br><span class="line">                <span class="comment">// 先pop()后peek()，很巧妙的写法设置</span></span><br><span class="line">                <span class="comment">// 这里多减一个1主要因为之前已经pop()了，这里要减回来</span></span><br><span class="line">                maxArea = Math.max(maxArea, heights[stack.pop() ] * (i - stack.peek() - <span class="number">1</span>));</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果遍历完了一遍最后栈不为空，则再用一重循环吧栈搞空</span></span><br><span class="line">        <span class="keyword">while</span>(stack.peek() != -<span class="number">1</span>)</span><br><span class="line">            maxArea = Math.max(maxArea, heights[stack.pop()] * (len - stack.peek() - <span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，n个数字每个会被压栈弹栈各一次。</li>
<li>空间复杂度：O(n)，存放栈中元素。</li>
</ul>
<h2 id="85-Maximal-Rectangle-最大矩形-Hard"><a href="#85-Maximal-Rectangle-最大矩形-Hard" class="headerlink" title="85.Maximal Rectangle(最大矩形)(Hard)"></a><a href="https://leetcode-cn.com/problems/maximal-rectangle/" target="_blank" rel="noopener">85.Maximal Rectangle(最大矩形)(Hard)</a></h2><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing only 1’s and return its area.</p>
<p><strong>Example:</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Input</span>:</span><br><span class="line">[</span><br><span class="line">  [<span class="string">"1"</span>,<span class="string">"0"</span>,<span class="string">"1"</span>,<span class="string">"0"</span>,<span class="string">"0"</span>],</span><br><span class="line">  [<span class="string">"1"</span>,<span class="string">"0"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>],</span><br><span class="line">  [<span class="string">"1"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>],</span><br><span class="line">  [<span class="string">"1"</span>,<span class="string">"0"</span>,<span class="string">"0"</span>,<span class="string">"1"</span>,<span class="string">"0"</span>]</span><br><span class="line">]</span><br><span class="line"><span class="symbol">Output</span>: <span class="number">6</span></span><br></pre></td></tr></table></figure>
<hr>
<p>解：此题可以基于84题实现的找到矩形围成的最大面积来考虑，利用84题已经实现的函数，在遍历input的数组的时候将每一行值都记录，并且在有连续的1的时候进行累加(碰到0的话对应下标值要清空)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length, rows = matrix.length;</span><br><span class="line">        <span class="keyword">int</span>[] heights = <span class="keyword">new</span> <span class="keyword">int</span>[cols];</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 每次遍历之后都获取当前row的直方图，保存到heights中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    heights[j]++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    heights[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将当前直方图面积和之前最大面积进行比较，取一个最大值</span></span><br><span class="line">            maxArea = Math.max(maxArea, largestRectangleArea(heights));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// corner case</span></span><br><span class="line">        <span class="keyword">if</span>(heights == <span class="keyword">null</span> || heights.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 方法二，栈,O(n)</span></span><br><span class="line">        <span class="comment">// 主要目标是求能够覆盖当前第i个柱子的最大矩形，即为第i个矩形的"专属面积"</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 栈里面存放heights数组的下标，取元素的时候为：heights[stack.pop()]</span></span><br><span class="line">        stack.push(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>, len = heights.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 只有遍历的heights[i]比当前stack里面的栈顶元素大，才能跳过while循环，直接入栈</span></span><br><span class="line">            <span class="keyword">while</span>(stack.peek() != -<span class="number">1</span> &amp;&amp; heights[stack.peek()] &gt;= heights[i])</span><br><span class="line">                <span class="comment">// 若当前遍历的heights[i]比栈顶元素小，则栈顶元素出栈，计算此时面积</span></span><br><span class="line">                <span class="comment">// 先pop()后peek()，很巧妙的写法设置</span></span><br><span class="line">                <span class="comment">// 这里多减一个1主要因为之前已经pop()了，这里要减回来</span></span><br><span class="line">                maxArea = Math.max(maxArea, heights[stack.pop() ] * (i - stack.peek() - <span class="number">1</span>));</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果遍历完了一遍最后栈不为空，则再用一重循环吧栈搞空</span></span><br><span class="line">        <span class="keyword">while</span>(stack.peek() != -<span class="number">1</span>)</span><br><span class="line">            maxArea = Math.max(maxArea, heights[stack.pop()] * (len - stack.peek() - <span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(mn)。84题实现的函数的时间复杂度为O(n)，然后主函数有两个循环，但是因为内层循环和84题的函数是并列的，所以整个时间复杂度还是O(mn)</li>
</ul>
<h2 id="42-Trapping-Rain-Water-接雨水-Hard"><a href="#42-Trapping-Rain-Water-接雨水-Hard" class="headerlink" title="42.Trapping Rain Water(接雨水)(Hard)"></a><a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">42.Trapping Rain Water(接雨水)(Hard)</a></h2><p>Given <em>n</em> non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt="42接雨水"></p>
<p>The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">Output: <span class="number">6</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：本篇题解内容取材于<a href="https://leetcode-cn.com/problems/trapping-rain-water/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-8/" target="_blank" rel="noopener">这篇文章</a></p>
<p>方法一：按列求。</p>
<p>整个题目需要遍历heights的每一个元素，即每一列的值。而对于每一列，我们只需要关注当前列、当前列左边墙最高值、当前列右边墙最高值，关注这三个值。而且由于木桶效应，我们只需要看左边和右边最高值中的较小的那个即可，这样把当前左边与右边的最小值和当前列作比较，就能得出当前列能够最多盛多少水了。</p>
<p>按照题意，会有三种情况：</p>
<ol>
<li>左边与右边两个中较矮的墙的高度大于当前列的墙的高度</li>
</ol>
<p>此时用较矮的值减去当前高度，即为当前列能盛放的高度。</p>
<ol start="2">
<li>左边与右边两个中较矮的墙的高度小于当前列的墙的高度</li>
</ol>
<p>此时当前列不能盛水。</p>
<ol start="3">
<li>左边与右边两个中较矮的墙的高度等于当前列的墙的高度</li>
</ol>
<p>此时当前列也不能盛水。</p>
<p>所以，根据这三种情况写程序。外层循环遍历每一列，然后针对当前列求出这一列两边的最高的墙，并找出较矮的一端，和当前列高度比较，用上述这三种情况作为参考的结果即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 方法一，按列求</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, len = height.length;</span><br><span class="line">        <span class="comment">//最两端的列不用考虑，因为一定不会有水。所以下标从 1 到 length - 2</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len-<span class="number">1</span> ;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> maxLeft = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 找出左边最高</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i-<span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span>(height[j] &gt; maxLeft) &#123;</span><br><span class="line">                    maxLeft = height[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> maxRight = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 找出右边最高</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(height[j] &gt; maxRight) &#123;</span><br><span class="line">                    maxRight = height[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找出左右两端更小的</span></span><br><span class="line">            <span class="keyword">int</span> min = Math.min(maxLeft, maxRight);</span><br><span class="line">            <span class="comment">// 根据之前分析，此时只有min大于height[i]，才能盛水</span></span><br><span class="line">            <span class="keyword">if</span>(min &gt; height[i])</span><br><span class="line">                sum += min-height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n^2)，遍历每一列一遍需要O(n)，然后每次找出左边和右边最高的墙，加起来又需要一个O(n)，合在一起是O(n^2)</li>
<li>空间复杂度：O(1)</li>
</ul>
<p>方法二：动态规划</p>
<p>基于方法一的优化，在方法一中，我们要求当前每一列的左边界和右边界，都必须重新遍历一遍所有高度，其实可以优化的。</p>
<p>这里用<code>maxLeft[]</code>和<code>maxRight[]</code>两个数组，<code>maxLeft[i]</code>代表<strong>第i列左边最高的墙的高度</strong>，<code>maxRight[i]</code>代表<strong>第i列右边最高的墙的高度</strong>。<font color=#FF0000>注意，这里两个数组中定义的第i列的左边和右边，不包括i本身</font></p>
<p>递推公式：<code>maxLeft[i]=Max(maxLeft[i-1], height[i-1])</code>。它左边的墙的左边的最高高度和它左边墙的高度选一个作为最大的即可。这里相当于用到了”备忘录”，让之前的每一次遍历都有意义，都被记忆了。</p>
<p>类似的：<code>maxRight[i] = Max(maxRight[i+1], height[i+1])</code>。它右边墙的最高高度和它右边墙本身的高度进行比较，取最高的。</p>
<p>由此一来，就不需要像方法一那样，在内部又加了一层for循环，不用每次都去求一次i的左边和右边的最大值了，已经用两个数组分别记录好了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// corner case</span></span><br><span class="line">        <span class="keyword">if</span>(height == <span class="keyword">null</span> || height.length &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = height.length, sum = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] maxLeft = <span class="keyword">new</span> <span class="keyword">int</span>[len], maxRight = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 道理还是和之前一样，下标为0和len-1的两个地方一定没办法盛水，可以直接跳过</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            maxLeft[i] = Math.max(maxLeft[i-<span class="number">1</span>], height[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            maxRight[i] = Math.max(maxRight[i+<span class="number">1</span>], height[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把结果全部放入到maxLeft和maxRight之后，用下标统一遍历，用到了</span></span><br><span class="line">        <span class="comment">// maxLeft, maxRight, height三个数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = Math.min(maxLeft[i], maxRight[i]);</span><br><span class="line">            <span class="keyword">if</span>(min &gt; height[i]) &#123;</span><br><span class="line">                sum += min - height[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)，保存每一列左边最高边界和右边最高边界</li>
</ul>
<p>方法三：动态规划在空间复杂度上的优化，<strong>双指针</strong>，时间复杂度为O(n)，时间复杂度为O(1)</p>
<p>动态规划中maxLeft[]和maxRight[]这两个数组中每个元素我们每次只用一次，之后不会再用，所以我们不需要用数组，用一个元素就够了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// corner case</span></span><br><span class="line">        <span class="keyword">if</span>(height == <span class="keyword">null</span> || height.length &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 方法三，双指针</span></span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>,leftmax = <span class="number">0</span>,rightmax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            leftmax = Math.max(leftmax, height[i]);</span><br><span class="line">            rightmax = Math.max(rightmax, height[j]);</span><br><span class="line">            <span class="keyword">if</span>(leftmax &lt; rightmax) &#123;</span><br><span class="line">                maxArea += leftmax - height[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                maxArea += rightmax - height[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法四：栈</p>
<p>这里用的，实际上在空间复杂度上不如方法三，但是用到栈的思路还是很巧妙的。</p>
<p>首先，这道题和括号匹配问题非常相似。我们可以每找到对应的两堵墙，就计算存储的水量，用栈保存每堵墙。</p>
<p>当遍历墙的高度的时候，如果当前高度小于栈顶的墙高度，说明这里会有积水，我们将墙的高度的下标入栈。</p>
<p>如果当前高度大于栈顶的墙的高度，说明之前的积水到这里停下，我们可以计算下有多少积水了。计算完，就把当前的墙继续入栈，作为新的积水的墙。</p>
<p>总体原则：</p>
<ol>
<li>当前高度小于等于栈顶高度，将墙的下标值入栈，后移指针。</li>
<li>当前高度大于栈顶高度，出栈，计算当前墙和当前栈顶值的差值，为可存储的水量。然后用当前墙高度再和栈的新栈顶比较，重复两个判断，一直到当前墙的高度不大于栈顶高度或者栈为空，再把当前墙入栈，指针后移。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap6</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (current &lt; height.length) &#123;</span><br><span class="line">        <span class="comment">//如果栈不空并且当前指向的高度大于栈顶高度就一直循环</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.empty() &amp;&amp; height[current] &gt; height[stack.peek()]) &#123;</span><br><span class="line">            <span class="keyword">int</span> h = height[stack.peek()]; <span class="comment">//取出要出栈的元素</span></span><br><span class="line">            stack.pop(); <span class="comment">//出栈</span></span><br><span class="line">            <span class="keyword">if</span> (stack.empty()) &#123; <span class="comment">// 栈空就出去</span></span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> distance = current - stack.peek() - <span class="number">1</span>; <span class="comment">//两堵墙之前的距离。</span></span><br><span class="line">            <span class="keyword">int</span> min = Math.min(height[stack.peek()], height[current]);</span><br><span class="line">            sum = sum + distance * (min - h);</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(current); <span class="comment">//当前指向的墙入栈</span></span><br><span class="line">        current++; <span class="comment">//指针后移</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="394-Decode-String-字符串解码-Mid"><a href="#394-Decode-String-字符串解码-Mid" class="headerlink" title="394.Decode String(字符串解码)(Mid)"></a><a href="https://leetcode-cn.com/problems/decode-string/" target="_blank" rel="noopener">394.Decode String(字符串解码)(Mid)</a></h2><p>Given an encoded string, return its decoded string.</p>
<p>The encoding rule is: <code>k[encoded_string]</code>, where the <em>encoded_string</em> inside the square brackets is being repeated exactly <em>k</em> times. Note that <em>k</em> is guaranteed to be a positive integer.</p>
<p>You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.</p>
<p>Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won’t be input like <code>3a</code> or <code>2[4]</code>.</p>
<p><strong>Examples:</strong></p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">s</span> = <span class="string">"3[a]2[bc]"</span>, return <span class="string">"aaabcbc"</span>.</span><br><span class="line"><span class="attribute">s</span> = <span class="string">"3[a2[c]]"</span>, return <span class="string">"accaccacc"</span>.</span><br><span class="line"><span class="attribute">s</span> = <span class="string">"2[abc]3[cd]ef"</span>, return <span class="string">"abcabccdcdcdef"</span>.</span><br></pre></td></tr></table></figure>

<hr>
<p>解：举个例子，<code>s=&quot;3[a2[c]]&quot;</code></p>
<p>这道题最后我们用StringBuilder记录目前为止字符的长度，然后需要用到两个栈进行辅助，分别是Integer和String泛型的栈，一个(numStack)用于保存当前字符重复的遍数,另一个(strStack)用于保存当前要重复的字符,需要它的原因是，哪怕你知道了某一个字符要重复的遍数，你还需要知道它前面还有什么字符，可能它前面的需要和它一起重复。</p>
<p>拿例子来说，走到了<code>2[c]</code>的时候，tail这个StringBuilder就是”c”，numStack就是2</p>
<p>具体入栈规则：</p>
<p>String泛型栈：每当遇到左括号的时候，要把之前记录的String(在StringBuilder里面保存着)都push到strStack，当然这个StringBuilder本身不会变化</p>
<p>Integer泛型栈：碰到数字就入这个栈，用来记录某一段字符串要重复的次数。</p>
<p>直到遍历到右括号，开始出栈。首先从numStack中pop()出一个数字，</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public String decode<span class="constructor">String(String <span class="params">s</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 存储当前字符需要重复的遍数</span></span><br><span class="line">        Stack&lt;Integer&gt; numStack = <span class="keyword">new</span> Stack&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">        <span class="comment">// 记录前面没有数字的，"落单"的字母</span></span><br><span class="line">        Stack&lt;String&gt; strStack = <span class="keyword">new</span> Stack&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">        <span class="comment">// 记录迄今为止的解码结果</span></span><br><span class="line">        StringBuilder tail = <span class="keyword">new</span> <span class="constructor">StringBuilder()</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> n = s.length<span class="literal">()</span>;</span><br><span class="line">        </span><br><span class="line">        for(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">char</span> c = s.<span class="built_in">char</span><span class="constructor">At(<span class="params">i</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="module-access"><span class="module"><span class="identifier">Character</span>.</span></span>is<span class="constructor">Digit(<span class="params">c</span>)</span>) &#123; <span class="comment">// 第一种情况，当前遍历的为数字</span></span><br><span class="line">                <span class="built_in">int</span> num = c - <span class="character">'0'</span>;</span><br><span class="line">                <span class="comment">// 因为前面的数字可能有十位、百位等，所以要循环判断</span></span><br><span class="line">                <span class="keyword">while</span>(<span class="module-access"><span class="module"><span class="identifier">Character</span>.</span></span>is<span class="constructor">Digit(<span class="params">s</span>.<span class="params">charAt</span>(<span class="params">i</span> + 1)</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 每往后一位，num相当于要乘10再加上新数字</span></span><br><span class="line">                    num = num<span class="operator"> * </span><span class="number">10</span> + s.<span class="built_in">char</span><span class="constructor">At(<span class="params">i</span> + 1)</span> - <span class="character">'0'</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                numStack.push(num);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(c<span class="operator"> == </span><span class="character">'['</span>) &#123; <span class="comment">// 每当遇到左括号，就开始存encoded_string</span></span><br><span class="line">                <span class="comment">// 具体做法就是把当前tail的所有内容都push进strStack，然后重新定义一个StringBuilder记录</span></span><br><span class="line">                <span class="comment">// 被加密的内层的字符串</span></span><br><span class="line">                strStack.push(tail.<span class="keyword">to</span><span class="constructor">String()</span>);</span><br><span class="line">                <span class="comment">// 清空tail</span></span><br><span class="line">                tail = <span class="keyword">new</span> <span class="constructor">StringBuilder()</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(c<span class="operator"> == </span><span class="character">']'</span>) &#123;</span><br><span class="line">                <span class="comment">// 碰到右括号，首先把落单的，在被加密的字符的前面的字符pop出来</span></span><br><span class="line">                StringBuilder temp = <span class="keyword">new</span> <span class="constructor">StringBuilder(<span class="params">strStack</span>.<span class="params">pop</span>()</span>);</span><br><span class="line">                <span class="comment">// 记录当前被加密的内容的重复的次数，从numStack里面pop()即可</span></span><br><span class="line">                <span class="built_in">int</span> repeatedTimes = numStack.pop<span class="literal">()</span>;</span><br><span class="line">                <span class="comment">// 解码的过程，持续将tail的内容放入到temp，从而变成："非加密+加密*次数"</span></span><br><span class="line">                for(<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; repeatedTimes; j++) &#123;</span><br><span class="line">                    temp.append(tail);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 保存当前生成的temp值</span></span><br><span class="line">                tail = temp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return tail.<span class="keyword">to</span><span class="constructor">String()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithms Note</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Array,LinkedList,SkipList</title>
    <url>/2019/12/28/LeetCode-Practice-by-Categories/</url>
    <content><![CDATA[<blockquote>
<p>天才是长期劳动的结果。 —— 牛顿</p>
</blockquote>
<p>包含大量LeetCode链表、数组相关题目及其解决思路和具体代码。</p>
<a id="more"></a>

<p>点击题目链接为中国站题目，页面附上英文题目。</p>
<p><strong>对于链表，在操作上实际是有需要注意的地方的。</strong><br><font color=#FF0000></p>
<ol>
<li>利用快慢指针(有时候需要用到三个指针)。例如，链表翻转、寻找倒数第k个元素、寻找链表中间元素、判断链表是否有环</font><font color=#FF0000></li>
<li>构建一个虚假的链表头，一般用在需要返回一个新的链表的题目中。(整合两个有序链表、整合奇数偶数链表)。如果不创建空的链表头，每次都要多一个if else判断头结点是否为空。</font>

</li>
</ol>
<p>第二点也可以理解成是一个小技巧：对于链表问题，返回结果为头结点时，通常需要先初始化一个预先指针 pre，该指针的下一个节点指向真正的头结点head。<strong>使用预先指针的目的在于链表初始化时无可用节点值，而且链表构造过程需要指针移动，进而会导致头指针丢失，无法返回结果</strong>。</p>
<h1 id="数组、链表、跳表"><a href="#数组、链表、跳表" class="headerlink" title="数组、链表、跳表"></a>数组、链表、跳表</h1><h2 id="283-Move-zeros-移动零-Easy"><a href="#283-Move-zeros-移动零-Easy" class="headerlink" title="283.Move zeros(移动零)(Easy)"></a><a href="https://leetcode-cn.com/problems/move-zeroes/?utm_source=LCUS&utm_medium=ip_redirect_q_uns&utm_campaign=transfer2china" target="_blank" rel="noopener">283.Move zeros(移动零)(Easy)</a></h2><p>Given an array <code>nums</code> , write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.</p>
<p><strong>Examples:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">12</span>]</span><br><span class="line">Output: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ol>
<li>You must do this in-place without making a copy of the array.</li>
<li>Minimize the total number of operations.</li>
</ol>
<hr>
<p>解：这道题可以使用双指针思想很简洁代码解决。用i作为指针，只要之前元素不为0，就把它移动到j的位置上去，把i位置的元素赋值为0. 但是需要注意corner case, 如果传入的数据全都是非0，那么i和j始终相等，不能给任何元素赋值为0.</p>
<p>需要注意指针j什么时候递增，<strong>只要i指的位置不为零，j就要往后移动</strong>，j用来记录从左到右，下一个非0元素的位置.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                nums[j] = nums[i];</span><br><span class="line">                <span class="keyword">if</span>(i != j) &#123;</span><br><span class="line">                    nums[i] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)，一重循环</p>
<p>空间复杂度：O(1)，按照题目要求，不能使用额外数组空间</p>
<h2 id="11-Container-With-Most-Water-盛水最多的容器-Mid"><a href="#11-Container-With-Most-Water-盛水最多的容器-Mid" class="headerlink" title="11.Container With Most Water(盛水最多的容器)(Mid)"></a><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">11.Container With Most Water(盛水最多的容器)(Mid)</a></h2><p>Given n non-negative integers <em>a1, a2, …, an</em> , where each represents a point at coordinate <em>(i, ai)</em>. <em>n</em> vertical lines are drawn such that the two endpoints of line <em>i</em> is at <em>(i, ai)</em> and <em>(i, 0)</em>. Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>
<p><strong>Note</strong>: You may not slant the container and n is at least 2.</p>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg" alt=""></p>
<p>The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.</p>
<p><strong>Example</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">7</span>]</span><br><span class="line">Output: <span class="number">49</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：<strong>方法一</strong>，枚举。记录左边bar x, 右边 bar y，遍历每一个x和y的组合，计算(x-y)*height_diff，但是时间复杂度太高了，O(n^2)，显然不是最优解法。</p>
<p>但是这里可以回顾一下遍历数组的固定写法，形成机械记忆，一定要熟悉。</p>
<p>正常遍历一维数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.length; i++) &#123;</span><br></pre></td></tr></table></figure>

<p>遍历二维数组，实现 i 和 j 两个下标对数组的遍历，而且 i 和 j 不会重复</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; height.length; j++) &#123;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一段二维数组的遍历应当形成肌肉式记忆。 整个遍历过程中，j 总是比 i 大，最后j到了最后一个元素，i还在前面。当然，这种暴力的方式很慢，开销很大。</p>
<p><strong>方法二</strong>，从左边和右边开始往中间收敛（或者理解是左右往中间夹逼）。<strong>因为肯定是外面的棒子组成的面积更大。如果内部的棒子高度也不如外面，那么组成的面积肯定比外面小</strong>，这里可以看做是一个tricky的点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//循环初始条件巧妙，很简洁</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = height.length-<span class="number">1</span>; i &lt; j;) &#123;</span><br><span class="line">            <span class="comment">// 这句话真的很巧妙，也侧面利用了类似i++和++i的语法内容，把下标的挪动放在了比较选择更低的那一端，会更舒服</span></span><br><span class="line">            <span class="keyword">int</span> minHeight = (height[i] &lt; height[j]) ? height[i++] : height[j--];</span><br><span class="line">            <span class="comment">//这里加一是一因为经过上面选择最小内容之后的操作，两个点之间的宽度减小了1，这里加回来</span></span><br><span class="line">            <span class="keyword">int</span> area = (j-i+<span class="number">1</span>) * minHeight;</span><br><span class="line">            max = Math.max(area,max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>i 和 j 是左下标和右下标，哪个棒子更矮，就挪动哪个。</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<h2 id="1-Two-Sum-两数之和-Easy"><a href="#1-Two-Sum-两数之和-Easy" class="headerlink" title="1. Two Sum(两数之和)(Easy)"></a><a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">1. Two Sum(两数之和)(Easy)</a></h2><p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have <strong><em>exactly</em></strong> one solution, and you may not use the same element twice.</p>
<p><strong>Example:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Given nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span>,</span><br><span class="line"></span><br><span class="line">Because nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span>,</span><br><span class="line"><span class="keyword">return</span> [<span class="number">0</span>, <span class="number">1</span>].</span><br></pre></td></tr></table></figure>

<hr>
<p>解：<font color=#FF0000>这里给出两个解法，第一个无脑双指针遍历，第二个基于哈希表，是正解。</font></p>
<p><strong>方法一</strong>，两重循环，枚举下标，如果下标对应的内容相加可以达成target，那么完成。但是这种方法时间复杂度较大，O(n^2)</p>
<p>直接可以利用之前讲过的双指针遍历的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    result[<span class="number">0</span>] = i;</span><br><span class="line">                    result[<span class="number">1</span>] = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码可以通过，但是性能怎么样？——某次LeetCode的统计结果是，击败8%用户。<font color=#FF0000>所以如果你面试只想到了这个方法，刷刷写完了，没后续了，还很得意，那对不起，你的面试肯定过不了。除非其他候选者连这个方法都没想到。</font></p>
<p><strong>方法二</strong>,保持数组中的每个元素与其索引相互对应的最好方式是什么？当然是基于数组的哈希表。利用哈希表先把内容存储起来，这样一来查找的过程只需要O(1)了。</p>
<p>这个map中，key是nums元素的值，value是该元素的下标。因为要找到a+b = target,所以 a = target - b，所以查找 target-a 在不在数组里面即可。</p>
<p>注意</p>
<ol>
<li>这里是把元素当做key，该元素的位置当做value。</li>
<li>虽然看起来 <code>map.put(nums[i], i)</code> 这句放在循环体里的前面和后面都可以，但是其实是不能放在前面的，否则如果某个元素的值是target的二分之一，先把它添加进map之后再比较，会直接比较到它自己。换句话说，必须先比较，再put进map。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                result[<span class="number">0</span>] = i;</span><br><span class="line">                result[<span class="number">1</span>] = map.get(target - nums[i]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 注意这里put不能放在判断前面，必须先比较再放入。否则如果某个元素是target的一半，先添加再比较的话，会比较到它自己。</span></span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="167-Two-Sum-II-两数之和-II-输入有序数组-Easy"><a href="#167-Two-Sum-II-两数之和-II-输入有序数组-Easy" class="headerlink" title="167. Two Sum - II(两数之和 II - 输入有序数组)(Easy)"></a><a href="(https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)">167. Two Sum - II(两数之和 II - 输入有序数组)(Easy)</a></h2><p>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。</p>
<p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p>
<p>说明:</p>
<p>返回的下标值（index1 和 index2）不是从零开始的。<br>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。<br>示例:</p>
<p>输入: numbers = [2, 7, 11, 15], target = 9<br>输出: [1,2]<br>解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</p>
<hr>
<p>解：</p>
<p>因为输入的数组是有序的了，所以做法和第一题的两数之和完全不同了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = numbers.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = numbers[i] + numbers[j];</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i+<span class="number">1</span>, j+<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-3Sum-三数之和-Mid"><a href="#15-3Sum-三数之和-Mid" class="headerlink" title="15. 3Sum(三数之和)(Mid)"></a><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">15. 3Sum(三数之和)(Mid)</a></h2><p>Given an array <code>nums</code> of <em>n</em> integers, are there elements <em>a, b, c</em> in <code>nums</code> such that <em>a + b + c</em> = 0? Find all unique triplets in the array which gives the sum of zero.</p>
<p><strong>Note:</strong><br>The solution set must not contain duplicate triplets.(答案不能包含重复三元组)</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Given <span class="built_in">array</span> nums = [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-4</span>],</span><br><span class="line"></span><br><span class="line">A solution <span class="keyword">set</span> <span class="keyword">is</span>:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">2</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<hr>
<p>解：这道三数之和其实是第一题两数之和的升级版本。</p>
<p>方法一：暴力求解，和第一题非常相似，但是时间复杂度为O(n^3)，非常高。</p>
<p>方法二，用类似第一题的哈希表，时间复杂度可以降到O(n^2)</p>
<p>方法三，用左右下标夹逼的方法。其实很难直接想到，比较tricky。</p>
<p>方法三的解法详解：<a href="https://leetcode-cn.com/problems/3sum/solution/hua-jie-suan-fa-15-san-shu-zhi-he-by-guanpengchn/" target="_blank" rel="noopener">点击这里</a></p>
<p>需要注意题目输入的nums中可能有重复的元素；最后返回的答案不能有重复的三元组。</p>
<p>步骤：</p>
<ol>
<li>排序（排好序之后非常利于判重）</li>
<li>循环，因为有3个指针，循环length-2即可</li>
<li>设置判断条件，初始化指针位置</li>
<li>遍历找符合条件的3个数，一路上都要注意判重</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);<span class="comment">// 默认有小到大排序，先排序</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">		<span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="comment">// 有三个指针，循环 nums.length-2 次就够了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len-<span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> || (i &gt; <span class="number">0</span> &amp;&amp; nums[i] != nums[i-<span class="number">1</span>])) &#123; <span class="comment">//第二个条件是去重</span></span><br><span class="line">                <span class="keyword">int</span> lo = i+<span class="number">1</span>, hi = len-<span class="number">1</span>, sum = <span class="number">0</span>-nums[i];</span><br><span class="line">                <span class="keyword">while</span>(lo &lt; hi) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[lo] + nums[hi] == sum) &#123;</span><br><span class="line">                        <span class="comment">// asList是Arrays的工具类，能把数组转化成List，但是注意只能转换包装类，不能转换基本数据类型</span></span><br><span class="line">                    <span class="comment">// 此外asList不支持add和remove方法。</span></span><br><span class="line">                    <span class="comment">// 把所有数组里的内容丢到asList的参数里面来直接把几个数变成list，看得出技巧熟练</span></span><br><span class="line">                        res.add(Arrays.asList(nums[i], nums[lo],nums[hi]));</span><br><span class="line">                        <span class="keyword">while</span>(lo &lt; hi &amp;&amp; nums[lo] == nums[lo+<span class="number">1</span>]) lo++;</span><br><span class="line">                        <span class="keyword">while</span>(lo &lt; hi &amp;&amp; nums[hi] == nums[hi-<span class="number">1</span>]) hi--;</span><br><span class="line">                        lo++;hi--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[lo] + nums[hi] &lt; sum) lo++; <span class="comment">// lo++ 把和变大</span></span><br><span class="line">                    <span class="keyword">else</span> hi--; <span class="comment">// hi-- 把和变小</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="206-Reverse-LinkedList-反转链表-Easy"><a href="#206-Reverse-LinkedList-反转链表-Easy" class="headerlink" title="206. Reverse LinkedList(反转链表)(Easy)"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">206. Reverse LinkedList(反转链表)(Easy)</a></h2><p>Reverse a singly linked list.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL</span><br><span class="line">Output: <span class="number">5</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br></pre></td></tr></table></figure>

<p><strong>Follow up:</strong></p>
<p>A linked list can be reversed either iteratively or recursively. Could you implement both?</p>
<hr>
<p>解：就按照题目，给出迭代(iteratively)和递归(recursively)两种方法的解法。</p>
<p><strong>方法一：栈</strong></p>
<p>这个方法是参考Kevin大神的思路，因为要反转整个链表，所以最直接的想法就是依次遍历整个链表之后把每一个节点都放到栈里，然后再反过来取出来。但是这样的做法会使得空间复杂度很高，这点可以在方法二的迭代中得到优化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(head);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode dummyNode = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        head = dummyNode;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 注意这里需要用current接住pop出来的节点，否则</span></span><br><span class="line">            <span class="comment">// pop()之后就没了</span></span><br><span class="line">            ListNode current = stack.pop();</span><br><span class="line">            head.next = <span class="keyword">new</span> ListNode(current.val);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>方法二：迭代</strong></p>
<p>可以直接利用head，也只需要新定义两个ListNode</p>
<p>具体相等操作的过程可以记成修改指针指向的四步走。</p>
<p>总的来说，head总是在newHeader的next的位置，nextTemp总是在head的next的位置。</p>
<p>反转的四步：</p>
<ol>
<li>用nextTemp记录保存head.next</li>
<li>将head.next往前指，即指向newHeader</li>
<li>将newHeader往前移动一个位置指到head</li>
<li>把head往前一个位置，让其与nextTemp位置相同。但是因为下一次循环nextTemp又会在head.next的位置，所以不影响后面的反转。</li>
</ol>
<p>当跳出循环的时候，head为null，newHeader为反转后的链表的头结点，返回newHeader即可，不像方法一那样从0重新构建一个链表然后返回dummyNode.next。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode newHeader = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 最后返回的时候head为null，返回newHeader即可</span></span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 第一步，记录head的next，避免head.next丢失</span></span><br><span class="line">            ListNode nextTemp = head.next;</span><br><span class="line">            <span class="comment">// 第二部，翻转操作，把原先的head.next指向前面</span></span><br><span class="line">            head.next = newHeader;</span><br><span class="line">            <span class="comment">// newHeader指向旧的head的位置</span></span><br><span class="line">            newHeader = head;</span><br><span class="line">            <span class="comment">// head往后移动</span></span><br><span class="line">            head = nextTemp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHeader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法三：递归</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        ListNode newHeader = reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newHeader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对递归方法值得注意的是，因为newHeader没有被动过，所以在一开始递归结束的时候，就返回的是反转之后的链表的新的head，也就是这个newHeader，所以最后的结果就是每一层的递归返回的都是一开始递归返回的newHeader，问题就迎刃而解了。</p>
<h2 id="92-Reverse-LinkedList-II-反转链表II-Mid"><a href="#92-Reverse-LinkedList-II-反转链表II-Mid" class="headerlink" title="92. Reverse LinkedList II(反转链表II)(Mid)"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">92. Reverse LinkedList II(反转链表II)(Mid)</a></h2><p>Reverse a linked list from position <em>m</em> to <em>n</em>. Do it in one-pass.</p>
<p>Note: 1 ≤ <em>m ≤ n</em> ≤ length of list.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL, m = <span class="number">2</span>, n = <span class="number">4</span></span><br><span class="line">Output: <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span>-&gt;NULL</span><br></pre></td></tr></table></figure>

<hr>
<p>解：和数组不同，这里的反转下标从1开始。需要初始化一个dummy节点代表0号节点，然后开始遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create a dummy node to mark the head of this list</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>); </span><br><span class="line">        dummy.next = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// make a pointer pre as a marker for the node before reversing</span></span><br><span class="line">        ListNode pre = dummy; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m-<span class="number">1</span>; i++) pre = pre.next;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// a pointer to the beginning of a sub-list that will be reversed</span></span><br><span class="line">        ListNode start = pre.next; </span><br><span class="line">        <span class="comment">// a pointer to a node that will be reversed</span></span><br><span class="line">        ListNode then = start.next; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1 - 2 -3 - 4 - 5 ; m=2; n =4 ---&gt; pre = 1, start = 2, then = 3</span></span><br><span class="line">    <span class="comment">// dummy-&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n-m; i++) &#123;</span><br><span class="line">        start.next = then.next;</span><br><span class="line">        then.next = pre.next;</span><br><span class="line">        pre.next = then;</span><br><span class="line">        then = start.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// first reversing : dummy-&gt;1 - 3 - 2 - 4 - 5; pre = 1, start = 2, then = 4</span></span><br><span class="line">    <span class="comment">// second reversing: dummy-&gt;1 - 4 - 3 - 2 - 5; pre = 1, start = 2, then = 5 (finish)</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="141-Linked-List-Cycle-环形链表-Easy"><a href="#141-Linked-List-Cycle-环形链表-Easy" class="headerlink" title="141. Linked List Cycle(环形链表)(Easy)"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">141. Linked List Cycle(环形链表)(Easy)</a></h2><p>Given a linked list, determine if it has a cycle in it.</p>
<p>To represent a cycle in the given linked list, we use an integer <code>pos</code> which represents the position (0-indexed) in the linked list where tail connects to. If <code>pos</code> is <code>-1</code>, then there is no cycle in the linked list.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: head = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">-4</span>], pos = <span class="number">1</span></span><br><span class="line">Output: <span class="literal">true</span></span><br><span class="line">Explanation: There <span class="keyword">is</span> a cycle <span class="keyword">in</span> the linked list, </span><br><span class="line">where tail connects to the second node.</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt=""></p>
<p><strong>Example 2:</strong></p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">Input:<span class="built_in"> head</span> = [<span class="number">1</span>,<span class="number">2</span>], pos = <span class="number">0</span></span><br><span class="line">Output:<span class="built_in"> true</span></span><br><span class="line">Explanation: There <span class="literal">is</span> a cycle <span class="keyword">in</span> the linked list, <span class="keyword">where</span><span class="built_in"> tail</span> connects <span class="keyword">to</span> the first <span class="type">node</span>.</span><br></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" alt=""></p>
<p><strong>Example 3:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="string">head</span> <span class="string">=</span> <span class="string">[1],</span> <span class="string">pos</span> <span class="string">=</span> <span class="number">-1</span></span><br><span class="line"><span class="attr">Output:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">Explanation:</span> <span class="string">There</span> <span class="string">is</span> <span class="literal">no</span> <span class="string">cycle</span> <span class="string">in</span> <span class="string">the</span> <span class="string">linked</span> <span class="string">list.</span></span><br></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png" alt=""></p>
<p><strong>Follow up:</strong></p>
<p>Can you solve it using O(1) (i.e. constant) memory?</p>
<hr>
<p>解：题目中虽然说会用pos明显标出成环的链表情况，而且貌似人用眼睛可以非常直接地发现，pos只要不是-1就一定有环，但是传入的参数没有pos,不能直接使用它。</p>
<p>判断链表成环可以有思维上的巧妙性，主要是快慢指针的使用。</p>
<p>解法一，用哈希表，但是不符合进阶要求，时间复杂度和空间复杂度都是O(n)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        Set&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(head)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set.add(head);</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，如果没有了解，很难想到的双指针法（其实之前很多题目已经用到了双指针，比如283题移动零、11题盛水容器、15题三数之和等。三数之和甚至用到了三指针。）</p>
<p>时间复杂度为O(n)，但是符合空间复杂度为O(1)的要求因为它是在原有的链表上进行操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 一开始考虑边界条件，head或head.next可能为空，那么slow或fast就有一个</span></span><br><span class="line">        <span class="comment">// 会是空指针异常了。这个边界条件考虑得很重要</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head.next;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast) &#123;</span><br><span class="line">            <span class="comment">// 只要链表有环，fast和fast.next一定不会为null，会一直走下去</span></span><br><span class="line">            <span class="comment">// 不可能跳出false</span></span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="142-Linked-List-Cycle-II-环形链表II-Mid"><a href="#142-Linked-List-Cycle-II-环形链表II-Mid" class="headerlink" title="142. Linked List Cycle II(环形链表II)(Mid)"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">142. Linked List Cycle II(环形链表II)(Mid)</a></h2><p>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.</p>
<p>To represent a cycle in the given linked list, we use an integer <code>pos</code> which represents the position (0-indexed) in the linked list where tail connects to. If <code>pos</code> is <code>-1</code>, then there is no cycle in the linked list.</p>
<p><strong>Note</strong>: Do not modify the linked list.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">Input:<span class="built_in"> head</span> = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,-<span class="number">4</span>], pos = <span class="number">1</span></span><br><span class="line">Output:<span class="built_in"> tail</span> connects <span class="keyword">to</span> <span class="type">node</span> index <span class="number">1</span></span><br><span class="line">Explanation: There <span class="literal">is</span> a cycle <span class="keyword">in</span> the linked list, <span class="keyword">where</span><span class="built_in"> tail</span> connects <span class="keyword">to</span> the second <span class="type">node</span>.</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt=""></p>
<p><strong>Example 2:</strong></p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">Input:<span class="built_in"> head</span> = [<span class="number">1</span>,<span class="number">2</span>], pos = <span class="number">0</span></span><br><span class="line">Output:<span class="built_in"> tail</span> connects <span class="keyword">to</span> <span class="type">node</span> index <span class="number">0</span></span><br><span class="line">Explanation: There <span class="literal">is</span> a cycle <span class="keyword">in</span> the linked list, <span class="keyword">where</span><span class="built_in"> tail</span> connects <span class="keyword">to</span> the first <span class="type">node</span>.</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" alt=""></p>
<p><strong>Example 3:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="string">head</span> <span class="string">=</span> <span class="string">[1],</span> <span class="string">pos</span> <span class="string">=</span> <span class="number">-1</span></span><br><span class="line"><span class="attr">Output:</span> <span class="literal">no</span> <span class="string">cycle</span></span><br><span class="line"><span class="attr">Explanation:</span> <span class="string">There</span> <span class="string">is</span> <span class="literal">no</span> <span class="string">cycle</span> <span class="string">in</span> <span class="string">the</span> <span class="string">linked</span> <span class="string">list.</span></span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png" alt=""></p>
<p><strong>Follow-up:</strong><br>Can you solve it without using extra space?</p>
<hr>
<p>解：还是两个方法，快慢指针是环形链表相关的常用方法。</p>
<p>方法一，哈希表。虽然不符合进阶要求，但是可以解决。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        Set&lt;ListNode&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        ListNode node = head;</span><br><span class="line">        <span class="keyword">while</span>( node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(visited.contains(node)) &#123;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">            visited.add(node);</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这个方法在空间上开辟了新的空间给哈希表。</p>
<p>方法二，快慢指针，空间复杂度为O(1)。和单独判断链表是否成环的操作类似，第一次先让fast和slow指针跑一遍，如果fast或fast.next为null了，就证明不存在成环，返回null。</p>
<p>如果相遇了，证明有环。此时怎么找到环的起点呢？</p>
<p>此时让fast重新从head开始遍历，<strong>但是这回fast一次走一步</strong>，这样的话当fast和slow再次相遇的时候，它们俩都指向的节点，就是环开始的节点。</p>
<p>这个原因可以用数学公式推到的。因为fast每次走2步(假设fast指针一共走了f步)，slow每次走1步(假设slow指针一共走了s步)，所以两者相遇的时候fast总共走了2s步(f = 2s)，而fast又比slow多走了n个环的周长(不一定是1个环的长度，可能f已经走过了很多次环s才和f相遇)，所以f=s+nb</p>
<p>两式相减，得到：f = 2nb, s = nb,即<code>fast</code>和<code>slow</code>分别走了2n，n个环的周长。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 方法二，快慢指针，也叫Floyd算法</span></span><br><span class="line">        ListNode fast = head, slow = head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一次相遇之后，让fast回到head，再一次走一步，这样当slow和fast再相遇的时候，slow位置就是环入口</span></span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != slow) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(N),第二次相遇中，慢指针须走步数 a &lt; a + b；第一次相遇中，慢指针须走步数 a + b - x &lt; a + b其中 x 为双指针重合点与环入口距离；因此总体为线性复杂度；</li>
<li>空间复杂度：O(1)：双指针使用常数大小的额外空间。</li>
</ul>
<h2 id="24-Swap-Nodes-in-Pairs-两两交换链表中的节点-Mid"><a href="#24-Swap-Nodes-in-Pairs-两两交换链表中的节点-Mid" class="headerlink" title="24. Swap Nodes in Pairs(两两交换链表中的节点)(Mid)"></a><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">24. Swap Nodes in Pairs(两两交换链表中的节点)(Mid)</a></h2><p>Given a linked list, swap every two adjacent nodes and return its head.</p>
<p>You may <strong>not</strong> modify the values in the list’s nodes, only nodes itself may be changed.</p>
<p><strong>Example:</strong><br><code>Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</code></p>
<hr>
<p>解：<br>方法一，递归，开销较大。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// terminator</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// process current logic</span></span><br><span class="line">        ListNode node = head.next;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// drill down</span></span><br><span class="line">        head.next = swapPairs(node.next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// reverse current state</span></span><br><span class="line">        node.next = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，非递归：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode pre = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode temp = pre;</span><br><span class="line">        pre.next = head;</span><br><span class="line">        <span class="keyword">while</span>(temp.next != <span class="keyword">null</span> &amp;&amp; temp.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode start = temp.next;</span><br><span class="line">            ListNode end = temp.next.next;</span><br><span class="line">            temp.next = end;</span><br><span class="line">            start.next = end.next;</span><br><span class="line">            end.next = start;</span><br><span class="line">            temp = start;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比于递归，非递归的写法实际对链表指针的操作更明显，需要注意在改变指针的过程中需要利用临时指针temp.next和temp.next.next分别定义start和end的位置。将start和end指向的节点反转之后将temp位置改变再重新定义start和end的位置从而重新操作。</p>
<p>具体过程可以如下图所示：</p>
<p><img src="https://s2.ax1x.com/2020/01/04/ldDjSA.jpg" alt="ldDjSA.jpg"></p>
<h2 id="25-Reverse-Nodes-in-k-Group-k个一组翻转链表-Hard"><a href="#25-Reverse-Nodes-in-k-Group-k个一组翻转链表-Hard" class="headerlink" title="25. Reverse Nodes in k-Group(k个一组翻转链表)(Hard)"></a><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">25. Reverse Nodes in k-Group(k个一组翻转链表)(Hard)</a></h2><p>Given a linked list, reverse the nodes of a linked list <em>k</em> at a time and return its modified list.</p>
<p><em>k</em> is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of <em>k</em> then left-out nodes in the end should remain as it is.</p>
<p><strong>Example:</strong></p>
<p>Given this linked list:  <code>1-&gt;2-&gt;3-&gt;4-&gt;5</code></p>
<p>For k = 2, you should return: <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code></p>
<p>For k = 3, you should return: <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code></p>
<p><strong>Note:</strong></p>
<ul>
<li><p>Only constant extra memory is allowed.</p>
</li>
<li><p>You may not alter the values in the list’s nodes, only nodes itself may be changed.</p>
</li>
</ul>
<hr>
<p>解：提供递归和非递归两种解法。</p>
<p>方法一，递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span> &amp;&amp; count != k) &#123; <span class="comment">// To find the k+1 node</span></span><br><span class="line">            curr = curr.next;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(count == k) &#123;</span><br><span class="line">            curr = reverseKGroup(curr, k); <span class="comment">// reverse list with k+1 node as head</span></span><br><span class="line">            <span class="comment">// head - head-pointer to direct part</span></span><br><span class="line">            <span class="comment">// curr - head-pointer to reversed part</span></span><br><span class="line">            <span class="keyword">while</span>(count-- &gt; <span class="number">0</span>) &#123; <span class="comment">// reverse the k-group</span></span><br><span class="line">                ListNode tmp = head.next; <span class="comment">//tmp - next head in direct part</span></span><br><span class="line">                head.next = curr; <span class="comment">// preappending "direct" head to the reversed list</span></span><br><span class="line">                curr = head; <span class="comment">//move head of reversed part to a new node</span></span><br><span class="line">                head = tmp; <span class="comment">// move ""direct" head to the next node in direct part</span></span><br><span class="line">            &#125;</span><br><span class="line">            head = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归写法在找到k组节点之后的反转操作和单纯的链表翻转的节点指针的改变操作相同，即把第206题翻转链表非递归写法提取了出来。</p>
<p>方法二，非递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        </span><br><span class="line">        ListNode pre = dummy;</span><br><span class="line">        ListNode end = dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(end.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k &amp;&amp; end != <span class="keyword">null</span>; i++) &#123;</span><br><span class="line">                end = end.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(end == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode start = pre.next;</span><br><span class="line">            ListNode next = end.next;</span><br><span class="line">            end.next = <span class="keyword">null</span>;</span><br><span class="line">            pre.next = reverse(start);</span><br><span class="line">            start.next = next;</span><br><span class="line">            pre = start;</span><br><span class="line">            end = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode next = curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细题解：<br><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/solution/tu-jie-kge-yi-zu-fan-zhuan-lian-biao-by-user7208t/" target="_blank" rel="noopener">点击这里</a></p>
<h2 id="26-Remove-Duplicates-from-Sorted-Array-删除排序数组中的重复项-Easy"><a href="#26-Remove-Duplicates-from-Sorted-Array-删除排序数组中的重复项-Easy" class="headerlink" title="26. Remove Duplicates from Sorted Array(删除排序数组中的重复项)(Easy)"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">26. Remove Duplicates from Sorted Array(删除排序数组中的重复项)(Easy)</a></h2><p>Given a sorted array <em>nums</em>, remove the duplicates in-place(原地操作) such that each element appear only <em>once</em> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array in-place</strong> with O(1) extra memory.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">Given nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line"></span><br><span class="line">Your <span class="keyword">function</span> <span class="title">should</span> <span class="keyword">return</span> <span class="type">length</span> = <span class="number">2</span>, <span class="keyword">with</span> the first two elements <span class="keyword">of</span> nums being <span class="number">1</span> <span class="keyword">and</span> <span class="number">2</span> respectively.</span><br><span class="line"></span><br><span class="line">It doesn<span class="symbol">'t</span> matter what you leave beyond the returned length.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">Given nums = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line"></span><br><span class="line">Your function should return length = <span class="number">5</span>, with the first five elements of nums being modified to <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, and <span class="number">4</span> respectively.</span><br><span class="line"></span><br><span class="line">It doesn't matter what values are set beyond the returned length.</span><br></pre></td></tr></table></figure>

<p><strong>Clarfication:</strong><br>Confused why the returned value is an integer but your answer is an array?</p>
<p>Note that the input array is passed in by <strong>reference</strong>, which means modification to the input array will be known to the caller as well.</p>
<p>Internally you can think of this:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// nums is passed in by reference. (i.e., without making a copy)</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">len</span> = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// any modification to nums in your function would be known by the caller.</span></span><br><span class="line"><span class="comment">// using the length returned by your function, it prints the first len elements.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">len</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">print</span>(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>解：</p>
<p>方法一，快慢指针：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 删除重复项之后的数组下标为after_numsLength</span></span><br><span class="line">        <span class="keyword">int</span> after_numslength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// i在前，after_numslength在后，nums[after_numslength]为去重之后的数组</span></span><br><span class="line">            <span class="keyword">if</span>(nums[after_numslength] != nums[i]) &#123;</span><br><span class="line">                after_numslength++;</span><br><span class="line">                nums[after_numslength] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回长度，为下标最大值+1</span></span><br><span class="line">        <span class="keyword">return</span> after_numslength+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，i表示删除元素后数组元素的个数，注意因为i是元素个数，所以判断元素是否重复的时候比较的是”n != nums[i-1]”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> || nums[i-<span class="number">1</span>] != n) &#123;</span><br><span class="line">                nums[i++] = n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="189-Rotate-Array-旋转数组-Easy"><a href="#189-Rotate-Array-旋转数组-Easy" class="headerlink" title="189. Rotate Array(旋转数组)(Easy)"></a><a href="https://leetcode-cn.com/problems/rotate-array/" target="_blank" rel="noopener">189. Rotate Array(旋转数组)(Easy)</a></h2><p>Given an array, rotate the array to the right by <em>k</em> steps, where <em>k</em> is non-negative.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>] <span class="keyword">and</span> k = <span class="number">3</span></span><br><span class="line">Output: [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">Explanation:</span><br><span class="line">rotate <span class="number">1</span> steps to the right: [<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">rotate <span class="number">2</span> steps to the right: [<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">rotate <span class="number">3</span> steps to the right: [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">-1</span>,<span class="number">-100</span>,<span class="number">3</span>,<span class="number">99</span>] <span class="keyword">and</span> k = <span class="number">2</span></span><br><span class="line">Output: [<span class="number">3</span>,<span class="number">99</span>,<span class="number">-1</span>,<span class="number">-100</span>]</span><br><span class="line">Explanation: </span><br><span class="line">rotate <span class="number">1</span> steps to the right: [<span class="number">99</span>,<span class="number">-1</span>,<span class="number">-100</span>,<span class="number">3</span>]</span><br><span class="line">rotate <span class="number">2</span> steps to the right: [<span class="number">3</span>,<span class="number">99</span>,<span class="number">-1</span>,<span class="number">-100</span>]</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ul>
<li><p>Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.</p>
</li>
<li><p>Could you do it in-place with O(1) extra space?</p>
</li>
</ul>
<hr>
<p>解：给出三种解法。</p>
<p>方法一，双重循环，比较暴力。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 按照轮次来做，每一轮操作一个数字</span></span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="comment">// 如果k太大，甚至比nums还大，那么移动过程会经过了一轮。这里k表示最后要位移的位数</span></span><br><span class="line">        k %= len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="comment">//temp 保存最后一个元素的值</span></span><br><span class="line">            <span class="keyword">int</span> temp = nums[len - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = len-<span class="number">1</span>; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">                nums[j] = nums[j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            nums[<span class="number">0</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(kn)</p>
<p>空间复杂度：O(1)</p>
<p>方法二</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nums_length = nums.length;</span><br><span class="line">        k %= nums_length;</span><br><span class="line">        <span class="comment">// 第一次交换完毕后，前 k 位数字位置正确，后 n-k 位数字中最后 k 位数字顺序错误，继续交换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; nums.length &amp;&amp; k != <span class="number">0</span>; nums_length -= k, start += k, k %= nums_length) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">                swap(nums, start + i, nums.length - k + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> [] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度:O(n)<br>空间复杂度：O(1)</p>
<p>方法三，翻转，最巧妙。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="comment">// 如果k太大，甚至比nums还大，那么移动过程会经过一轮，在这里k表示最后要位移的位数。</span></span><br><span class="line">        k %= len;</span><br><span class="line">        reverse(nums,<span class="number">0</span>,len-<span class="number">1</span>);</span><br><span class="line">        reverse(nums,<span class="number">0</span>,k-<span class="number">1</span>);</span><br><span class="line">        reverse(nums,k,len-<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[start];</span><br><span class="line">            nums[start++] = nums[end];</span><br><span class="line">            nums[end--] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>arr = [1,2,3,4,5] –右移两位–&gt; [4,5,1,2,3]<br>假设 n = arr.length，k = 右移位数，可得：  </p>
<pre><code>[1,2,3,4,5] --翻转索引为[0,n-1]之间的元素--&gt; [5,4,3,2,1] 
            --翻转索引为[0,k-1]之间的元素--&gt; [4,5,3,2,1] 
            --翻转索引为[k,n-1]之间的元素--&gt; [4,5,1,2,3]</code></pre><p>注意上面这个区间貌似左和右都是闭合的</p>
<p>旋转数组其实就是把数组分成了两部分，解题关键就是在保证原有顺序的情况下<br>把后面一部分移到前面去。数组整体翻转满足了第二个要素，但是打乱了数组的<br>原有顺序，所以此时再次对两部分进行翻转，让他们恢复到原有顺序（翻转之后<br>再翻转，就恢复成原有顺序了）。没有什么太复杂的思想，但是这种很巧妙的思想或许是神来之笔。</p>
<h2 id="21-Merge-Two-Sorted-Lists-合并两个有序链表-Easy"><a href="#21-Merge-Two-Sorted-Lists-合并两个有序链表-Easy" class="headerlink" title="21. Merge Two Sorted Lists(合并两个有序链表)(Easy)"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">21. Merge Two Sorted Lists(合并两个有序链表)(Easy)</a></h2><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>, <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span></span><br><span class="line">Output: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：<br>方法一，非递归，操作指针。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建合并后链表的虚拟头结点</span></span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode curr = dummyHead;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 若链表不为空，开始合并,实际操作是插入节点</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt; l2.val) &#123;</span><br><span class="line">                curr.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">                curr = curr.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">                curr = curr.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 若l1或者l2有一个为空，则直接返回另一条链表</span></span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            curr.next = l2;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curr.next = l1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，递归</p>
<p>分析递归的解法：</p>
<ul>
<li>终止条件：两条链表分别名为l1和l2，当l1为空或者l2为空是结束</li>
<li>返回值：每一层调用都返回排好序的链表头</li>
<li>本级递归内容：如果l1的val值更小，则将l1.next与排序好的链表头相接，l2同理</li>
</ul>
<p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/hua-jie-suan-fa-21-he-bing-liang-ge-you-xu-lian-bi/" target="_blank" rel="noopener">可以画图分析，具体分析可以参考这篇题解</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用recursion，代码虽然简洁，但是可能导致Stack OverFlow</span></span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">if</span>(l1.val &lt; l2.val) &#123;</span><br><span class="line">            l1.next = mergeTwoLists(l1.next,l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            l2.next = mergeTwoLists(l1,l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="88-Merge-Sorted-Array-合并两个有序数组-Easy-https-leetcode-cn-com-problems-merge-sorted-array"><a href="#88-Merge-Sorted-Array-合并两个有序数组-Easy-https-leetcode-cn-com-problems-merge-sorted-array" class="headerlink" title="88. Merge Sorted Array(合并两个有序数组)(Easy)](https://leetcode-cn.com/problems/merge-sorted-array/)"></a>88. Merge Sorted Array(合并两个有序数组)(Easy)](<a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-sorted-array/</a>)</h2><p>Given two sorted integer arrays <em>nums1</em> and <em>nums2</em>, merge <em>nums2</em> into <em>nums1</em> as one sorted array.</p>
<p><strong>Note:</strong></p>
<ul>
<li><p>The number of elements initialized in <em>nums1</em> and <em>nums2</em> are m and n respectively.</p>
</li>
<li><p>You may assume that <em>nums1</em> has enough space (size that is greater or equal to <em>m + n</em>) to hold additional elements from <em>nums2</em>.</p>
</li>
</ul>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], m = <span class="number">3</span></span><br><span class="line">nums2 = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>],       n = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">Output: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure>

<hr>
<p>解：<br>方法一，调用自带函数，但是面试中肯定不允许使用，可以提一嘴</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 方法一，使用java的arraycopy进行nums1和nums2的合并，合并之后再排序即可</span></span><br><span class="line">        System.arraycopy(nums2,<span class="number">0</span>,nums1,m,n);</span><br><span class="line">        <span class="comment">// 使用工具类Arrays的排序方法</span></span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，使用从后往前的指针，一共三个指针，分别在在nums1元素的最后位置、nums1长度的最后位置和nums2的最后位置。每次进行比较，直到nums1或nums2被遍历完为止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 更加酷，不需要开辟额外空间，直接在nums1的末尾开始，用三个指针从后往前</span></span><br><span class="line">        <span class="comment">// two pointers for nums1 and nums2</span></span><br><span class="line">        <span class="keyword">int</span> p1 = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> p2 = n - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// set pointer for nums1</span></span><br><span class="line">        <span class="keyword">int</span> p = m + n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// while there are still elements to compare</span></span><br><span class="line">        <span class="keyword">while</span>((p1 &gt;= <span class="number">0</span>) &amp;&amp; (p2 &gt;= <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">// compare two elements from nums1 and nums2 and add the largest</span></span><br><span class="line">            <span class="comment">// one in nums1</span></span><br><span class="line">            nums1[p--] = (nums1[p1] &lt; nums2[p2]) ? nums2[p2--] : nums1[p1--];</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="comment">// add missing elements from nums2</span></span><br><span class="line">            <span class="comment">// 如果先触发了p1 &lt; 0的条件，nums2不再能copy了，需要手动arraycopy过去</span></span><br><span class="line">            System.arraycopy(nums2, <span class="number">0</span>, nums1, <span class="number">0</span>, p2 + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="66-Plus-One-加一-Easy"><a href="#66-Plus-One-加一-Easy" class="headerlink" title="66. Plus One(加一)(Easy)"></a><a href="https://leetcode-cn.com/problems/plus-one/" target="_blank" rel="noopener">66. Plus One(加一)(Easy)</a></h2><p>Given a <strong>non-empty</strong> array of digits representing a non-negative integer, plus one to the integer.</p>
<p>The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.</p>
<p>You may assume the integer does not contain any leading zero, except the number 0 itself.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">Output: [1,2,4]</span><br><span class="line">Explanation: The<span class="built_in"> array </span>represents the integer 123.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">Output: [<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">Explanation: The <span class="built_in">array</span> represents the <span class="built_in">int</span>eger <span class="number">4321.</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = digits.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            digits[i]++;</span><br><span class="line">            digits[i] %= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(digits[i] != <span class="number">0</span>) <span class="keyword">return</span> digits;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若digits起初所有元素都为9，则需要新开辟一位</span></span><br><span class="line">        digits = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">1</span>];</span><br><span class="line">        digits[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="83-Remove-Duplicates-from-Sorted-List-删除排序链表中的重复元素-Easy"><a href="#83-Remove-Duplicates-from-Sorted-List-删除排序链表中的重复元素-Easy" class="headerlink" title="83. Remove Duplicates from Sorted List(删除排序链表中的重复元素)(Easy)"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">83. Remove Duplicates from Sorted List(删除排序链表中的重复元素)(Easy)</a></h2><p>Given a sorted linked list, delete all duplicates such that each element appear only once.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span></span><br><span class="line">Output: <span class="number">1</span>-&gt;<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">3</span></span><br><span class="line">Output: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：比较简单，只是考察操作链表节点指针的能力。因为传入的链表已经排序，我们只需要比较当前节点和它之后节点的值是否相等即可，如果相等，让当前节点指针跳过下一个节点，指向下一个节点的next即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span> &amp;&amp; curr.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(curr.val == curr.next.val) &#123;</span><br><span class="line">                curr.next = curr.next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr = curr.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h2 id="82-Remove-Duplicates-from-Sorted-List-II-删除排序链表中的重复元素-II-Mid"><a href="#82-Remove-Duplicates-from-Sorted-List-II-删除排序链表中的重复元素-II-Mid" class="headerlink" title="82. Remove Duplicates from Sorted List II(删除排序链表中的重复元素 II)(Mid)"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/submissions/" target="_blank" rel="noopener">82. Remove Duplicates from Sorted List II(删除排序链表中的重复元素 II)(Mid)</a></h2><p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span></span><br><span class="line">Output: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span></span><br><span class="line">Output: <span class="number">2</span>-&gt;<span class="number">3</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：</p>
<p>方法一，非递归。</p>
<p>重复的元素直接彻底跳过而不是去重，难度上升变成中等。方法中定义虚拟节点FakeNode(用于处理开头节点就是重复节点的情况，最后一定要返回FakeNode.next)、pre节点(用于直接跳过重复的所有元素)、cur(判断当前节点是否为重复元素的节点)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> ) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode FakeNode = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        FakeNode.next = head;</span><br><span class="line">        ListNode pre = FakeNode;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span> ) &#123;</span><br><span class="line">            <span class="comment">// cur 标记是否当前节点为重复节点，用pre进行过滤，链起来一个新链表</span></span><br><span class="line">            <span class="comment">// cur为重复元素的最后一个结点</span></span><br><span class="line">            <span class="comment">// 不能把cur.next != null 放入大循环条件，否则可能报空指针</span></span><br><span class="line">            <span class="keyword">while</span>(cur.next != <span class="keyword">null</span> &amp;&amp; cur.val == cur.next.val) &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若pre的下一个节点就是cur，说明cur当前元素不是重复的，不需要跳过</span></span><br><span class="line">            <span class="comment">// 反之，根据题意需要跳过cur指向的找到的重复的最后一个结点</span></span><br><span class="line">            <span class="keyword">if</span>(pre.next == cur) &#123;</span><br><span class="line">                pre = pre.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre.next = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 相比83题简单地去重，这里需要判断cur重复之后还要删除重复元素，使用pre指针</span></span><br><span class="line">            <span class="comment">// 所以不是简单地在判断元素重复之后直接进入下一元素，而是经过一个循环和一个判断之后才可以</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> FakeNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，递归。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> ) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(head.next != <span class="keyword">null</span> &amp;&amp; head.val == head.next.val) &#123;</span><br><span class="line">            <span class="keyword">while</span>(head.next != <span class="keyword">null</span> &amp;&amp; head.val == head.next.val) &#123;</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> deleteDuplicates(head.next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head.next = deleteDuplicates(head.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="203-Remove-Linked-List-Elements-移除链表元素-Easy"><a href="#203-Remove-Linked-List-Elements-移除链表元素-Easy" class="headerlink" title="203. Remove Linked List Elements(移除链表元素)(Easy)"></a><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/" target="_blank" rel="noopener">203. Remove Linked List Elements(移除链表元素)(Easy)</a></h2><p>Remove all elements from a linked list of integers that have value <strong><em>val</em></strong>.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input:  <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">6</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span>, val = <span class="number">6</span></span><br><span class="line">Output: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：<br>方法一，递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode next = removeElements(head.next, val);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(head.val == val) <span class="keyword">return</span> next;</span><br><span class="line">        </span><br><span class="line">        head.next = next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，非递归，迭代，定义虚拟节点</p>
<p>需要注意，如果第一个元素的值是val,无法返回头结点。所以自然想到需要dummyuNode(或者叫做FakeNode)。当遇到含有val的值的时候，比如2-&gt;6-&gt;3，val是6，此时需要赋值：2.next=2.next.next，和83题的操作同样很类似。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode fakeNode = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        fakeNode.next = head;</span><br><span class="line">        ListNode curr = fakeNode;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span> &amp;&amp; curr.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(curr.next.val == val) &#123;</span><br><span class="line">                curr.next = curr.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fakeNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法三，非递归，不使用虚拟节点，单纯删除节点，只是头结点值为val的时候需要单独考虑。(删除节点操作很简单,很类似83题，只是83题是和 x.next 去比较val是否相同，而这道题比较当前节点的 val 是否和传入的val相同)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span> &amp;&amp; head.val == val) &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果没有这个判断，curr.next在corner edge情况下很可能会报空指针</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span> &amp;&amp; curr.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(curr.next.val == val) &#123;</span><br><span class="line">                curr.next = curr.next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr = curr.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指offer22-链表中倒数第k个节点-Easy"><a href="#剑指offer22-链表中倒数第k个节点-Easy" class="headerlink" title="剑指offer22.链表中倒数第k个节点(Easy)"></a><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/" target="_blank" rel="noopener">剑指offer22.链表中倒数第k个节点(Easy)</a></h2><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p>
<p><strong>示例：</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">给定一个链表: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>, 和 k = <span class="number">2.</span></span><br><span class="line"></span><br><span class="line">返回链表 <span class="number">4</span>-&gt;<span class="number">5.</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：这道题暴力的想法可以遍历两次链表，第一次遍历用变量保存链表的长度n,要访问倒数第k个，第二次直接走n-k+1步即可。</p>
<p>但是这样做要先后遍历一遍链表，一共遍历两遍，时间复杂度太高。</p>
<p>第二种方法，遍历一遍链表即可，用快慢指针。快指针先走k步，然后两个指针一起往后移，直到快指针指到了最后一个节点。</p>
<p>按照这个思路，代码可以这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getKthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这道题其实非常重点之一其实是考察代码的鲁棒性。上面这段代码虽然可以解决问题，但是有三个致命缺陷，可以让程序执行的时候崩溃：</p>
<ol>
<li>k为0，如果直接计算k-1，那么结果会是错误的，甚至如果溢出的话，对指针的操作次数会让内存不够用</li>
<li>如果k的大小大于链表的长度，会有空指针异常</li>
<li>如果输入的head为空指针，程序也会崩溃</li>
</ol>
<p>上面三点中，第三点经常会碰到而且很容易考虑的，但是前两点可能会考虑不到。</p>
<p>针对这三点问题，可以这样解决：</p>
<ol>
<li>如果传入的链表头指针head为Null，那么再怎样查询都没有意义，直接返回null即可</li>
<li>如果k的值为0，也就是要找到倒数第0个节点。但是因为我们是从1开始计数的，所以没有倒数第0个，这个情况也要返回null</li>
<li>如果k的值比链表长度更大，那么在查询过程中fast可能会指向null，此时我们也需要即时返回null，否则后面再移动fast或者slow的时候会报错。这里可以通过加一个if判断fast是否为空来解决。</li>
</ol>
<p>增加鲁棒性之后的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getKthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span> || head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="237-Delete-Node-in-a-Linked-List-删除链表中的节点-Easy"><a href="#237-Delete-Node-in-a-Linked-List-删除链表中的节点-Easy" class="headerlink" title="237. Delete Node in a Linked List(删除链表中的节点)(Easy)"></a><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/" target="_blank" rel="noopener">237. Delete Node in a Linked List(删除链表中的节点)(Easy)</a></h2><p>Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.</p>
<p>Given linked list – head = [4,5,1,9], which looks like following:</p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/28/237_example.png" alt=""></p>
<p><strong>Example 1:</strong></p>
<p>Input: head = [4,5,1,9], node = 5<br>Output: [4,1,9]<br>Explanation: You are given the second node with value 5, the linked list should become 4 -&gt; 1 -&gt; 9 after calling your function.</p>
<p><strong>Example 2:</strong></p>
<p>Input: head = [4,5,1,9], node = 1<br>Output: [4,5,9]<br>Explanation: You are given the third node with value 1, the linked list should become 4 -&gt; 5 -&gt; 9 after calling your function.</p>
<p><strong>Note:</strong></p>
<ul>
<li>The linked list will have at least two elements.</li>
<li>All of the nodes’ values will be unique.</li>
<li>The given node will not be the tail and it will always be a valid node of the linked list.</li>
<li>Do not return anything from your function.</li>
</ul>
<hr>
<p>解：<br>注意，这道题只是考如何删除某个指定的节点，考的就是在无法知道这个节点前面指针的时候该如何操作。感觉和脑筋急转弯差不多。</p>
<p>因为我们不能操作这个节点前面的节点的next指针，所以要删除当前这个节点，就只能把下一个节点的值赋给当前这个节点，然后让当前节点跳过下一个节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">        node.val = node.next.val;</span><br><span class="line">        node.next = node.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="61-Rotate-List-旋转链表-Mid"><a href="#61-Rotate-List-旋转链表-Mid" class="headerlink" title="61. Rotate List(旋转链表)(Mid)"></a><a href="https://leetcode-cn.com/problems/rotate-list/" target="_blank" rel="noopener">61. Rotate List(旋转链表)(Mid)</a></h2><p>Given a linked list, rotate the list to the right by <em>k</em> places, where <em>k</em> is non-negative.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL, k = <span class="number">2</span></span><br><span class="line">Output: <span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;NULL</span><br><span class="line">Explanation:</span><br><span class="line">rotate <span class="number">1</span> steps to the right: <span class="number">5</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;NULL</span><br><span class="line">rotate <span class="number">2</span> steps to the right: <span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;NULL</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: <span class="number">0</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;NULL, k = <span class="number">4</span></span><br><span class="line">Output: <span class="number">2</span>-&gt;<span class="number">0</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br><span class="line">Explanation:</span><br><span class="line">rotate <span class="number">1</span> steps to the right: <span class="number">2</span>-&gt;<span class="number">0</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br><span class="line">rotate <span class="number">2</span> steps to the right: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">0</span>-&gt;NULL</span><br><span class="line">rotate <span class="number">3</span> steps to the right: <span class="number">0</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;NULL</span><br><span class="line">rotate <span class="number">4</span> steps to the right: <span class="number">2</span>-&gt;<span class="number">0</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br></pre></td></tr></table></figure>

<hr>
<p>解：这道题用双指针来解决，即快慢指针。</p>
<p>需要返回一个新的链表，就要考虑到定义一个虚拟头结点，这样可以省去每次都判断链表头是否为空。</p>
<p>用慢指针来标记反转之后的最后一个节点的位置。但是因为反转的k值可能大于之前的总长度，所以可以先用快指针遍历一遍链表得到总长度(顺便利于最后的rotation操作)，然后再移动slow指针过k个位置，最后再反转即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">rotateRight</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// corner case</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        ListNode fakeNode = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        fakeNode.next = head;</span><br><span class="line">        ListNode fast = fakeNode, slow = fakeNode;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i;<span class="comment">//i用来存储链表长度,用来给k求余，这个和数组旋转差不多,k太大要求余</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; fast.next != <span class="keyword">null</span>; i++) <span class="comment">// Get the total length</span></span><br><span class="line">            fast = fast.next;<span class="comment">//此时fast已经在链表尾部了</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 需要注意最后移动完之后，slow的位置是在第 i-i%k 的位置的，相当于尾节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i - k % i; j++)<span class="comment">//让slow移动到第 i-k%i 个位置</span></span><br><span class="line">            slow = slow.next;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 最后进行反转,把fast指向原来的头结点</span></span><br><span class="line">        fast.next = fakeNode.next;</span><br><span class="line">        fakeNode.next = slow.next;</span><br><span class="line">        slow.next = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> fakeNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-Add-Two-Numbers-两数相加-Mid"><a href="#2-Add-Two-Numbers-两数相加-Mid" class="headerlink" title="2. Add Two Numbers(两数相加)(Mid)"></a><a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">2. Add Two Numbers(两数相加)(Mid)</a></h2><p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<p><strong>Example:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="string">(2</span> <span class="string">-&gt;</span> <span class="number">4</span> <span class="string">-&gt;</span> <span class="number">3</span><span class="string">)</span> <span class="string">+</span> <span class="string">(5</span> <span class="string">-&gt;</span> <span class="number">6</span> <span class="string">-&gt;</span> <span class="number">4</span><span class="string">)</span></span><br><span class="line"><span class="attr">Output:</span> <span class="number">7</span> <span class="string">-&gt;</span> <span class="number">0</span> <span class="string">-&gt;</span> <span class="number">8</span></span><br><span class="line"><span class="attr">Explanation:</span> <span class="number">342</span> <span class="string">+</span> <span class="number">465</span> <span class="string">=</span> <span class="number">807</span><span class="string">.</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：方法一：</p>
<p>其实这道题看上去比较别扭，实际上可以理解，因为相当于链表的头指针从个位开始指，然后往后依次加起来</p>
<p>因为最后要返回一个新的链表，所以好的方法还是创建一个fakeNode。然后用sum表示当前求和结果，carry表示进位。</p>
<p>比较重要的两个公式是求加之后的位数值(sum%10)和加之后的进位的值(sum/10)。每次只要有加计算，就让current.next指向新创建的节点</p>
<p>需要考虑三个部分：</p>
<ol>
<li>两个链表都有数位的部分，也就是从个位，十位开始l1和l2都有数，此时求和(sum)的方法是<code>l1.val+l2.val+carry</code></li>
<li>l1或者l2有一个为null了，另一个不为null，此时用不为null的节点的值加上carry为新的sum</li>
<li>l1和l2都遍历完了，最后只需要看carry是不是0，如果不是0，意味着最后要开辟一个新节点，也就是返回的求和之后的链表长度为<code>l1的长度+l2的长度+1</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// corner case</span></span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        </span><br><span class="line">        ListNode fakeNode = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode current = fakeNode;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>; <span class="comment">// carry表示进位</span></span><br><span class="line">        <span class="comment">// 第一段，l1和l2共有的部分</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = l1.val + l2.val + carry;</span><br><span class="line">            <span class="keyword">int</span> val = sum % <span class="number">10</span>;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            current.next = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">            current = current.next;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span>) &#123; <span class="comment">// 此时l1 is not null, but l2 is null</span></span><br><span class="line">            <span class="keyword">int</span> sum = l1.val + carry;</span><br><span class="line">            <span class="keyword">int</span> val = sum % <span class="number">10</span>;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            current.next = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">            current = current.next;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l2 != <span class="keyword">null</span>) &#123; <span class="comment">// 此时l2 is not null, but l1 is null</span></span><br><span class="line">            <span class="keyword">int</span> sum = l2.val + carry;</span><br><span class="line">            <span class="keyword">int</span> val = sum % <span class="number">10</span>;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            current.next = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">            current = current.next;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//此时遍历完了所有l1和l2的节点，只看最后需不需要新进一位</span></span><br><span class="line">        <span class="comment">// 进位完之后新链表长度是l1和l2长度和 +1</span></span><br><span class="line">        <span class="keyword">if</span>(carry != <span class="number">0</span>) current.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> fakeNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：</p>
<p>其实可以简化代码，虽然不如上面的好理解，但是公式是完全相同的(就是<code>sum%10</code>和<code>sum/10</code>)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode fakeNode = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode curr = fakeNode;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = l1==<span class="keyword">null</span> ? <span class="number">0</span> : l1.val;</span><br><span class="line">            <span class="keyword">int</span> y = l2==<span class="keyword">null</span> ? <span class="number">0</span> : l2.val;</span><br><span class="line">            sum = x + y + carry;</span><br><span class="line">            </span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            sum = sum % <span class="number">10</span>;</span><br><span class="line">            </span><br><span class="line">            curr.next = <span class="keyword">new</span> ListNode(sum);</span><br><span class="line">            </span><br><span class="line">            curr = curr.next;</span><br><span class="line">            <span class="keyword">if</span>(l1 != <span class="keyword">null</span>) </span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(l2 != <span class="keyword">null</span>)</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry == <span class="number">1</span>) </span><br><span class="line">            curr.next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> fakeNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="54-Spiral-Matrix-螺旋矩阵-剑指29-顺序打印矩阵-Mid"><a href="#54-Spiral-Matrix-螺旋矩阵-剑指29-顺序打印矩阵-Mid" class="headerlink" title="54.  Spiral Matrix(螺旋矩阵) / 剑指29(顺序打印矩阵)(Mid)"></a><a href="https://leetcode-cn.com/problems/spiral-matrix/" target="_blank" rel="noopener">54.  Spiral Matrix(螺旋矩阵) / 剑指29(顺序打印矩阵)(Mid)</a></h2><p>Given a matrix of <em>m x n</em> elements (<em>m</em> rows, <em>n</em> columns), return all elements of the matrix in spiral order.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line"> [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ],</span><br><span class="line"> [ <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> ],</span><br><span class="line"> [ <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> ]</span><br><span class="line">]</span><br><span class="line">Output: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">  [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]</span><br><span class="line">]</span><br><span class="line">Output: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure>

<hr>
<p>解：这道题和《剑指offer》上面试29题<a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/" target="_blank" rel="noopener">顺序打印矩阵</a>，顺时针打印矩阵，相同，都是用顺时针旋转的方式打印出来一个二维数组。</p>
<p>可以提取出来访问顺序：从左往右、从上往下、从右往左、从下往上。按照这个规律进行循环，条件是结果集的size()小于目标矩阵的大小。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> bottom = matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> size = matrix.length * matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">while</span>(result.size() &lt; size) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right &amp;&amp; result.size() &lt; size; i++) &#123;</span><br><span class="line">                result.add(matrix[top][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            top++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = top; i &lt;= bottom &amp;&amp; result.size() &lt; size; i++) &#123;</span><br><span class="line">                result.add(matrix[i][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = right; i &gt;= left &amp;&amp; result.size() &lt; size; i--) &#123;</span><br><span class="line">                result.add(matrix[bottom][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            bottom--;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = bottom; i &gt;= top &amp;&amp; result.size() &lt; size; i--) &#123;</span><br><span class="line">                result.add(matrix[i][left]);</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指22-找到链表倒数第k个节点"><a href="#剑指22-找到链表倒数第k个节点" class="headerlink" title="剑指22.找到链表倒数第k个节点"></a><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/" target="_blank" rel="noopener">剑指22.找到链表倒数第k个节点</a></h2><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">给定一个链表: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>, 和 k = <span class="number">2.</span></span><br><span class="line"></span><br><span class="line">返回链表 <span class="number">4</span>-&gt;<span class="number">5.</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：这道题主要考察代码鲁棒性。常规找到倒数第k个节点很容易，可以用两个快慢指针，快的先走，走k步，然后让慢的走，当快的走到null了，慢的就是倒数第k个节点。</p>
<p>但是主要注意几个很可能出现的边界情况：</p>
<ol>
<li><strong>输入的head为null</strong>：此时我们要返回null指针</li>
<li><strong>输入的k为0</strong>：如果输入的k为0，意思是删除第k个指针，但是因为我们这里是从1开始计数的，所以也要返回null</li>
<li><strong>输入的k大于链表长度</strong>：这个不能一下子就判断出来，可以在一开始移动fast的过程中加一个判断，如果在循环还没结束的时候fast就指到了null，则提前返回</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getKthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span> || head == <span class="keyword">null</span>) <span class="keyword">return</span> slow;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="19-Remove-N-th-node-from-end-of-list-删除链表的倒数第N个节点-Mid"><a href="#19-Remove-N-th-node-from-end-of-list-删除链表的倒数第N个节点-Mid" class="headerlink" title="19. Remove N-th node from end of list(删除链表的倒数第N个节点)(Mid)"></a><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">19. Remove N-th node from end of list(删除链表的倒数第N个节点)(Mid)</a></h2><p>Given a linked list, remove the <em>n</em>-th node from the end of list and return its head.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Given linked list: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>, <span class="keyword">and</span> n = <span class="number">2.</span></span><br><span class="line"></span><br><span class="line">After removing the second node <span class="keyword">from</span> the end, the linked list becomes <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">5.</span></span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<p>Given <em>n</em> will always be valid.</p>
<p><strong>Follow up:</strong></p>
<p>Could you do this in one pass?</p>
<hr>
<p>解：用快慢两个指针即可。因为这里要删除倒数第n个，所以slow最后要指向倒数第n+1个才能快速顺利删除。</p>
<p>这里用到一个虚拟头结点，方便slow和fast移动，一开始移动fast，移动n+1步，这样保证slow和fast之间距离为n个节点。然后fast和slow一起移动，直到fast移动到null的时候，slow指向倒数第n+1个，移动指针可以很方便地删除第n个节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ListNode dummyNode = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummyNode.next = head;</span><br><span class="line">        </span><br><span class="line">        ListNode fast = dummyNode;</span><br><span class="line">        ListNode slow = dummyNode;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//让slow和fast拉开n的距离,因为最后要删除倒数第k个</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n; i++) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//移动fast和slow，当fast指到null的时候，slow为倒数第n+1个</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow.next = slow.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="160-Intersection-of-Two-Linked-Lists-相交链表-Easy"><a href="#160-Intersection-of-Two-Linked-Lists-相交链表-Easy" class="headerlink" title="160. Intersection of Two Linked Lists(相交链表)(Easy)"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">160. Intersection of Two Linked Lists(相交链表)(Easy)</a></h2><p>Write a program to find the node at which the intersection of two singly linked lists begins.</p>
<p>For example, the following two linked lists:</p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png" alt="例子"></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: <span class="built_in">int</span>ersectVal = <span class="number">8</span>, listA = [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>], listB = [<span class="number">5</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>], skipA = <span class="number">2</span>, skipB = <span class="number">3</span></span><br><span class="line">Output: Reference of the node with value = <span class="number">8</span></span><br><span class="line">Input Explanation: The <span class="built_in">int</span>ersected node<span class="string">'s value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,0,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.</span></span><br></pre></td></tr></table></figure>

<p><strong>Notes</strong>:</p>
<ul>
<li>If the two linked lists have no intersection at all, return <code>null</code>.</li>
<li>The linked lists must retain their original structure after the function returns.</li>
<li>You may assume there are no cycles anywhere in the entire linked structure.</li>
<li>Your code should preferably run in O(n) time and use only O(1) memory.</li>
</ul>
<hr>
<p>解：方法是用A、B两个指针循环遍历，A和B各自遍历到末尾一次，然后各自移动到对方的头指针位置。比如A先到末尾的NULL，说明链表A比较短，那么之后pA移动到headB。继续移动pB到末尾NULL，然后再让pB移动到headA。此时两者之间距离就是两个链表之间的节点数量了，后面直接判断这两个节点是否相等即可，如果相等，那个点就是交点。</p>
<p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/tu-jie-xiang-jiao-lian-biao-by-user7208t/" target="_blank" rel="noopener">详细图片解释可以看这篇文章</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode pA = headA;</span><br><span class="line">        ListNode pB = headB;</span><br><span class="line">        <span class="keyword">while</span>(pA != pB) &#123;</span><br><span class="line">            pA = pA == <span class="keyword">null</span> ? headB : pA.next;</span><br><span class="line">            pB = pB == <span class="keyword">null</span> ? headA : pB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O()</li>
</ul>
<h2 id="23-Merge-k-Sorted-Lists-合并K个排序链表-Hard"><a href="#23-Merge-k-Sorted-Lists-合并K个排序链表-Hard" class="headerlink" title="23.Merge k Sorted Lists(合并K个排序链表)(Hard)"></a><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">23.Merge k Sorted Lists(合并K个排序链表)(Hard)</a></h2><p>Merge <em>k</em> sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>,</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>,</span><br><span class="line">  <span class="number">2</span>-&gt;<span class="number">6</span></span><br><span class="line">]</span><br><span class="line">Output: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：<strong>解法一：暴力法</strong></p>
<ul>
<li>用一个数组保存所有链表中的数，之后进行排序，再从头到尾将数组遍历，生成一个排好序的链表</li>
<li>假设每个链表平均长度为n,整体时间复杂度为O(nk * log(nk))，偏大</li>
</ul>
<p><strong>解法二：最小堆</strong></p>
<ul>
<li>每次比较k个链表头，时间复杂度为O(k)</li>
<li>对k个链表头创建一个大小为k的最小堆<ul>
<li>创建一个大小为k的最小堆所需时间为O(k)</li>
<li>从堆中取最小的数，所需时间都是O(logk)</li>
<li>如果每个链表平均长度为n，则共有nk个元素，即用大小为k的最小堆过滤nk个元素</li>
<li>整体时间复杂度为O(nk*log(k))</li>
<li>空间复杂度为O(k)，我们有k个list，占据k个空间</li>
</ul>
</li>
</ul>
<p>我们一直维护这个大小为k的最小堆，直到遍历完所有链表的节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果输入为[]，边界条件</span></span><br><span class="line">        <span class="keyword">if</span>(lists.length == <span class="number">0</span> || lists == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 利用一个空的链表头方便我们插入节点</span></span><br><span class="line">        ListNode fakeHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>), p = fakeHead;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义一个最小堆来保存k个链表节点</span></span><br><span class="line">        <span class="keyword">int</span> k = lists.length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将k个链表的头放到最小堆中,因为使用ListNode数据结构，所以重新定义比较器</span></span><br><span class="line">        PriorityQueue&lt;ListNode&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k, <span class="keyword">new</span> Comparator&lt;ListNode&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(ListNode a, ListNode b)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a.val - b.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从k个链表中将当前最小节点取出，插入到结果链表中</span></span><br><span class="line">        <span class="comment">// 每条链表都会有一个指针i，这个for把每条链表的第一个加入到小顶堆中</span></span><br><span class="line">        <span class="comment">// 因为本身就有k个链表，所以相当于初始化的步骤</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(lists[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                heap.offer(lists[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 真正使用最小堆的操作，将堆中元素一个一个取出，插入到结果链表中</span></span><br><span class="line">        <span class="keyword">while</span>(!heap.isEmpty()) &#123;</span><br><span class="line">            ListNode node = heap.poll();</span><br><span class="line">            </span><br><span class="line">            p.next = node;</span><br><span class="line">            p = p.next;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// p是结果链表节点，node是当前遍历的节点</span></span><br><span class="line">            <span class="comment">// 如果当前链表有后续节点，在poll()了它之后自然要访问它后续节点</span></span><br><span class="line">            <span class="keyword">if</span>(node.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                heap.offer(node.next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 最后返回结果链表</span></span><br><span class="line">        <span class="keyword">return</span> fakeHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述定义小顶堆的代码也可以用Lambda表达式简化：</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">PriorityQueue&lt;ListNode&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(</span><br><span class="line">    (a,b) -&gt; a.val - b.val</span><br><span class="line">);</span><br></pre></td></tr></table></figure>


<p><strong>解法三：分治法</strong></p>
<p>利用分治思想，非常类似归并排序操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主函数非常类似归并排序的过程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果输入为[]，边界条件</span></span><br><span class="line">    <span class="keyword">if</span>(lists.length == <span class="number">0</span> || lists == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(low == high) <span class="keyword">return</span> lists[low];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从中间切一刀</span></span><br><span class="line">    <span class="keyword">int</span> middle = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归地处理坐标和右边的列表，最后合并起来</span></span><br><span class="line">    <span class="keyword">return</span> mergeTwoLists(</span><br><span class="line">        mergeKLists(lists, low, middle),</span><br><span class="line">        mergeKLists(lists, middle + <span class="number">1</span>, high)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode a, ListNode b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>) <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>) <span class="keyword">return</span> a;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(a.val &lt;= b.val) &#123;</span><br><span class="line">        a.next = mergeTwoLists(a.next, b);</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    b.next = mergeTwoLists(a, b.next);</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(nk * log(k))</li>
<li>空间复杂度：O(1)，可以直接在链表上进行操作</li>
</ul>
<h2 id="148-Sort-List-排序链表-Mid"><a href="#148-Sort-List-排序链表-Mid" class="headerlink" title="148.Sort List(排序链表)(Mid)"></a><a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">148.Sort List(排序链表)(Mid)</a></h2><p>Sort a linked list in <em>O</em>(<em>n</em> log <em>n</em>) time using constant space complexity.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: <span class="number">4</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">3</span></span><br><span class="line">Output: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: <span class="number">-1</span>-&gt;<span class="number">5</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">0</span></span><br><span class="line">Output: <span class="number">-1</span>-&gt;<span class="number">0</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：需要注意，时间复杂度必须是O(nlogn)，空间复杂度也必须是常数级的，不能是O(n)的空间复杂度。</p>
<p>解决方法是归并排序的思想，但是因为空间复杂度必须为常数级，所以不能用递归。</p>
<p>这道题融合了另外两道题，876链表的中间节点，和21，合并两个有序链表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1、递归结束条件</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、找到链表中间节点并断开链表 &amp; 递归下探</span></span><br><span class="line">        ListNode midNode = middleNode(head);</span><br><span class="line">        ListNode rightHead = midNode.next;</span><br><span class="line">        midNode.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        ListNode left = sortList(head);</span><br><span class="line">        ListNode right = sortList(rightHead);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、当前层业务操作（合并有序链表）</span></span><br><span class="line">        <span class="keyword">return</span> mergeTwoLists(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  找到链表中间节点（876. 链表的中间结点）</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head.next.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并两个有序链表（21. 合并两个有序链表）</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode dummyNode = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode curr = dummyNode;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt; l2.val) &#123;</span><br><span class="line">                curr.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        curr.next = l1 != <span class="keyword">null</span> ? l1 : l2;</span><br><span class="line">        <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithms Note</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Object Oriented Programming(OOP)</title>
    <url>/2019/12/25/Object-oriented-OOP/</url>
    <content><![CDATA[<p><img src="https://s2.ax1x.com/2019/12/30/lKcqcd.md.jpg" alt=""></p>
<blockquote>
<p>在乎的是，自己以及他所在乎的人，能不能够秉持着自己的心意与信念，在人生中大部分时间里都能自在、快乐</p>
</blockquote>
<a id="more"></a>

<p>本文参考<a href="https://blog.csdn.net/baidu_33714003/article/details/52290627" target="_blank" rel="noopener">https://blog.csdn.net/baidu_33714003/article/details/52290627</a></p>
<h1 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h1><ol>
<li><strong>出发点不同</strong>。面向对象强调把问题直接映射到对象以及对象之间的接口上；而面向过程强调的则是过程的抽象化和模块化，它是以过程为中心构造或者处理客观世界问题的。</li>
<li><strong>层次逻辑关系不同</strong>。面向对象尽量会用计算机逻辑来模拟客观世界的物理存在，用类的层次结构展现类之间的继承和发展；而面向过程的处理问题的基本单位是能够清晰准确表达过程的模块，而且用模块之间的关系和内容表述计算机处理问题的过程。</li>
<li><strong>数据处理方式与控制程序方式不同</strong>。面向对象方法是”事件驱动”的，通过事件来激活和运行程序，而且它会把对应的代码封装成一个整体，原则上其他类不能直接修改其数据；面向过程则通过直接调用程序来处理数据，处理完后显示结果，在控制的方式上是按照涉及调用或者返回程序，不能导航，各模块之间存在控制与被控制，调用与被调用的关系。</li>
<li><strong>分析设计与编码转换方式不同</strong>。面向对象是无缝连接，从分析到设计再到编码是采用一致性的模型表示的；面向对象是有缝链接，它强调分析、设计以及编码之间按照规则的转换，过程中使用的模型是不一样的。</li>
</ol>
<h1 id="面向对象有哪些特征"><a href="#面向对象有哪些特征" class="headerlink" title="面向对象有哪些特征"></a>面向对象有哪些特征</h1><p>应当记住这段话：<strong>封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而多态则是为了实现另一个目的——接口重用！多态的作用，就是为了类在继承和派生的时候，保证使用“家谱”中任一类的实例的某一属性时的正确调用。</strong></p>
<p>主要包括：抽象、继承、封装和多态</p>
<ol>
<li><strong>抽象</strong>。抽象包括两个方面，一是<strong>过程抽象</strong>，二是<strong>数据抽象</strong>；忽略一个主体中与当前目标无关的方面和细节，以便更充分地注意与当前目标有关的方面。</li>
<li><strong>封装</strong>。可以说是最好理解的了，把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。</li>
<li><strong>继承</strong>。通过继承，子类可以使用父类中的一些成员变量和方法，从而能够提高代码的复用性，提高开发效率。</li>
<li><strong>多态</strong>。多态也是实现代码重用的重要机制，简单来说，就是实现接口的重用。它能够实现父类和一个或者多个它的子对象<strong>相等</strong>，但是有不同的表现形式。专业点说，就是<strong>允许将子类类型的指针赋值给父类类型的指针</strong>。</li>
</ol>
<h2 id="详解继承"><a href="#详解继承" class="headerlink" title="详解继承"></a>详解继承</h2><p>继承可以让子类使用父类中的一些成员变量和方法，从而能够提高代码复用性，提高开发效率。</p>
<p>继承的特点：在继承关系中，父类更通用，子类更具体。父类具有更一般的特征和行为，而子类除了具有父类的特征和行为，还具有一些自己特殊的特征和行为。</p>
<p>Java语言中，有关继承的术语主要是，被继承类叫做的父类或者基类(superclass)，继承父类的类叫做派生类或子类(subclass)。</p>
<p>在继承关系中，父类和子类需要满足”is-a”的关系，”子类是父类”。</p>
<h3 id="继承的特性"><a href="#继承的特性" class="headerlink" title="继承的特性"></a>继承的特性</h3><ol>
<li>Java语言不支持多重继承，也就是说一个子类至多只能有一个父类，但是可以通过实现多个接口来达到多重继承的目的，这一点上可以理解继承和多态有了overlap</li>
<li><strong>子类只能继承父类的非私有(public 和 protected)成员变量和方法</strong>。<font color=#FF0000>注意这一点经常容易出题，注意是”子类能继承父类的非私有方法和状态”</font></li>
<li>当子类中的成员变量与父类中的成员变量同名时，子类中的成员变量会覆盖父类的成员变量，而不会继承。可以理解为”就近原则”</li>
<li>当子类中的方法与父类中的方法有相同的函数签名(相同的方法名，相同的参数个数与类型)时，子类将会覆盖父类的方法，而不会继承。</li>
</ol>
<h3 id="为什么要继承？什么时候应该避免继承？"><a href="#为什么要继承？什么时候应该避免继承？" class="headerlink" title="为什么要继承？什么时候应该避免继承？"></a>为什么要继承？什么时候应该避免继承？</h3><p>继承可以有效实现代码复用，避免重复代码的出现。</p>
<p>当两个类具有相同的特征(属性)和行为(方法)时，可以将相同的部分抽取出来放到一个类中作为父类，其他两个类继承这个父类。</p>
<p>继承实现了面向对象的原则：write once, only once(编写一次，且只编写一次)</p>
<p>实际上，能用组合(下面<code>继承与组合的区别</code>部分有介绍什么是组合)的话就尽量别用继承，除非两个类之间确定是”is-a”的关系。<font color=#FF0000>具体使用，应当遵循以下两点原则</font>：</p>
<ol>
<li>除非两个类之间是”is-a”的关系，否则不要轻易使用继承。不要单纯为了实现代码重用而使用继承，因为过多的继承会破坏代码的可维护性，因为当父类被修改时，会影响所有继承了它的子类，从而增加程序的维护难度与成本。</li>
<li>不要仅仅为了实现多态而使用继承，如果类之间没有”is-a”的关系，可以通过实现接口与组合的方式来达到相同的目的。设计模式中的策略模式可以很好地说明这一点，采用接口与组合的方式比采用继承的方式具有更好的可扩展性。</li>
</ol>
<h4 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4><p>由于Java只支持单继承，如果想要同时继承两个类或多个类，无法用继承实现，只能选择实现多个接口。</p>
<p>同时，Java语言中，如果继承使用太多，也会让一个class里面的内容变得臃肿不堪。<font color=#FF0000>所以，在Java语言中，能使用组合就尽量不要用继承。</font></p>
<h3 id="如何实现继承"><a href="#如何实现继承" class="headerlink" title="如何实现继承"></a>如何实现继承</h3><p>在Java中，用extends(扩展)关键字实现，使用格式为：</p>
<p><code>class 子类名 extends 父类名</code></p>
<p>在父类中只定义一些通用的属性和方法，之后子类继承父类之后自动获取父类的属性和方法。当然子类可以定义特定的属性和方法，或子类重新定义父亲的属性、重写父亲的方法，这样可以获得与父类不同的功能。</p>
<p>如果想在子类中使用父类的构造方法，可以通过super()关键字调用父类方法，但是要注意调用父类的构造方法语句(super语句)必须是构造方法中的第一条语句，因为创建对象时西安仓就爱你父类对象，再创建子类对象。如果没有显示调用父类的构造方法，将自动调用父类的无参构造方法。</p>
<h3 id="一切类的老大-祖先-Object"><a href="#一切类的老大-祖先-Object" class="headerlink" title="一切类的老大(祖先)Object"></a>一切类的老大(祖先)Object</h3><p>所有类都直接或者间接地继承了java.lang.Object类，Object类中定义了所有的java对象都具有的相同行为，是所有类的祖先。</p>
<p>一个类如果没有使用extends关键字，那么这个类直接继承自Object类。</p>
<h3 id="继承与组合的区别"><a href="#继承与组合的区别" class="headerlink" title="继承与组合的区别"></a>继承与组合的区别</h3><p>继承和组合是面向对象的两种代码复用的方式。<strong>组合是指在新类里面创建原有类的对象，从而重复利用已有类的功能</strong>，而<strong>继承则允许设计人员根据其他类的实现来定义一个新类的实现。</strong></p>
<p>继承和组合都允许在新的类中定义子对象，但是组合是显示的，继承是隐式的。</p>
<p>组合与继承存在着对应关系：组合中的整体类和继承中的子类对应，组合中的局部类和继承中的父类对应。</p>
<p>正如之前所说了，在继承中父类和子类需要满足”is-a”的关系，即要满足”子类是父类”；而组合则是两个类之间有”<br>has-a”的关系，即”组合类有父类”</p>
<p>比如现在有三个类：Car(汽车)、Vehicle(交通工具)、Tire(轮胎)，那么正确的关系应该是：Car继承Vehicle(汽车是交通工具)、Car组合Tire(汽车拥有多个轮胎)，具体实现方法如下代码：</p>
<p>继承：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">extends</span> <span class="title">Vehicle</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组合：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tire</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">extends</span> <span class="title">Vehicle</span></span>&#123;</span><br><span class="line">	<span class="type">Tire</span> tire = <span class="keyword">new</span> <span class="type">Tire</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承和组合在实际使用中的选择，可以参考上面<code>什么时候应该避免使用继承？</code>模块。</p>
<h2 id="详解多态"><a href="#详解多态" class="headerlink" title="详解多态"></a>详解多态</h2><p>多态是实现代码重用的重要机制，主要表现在同一个操作在作用在不同对象的时候，有不同的语义(或者说操作内容不同)，从而会产生不同的结果。</p>
<h3 id="使用多态的好处"><a href="#使用多态的好处" class="headerlink" title="使用多态的好处"></a>使用多态的好处</h3><p>可以增强程序的可扩展性以及可维护性，也可以使得代码更加简洁。</p>
<h3 id="实现多态机制的方法"><a href="#实现多态机制的方法" class="headerlink" title="实现多态机制的方法"></a>实现多态机制的方法</h3><p>实现多态机制主要有两种方法：方法重载(overload)和方法覆盖(override)(也叫作方法重写)</p>
<h3 id="方法重载-overload"><a href="#方法重载-overload" class="headerlink" title="方法重载(overload)"></a>方法重载(overload)</h3><p>具体实现：</p>
<p>方法的重载(overload)：重载是发生在<strong>类内部</strong>，实质是不同的方法，也可以用不同的方法名进行替换，但是采用同一方法名能间接体现方法之间的内在相似性。</p>
<p>使用方法重载的目的：</p>
<ol>
<li>节省方法名</li>
<li>体现这些方法之间的内在联系</li>
</ol>
<p>举例：</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class KeyValue &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">HashMap</span>&lt;<span class="keyword">String</span> , <span class="keyword">Object</span>&gt; kvs = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> KeyValue put(<span class="keyword">String</span> <span class="built_in">key</span> , <span class="built_in">int</span> value) &#123;</span><br><span class="line">        kvs.put(<span class="built_in">key</span> , value);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> KeyValue put(<span class="keyword">String</span> <span class="built_in">key</span> , <span class="keyword">long</span> value) &#123;</span><br><span class="line">        kvs.put(<span class="built_in">key</span> , value);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> KeyValue put(<span class="keyword">String</span> <span class="built_in">key</span> , <span class="keyword">String</span> value)&#123;</span><br><span class="line">    	kvs.put(<span class="built_in">key</span> , value);</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为这些有着相同方法名的方法参数不同，所以在<strong>编译时</strong>就可以确定到底用哪个方法，<font color=#FF0000>它是一种编译时多态</font>。</p>
<h3 id="方法覆盖-重写-override"><a href="#方法覆盖-重写-override" class="headerlink" title="方法覆盖/重写(override)"></a>方法覆盖/重写(override)</h3><p>方法覆盖发生在继承里，子类根据需要，重写继承的方法。</p>
<p>目的：用父类的方法名重写了一个新的方法。</p>
<p>需要覆盖的方法要和父类方法具有完全相同的方法名，返回值，参数列表（个数、类型、顺序）</p>
<p>举例：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">String</span> name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">String</span> <span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">	Base()&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">printFuc</span><span class="params">(<span class="keyword">int</span> data,<span class="keyword">char</span> cr,<span class="keyword">String</span> strings)</span></span>&#123;</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"父类"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现多态的子类为SubBase</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">SubBase</span> <span class="symbol">extends</span> <span class="symbol">Base</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span> printFuc(<span class="built_in">int</span> data,char cr,String <span class="built_in">string</span>s)&#123;</span><br><span class="line">		<span class="built_in">int</span> a=<span class="number">3</span>;</span><br><span class="line">		<span class="built_in">int</span> b=<span class="number">3</span>;</span><br><span class="line">		<span class="keyword">class</span> <span class="symbol">inner</span>&#123;</span><br><span class="line">			<span class="keyword">public</span> <span class="built_in">int</span> add(<span class="built_in">int</span> a, <span class="built_in">int</span> b)&#123;</span><br><span class="line">				<span class="keyword">return</span> a + b;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		inner nomean = new inner();</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"重写父类"</span>);</span><br><span class="line">		<span class="keyword">return</span> nomean.add(a , b);		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有在<strong>运行时</strong>才能确定调用哪个方法，因此<font color=#FF0000>通过方法覆盖实现的多态也被称为运行时多态</font>。</p>
<h2 id="继承与多态的区别"><a href="#继承与多态的区别" class="headerlink" title="继承与多态的区别"></a>继承与多态的区别</h2><p>继承，子类继承父类中所以的属性和方法，但是对于private的属相和方法，由于这个是父类的隐私，所以子类虽然是继承了，但是没有可以访问这些属性和方法的引用，所以相当于没有继承到。很多时候，可以理解为，没有继承。</p>
<p>多态：就是父类引用可以持有子类对象。这时候只能调用父类中的方法，而子类中特有方法是无法访问的，因为这个时候（编译时）你把他看作父类对象的原因，但是到了运行的时候，编译器就会发现这个父类引用中原来是一个子类的对像，所以如果父类和子类中有相同的方法时，调用的会是子类中的方法，而不是父类的。</p>
<p>可以这么说：编译时看父类，运行时看子类。</p>
]]></content>
  </entry>
  <entry>
    <title>Design Pattern</title>
    <url>/2019/12/25/Design-Pattern/</url>
    <content><![CDATA[<blockquote>
<p>看待事物都可以按照这个顺序：发现问题、分析问题、理顺逻辑、寻求证据、解决问题</p>
</blockquote>
<p>设计模式相关内容介绍，尤其着重Java的单例模拟，看完必有收获。</p>
<a id="more"></a>

<h1 id="常见的设计模式有哪些？"><a href="#常见的设计模式有哪些？" class="headerlink" title="常见的设计模式有哪些？"></a>常见的设计模式有哪些？</h1><p>设计模式分为 3 大类型共 23 种：</p>
<ol>
<li><p>创建型：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p>
</li>
<li><p>结构型：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p>
</li>
<li><p>行为型：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p>
</li>
</ol>
<p>最常见的设计模式有：单例模式、工厂模式、代理模式、构造者模式、责任链模式、适配器模式、观察者模式等。</p>
<h1 id="如何用java写一个单例模式？"><a href="#如何用java写一个单例模式？" class="headerlink" title="如何用java写一个单例模式？"></a>如何用java写一个单例模式？</h1><p>参考文章：<a href="https://mp.weixin.qq.com/s/NVgVy07oXukQHzT80Bd1Jw" target="_blank" rel="noopener">你确定，你真的理解了单例模式么？</a></p>
<p>只能生成一个实例的类是实现了Singleton(单例)模式的类。由于设计模式在面向对象编程中起到了举足轻重的作用，所以在面试中很多公司都会问。而在常用的设计模式中，Singleton是唯一一个能够用短短几十行代码完整实现的设计模式，<font color=#FF0000>所以写一个Singleton是一个很常见的面试题</font>。</p>
<p>单例模式虽然看起来简单，但是如果往深了挖，又可以考察出候选者对于并发、类加载、序列化等知识点的掌握。</p>
<h2 id="什么是单例模式？"><a href="#什么是单例模式？" class="headerlink" title="什么是单例模式？"></a>什么是单例模式？</h2><p>如上面所说，只能生成一个实例的类是实现了Singleton(单例模式)的类，也就是一个单例模式的类只有一个实例，并且提供一个全局可以访问的入口(比如getInstance()方法)。比如《火影忍者》中漩涡鸣人特别喜欢用的影分身之术，实际上，每一个影分身都只对应着一个真身。</p>
<p>为什么要有只有一个实例的这种类？我们为什么需要它？</p>
<p><strong>理由一：</strong>为了节省内存、节省计算。很多情况下，我们只需要一个实例，如果出现了更多实例，反而是浪费。</p>
<p>举例：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">ExpensiveResource</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ExpensiveResource() &#123;</span><br><span class="line">        field1 = <span class="comment">// 查询数据库</span></span><br><span class="line">        field2 = <span class="comment">// 对查到的数据做大量计算</span></span><br><span class="line">        field3 = <span class="comment">// 加密、压缩等耗时操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类在构造的时候，需要查询数据库，对查到的数据做大量的计算，然后还要进行加密、压缩等非常耗时的操作。所以在第一次构造这个类的时候，我们就要花费很多时间来初始化这个对象。</p>
<p>假设数据库在一段时间不变，那么我们其实只需要使用这一个实例完成任务即可。如果每次都重新生成新的实例，浪费资源，十分没有必要。</p>
<p><strong>理由二：</strong>为了保证结果的正确。比如我们需要一个全局计数器用来统计人数。如果有多个实例，反而会造成混乱。</p>
<p><strong>理由三：</strong>方便管理。很多工具类，我们只需要一个实例，通过一个统一的入口，获取这个单例。太多实例不但没有帮助，只会让人眼花缭乱。</p>
<h2 id="单例模式使用场景？"><a href="#单例模式使用场景？" class="headerlink" title="单例模式使用场景？"></a>单例模式使用场景？</h2><ol>
<li><p><strong>无状态的工具类：日志工具、字符串工具等</strong>。——日志工具，不论在哪里使用，我们只需要它帮我们记录日志信息，除此功能之外并不需要在它的实例对象上存储任何状态，所以我们只需要一个实例对象就可以了。</p>
</li>
<li><p><strong>全局信息类：全局计数、环境变量</strong>。——比如我们要记录某个网站的访问次数，而且不希望有的访问记录被记录在对象A上，而有的被记录在对象B上。此时我们就可以让这个类为单例，在需要计数的时候拿出来用就可以了。</p>
</li>
</ol>
<p><font color=#FF0000>单例模式常见写法，这里列举五种：饿汉式、懒汉式、双重检查式、静态内部类式、枚举式</font></p>
<h2 id="单例模式的实现"><a href="#单例模式的实现" class="headerlink" title="单例模式的实现"></a>单例模式的实现</h2><p>下面按照写法的难易程度逐层递进：<br>相对简单的<strong>饿汉式：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 饿汉式写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类的第一行，用static修饰实例，并且把构造函数用private修饰。</p>
<p><font color=#FF0000>注：static关键字本身很重要的一个用途就是实现单例模式。</font>单例模式特点是只能有一个实例，为了实现这一功能，必须隐藏类的构造函数，即把构造函数声明为private，并提供一个创建对象的方法。由于构造对象被声明为private，所以外界无法直接创建这个对象，只能通过该类提供的方法来获取类的对象，要达到这样的目的只能把创建对象的方法声明为static.</p>
<p><strong>饿汉式优点：</strong>这种写法比较简单，在类装载的时候就完成了实例化，避免了线程同步的问题。</p>
<p><strong>饿汉式缺点：</strong>类装载的时候就完成了实例化，没有达到懒加载的效果，这点是最大缺陷。所以如果自始至终都没使用过这个实例，就可能会造成内存的浪费。</p>
<p>饿汉式写法的变种：<strong>静态代码块</strong>形式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 饿汉式另一种写法，静态代码块</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法和最开始的饿汉式的方式类似，只是把类实例化的过程放在了静态代码块中。同样，在类装载的过程中会执行静态代码块中的代码，完成实例的初始化，所以静态代码块的优缺点和饿汉式是一样的。<em>静态代码块写法就是饿汉式的写法。</em></p>
<p>接下来看第二种<strong>懒汉式</strong>。</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线程不安全的懒汉式写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是需要注意，上面这个懒汉式写法只能用于单线程。因为如果一个线程进入了 <code>if(singleton == null)</code> 判断语句块，还没来得及往下执行，另一个线程也通过了这个判断语句，此时会多次创建实例。所以这里需要注意，在多线程环境下，不能用上面这种懒汉式写法，它是错误的。</p>
<p>当然，懒汉式写法可以进行升级，让其成为线程安全的懒汉式写法。升级之后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线程安全的懒汉式写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加上了synchronized关键字，为了解决刚才的线程安全问题。<strong>缺点是效率太低了</strong>，每个线程在想获得类的实例的时候，执行getInstance的时候都要进行同步，虽然保证了多个线程不能同时访问，但是这在大多数情况下是没有必要的。</p>
<p>为了解决这个问题，衍生出了<strong>双重检查模式</strong>。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双重检查模式写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点在getInstance方法，我们进行了两次 <code>if(singleton == null)</code> 的判断，这样可以保证线程安全了。可以想象，在第一次初始化了singleton对象之后，再次调用代码块的时候，第一个if判断就可以让执行跳过整个代码块，返回之前已经初始化过的singleton,避免破坏单例。</p>
<p>这种写法的优势是，不仅保证了线程安全，而且延迟加载，效率也更高。</p>
<p>这里会有一个面试经常会问到的问题：”为什么要有两个if判断呢？去掉第二个if，可以么？(或者说，为什么要double-check?去掉第二个check行不行呢？)”</p>
<p>结论是，不行。为什么不行？我们来考虑这样的情景：</p>
<p>有两个线程同时调用getInstance()方法，由于singleton是空的，所以两个线程都可以通过第一重if判断。然后由于锁机制的存在，会有一个线程进入到第二个判断语句，而另一个线程会在外等候。过了一小段时间，第一个线程完成了对singleton的创建操作，它会退出synchronized的保护区域。此时第二个线程会进入到运行区域。此时如果没有第二个if判断，那么第二个线程也会创建一个实例，这就破坏了单例，这肯定是不行的。</p>
<p>当然，第一个check也是不能去掉的。如果去掉了第一个check,那么所有线程都会串行执行，效率低下。所以，<strong>两个check都是需要保留的</strong>。</p>
<p>此外，在双重检查模式中，我们给singleton加了 <code>volatile</code> 关键字。为什么要增加volatile呢？</p>
<p>原因在于， <code>singleton = new Singleton();</code> 这句话不是一个原子操作。事实上，在JVM中，这句话至少做了<strong>3件事</strong>：</p>
<ol>
<li>给singleton分配内存空间</li>
<li>调用Singleton的构造函数等来初始化singleton</li>
<li>将singleton对象指向分配的内存空间(执行完这步，singleton就不是Null了)</li>
</ol>
<p>但是这里需要注意1、2、3步骤的顺序。因为存在着重排序的优化。也就是说，<strong>第二步和第三步这两者的顺序是不能保证的</strong>。</p>
<p>最终的执行顺序可能是1-2-3，也可能是1-3-2。如果是1-3-2，那么如果第一个线程正在创建的时候，另一个线程也进来了，那么在进行第一重判断的时候会直接跳过整个代码块，直接返回singleton对象。而此时因为singleton还没有被初始化，所以会有空指针报错。哪怕最后线程1最后的初始化了，但是只是姗姗来迟，程序已经报错了。</p>
<p>用图解详细分析一下：<br><img src="https://s2.ax1x.com/2020/01/10/lfTzJs.png" alt="lfTzJs.png"></p>
<p>总结用volatile的原因：<strong>它可以防止上面重排序的发生，可以避免拿到未完成初始化的对象。</strong></p>
<p>下面来看静态内部类的写法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态内部类写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span> &#123;</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法和饿汉式所采用的机制类似，都才用了类装载的机制：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以此保证我们初始化实例时只有一个线程，而且是JVM帮助我们保证了线程安全性。</p>
<p>但是，饿汉式有一个特点，就是只要Singleton这个类被加载了，就会实例化单例对象。而静态内部类方式在Singleton类被装载的时候，并不会立刻实例化，而是在需要实例的时候，也就是调用getInstance()方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SingletonInstance.singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>的时候，才会去完成对singleton实例的实例化。</p>
<p><strong>静态内部类写法优点：</strong></p>
<ol>
<li>代码简洁，和双重检查的单例模式对比，静态内部类的单例实现代码更加简洁，清晰明了。</li>
<li>延迟初始化，调用getInstance()才会初始化Singleton对象。</li>
<li>线程安全。JVM在执行类的初始化阶段，会获得一个可以同步多个线程对同一个类的初始化锁。</li>
</ol>
<p>在介绍枚举写法之前，做一个小总结：</p>
<p><strong>静态内部类的写法与双重检查模式的优点是一样的，都避免了线程不安全的问题，并且延迟加载，效率高。</strong></p>
<p>可以看出，静态内部类和双重检查都是不错的写法。但是这两种方法都有一个缺陷：<strong>不能防止被反序列化。</strong></p>
<p>最后，枚举类的写法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 枚举类写法实现单例模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whatereverMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举类是在JDK1.5之后新增的方法。它不仅可以避免多线程同步的问题，而且还能防止反序列化和反射(这两种方法可以创建新的对象)破坏单例模式。</p>
<p>上面讲了五种方式，但是可以说，实现单例模式最好的方式，是利用枚举。这个观点其实是Josh Bloch的。他曾经在Effective Java中写道：”使用枚举实现单例的方法，虽然还没有被广泛采用，但是单元素的枚举类型应成为了实现Singleton的最佳方法。”</p>
<p>他如此推崇枚举，主要还是因为枚举写法的优点：</p>
<ol>
<li>代码简洁。枚举的写法不需要我们去考虑懒加载或者线程安全等问题。同时，代码短小精悍，比其他任何写法都更加简洁。</li>
<li>线程安全有保障。通过反编译枚举类，我们可以发现枚举种的各个枚举项，都是通过static代码块来定义和初始化的。他们会在类被加载的时候完成初始化。而java类的加载由JVM保证线程安全。所以，创建一个Enum类型的枚举是线程安全的。</li>
<li>最重要的优点：<strong>防止破坏单例</strong>。java专门对枚举的序列化做了单独的规定。在<strong>序列化</strong>的时候，仅仅会将枚举对象的name属性输出到结果中。而在反序列化时，会通过 <code>java.lang.Enum</code> 的valueOf方法来根据名字查找对象，而不会新建一个新的对象。这就防止了反序列化导致的单例破坏问题的出现。而针对<strong>反射</strong>，枚举类同样有防御措施。反射在通过newInstance创建对象时，会检查这个类是否是枚举类。如果是，会抛出： <code>IllegalArgumentException(&quot;Cannot reflecatively create enum objects&quot;)</code> 这个异常，反射创建对象会失败。可以说，java针对枚举做的工作是非常全面的，枚举，是java亲生的。</li>
</ol>
<p>可以看出，枚举这种方式可以防止反序列化和反射破坏单例，在这一点上与其他方式相比，优势巨大。安全问题不容小觑，一旦通过反序列化或者反射生成了多个实例，那么单例模式就彻底没用了。</p>
<p>总结：<br><img src="https://s2.ax1x.com/2020/01/10/lhCFII.png" alt="lhCFII.png"></p>
<p>需要注意，如果使用了线程不安全的写法，在并发的情况下可能产生多个实例，那么不仅会影响性能，更可能造成数据错误等严重的后果。</p>
<p>回答面试问题过程中，可以先从饿汉式、懒汉式说起，一步一步地分析每一种的优缺点，并且对写法进行演进。重点需要关注，<strong>双重检查模式为什么需要两次检查？为什么要是用volatile关键字？</strong>最后再说枚举类写法的优点和其背后的原理。</p>
<p>此外，在工作中，如果遇到了<strong>全局信息类、无状态工具类</strong>等场景，推荐使用枚举的写法实现单例模式。</p>
<h1 id="备注-static、volatile"><a href="#备注-static、volatile" class="headerlink" title="备注(static、volatile)"></a>备注(static、volatile)</h1><h2 id="static关键字用法"><a href="#static关键字用法" class="headerlink" title="static关键字用法"></a>static关键字用法</h2><p>static关键字在Java中主要有四种定义的类型：成员变量、成员方法、代码块和内部类</p>
<h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>Java语言没有全局变量的概念，但是可以通过static达到全局变量的效果。</p>
<p>不同于普通的实例变量(new出来对象之后才定义的对象)，用static修饰的变量为静态变量，<strong>只要静态变量所在的类被加载，这个静态变量就会被分配空间，后面每次只要使用这个变量，就是唯一的</strong>。</p>
<p>静态变量只有一个，被类拥有，所有对象都共享这个静态变量，而实例对象是与具体对象相关的。需要注意的是，与C++语言不同的是，在Java语言中，不能在方法中定义static变量。</p>
<h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p>static方法是类的方法，不需要创建对象就可以被调用，而非static方法是对象的方法，只有对象被创建出来后才可以被使用。</p>
<p>static方法中不能使用this和super关键字，不能调用非static方法，只能访问所属类的静态成员变量和成员方法，因为当static方法被调用时，这个类的对象可能还没被创建，即使已经被创建了，也无法确定调用哪个对象的方法。同理，static方法也不能访问非static类型的变量。</p>
<h3 id="static代码块"><a href="#static代码块" class="headerlink" title="static代码块"></a>static代码块</h3><p>static代码块，即静态代码块，在类中是独立于成员变量和成员函数的代码块的。注意它不会被定义在任何一个方法体内，JVM在加载类时会执行static代码块，如果有多个static代码块，JVM会按顺序执行。static代码块经常被用于初始化静态变量，而且只会被加载一次。</p>
<h3 id="static内部类"><a href="#static内部类" class="headerlink" title="static内部类"></a>static内部类</h3><p>static内部类指被声明为static的内部类，他可以不依赖于外部实例对象而被实例化，而通常的内部类需要在外部类实例化后才能实例化。静态内部类不能与外部类有相同的名字，不能访问外部类的普通成员变量，只能访问外部类中的静态成员和静态方法(包括私有类型)。</p>
<h2 id="static和final组合"><a href="#static和final组合" class="headerlink" title="static和final组合"></a>static和final组合</h2><p>被final修饰的变量，都是指不能被修改的。</p>
<p>在Java中，static关键字经常和final结合使用，用来修饰成员变量和成员方法，修饰之后的变量类似C/C++中的全局变量。</p>
<ul>
<li>对于变量，若使用static final修饰，则表示一旦赋值，就不可以修改，并且通过类名可以访问。</li>
<li>对于方法，若使用static final修饰，则表示该方法不可覆盖并且可以通过类名直接访问。</li>
</ul>
<p><font color=#FF0000>在Java中，不能在成员函数内部定义static变量</font></p>
<h2 id="volatile有什么用"><a href="#volatile有什么用" class="headerlink" title="volatile有什么用"></a>volatile有什么用</h2><p>用Java语言编写的程序中，有时为了提高程序的运行效率，编译器会自动对其进行优化，把经常访问的变量缓存起来，程序在读取这个变量时有可能会直接从缓存(例如寄存器)中来读取这个值，而不会去内存中读取。这样做的一个好处是提高了程序的运行效率，但当遇到多线程编程时，某个变量的值可能因为其他线程的使用而改变了，但是因为该值的缓存的值不会改变，所以会造成程序读取的值和其实际的值不一致。</p>
<p>举个可以解决问题的例子，在本次线程内，当读取一个变量时，为了提高读取速度，优先把变量存入到缓存中，之后再取变量的值时，直接从缓存中读。当变量值改变的时候，需要把新的值复制到该缓存中，以便保持一致。</p>
<p><code>volatile</code>是一个类型修饰符(type specifier)，当初设计它的用途就是用来修饰被不同线程访问和修改的变量，被<code>volatile</code>修饰之后，<strong>系统默认每次使用它的时候都是从内存中提取，而不会利用缓存</strong>。在使用了volatile修饰之后，所有线程看到的同一变量的值都是相同的。</p>
<p>一个代码例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Boolean flag;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(flag) &#123;</span><br><span class="line">            ; <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码可以停止线程，也是最常用的一种方法。如果变量flag没有被volatile修饰，那么当这个线程的run方法在判断flag值的时候，使用的有可能是缓存中的值，此时就不能即时地获取其他线程对flag所做的操作，因此会导致线程不能及时地停止。</p>
<p><strong>需要注意</strong>，volatile不能保证操作原子性，所以volatile不能代替synchronized，此外volatile会阻止编译器对代码的优化，降低执行效率，所以一般来说能不用就不用volatile.</p>
<h1 id="常用的设计模式与使用场景"><a href="#常用的设计模式与使用场景" class="headerlink" title="常用的设计模式与使用场景"></a>常用的设计模式与使用场景</h1><p>例如，在回答 “你知道哪几种设计模式” 这个问题时，不但能说出几种设计模式，以及适合哪类场景，而且还能指出哪些著名的框架在处理什么问题时使用了哪种设计模式，或者自己在处理某个项目的什么场景时，使用了哪种设计模式，取得了什么效果，这样肯定会给面试官留下非常好的印象。</p>
<h2 id="1-工厂模式：Spring如何创建Bean"><a href="#1-工厂模式：Spring如何创建Bean" class="headerlink" title="1.工厂模式：Spring如何创建Bean"></a>1.工厂模式：Spring如何创建Bean</h2><p>工厂模式是创建不同类型实例时常用的方式，例如 Spring 中的各种 Bean 是有不同 Bean 工厂类进行创建的。</p>
<h2 id="2-代理模式：Motan服务的动态代理"><a href="#2-代理模式：Motan服务的动态代理" class="headerlink" title="2.代理模式：Motan服务的动态代理"></a>2.代理模式：Motan服务的动态代理</h2><p>代理模式，主要用在不适合或者不能直接引用另一个对象的场景，可以通过代理模式对被代理对象的访问行为进行控制。Java 的代理模式分为静态代理和动态代理。静态代理指在编译时就已经创建好了代理类，例如在源代码中编写的类；动态代理指在 JVM 运行过程中动态创建的代理类，使用动态代理的方法有 JDK 动态代理、CGLIB、Javassist 等。面试时遇到这个问题可以举个动态代理的例子，比如在 Motan RPC 中，是使用 JDK 的动态代理，通过反射把远程请求进行封装，使服务看上去就像在使用本地的方法。</p>
<h2 id="3-责任链模式：Netty消息处理的方式"><a href="#3-责任链模式：Netty消息处理的方式" class="headerlink" title="3.责任链模式：Netty消息处理的方式"></a>3.责任链模式：Netty消息处理的方式</h2><p>责任链模式有点像工厂的流水线，链上每一个节点完成对对象的某一种处理，例如 Netty 框架在处理消息时使用的 Pipeline 就是一种责任链模式。</p>
<h2 id="4-适配器模式：SLF4J如何支持Log4J"><a href="#4-适配器模式：SLF4J如何支持Log4J" class="headerlink" title="4.适配器模式：SLF4J如何支持Log4J"></a>4.适配器模式：SLF4J如何支持Log4J</h2><p>适配器模式，类似于我们常见的转接头，把两种不匹配的对象来进行适配，也可以起到对两个不同的对象进行解藕的作用。例如我们常用的日志处理框架 SLF4J，如果我们使用了 SLF4J 就可以跟 Log4j 或者 Logback 等具体的日志实现框架进行解藕。通过不同适配器将 SLF4J 与 Log4j 等实现框架进行适配，完成日志功能的使用。</p>
<h2 id="5-观察者模式：GRPC是如何支持流式请求的"><a href="#5-观察者模式：GRPC是如何支持流式请求的" class="headerlink" title="5.观察者模式：GRPC是如何支持流式请求的"></a>5.观察者模式：GRPC是如何支持流式请求的</h2><p>观察者模式也被称作发布订阅模式，适用于一个对象的某个行为需要触发一系列事件的场景，例如 gRPC 中的 Stream 流式请求的处理就是通过观察者模式实现的。</p>
<h2 id="6-构造者模式：PB序列化中的Builder"><a href="#6-构造者模式：PB序列化中的Builder" class="headerlink" title="6.构造者模式：PB序列化中的Builder"></a>6.构造者模式：PB序列化中的Builder</h2><p>构造者模式，适用于一个对象有很多复杂的属性，需要根据不同情况创建不同的具体对象，例如创建一个 PB 对象时使用的 builder 方式。</p>
]]></content>
      <categories>
        <category>Study Note</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
        <tag>Foundation</tag>
      </tags>
  </entry>
</search>
