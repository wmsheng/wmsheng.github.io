<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>List, Map Analysis</title>
    <url>/2020/03/16/List-Map-Analysis/</url>
    <content><![CDATA[<blockquote>
<p>世上无难事，只要肯攀登——毛泽东</p>
</blockquote>
<a id="more"></a>

<h1 id="ArrayList源码解析及设计思路"><a href="#ArrayList源码解析及设计思路" class="headerlink" title="ArrayList源码解析及设计思路"></a>ArrayList源码解析及设计思路</h1><p>提纲挈领地说，主要从ArrayList整体架构出发，考虑到新增、扩容、删除、迭代等内容。</p>
<p>ArrayList其实就是围绕底层数组，各个API都是对数组的操作进行封装，使用者使用的时候对底层无需感知，只要关注如何使用即可。</p>
<p><strong>ArrayList是线程不安全的</strong>，多线程情况下更推荐使用线程安全的类：Collections#synchronizedList。</p>
<p>如果我们不指定位置直接添加元素时(add(E element))，元素会默认会添加在最后，不会触发底层数组的复制，不考虑底层数组自动扩容的话，时间复杂度为O(1) ，在指定位置添加元素(add(int index, E element))，需要复制底层数组，根据最坏打算，时间复杂度是O(n)。</p>
<h2 id="ArrayList整体架构"><a href="#ArrayList整体架构" class="headerlink" title="ArrayList整体架构"></a>ArrayList整体架构</h2><p>ArrayList底层就是一个数组，如图：</p>
<p><img src="https://i.loli.net/2020/03/16/6qckhNGguBS95KQ.png" alt="ArrayList底层结构.png"></p>
<p>和数组一样，index下标从0开始，然后上图数组的名字是<code>elementData</code>。</p>
<p>除了上面这两个概念，源码中还有下面三个基础概念：</p>
<ul>
<li>DEFAULT_CAPACITY 表示数组的初始大小，默认是 10，这个数字要记住；</li>
<li>size 表示当前数组的大小，类型 int，因为没有使用 volatile 修饰，所以是非线程安全的；</li>
<li>modCount 统计当前数组被修改的版本次数，每当这个结构发生结构变动的时候，会 +1。</li>
</ul>
<p>然后，在ArrayList的类注释中有下面比较重要的四点：</p>
<ol>
<li>ArrayList允许put null值，而且会自动扩容;</li>
<li>size()、isEmpty()、get()、set()、add()等方法的时间复杂度都是O(1);</li>
<li>ArrayList不是线程安全的，多线程情况下更推荐使用线程安全的类：Collections#synchronizedList;</li>
<li>增强 for 循环，或者使用迭代器迭代过程中，如果数组大小被改变，会快速失败，抛出异常。</li>
</ol>
<h2 id="源码解析-未完成"><a href="#源码解析-未完成" class="headerlink" title="源码解析(未完成)"></a>源码解析(未完成)</h2><p>源码解析主要集中在ArrayList的初始化、新增与扩容、删除元素、迭代器等方面</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化有三种方法：无参数直接初始化、指定大小初始化、指定初始数据初始化</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> static final Object<span class="literal">[]</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无参数直接初始化，数组大小为空</span></span><br><span class="line">public <span class="constructor">ArrayList()</span> &#123;</span><br><span class="line">    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定初始数据初始化</span></span><br><span class="line">public <span class="constructor">ArrayList(Collection&lt;? <span class="params">extends</span> E&gt; <span class="params">c</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//elementData 是保存数组的容器，默认为 null</span></span><br><span class="line">    elementData = c.<span class="keyword">to</span><span class="constructor">Array()</span>;</span><br><span class="line">    <span class="comment">//如果给定的集合（c）数据有值</span></span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="comment">//如果集合元素类型不是 Object 类型，我们会转成 Object</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.get<span class="constructor">Class()</span> != Object<span class="literal">[]</span>.<span class="keyword">class</span>) &#123;</span><br><span class="line">            elementData = <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span>copy<span class="constructor">Of(<span class="params">elementData</span>, <span class="params">size</span>, Object[].<span class="params">class</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 给定集合（c）无值，则默认空数组</span></span><br><span class="line">        this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要补充：</p>
<ol>
<li>ArrayList无参构造器初始化的时候，默认大小是空数组，并不是大家常说的 10，10 是在第一次 add 的时候扩容的数组值。</li>
<li>指定初始数据初始化时，我们发现一个这样子的注释 see 6260652，这是 Java 的一个 bug，意思是当给定集合内的元素不是 Object 类型时，我们会转化成 Object 的类型。这个BUG在JDK9中被解决。</li>
</ol>
<h3 id="新增和扩容实现"><a href="#新增和扩容实现" class="headerlink" title="新增和扩容实现"></a>新增和扩容实现</h3><p>新增就是往数组中添加元素，主要分成两步：</p>
<ol>
<li>判断是否需要扩容，如果需要执行扩容操作；</li>
<li>直接赋值。</li>
</ol>
<p>两步的源码如下：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//确保数组大小是否足够，不够执行扩容，size 为当前数组的大小</span></span><br><span class="line">  ensureCapacityInternal(<span class="built_in">size</span> + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">  <span class="comment">//直接赋值，线程不安全的</span></span><br><span class="line">  elementData[<span class="built_in">size</span>++] = e;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩容(ensureCapacityInternal)的源码：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> void ensure<span class="constructor">CapacityInternal(<span class="params">int</span> <span class="params">minCapacity</span>)</span> &#123;</span><br><span class="line">  <span class="comment">//如果初始化数组大小时，有给定初始值，以给定的大小为准，不走 if 逻辑</span></span><br><span class="line">  <span class="keyword">if</span> (elementData<span class="operator"> == </span>DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">    minCapacity = <span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//确保容积足够</span></span><br><span class="line">  ensure<span class="constructor">ExplicitCapacity(<span class="params">minCapacity</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> void ensure<span class="constructor">ExplicitCapacity(<span class="params">int</span> <span class="params">minCapacity</span>)</span> &#123;</span><br><span class="line">  <span class="comment">//记录数组被修改</span></span><br><span class="line">  modCount++;</span><br><span class="line">  <span class="comment">// 如果我们期望的最小容量大于目前数组的长度，那么就扩容</span></span><br><span class="line">  <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">    grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//扩容，并把现有数据拷贝到新的数组里面去</span></span><br><span class="line"><span class="keyword">private</span> void grow(<span class="built_in">int</span> minCapacity) &#123;</span><br><span class="line">  <span class="built_in">int</span> oldCapacity = elementData.length;</span><br><span class="line">  <span class="comment">// oldCapacity &gt;&gt; 1 是把 oldCapacity 除以 2 的意思</span></span><br><span class="line">  <span class="built_in">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果扩容后的值 &lt; 我们的期望值，扩容后的值就等于我们的期望值</span></span><br><span class="line">  <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = minCapacity;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果扩容后的值 &gt; jvm 所能分配的数组的最大值，那么就用 Integer 的最大值</span></span><br><span class="line">  <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = huge<span class="constructor">Capacity(<span class="params">minCapacity</span>)</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 通过复制进行扩容</span></span><br><span class="line">  elementData = <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span>copy<span class="constructor">Of(<span class="params">elementData</span>, <span class="params">newCapacity</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了注释内容，需要额外注意四点：</p>
<ul>
<li><p>扩容的规则并不是翻倍，是原来容量大小 + 容量大小的一半，直白来说，扩容后的大小是原来容量的 1.5 倍；</p>
</li>
<li><p>ArrayList 中的数组的最大值是 Integer.MAX_VALUE，超过这个值，JVM 就不会给数组分配内存空间了。</p>
</li>
<li><p>新增时，并没有对值进行严格的校验，所以 ArrayList 是允许 null 值的。</p>
</li>
<li><p>源码在扩容的时候，有数组大小溢出意识，就是说扩容后数组的大小下界不能小于 0，上界不能大于 Integer 的最大值，这种意识我们可以学习。</p>
</li>
</ul>
<p>扩容完成之后，赋值是非常简单的，直接往数组上添加元素即可：elementData [size++] = e。也正是通过这种简单赋值，没有任何锁控制，所以这里的操作是线程不安全的。</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>对ArrayList的新增或者删除操作本质都是对数组元素的操作，只需要根据数组索引，直接新增和删除数据，所以时间复杂度是O(1)</p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>需要强调的是，<font color=#FF0000>只有当 ArrayList 作为共享变量时，才会有线程安全问题，当 ArrayList 是方法内的局部变量时，是没有线程安全的问题的</font>。</p>
<p>ArrayList 有线程安全问题的本质，是因为 ArrayList 自身的 elementData、size、modConut 在进行各种操作时，都没有加锁，而且这些变量的类型并非是可见（volatile）的，所以如果多个线程对这些变量进行操作时，可能会有值被覆盖的情况。</p>
<p>类注释中推荐我们使用 Collections#synchronizedList 来保证线程安全，SynchronizedList 是通过在每个方法上面加上锁来实现，虽然实现了线程安全，但是性能大大降低，具体实现源码：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;<span class="comment">// synchronized 是一种轻量锁，mutex 表示一个当前 SynchronizedList</span></span><br><span class="line">        <span class="function"><span class="keyword">return</span> c.<span class="title">add</span><span class="params">(e)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="LinkedList源码解析及设计思路"><a href="#LinkedList源码解析及设计思路" class="headerlink" title="LinkedList源码解析及设计思路"></a>LinkedList源码解析及设计思路</h1><p>LinkedList可以用于先入先出，也可以用于先入后出，因为它本质是一个链表，而且是双向链表。</p>
<h2 id="LinkedList整体架构"><a href="#LinkedList整体架构" class="headerlink" title="LinkedList整体架构"></a>LinkedList整体架构</h2><p>LinkedList本质是双向链表，整体结构如下图：</p>
<p><img src="https://i.loli.net/2020/03/16/oIRDHnTqAy2dcsB.png" alt="LinkedList底层架构.png"></p>
<h2 id="源码解析-未完"><a href="#源码解析-未完" class="headerlink" title="源码解析(未完)"></a>源码解析(未完)</h2><h3 id="新增元素"><a href="#新增元素" class="headerlink" title="新增元素"></a>新增元素</h3><p>追加节点时，我们可以选择追加到链表头部，还是追加到链表尾部，add 方法默认是从尾部开始追加，addFirst 方法是从头部开始追加。</p>
<h4 id="从尾部追加-add"><a href="#从尾部追加-add" class="headerlink" title="从尾部追加(add)"></a>从尾部追加(add)</h4><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从尾部开始追加节点</span></span><br><span class="line">void linkLast(E e) &#123;</span><br><span class="line">    <span class="comment">// 把尾节点数据暂存</span></span><br><span class="line">    final Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">// 新建新的节点，初始化入参含义：</span></span><br><span class="line">    <span class="comment">// l 是新节点的前一个节点，当前值是尾节点值</span></span><br><span class="line">    <span class="comment">// e 表示当前新增节点，当前新增节点后一个节点是 null</span></span><br><span class="line">    final Node&lt;E&gt; <span class="keyword">new</span><span class="type">Node</span> = <span class="keyword">new</span> <span class="type">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 新建节点追加到尾部</span></span><br><span class="line">    last = <span class="keyword">new</span><span class="type">Node</span>;</span><br><span class="line">    <span class="comment">//如果链表为空（l 是尾节点，尾节点为空，链表即空），头部和尾部是同一个节点，都是新建的节点</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        first = <span class="keyword">new</span><span class="type">Node</span>;![图片描述](<span class="comment">//img1.sycdn.imooc.com/5d5fc69600013e4803600240.gif)</span></span><br><span class="line">    <span class="comment">//否则把前尾节点的下一个节点，指向当前尾节点。</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = <span class="keyword">new</span><span class="type">Node</span>;</span><br><span class="line">    <span class="comment">//大小和版本更改</span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码上来看，尾部追加节点比较简单，只需要简单地把指向位置修改下即可</p>
<h4 id="从头部追加-addFirst"><a href="#从头部追加-addFirst" class="headerlink" title="从头部追加(addFirst)"></a>从头部追加(addFirst)</h4><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从头部追加</span></span><br><span class="line"><span class="keyword">private</span> void linkFirst(E e) &#123;</span><br><span class="line">    <span class="comment">// 头节点赋值给临时变量</span></span><br><span class="line">    final Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="comment">// 新建节点，前一个节点指向null，e 是新建节点，f 是新建节点的下一个节点，目前值是头节点的值</span></span><br><span class="line">    final Node&lt;E&gt; <span class="keyword">new</span><span class="type">Node</span> = <span class="keyword">new</span> <span class="type">Node</span>&lt;&gt;(<span class="literal">null</span>, e, f);</span><br><span class="line">    <span class="comment">// 新建节点成为头节点</span></span><br><span class="line">    first = <span class="keyword">new</span><span class="type">Node</span>;</span><br><span class="line">    <span class="comment">// 头节点为空，就是链表为空，头尾节点是一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span>)</span><br><span class="line">        last = <span class="keyword">new</span><span class="type">Node</span>;</span><br><span class="line">    <span class="comment">//上一个头节点的前一个节点指向当前节点</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        f.prev = <span class="keyword">new</span><span class="type">Node</span>;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>头部追加节点和尾部追加节点非常类似，只是前者是移动头节点的 prev 指向，后者是移动尾节点的 next 指向。</p>
<h3 id="节点删除"><a href="#节点删除" class="headerlink" title="节点删除"></a>节点删除</h3><p>节点删除的方式和追加类似，我们可以选择从头部删除，也可以选择从尾部删除，删除操作会把节点的值，前后指向节点都置为 null，帮助 GC 进行回收。</p>
<p>从头部删除：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从头删除节点 f 是链表头节点</span></span><br><span class="line"><span class="keyword">private</span> E unlinkFirst(Node&lt;E&gt; f) &#123;</span><br><span class="line">    <span class="comment">// 拿出头节点的值，作为方法的返回值</span></span><br><span class="line">    <span class="keyword">final</span> E element = f.item;</span><br><span class="line">    <span class="comment">// 拿出头节点的下一个节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; <span class="keyword">next</span> = f.<span class="keyword">next</span>;</span><br><span class="line">    <span class="comment">//帮助 GC 回收头节点</span></span><br><span class="line">    f.item = <span class="keyword">null</span>;</span><br><span class="line">    f.<span class="keyword">next</span> = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 头节点的下一个节点成为头节点</span></span><br><span class="line">    first = <span class="keyword">next</span>;</span><br><span class="line">    <span class="comment">//如果 next 为空，表明链表为空</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">next</span> == <span class="keyword">null</span>)</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//链表不为空，头节点的前一个节点指向 null</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">next</span>.prev = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//修改链表大小和版本</span></span><br><span class="line">    <span class="keyword">size</span>--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从尾部删除差不多，不重复贴了。</p>
<p>链表结构的节点新增、删除都非常简单，仅仅把前后节点的指向修改下就好了，所以 LinkedList 新增和删除速度很快。</p>
<h3 id="访问元素-节点"><a href="#访问元素-节点" class="headerlink" title="访问元素(节点)"></a>访问元素(节点)</h3><p>这是LinkedList的缺陷了，需要循环挨个查找才行。但是LinkedList其实也是用了二分法来加快查找的。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">// 根据链表索引位置查询节点</span><br><span class="line"><span class="keyword">Node</span><span class="title">&lt;E</span>&gt; <span class="keyword">node</span><span class="title">(int</span> index) &#123;</span><br><span class="line">    // 如果 index 处于队列的前半部分，从头开始找，size &gt;&gt; <span class="number">1</span> 是 size 除以 <span class="number">2</span> 的意思。</span><br><span class="line">    if (index <span class="tag">&lt; (size &gt;</span>&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">Node</span><span class="title">&lt;E</span>&gt; x = first;</span><br><span class="line">        // 直到 for 循环到 index 的前一个 <span class="keyword">node</span> <span class="title">停止</span></span><br><span class="line"><span class="title">        for</span> (int i = <span class="number">0</span>; i <span class="tag">&lt; index; i++)</span></span><br><span class="line"><span class="tag">            x = x.next;</span></span><br><span class="line"><span class="tag">        return x;</span></span><br><span class="line"><span class="tag">    &#125; else &#123;// 如果 index 处于队列的后半部分，从尾开始找</span></span><br><span class="line"><span class="tag">        Node&lt;E&gt;</span> x = last;</span><br><span class="line">        // 直到 for 循环到 index 的后一个 <span class="keyword">node</span> <span class="title">停止</span></span><br><span class="line"><span class="title">        for</span> (int i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LinkedList 并没有采用从头循环到尾的做法，而是采取了简单二分法，首先看看 index 是在链表的前半部分，还是后半部分。如果是前半部分，就从头开始寻找，反之亦然。通过这种方式，使循环的次数至少降低了一半，提高了查找的性能，这种思想值得我们借鉴。</p>
<h3 id="LinkedList和其他结构对比"><a href="#LinkedList和其他结构对比" class="headerlink" title="LinkedList和其他结构对比"></a>LinkedList和其他结构对比</h3><p>首先，LinkedList实现了Queue接口，也就是实例化Queue的时候，需要这么写：<code>Queue&lt;E&gt; queue = new LinkedList&lt;&gt;()</code>，在新增、删除、查询等方面增加了很多新的方法，这些方法在平时特别容易混淆，在链表为空的情况下，返回值也不太一样</p>
<p><img src="https://i.loli.net/2020/03/16/RykLXdcBrnDTUJl.png" alt="LinkedList方法对比表格.png"></p>
<h1 id="List接口常见问题"><a href="#List接口常见问题" class="headerlink" title="List接口常见问题"></a>List接口常见问题</h1><h2 id="1-说说对ArrayList的理解？"><a href="#1-说说对ArrayList的理解？" class="headerlink" title="1.说说对ArrayList的理解？"></a>1.说说对ArrayList的理解？</h2><p>建议先回答总体架构，再从某个细节出发作为突破口，比如这样：</p>
<p>ArrayList 底层数据结构是个数组，其 API 都做了一层对数组底层访问的封装，比如说 add 方法的过程是……（这里可以引用我们在 ArrayList 源码解析中 add 的过程）。</p>
<p>谈谈对LinkedList的理解？——一样的套路。</p>
<h2 id="2-扩容类问题"><a href="#2-扩容类问题" class="headerlink" title="2.扩容类问题"></a>2.扩容类问题</h2><h3 id="2-1-ArrayList-无参数构造器构造，现在-add-一个值进去，此时数组的大小是多少，下一次扩容前最大可用大小是多少？"><a href="#2-1-ArrayList-无参数构造器构造，现在-add-一个值进去，此时数组的大小是多少，下一次扩容前最大可用大小是多少？" class="headerlink" title="2.1 ArrayList 无参数构造器构造，现在 add 一个值进去，此时数组的大小是多少，下一次扩容前最大可用大小是多少？"></a>2.1 ArrayList 无参数构造器构造，现在 add 一个值进去，此时数组的大小是多少，下一次扩容前最大可用大小是多少？</h3><p>答：此处数组的大小是 1，下一次扩容前最大可用大小是 10，因为 ArrayList 第一次扩容时，是有默认值的，默认值是 10，在第一次 add 一个值进去时，数组的可用大小被扩容到 10 了。</p>
<h3 id="2-2-如果我连续往-list-里面新增值，增加到第-11-个的时候，数组的大小是多少？"><a href="#2-2-如果我连续往-list-里面新增值，增加到第-11-个的时候，数组的大小是多少？" class="headerlink" title="2.2 如果我连续往 list 里面新增值，增加到第 11 个的时候，数组的大小是多少？"></a>2.2 如果我连续往 list 里面新增值，增加到第 11 个的时候，数组的大小是多少？</h3><p>扩容一次，从10扩容1.5倍，到15</p>
<h3 id="2-3-数组初始化，被加入一个值后，如果我使用-addAll-方法，一下子加入-15-个值，那么最终数组的大小是多少？"><a href="#2-3-数组初始化，被加入一个值后，如果我使用-addAll-方法，一下子加入-15-个值，那么最终数组的大小是多少？" class="headerlink" title="2.3 数组初始化，被加入一个值后，如果我使用 addAll 方法，一下子加入 15 个值，那么最终数组的大小是多少？"></a>2.3 数组初始化，被加入一个值后，如果我使用 addAll 方法，一下子加入 15 个值，那么最终数组的大小是多少？</h3><p>扩容一次不够，根据ArrayList源码的扩容原则，当期望值(这里是16)大于一次扩容之后的量，那么我们这次扩容的值为期望值，即扩容之后容量为16</p>
<h3 id="2-4-现在我有一个很大的数组需要拷贝，原数组大小是-5k，请问如何快速拷贝？"><a href="#2-4-现在我有一个很大的数组需要拷贝，原数组大小是-5k，请问如何快速拷贝？" class="headerlink" title="2.4 现在我有一个很大的数组需要拷贝，原数组大小是 5k，请问如何快速拷贝？"></a>2.4 现在我有一个很大的数组需要拷贝，原数组大小是 5k，请问如何快速拷贝？</h3><p>答：因为原数组比较大，不能频繁扩容，否则有大量拷贝的工作，造成拷贝的性能低下，所以回答说新建数组时，指定新数组的大小为 5k 即可。</p>
<h3 id="2-5-为什么说扩容会消耗性能？"><a href="#2-5-为什么说扩容会消耗性能？" class="headerlink" title="2.5 为什么说扩容会消耗性能？"></a>2.5 为什么说扩容会消耗性能？</h3><p>答：扩容底层使用的是 System.arraycopy 方法，会把原数组的数据全部拷贝到新数组上，所以性能消耗比较严重。</p>
<h3 id="2-6-源码扩容过程有什么值得借鉴的地方？"><a href="#2-6-源码扩容过程有什么值得借鉴的地方？" class="headerlink" title="2.6 源码扩容过程有什么值得借鉴的地方？"></a>2.6 源码扩容过程有什么值得借鉴的地方？</h3><p>主要两点：</p>
<ol>
<li>扩容的思想。每次扩容1.5倍，也是比较合理的设置，前期慢慢增加，后期增加速度更快</li>
<li>扩容过程中，有数组大小溢出的意识，比如要求扩容后的数组大小，不能小于 0，不能大于 Integer 的最大值。</li>
</ol>
<h2 id="3-对比问题"><a href="#3-对比问题" class="headerlink" title="3.对比问题"></a>3.对比问题</h2><h3 id="3-1-ArrayList和LinkedList有何不同？"><a href="#3-1-ArrayList和LinkedList有何不同？" class="headerlink" title="3.1 ArrayList和LinkedList有何不同？"></a>3.1 ArrayList和LinkedList有何不同？</h3><p>最大的不同是两者底层的数据结构不同，ArrayList 底层是数组，LinkedList 底层是双向链表，两者的数据结构不同也导致了操作的 API 实现有所差异，拿新增实现来说，ArrayList 会先计算并决定是否扩容，然后把新增的数据直接赋值到数组上，而 LinkedList 仅仅只需要改变插入节点和其前后节点的指向位置关系即可。</p>
<h3 id="3-2-ArrayList-和-LinkedList-应用场景有何不同"><a href="#3-2-ArrayList-和-LinkedList-应用场景有何不同" class="headerlink" title="3.2 ArrayList 和 LinkedList 应用场景有何不同"></a>3.2 ArrayList 和 LinkedList 应用场景有何不同</h3><p>答：ArrayList 更适合于快速的查找匹配，不适合频繁新增删除，像工作中经常会对元素进行匹配查询的场景比较合适，LinkedList 更适合于经常新增和删除，对查询反而很少的场景。</p>
<h3 id="3-3-ArrayList-和-LinkedList-两者有没有最大容量"><a href="#3-3-ArrayList-和-LinkedList-两者有没有最大容量" class="headerlink" title="3.3 ArrayList 和 LinkedList 两者有没有最大容量"></a>3.3 ArrayList 和 LinkedList 两者有没有最大容量</h3><p>答：ArrayList 有最大容量的，为 Integer 的最大值，大于这个值 JVM 是不会为数组分配内存空间的，LinkedList 底层是双向链表，理论上可以无限大。但源码中，LinkedList 实际大小用的是 int 类型，这也说明了 LinkedList 不能超过 Integer 的最大值，不然会溢出。</p>
<h3 id="3-4-ArrayList-和-LinkedList-是如何对-null-值进行处理的"><a href="#3-4-ArrayList-和-LinkedList-是如何对-null-值进行处理的" class="headerlink" title="3.4 ArrayList 和 LinkedList 是如何对 null 值进行处理的"></a>3.4 ArrayList 和 LinkedList 是如何对 null 值进行处理的</h3><p>答：ArrayList 允许 null 值新增，也允许 null 值删除。删除 null 值时，是从头开始，找到第一值是 null 的元素删除；LinkedList 新增删除时对 null 值没有特殊校验，是允许新增和删除的。</p>
<h3 id="3-5-ArrayList-和-LinedList-是线程安全的么，为什么？"><a href="#3-5-ArrayList-和-LinedList-是线程安全的么，为什么？" class="headerlink" title="3.5 ArrayList 和 LinedList 是线程安全的么，为什么？"></a>3.5 ArrayList 和 LinedList 是线程安全的么，为什么？</h3><p>答：当两者作为非共享变量时，比如说仅仅是在方法里面的局部变量时，是没有线程安全问题的，只有当两者是共享变量时，才会有线程安全问题。主要的问题点在于多线程环境下，所有线程任何时刻都可对数组和链表进行操作，这会导致值被覆盖，甚至混乱的情况。</p>
<p>如果有线程安全问题，在迭代的过程中，会频繁报 ConcurrentModificationException 的错误，意思是在我当前循环的过程中，数组或链表的结构被其它线程修改了。</p>
<h3 id="3-6-如何解决线程安全问题？"><a href="#3-6-如何解决线程安全问题？" class="headerlink" title="3.6 如何解决线程安全问题？"></a>3.6 如何解决线程安全问题？</h3><p>Java 源码中推荐使用 Collections#synchronizedList 进行解决，Collections#synchronizedList 的返回值是 List 的每个方法都加了 synchronized 锁，保证了在同一时刻，数组和链表只会被一个线程所修改，或者采用CopyOnWriteArrayList 并发 List 来解决。</p>
<h2 id="4-其他"><a href="#4-其他" class="headerlink" title="4.其他"></a>4.其他</h2><h3 id="4-1-描述下双向链表的新增和删除"><a href="#4-1-描述下双向链表的新增和删除" class="headerlink" title="4.1 描述下双向链表的新增和删除"></a>4.1 描述下双向链表的新增和删除</h3><p>如果条件允许，可以画图说明，参考前面LinkedList的图。</p>
<p>如果远程电话面试，可以这样描述：双向链表中双向的意思是说前后节点之间互相有引用，链表的节点我们称为 Node。Node 有三个属性组成：其前一个节点，本身节点的值，其下一个节点，假设 A、B 节点相邻，A 节点的下一个节点就是 B，B 节点的上一个节点就是 A，两者互相引用，在链表的头部节点，我们称为头节点。头节点的前一个节点是 null，尾部称为尾节点，尾节点的后一个节点是 null，如果链表数据为空的话，头尾节点是同一个节点，本身是 null，指向前后节点的值也是 null。</p>
<h3 id="4-2-描述下双向链表的新增和删除"><a href="#4-2-描述下双向链表的新增和删除" class="headerlink" title="4.2 描述下双向链表的新增和删除"></a>4.2 描述下双向链表的新增和删除</h3><p>答：如果是面对面沟通，最好可以直接画图，如果是电话面试，可以这么描述：</p>
<p>新增：我们可以选择从链表头新增，也可以选择从链表尾新增，如果是从链表尾新增的话，直接把当前节点追加到尾节点之后，本身节点自动变为尾节点。</p>
<p>删除：把删除节点的后一个节点的 prev 指向其前一个节点，把删除节点的前一个节点的 next 指向其后一个节点，最后把删除的节点置为 null 即可。</p>
<h1 id="Hashmap源码解析与架构-未完"><a href="#Hashmap源码解析与架构-未完" class="headerlink" title="Hashmap源码解析与架构(未完)"></a>Hashmap源码解析与架构(未完)</h1><p>首先HashMap的源码很长，面试题也很多，最好能弄清楚底层。</p>
<h2 id="整体架构-未完"><a href="#整体架构-未完" class="headerlink" title="整体架构(未完)"></a>整体架构(未完)</h2><p>HashMap 底层的数据结构主要是：数组 + 链表 + 红黑树。其中当链表的长度大于等于 8 时，链表会转化成红黑树，当红黑树的大小小于等于 6 时，红黑树会转化成链表。</p>
<p><img src="https://i.loli.net/2020/03/16/aguyM8eO4cqZ9Qt.png" alt="HashMap整体架构.png"></p>
<p>图中左边竖着的是 HashMap 的数组结构，数组的元素可能是单个 Node，也可能是个链表，也可能是个红黑树，比如数组下标索引为 2 的位置就是一个链表，下标索引为 9 的位置对应的就是红黑树</p>
<h3 id="类注释中的信息"><a href="#类注释中的信息" class="headerlink" title="类注释中的信息"></a>类注释中的信息</h3><p>从下面这些信息可以大体把握HashMap的重点。</p>
<ul>
<li>允许 null 值，不同于 HashTable ，是线程不安全的；</li>
<li>load factor（影响因子） 默认值是 0.75， 是均衡了时间和空间损耗算出来的值，较高的值会减少空间开销（扩容减少，数组大小增长速度变慢），但增加了查找成本（hash 冲突增加，链表长度变长），不扩容的条件：数组容量 &gt; 需要的数组大小 /load factor；</li>
<li>如果有很多数据需要储存到 HashMap 中，建议 HashMap 的容量一开始就设置成足够的大小，这样可以防止在其过程中不断的扩容，影响性能；</li>
<li>HashMap 是非线程安全的，我们可以自己在外部加锁，或者通过 Collections#synchronizedMap 来实现线程安全，Collections#synchronizedMap 的实现是在每个方法上加上了 synchronized 锁；</li>
<li>在迭代过程中，如果 HashMap 的结构被修改，会快速失败。</li>
</ul>
<h1 id="Treemap源码解析与架构-未完"><a href="#Treemap源码解析与架构-未完" class="headerlink" title="Treemap源码解析与架构(未完)"></a>Treemap源码解析与架构(未完)</h1><h1 id="Map接口常问问题"><a href="#Map接口常问问题" class="headerlink" title="Map接口常问问题"></a>Map接口常问问题</h1><h2 id="1-Map整体数据结构问题"><a href="#1-Map整体数据结构问题" class="headerlink" title="1. Map整体数据结构问题"></a>1. Map整体数据结构问题</h2><h3 id="1-1-HashMap的底层数据结构"><a href="#1-1-HashMap的底层数据结构" class="headerlink" title="1.1 HashMap的底层数据结构"></a>1.1 HashMap的底层数据结构</h3><p>答：HashMap 底层是数组 + 链表 + 红黑树的数据结构，数组的主要作用是方便快速查找，时间复杂度是 O(1)，默认大小是 16，数组的下标索引是通过 key 的 hashcode 计算出来的，数组元素叫做 Node，当多个 key 的 hashcode 一致，但 key 值不同时，单个 Node 就会转化成链表，链表的查询复杂度是 O(n)，当链表的长度大于等于 8 并且数组的大小超过 64 时，链表就会转化成红黑树，红黑树的查询复杂度是 O(log(n))，简单来说，最坏的查询次数相当于红黑树的最大深度。</p>
<h3 id="1-2-HashMap、TreeMap、LinkedHashMap-三者有啥相同点，有啥不同点？"><a href="#1-2-HashMap、TreeMap、LinkedHashMap-三者有啥相同点，有啥不同点？" class="headerlink" title="1.2 HashMap、TreeMap、LinkedHashMap 三者有啥相同点，有啥不同点？"></a>1.2 HashMap、TreeMap、LinkedHashMap 三者有啥相同点，有啥不同点？</h3><p>答：相同点：</p>
<ol>
<li>三者在特定的情况下，都会使用红黑树；</li>
<li>底层的 hash 算法相同；</li>
<li>在迭代的过程中，如果 Map 的数据结构被改动，都会报 ConcurrentModificationException 的错误。</li>
</ol>
<p>不同点：</p>
<ol>
<li>Map 数据结构以数组为主，查询非常快，TreeMap 数据结构以红黑树为主，利用了红黑树左小右大的特点，可以实现 key 的排序，LinkedHashMap 在 HashMap 的基础上增加了链表的结构，实现了插入顺序访问和最少访问删除两种策略;</li>
<li>由于三种 Map 底层数据结构的差别，导致了三者的使用场景的不同，TreeMap 适合需要根据 key 进行排序的场景，LinkedHashMap 适合按照插入顺序访问，或需要删除最少访问元素的场景，剩余场景我们使用 HashMap 即可，我们工作中大部分场景基本都在使用 HashMap；</li>
<li>由于三种 map 的底层数据结构的不同，导致上层包装的 api 略有差别。</li>
</ol>
<h3 id="1-3-说一下-Map-的-hash-算法"><a href="#1-3-说一下-Map-的-hash-算法" class="headerlink" title="1.3 说一下 Map 的 hash 算法"></a>1.3 说一下 Map 的 hash 算法</h3><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> hash(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">    <span class="built_in">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">key</span> == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = <span class="built_in">key</span>.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">key</span> 在数组中的位置公式：tab[(n - <span class="number">1</span>) &amp; hash]</span><br></pre></td></tr></table></figure>

<p>这段代码是HashMap的hash算法。</p>
<p>这其实是一个数学问题，源码中就是通过以上代码来计算 hash 的，首先计算出 key 的 hashcode，因为 key 是 Object，所以会根据 key 的不同类型进行 hashcode 的计算，接着计算 h ^ (h &gt;&gt;&gt; 16) ，这么做的好处是使大多数场景下，算出来的 hash 值比较分散。</p>
<p>一般来说，hash 值算出来之后，要计算当前 key 在数组中的索引下标位置时，可以采用取模的方式，就是索引下标位置 = hash 值 % 数组大小，这样做的好处，就是可以保证计算出来的索引下标值可以均匀的分布在数组的各个索引位置上，但取模操作对于处理器的计算是比较慢的，数学上有个公式，当 b 是 2 的幂次方时，a % b = a &amp;（b-1），所以此处索引位置的计算公式我们可以更换为： (n-1) &amp; hash。</p>
<p>此问题可以延伸出三个小问题：</p>
<ol>
<li>为什么不用 key % 数组大小，而是需要用 key 的 hash 值 % 数组大小。</li>
</ol>
<p>答：如果 key 是数字，直接用 key % 数组大小是完全没有问题的，但我们的 key 还有可能是字符串，是复杂对象，这时候用 字符串或复杂对象 % 数组大小是不行的，所以需要先计算出 key 的 hash 值。</p>
<ol start="2">
<li>计算 hash 值时，为什么需要右移 16 位？</li>
</ol>
<p>答：hash 算法是 h ^ (h &gt;&gt;&gt; 16)，为了使计算出的 hash 值更分散，所以选择先将 h 无符号右移 16 位，然后再于 h 异或时，就能达到 h 的高 16 位和低 16 位都能参与计算，减少了碰撞的可能性。</p>
<ol start="3">
<li>为什么把取模操作换成了 &amp; 操作？</li>
</ol>
<p>答：key.hashCode() 算出来的 hash 值还不是数组的索引下标，为了随机的计算出索引的下表位置，我们还会用 hash 值和数组大小进行取模，这样子计算出来的索引下标比较均匀分布。</p>
<p>取模操作处理器计算比较慢，处理器对 &amp; 操作就比较擅长，换成了 &amp; 操作，是有数学上证明的支撑，为了提高了处理器处理的速度。</p>
<ol start="4">
<li>为什么提倡数组大小是 2 的幂次方？</li>
</ol>
<p>答：因为只有大小是 2 的幂次方时，才能使 hash 值 % n(数组大小) == (n-1) &amp; hash 公式成立。</p>
<h3 id="1-4-为解决-hash-冲突，大概有哪些办法。"><a href="#1-4-为解决-hash-冲突，大概有哪些办法。" class="headerlink" title="1.4 为解决 hash 冲突，大概有哪些办法。"></a>1.4 为解决 hash 冲突，大概有哪些办法。</h3><p>答：1：好的 hash 算法，细问的话复述一下上题的 hash 算法;</p>
<p>2：自动扩容，当数组大小快满的时候，采取自动扩容，可以减少 hash 冲突;</p>
<p>3：hash 冲突发生时，采用链表来解决;</p>
<p>4：hash 冲突严重时，链表会自动转化成红黑树，提高遍历速度。</p>
<p>其他不熟悉的方法不要说了。</p>
<h2 id="2-HashMap源码细节类问题"><a href="#2-HashMap源码细节类问题" class="headerlink" title="2. HashMap源码细节类问题"></a>2. HashMap源码细节类问题</h2><h3 id="2-1-HashMap-是如何扩容的？"><a href="#2-1-HashMap-是如何扩容的？" class="headerlink" title="2.1 HashMap 是如何扩容的？"></a>2.1 HashMap 是如何扩容的？</h3><p>答：扩容的时机：</p>
<ol>
<li>put 时，发现数组为空，进行初始化扩容，默认扩容大小为 16;</li>
<li>put 成功后，发现现有数组大小大于扩容的门阀值时，进行扩容，扩容为老数组大小的 2 倍;</li>
</ol>
<p>扩容的门阀是 threshold，每次扩容时 threshold 都会被重新计算，门阀值等于数组的大小 * 影响因子（0.75）。</p>
<p>新数组初始化之后，需要将老数组的值拷贝到新数组上，链表和红黑树都有自己拷贝的方法。</p>
<h3 id="2-1-HashMap-是如何扩容的？-1"><a href="#2-1-HashMap-是如何扩容的？-1" class="headerlink" title="2.1 HashMap 是如何扩容的？"></a>2.1 HashMap 是如何扩容的？</h3><h3 id="2-2-HashMap-是如何扩容的？"><a href="#2-2-HashMap-是如何扩容的？" class="headerlink" title="2.2 HashMap 是如何扩容的？"></a>2.2 HashMap 是如何扩容的？</h3><p>答：hash 冲突指的是 key 值的 hashcode 计算相同，但 key 值不同的情况。</p>
<p>如果桶中元素原本只有一个或已经是链表了，新增元素直接追加到链表尾部；</p>
<p>如果桶中元素已经是链表，并且链表个数大于等于 8 时，此时有两种情况：</p>
<p>如果此时数组大小小于 64，数组再次扩容，链表不会转化成红黑树;<br>如果数组大小大于 64 时，链表就会转化成红黑树。<br>这里不仅仅判断链表个数大于等于 8，还判断了数组大小，数组容量小于 64 没有立即转化的原因，猜测主要是因为红黑树占用的空间比链表大很多，转化也比较耗时，所以数组容量小的情况下冲突严重，我们可以先尝试扩容，看看能否通过扩容来解决冲突的问题。</p>
<h3 id="2-3-为什么链表个数大于等于-8-时，链表要转化成红黑树了？"><a href="#2-3-为什么链表个数大于等于-8-时，链表要转化成红黑树了？" class="headerlink" title="2.3 为什么链表个数大于等于 8 时，链表要转化成红黑树了？"></a>2.3 为什么链表个数大于等于 8 时，链表要转化成红黑树了？</h3><p>答：当链表个数太多了，遍历可能比较耗时，转化成红黑树，可以使遍历的时间复杂度降低，但转化成红黑树，有空间和转化耗时的成本，我们通过泊松分布公式计算，正常情况下，链表个数出现 8 的概念不到千万分之一，所以说正常情况下，链表都不会转化成红黑树，这样设计的目的，是为了防止非正常情况下，比如 hash 算法出了问题时，导致链表个数轻易大于等于 8 时，仍然能够快速遍历。</p>
<p>延伸问题：红黑树什么时候转变成链表。</p>
<p>答：当节点的个数小于等于 6 时，红黑树会自动转化成链表，主要还是考虑红黑树的空间成本问题，当节点个数小于等于 6 时，遍历链表也很快，所以红黑树会重新变成链表。</p>
<h3 id="2-4-HashMap-在-put-时，如果数组中已经有了这个-key，我不想把-value-覆盖怎么办？取值时，如果得到的-value-是空时，想返回默认值怎么办？"><a href="#2-4-HashMap-在-put-时，如果数组中已经有了这个-key，我不想把-value-覆盖怎么办？取值时，如果得到的-value-是空时，想返回默认值怎么办？" class="headerlink" title="2.4 HashMap 在 put 时，如果数组中已经有了这个 key，我不想把 value 覆盖怎么办？取值时，如果得到的 value 是空时，想返回默认值怎么办？"></a>2.4 HashMap 在 put 时，如果数组中已经有了这个 key，我不想把 value 覆盖怎么办？取值时，如果得到的 value 是空时，想返回默认值怎么办？</h3><p>答：如果数组有了 key，但不想覆盖 value ，可以选择 putIfAbsent 方法，这个方法有个内置变量 onlyIfAbsent，内置是 true ，就不会覆盖，我们平时使用的 put 方法，内置 onlyIfAbsent 为 false，是允许覆盖的。</p>
<p>取值时，如果为空，想返回默认值，可以使用 getOrDefault 方法，方法第一参数为 key，第二个参数为你想返回的默认值，如 map.getOrDefault(“2”,“0”)，当 map 中没有 key 为 2 的值时，会默认返回 0，而不是空。</p>
<h3 id="2-5-通过以下代码进行删除，是否可行？"><a href="#2-5-通过以下代码进行删除，是否可行？" class="headerlink" title="2.5 通过以下代码进行删除，是否可行？"></a>2.5 通过以下代码进行删除，是否可行？</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">HashMap&lt;<span class="keyword">String</span>,<span class="keyword">String</span> &gt; <span class="built_in">map</span> = Maps.newHashMap();</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">put</span>(<span class="string">"1"</span>,<span class="string">"1"</span>);</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">put</span>(<span class="string">"2"</span>,<span class="string">"2"</span>);</span><br><span class="line"><span class="built_in">map</span>.forEach((s, s2) -&gt; <span class="built_in">map</span>.<span class="built_in">remove</span>(<span class="string">"1"</span>));</span><br></pre></td></tr></table></figure>

<p>答：不行，会报错误 ConcurrentModificationException</p>
<h3 id="2-6-描述一下-HashMap-get、put-的过程"><a href="#2-6-描述一下-HashMap-get、put-的过程" class="headerlink" title="2.6 描述一下 HashMap get、put 的过程"></a>2.6 描述一下 HashMap get、put 的过程</h3><p>答：参考源码分析部分</p>
]]></content>
      <categories>
        <category>Study Note</category>
        <category>Interview Note</category>
      </categories>
      <tags>
        <tag>List</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title>Overview of SSL and TLS protocol operration mechanism</title>
    <url>/2020/03/16/SSL-and-TLS/</url>
    <content><![CDATA[<blockquote>
<p>不希望负担变轻，只希望肩膀变强</p>
</blockquote>
<a id="more"></a>

<p>本文参考转载阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">这篇文章</a></p>
<p>都说HTTPS比HTTP更安全，WHY？主要就是因为HTTPS比HTTP多一个SSL/TLS协议。可以说，互联网的安全，是建立在SSL/TLS协议之上的。</p>
<p>SSL/TLS使用非对称加密，即加密使用的秘钥和解密使用的秘钥是不相同的。</p>
<p>本文简要介绍SSL/TLS协议的运行机制。文章的重点是设计思想和运行过程，不涉及具体的实现细节。</p>
<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>不使用SSL/TLS的HTTP通信，就是不加密的通信。所有信息明文传播，带来了三大风险。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>） 窃听风险（eavesdropping）：第三方可以获知通信内容。</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>） 篡改风险（tampering）：第三方可以修改通信内容。</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>） 冒充风险（pretending）：第三方可以冒充他人身份参与通信。</span><br></pre></td></tr></table></figure>

<p>SSL/TLS协议是为了解决这三大风险而设计的，希望达到：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>） 所有信息都是加密传播，第三方无法窃听。</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>） 具有校验机制，一旦被篡改，通信双方会立刻发现。</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>） 配备身份证书，防止身份被冒充。</span><br></pre></td></tr></table></figure>

<p>互联网是开放环境，通信双方都是未知身份，这为协议的设计带来了很大的难度。而且，协议还必须能够经受所有匪夷所思的攻击，这使得SSL/TLS协议变得异常复杂。</p>
<h1 id="基本运行过程"><a href="#基本运行过程" class="headerlink" title="基本运行过程"></a>基本运行过程</h1><p>SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。(<strong>即非对称加密，加密和解密的秘钥不同</strong>)</p>
<p>但是，这里有两个问题。</p>
<p>（1）如何保证公钥不被篡改？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。</span><br></pre></td></tr></table></figure>

<p>（2）公钥加密计算量太大，如何减少耗用的时间？</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">解决方法：每一次对话（<span class="keyword">session</span>），客户端和服务器端都生成一个"对话密钥"（<span class="keyword">session</span> key），用它来加密信息。由于"对话密钥"是对称加密，所以运算速度非常快，而服务器公钥只用于加密"对话密钥"本身，这样就减少了加密运算的消耗时间。</span><br></pre></td></tr></table></figure>

<p>因此，SSL/TLS协议的基本过程是这样的：</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>） 客户端向服务器端索要并验证公钥。</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>） 双方协商生成<span class="string">"对话密钥"</span>。</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>） 双方采用<span class="string">"对话密钥"</span>进行加密通信。</span><br></pre></td></tr></table></figure>

<p>上面过程的前两步，又称为”握手阶段”（handshake）。</p>
<h1 id="HTTPS四次握手详细过程"><a href="#HTTPS四次握手详细过程" class="headerlink" title="HTTPS四次握手详细过程"></a>HTTPS四次握手详细过程</h1><p>“握手阶段”的所有通信都是明文的。</p>
<h2 id="客户端发出请求（ClientHello）"><a href="#客户端发出请求（ClientHello）" class="headerlink" title="客户端发出请求（ClientHello）"></a>客户端发出请求（ClientHello）</h2><p>首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做ClientHello请求。</p>
<p>在这一步，客户端主要向服务器提供以下信息。</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>） 支持的协议版本，比如TLS <span class="number">1.0</span>版。</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>） 一个客户端生成的随机数，稍后用于生成<span class="string">"对话密钥"</span>。</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>） 支持的加密方法，比如RSA公钥加密。</span><br><span class="line"></span><br><span class="line">（<span class="number">4</span>） 支持的压缩方法。</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是，客户端发送的信息之中不包括服务器的域名。也就是说，理论上服务器只能包含一个网站，否则会分不清应该向客户端提供哪一个网站的数字证书。这就是为什么通常一台服务器只能有一张数字证书的原因。</p>
<p>对于虚拟主机的用户来说，这当然很不方便。2006年，TLS协议加入了一个Server Name Indication扩展，允许客户端向服务器提供它所请求的域名。</p>
<h2 id="服务器回应（SeverHello）"><a href="#服务器回应（SeverHello）" class="headerlink" title="服务器回应（SeverHello）"></a>服务器回应（SeverHello）</h2><p>服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello。服务器的回应包含以下内容。</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>） 确认使用的加密通信协议版本，比如TLS <span class="number">1.0</span>版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>） 一个服务器生成的随机数，稍后用于生成<span class="string">"对话密钥"</span>。</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>） 确认使用的加密方法，比如RSA公钥加密。</span><br><span class="line"></span><br><span class="line">（<span class="number">4</span>） 服务器证书。</span><br></pre></td></tr></table></figure>

<p>除了上面这些信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供”客户端证书”。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。</p>
<h2 id="客户端回应"><a href="#客户端回应" class="headerlink" title="客户端回应"></a>客户端回应</h2><p>客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。</p>
<p>如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>） 一个随机数。该随机数用服务器公钥加密，防止被窃听。</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>） 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>） 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。</span><br></pre></td></tr></table></figure>

<p>上面第一项的随机数，是整个握手阶段出现的第三个随机数，又称”pre-master key”。有了它以后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把”会话密钥”。</p>
<p>至于为什么一定要用三个随机数，来生成”会话密钥”，dog250解释得很好：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">"不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。</span></span><br><span class="line"></span><br><span class="line">对于RSA密钥交换算法来说，<span class="keyword">pre</span>-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。</span><br><span class="line"></span><br><span class="line"><span class="keyword">pre</span> master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么<span class="keyword">pre</span> master secret就有可能被猜出来，那么仅适用<span class="keyword">pre</span> master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上<span class="keyword">pre</span> master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。<span class="comment">"</span></span><br></pre></td></tr></table></figure>

<p>此外，如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息。</p>
<h2 id="服务器的最后回应"><a href="#服务器的最后回应" class="headerlink" title="服务器的最后回应"></a>服务器的最后回应</h2><p>服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的”会话密钥”。然后，向客户端最后发送下面信息。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。</span><br></pre></td></tr></table></figure>

<p>至此，整个握手阶段全部结束。<strong>接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议</strong>，只不过用”会话密钥”加密内容。</p>
<p>如下图：</p>
<p><img src="https://i.loli.net/2020/03/16/ekPaYWIzLdbwo9F.png" alt="HTTPS协议的加密.png"></p>
]]></content>
      <categories>
        <category>Study Note</category>
        <category>Interview Note</category>
      </categories>
      <tags>
        <tag>HTTPS</tag>
        <tag>SSL</tag>
        <tag>TLS</tag>
      </tags>
  </entry>
  <entry>
    <title>What is RESTful?</title>
    <url>/2020/03/13/what-is-restful/</url>
    <content><![CDATA[<blockquote>
<p>不希望负担变轻，只希望肩膀变强</p>
</blockquote>
<p>介绍RESTful核心概念，列举RESTful API设计与实践的案例</p>
<a id="more"></a>

<p>本文参考转载阮一峰老师博客系列文章<a href="http://www.ruanyifeng.com/blog/" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/</a></p>
<h1 id="理解RESTful架构"><a href="#理解RESTful架构" class="headerlink" title="理解RESTful架构"></a>理解RESTful架构</h1><h2 id="什么是RESTful架构"><a href="#什么是RESTful架构" class="headerlink" title="什么是RESTful架构"></a>什么是RESTful架构</h2><p>互联网发展到了现在，我们需要把网站看做是一个软件。它是一种”客户端-服务器”模式的软件，建立在分布式体系上，通过互联网通信，具有高延时和高并发的特性。</p>
<p>(NOTE：高延时：high latency，指一个数据包从客户端发送到网站服务器，然后再立即从网站服务器返回用户计算机的来回时间，简单来说就是数据从用户这边发送到服务器那边所用的时间。网络延时越高，意味着网速越慢。网络延时1数值，代表1毫秒，通常使用网络管理工具<code>PING</code>来测量网络延时，典型数值为几十到几百毫秒。)</p>
<p>但是在以前，软件开发和网络是不同的领域，而且少有交集。因为软件开发主要针对单机环境，网络则主要研究系统之间通信，而互联网的兴起，使得这两个领域开始融合。</p>
<p>RESTful架构是什么，是一个比较不容易说清楚的问题，这里给出比较简单的解释。</p>
<p>“REST”源自于Roy Thomas Fielding在他的2000年的博士论文。(此人同时也是HTTP协议1.0和1.1版本的主要设计者)</p>
<p>他说他写这篇文章的目的：”我这篇文章的写作目的，就是想在符合架构原理的前提下，理解和评估以网络为基础的应用软件的架构设计，得到一个功能强、性能好、适宜通信的架构。”</p>
<h2 id="名称"><a href="#名称" class="headerlink" title="名称"></a>名称</h2><p>REST，即Representational State Transfer的缩写。中文翻译：”表现层状态转化”。</p>
<p>顺理成章，一个符合REST原则的架构，就称之为RESTful架构。</p>
<p>要理解RESTful架构，最好的方法就是去理解Representational State Transfer这个词组到底是什么意思，它的每一个词代表了什么涵义。</p>
<h2 id="资源-Resources"><a href="#资源-Resources" class="headerlink" title="资源(Resources)"></a>资源(Resources)</h2><p>所谓”状态转移”,省略了主语。”表现层”其实指的是”资源”（Resources）的”表现层”。</p>
<p>所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URL（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URL就可以，因此URL就成了每一个资源的地址或独一无二的识别符。</p>
<p>所谓”上网”，就是与互联网上一系列的”资源”互动，调用它的URL。</p>
<h2 id="表现层-Representation"><a href="#表现层-Representation" class="headerlink" title="表现层(Representation)"></a>表现层(Representation)</h2><p>“资源”是一种信息实体，它可以有多种外在表现形式。我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。</p>
<p>比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。</p>
<p>URL只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URL应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述。</p>
<h2 id="状态转化-State-Transfer"><a href="#状态转化-State-Transfer" class="headerlink" title="状态转化(State Transfer)"></a>状态转化(State Transfer)</h2><p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。</p>
<p>互联网通信协议HTTP协议，是一个<strong>无状态协议</strong>。这意味着，所有的状态都保存在服务器端(不考虑Cookie的话)。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。</p>
<p>客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</p>
<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>综合上面的解释，我们总结一下什么是RESTful架构：</p>
<p>（1）每一个URL代表一种资源；</p>
<p>（2）客户端和服务器之间，传递这种资源的某种表现层；</p>
<p>（3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。</p>
<h2 id="设计的误区"><a href="#设计的误区" class="headerlink" title="设计的误区"></a>设计的误区</h2><p>RESTful架构有一些典型的设计误区。</p>
<p>最常见的一种设计错误，就是URL包含动词。因为”资源”表示一种实体，所以应该是名词，URI不应该有动词，动词应该放在HTTP协议中。</p>
<p>举例来说，某个URI是/posts/show/1，其中show是动词，这个URL就设计错了，正确的写法应该是/posts/1，然后用GET方法表示show。</p>
<p>如果某些动作是HTTP动词表示不了的，你就应该把动作做成一种资源。比如网上汇款，从账户1向账户2汇款500元，错误的URL是：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">POST /accounts/<span class="number">1</span>/transfer/<span class="number">500</span>/to/<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>正确的写法是把动词transfer改成名词transaction，资源不能是动词，但是可以是一种服务：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">POST /transaction HTTP/<span class="number">1.1</span></span><br><span class="line">Host: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">　　</span><br><span class="line"><span class="keyword">from</span>=<span class="number">1</span>&amp;to=<span class="number">2</span>&amp;amount=<span class="number">500.00</span></span><br></pre></td></tr></table></figure>

<p>另一个设计误区，就是在URI中加入版本号：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.example.com/app</span><span class="regexp">/1.0/foo</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.example.com/app</span><span class="regexp">/1.1/foo</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.example.com/app</span><span class="regexp">/2.0/foo</span></span><br></pre></td></tr></table></figure>

<p>因为不同的版本，可以理解成同一种资源的不同表现形式，所以应该采用同一个URL。版本号可以在HTTP请求头信息的Accept字段中进行区分（参见<a href="https://www.informit.com/articles/article.aspx?p=1566460" target="_blank" rel="noopener">Versioning REST Services</a>）：</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Accept:</span> vnd.example-<span class="keyword">com</span>.foo+json<span class="comment">; version=1.0</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">Accept:</span> vnd.example-<span class="keyword">com</span>.foo+json<span class="comment">; version=1.1</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">Accept:</span> vnd.example-<span class="keyword">com</span>.foo+json<span class="comment">; version=2.0</span></span><br></pre></td></tr></table></figure>

<h1 id="RESTful-API设计指南"><a href="#RESTful-API设计指南" class="headerlink" title="RESTful API设计指南"></a>RESTful API设计指南</h1><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>API与用户的通信协议，很多时候使用HTTPS协议。</p>
<p>HTTPS协议和HTTP协议的区别就是在于SSL/TLS证书，可以参考<a href="http://wmsheng.cn/2020/03/16/SSL-and-TLS/" target="_blank" rel="noopener">这篇文章</a></p>
<h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h2><p>应该尽量将API部署在专用域名之下。</p>
<p><code>https://api.example.com</code></p>
<p>如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。</p>
<p><code>https://example.org/api/</code></p>
<h2 id="版本-Versioning"><a href="#版本-Versioning" class="headerlink" title="版本(Versioning)"></a>版本(Versioning)</h2><p>应该将API的版本号放入URL。</p>
<p><code>https://api.example.com/v1/</code></p>
<p>另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。</p>
<h2 id="路径-Endpoint"><a href="#路径-Endpoint" class="headerlink" title="路径(Endpoint)"></a>路径(Endpoint)</h2><p>路径又称”终点”（endpoint），表示API的具体网址。</p>
<p>在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。</p>
<p>举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">https:<span class="regexp">//</span>api.example.com<span class="regexp">/v1/</span>zoos</span><br><span class="line">https:<span class="regexp">//</span>api.example.com<span class="regexp">/v1/</span>animals</span><br><span class="line">https:<span class="regexp">//</span>api.example.com<span class="regexp">/v1/</span>employees</span><br></pre></td></tr></table></figure>

<h2 id="HTTP动词"><a href="#HTTP动词" class="headerlink" title="HTTP动词"></a>HTTP动词</h2><p>对于资源的具体操作类型，由HTTP动词表示。</p>
<p>常用的HTTP动词有下面五个（括号里是对应的SQL命令）。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span>（<span class="keyword">SELECT</span>）：从服务器取出资源（一项或多项）。</span><br><span class="line">POST（<span class="keyword">CREATE</span>）：在服务器新建一个资源。</span><br><span class="line">PUT（<span class="keyword">UPDATE</span>）：在服务器更新资源（客户端提供改变后的完整资源）。</span><br><span class="line">PATCH（<span class="keyword">UPDATE</span>）：在服务器更新资源（客户端提供改变的属性）。</span><br><span class="line"><span class="keyword">DELETE</span>（<span class="keyword">DELETE</span>）：从服务器删除资源。</span><br></pre></td></tr></table></figure>

<p>还有两个不常用的HTTP动词。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">HEAD</span>：获取资源的元数据。</span><br><span class="line"><span class="attribute"><span class="nomarkup">OPTIONS</span></span>：获取信息，关于资源的哪些属性是客户端可以改变的。</span><br></pre></td></tr></table></figure>

<p>下面是一些例子。</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">GET <span class="string">/zoos</span>：列出所有动物园</span><br><span class="line">POST <span class="string">/zoos</span>：新建一个动物园</span><br><span class="line">GET <span class="string">/zoos/ID</span>：获取某个指定动物园的信息</span><br><span class="line">PUT <span class="string">/zoos/ID</span>：更新某个指定动物园的信息（提供该动物园的全部信息）</span><br><span class="line">PATCH <span class="string">/zoos/ID</span>：更新某个指定动物园的信息（提供该动物园的部分信息）</span><br><span class="line">DELETE <span class="string">/zoos/ID</span>：删除某个动物园</span><br><span class="line">GET <span class="string">/zoos/ID/animals</span>：列出某个指定动物园的所有动物</span><br><span class="line">DELETE <span class="string">/zoos/ID/animals/ID</span>：删除某个指定动物园的指定动物</span><br></pre></td></tr></table></figure>

<h2 id="过滤信息-Filtering"><a href="#过滤信息-Filtering" class="headerlink" title="过滤信息(Filtering)"></a>过滤信息(Filtering)</h2><p>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。</p>
<p>下面是一些常见的参数。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">?<span class="attribute">limit</span>=10：指定返回记录的数量</span><br><span class="line">?<span class="attribute">offset</span>=10：指定返回记录的开始位置。</span><br><span class="line">?<span class="attribute">page</span>=2&amp;per_page=100：指定第几页，以及每页的记录数。</span><br><span class="line">?<span class="attribute">sortby</span>=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</span><br><span class="line">?<span class="attribute">animal_type_id</span>=1：指定筛选条件</span><br></pre></td></tr></table></figure>
<p>参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。</p>
<h2 id="状态码-Status-Code"><a href="#状态码-Status-Code" class="headerlink" title="状态码(Status Code)"></a>状态码(Status Code)</h2><p>服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">200 </span>OK - [<span class="keyword">GET</span>]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</span><br><span class="line"><span class="symbol">201 </span>CREATED - [POST/<span class="keyword">PUT</span>/PATCH]：用户新建或修改数据成功。</span><br><span class="line"><span class="symbol">202 </span>Accepted - [*]：表示一个请求已经进入后台排队（异步任务）</span><br><span class="line"><span class="symbol">204 </span>NO CONTENT - [<span class="keyword">DELETE</span>]：用户删除数据成功。</span><br><span class="line"><span class="symbol">400 </span>INVALID REQUEST - [POST/<span class="keyword">PUT</span>/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</span><br><span class="line"><span class="symbol">401 </span>Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。</span><br><span class="line"><span class="symbol">403 </span>Forbidden - [*] 表示用户得到授权（与<span class="number">401</span>错误相对），但是访问是被禁止的。</span><br><span class="line"><span class="symbol">404 </span><span class="keyword">NOT</span> FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</span><br><span class="line"><span class="symbol">406 </span><span class="keyword">Not</span> Acceptable - [<span class="keyword">GET</span>]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</span><br><span class="line"><span class="symbol">410 </span>Gone -[<span class="keyword">GET</span>]：用户请求的资源被永久删除，且不会再得到的。</span><br><span class="line"><span class="symbol">422 </span>Unprocesable entity - [POST/<span class="keyword">PUT</span>/PATCH] 当创建一个对象时，发生一个验证错误。</span><br><span class="line"><span class="symbol">500 </span>INTERNAL SERVER <span class="keyword">ERROR</span> - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</span><br></pre></td></tr></table></figure>

<p>状态码的完全列表参见<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html" target="_blank" rel="noopener">这里</a>。</p>
<h2 id="错误处理-Error-handling"><a href="#错误处理-Error-handling" class="headerlink" title="错误处理(Error handling)"></a>错误处理(Error handling)</h2><p>如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attribute">error</span>: <span class="string">"Invalid API key"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h2><p>针对不同操作，服务器向用户返回的结果应该符合以下规范。</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">GET <span class="string">/collection</span>：返回资源对象的列表（数组）</span><br><span class="line">GET <span class="string">/collection/resource</span>：返回单个资源对象</span><br><span class="line">POST <span class="string">/collection</span>：返回新生成的资源对象</span><br><span class="line">PUT <span class="string">/collection/resource</span>：返回完整的资源对象</span><br><span class="line">PATCH <span class="string">/collection/resource</span>：返回完整的资源对象</span><br><span class="line">DELETE <span class="string">/collection/resource</span>：返回一个空文档</span><br></pre></td></tr></table></figure>

<h2 id="Hypermedia-API"><a href="#Hypermedia-API" class="headerlink" title="Hypermedia API"></a>Hypermedia API</h2><p>RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。</p>
<p>比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"link"</span>: &#123;</span><br><span class="line">  <span class="attr">"rel"</span>:   <span class="string">"collection https://www.example.com/zoos"</span>,</span><br><span class="line">  <span class="attr">"href"</span>:  <span class="string">"https://api.example.com/zoos"</span>,</span><br><span class="line">  <span class="attr">"title"</span>: <span class="string">"List of zoos"</span>,</span><br><span class="line">  <span class="attr">"type"</span>:  <span class="string">"application/vnd.yourformat+json"</span></span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。</p>
<p>Hypermedia API的设计被称为HATEOAS。Github的API就是这种设计，访问<a href="https://api.github.com/" target="_blank" rel="noopener">api.github.com</a>会得到一个所有可用API的网址列表。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"current_user_url"</span>: <span class="string">"https://api.github.com/user"</span>,</span><br><span class="line">  <span class="attr">"authorizations_url"</span>: <span class="string">"https://api.github.com/authorizations"</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面可以看到，如果想获取当前用户的信息，应该去访问api.github.com/user，然后就得到了下面结果。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"message"</span>: <span class="string">"Requires authentication"</span>,</span><br><span class="line">  <span class="attr">"documentation_url"</span>: <span class="string">"https://developer.github.com/v3"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码表示，服务器给出了提示信息，以及文档的网址。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>（1）API的身份认证应该使用OAuth 2.0框架。</p>
<p>（2）服务器返回的数据格式，应该尽量使用JSON，避免使用XML。</p>
<h1 id="RESTful-API最佳实践"><a href="#RESTful-API最佳实践" class="headerlink" title="RESTful API最佳实践"></a>RESTful API最佳实践</h1><p>RESTful 是目前最流行的 API 设计规范，用于 Web 数据接口的设计。</p>
<p>它的大原则容易把握，但是细节不容易做对。本文总结 RESTful 的设计细节，介绍如何设计出易于理解和使用的 API。</p>
<h2 id="URL设计"><a href="#URL设计" class="headerlink" title="URL设计"></a>URL设计</h2><h3 id="动词-宾语"><a href="#动词-宾语" class="headerlink" title="动词 + 宾语"></a>动词 + 宾语</h3><p>RESTful 的核心思想就是，客户端发出的数据操作指令都是”动词 + 宾语”的结构。比如，<code>GET /articles</code>这个命令，<code>GET</code>是动词，<code>/articles</code>是宾语。</p>
<p>动词通常就是五种 HTTP 方法，对应 CRUD 操作。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span>：读取（<span class="keyword">Read</span>）</span><br><span class="line">POST：新建（<span class="keyword">Create</span>）</span><br><span class="line">PUT：更新（<span class="keyword">Update</span>）</span><br><span class="line">PATCH：更新（<span class="keyword">Update</span>），通常是部分更新</span><br><span class="line"><span class="keyword">DELETE</span>：删除（<span class="keyword">Delete</span>）</span><br></pre></td></tr></table></figure>

<p>根据 HTTP 规范，动词一律大写。</p>
<h3 id="动词的覆盖"><a href="#动词的覆盖" class="headerlink" title="动词的覆盖"></a>动词的覆盖</h3><p>有些客户端只能使用<code>GET</code>和<code>POST</code>这两种方法。服务器必须接受POST模拟其他三个方法（PUT、PATCH、DELETE）。</p>
<p>这时，客户端发出的 HTTP 请求，要加上X-HTTP-Method-Override属性，告诉服务器应该使用哪一个动词，覆盖POST方法。</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">POST /api/Person/<span class="number">4</span> HTTP/<span class="number">1.1</span>  </span><br><span class="line">X-HTTP-<span class="function"><span class="keyword">Method</span>-<span class="title">Override</span>:</span> PUT</span><br></pre></td></tr></table></figure>

<p>上面代码中，X-HTTP-Method-Override指定本次请求的方法是<code>PUT</code>，而不是<code>POST</code>。</p>
<h3 id="宾语必须是名词"><a href="#宾语必须是名词" class="headerlink" title="宾语必须是名词"></a>宾语必须是名词</h3><p>宾语就是 API 的 URL，是 HTTP 动词作用的对象。它应该是名词，不能是动词。比如，<code>/articles</code>这个 URL 就是正确的，而下面的 URL 不是名词，所以都是错误的。</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="string">/getAllCars</span></span><br><span class="line"><span class="string">/createNewCar</span></span><br><span class="line"><span class="string">/deleteAllRedCars</span></span><br></pre></td></tr></table></figure>

<h3 id="复数URL"><a href="#复数URL" class="headerlink" title="复数URL"></a>复数URL</h3><p>既然 URL 是名词，那么应该使用复数，还是单数？</p>
<p>这没有统一的规定，但是常见的操作是读取一个集合，比如<code>GET /articles</code>（读取所有文章），这里明显应该是复数。</p>
<p>为了统一起见，建议都使用复数 URL，比如<code>GET /articles/2</code>要好于<code>GET /article/2</code>。</p>
<h3 id="避免多级URL"><a href="#避免多级URL" class="headerlink" title="避免多级URL"></a>避免多级URL</h3><p>常见的情况是，资源需要多级分类，因此很容易写出多级的 URL，比如获取某个作者的某一类文章。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">GET /authors/<span class="number">12</span>/categories/<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>这种 URL 不利于扩展，语义也不明确，往往要想一会，才能明白含义。</p>
<p>更好的做法是，除了第一级，其他级别都用查询字符串表达。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> /authors/12?<span class="attribute">categories</span>=2</span><br></pre></td></tr></table></figure>

<p>下面是另一个例子，查询已发布的文章。你可能会设计成下面的 URL。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> /articles/published</span><br></pre></td></tr></table></figure>

<p>查询字符串的写法明显更好。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> /articles?<span class="attribute">published</span>=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><h3 id="状态码必须精确"><a href="#状态码必须精确" class="headerlink" title="状态码必须精确"></a>状态码必须精确</h3><p>客户端的每一次请求，服务器都必须给出回应。回应包括 HTTP 状态码和数据两部分。</p>
<p>HTTP 状态码就是一个三位数，分成五个类别。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>xx：相关信息</span><br><span class="line"><span class="number">2</span>xx：操作成功</span><br><span class="line"><span class="number">3</span>xx：重定向</span><br><span class="line"><span class="number">4</span>xx：客户端错误</span><br><span class="line"><span class="number">5</span>xx：服务器错误</span><br></pre></td></tr></table></figure>

<p>这五大类总共包含100多种状态码，覆盖了绝大部分可能遇到的情况。每一种状态码都有标准的（或者约定的）解释，客户端只需查看状态码，就可以判断出发生了什么情况，所以服务器应该返回尽可能精确的状态码。</p>
<p>API 不需要<code>1xx</code>状态码，下面介绍其他四类状态码的精确含义。</p>
<h3 id="2xx状态码"><a href="#2xx状态码" class="headerlink" title="2xx状态码"></a>2xx状态码</h3><p><code>200</code>状态码表示操作成功，但是不同的方法可以返回更精确的状态码。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">GET:</span> <span class="number">200</span> <span class="string">OK</span></span><br><span class="line"><span class="attr">POST:</span> <span class="number">201</span> <span class="string">Created</span></span><br><span class="line"><span class="attr">PUT:</span> <span class="number">200</span> <span class="string">OK</span></span><br><span class="line"><span class="attr">PATCH:</span> <span class="number">200</span> <span class="string">OK</span></span><br><span class="line"><span class="attr">DELETE:</span> <span class="number">204</span> <span class="literal">No</span> <span class="string">Content</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>POST</code>返回<code>201</code>状态码，表示生成了新的资源；<code>DELETE</code>返回<code>204</code>状态码，表示资源已经不存在。</p>
<p>此外，<code>202 Accepted</code>状态码表示服务器已经收到请求，但还未进行处理，会在未来再处理，通常用于异步操作。下面是一个例子。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">202</span> Accepted</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "task": &#123;</span><br><span class="line">    "href": "/api/company/job-management/jobs/2130040",</span><br><span class="line">    "id": "2130040"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3xx状态码"><a href="#3xx状态码" class="headerlink" title="3xx状态码"></a>3xx状态码</h3><p>API 用不到<code>301</code>状态码（永久重定向）和<code>302</code>状态码（暂时重定向，<code>307</code>也是这个含义），因为它们可以由应用级别返回，浏览器会直接跳转，API 级别可以不考虑这两种情况。</p>
<p>API 用到的<code>3xx</code>状态码，主要是<code>303 See Other</code>，表示参考另一个 URL。它与<code>302</code>和<code>307</code>的含义一样，也是”暂时重定向”，区别在于<code>302</code>和<code>307</code>用于<code>GET</code>请求，而<code>303</code>用于<code>POST</code>、<code>PUT</code>和<code>DELETE</code>请求。收到<code>303</code>以后，浏览器不会自动跳转，而会让用户自己决定下一步怎么办。下面是一个例子。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">303</span> See Other</span><br><span class="line">Location: /api/orders/<span class="number">12345</span></span><br></pre></td></tr></table></figure>

<h3 id="4xx状态码"><a href="#4xx状态码" class="headerlink" title="4xx状态码"></a>4xx状态码</h3><p><code>4xx</code>状态码表示客户端错误，主要有下面几种。</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">400 </span>Bad Request：服务器不理解客户端的请求，未做任何处理。</span><br><span class="line"></span><br><span class="line"><span class="symbol">401 </span>Unauthorized：用户未提供身份验证凭据，或者没有通过身份验证。</span><br><span class="line"></span><br><span class="line"><span class="symbol">403 </span>Forbidden：用户通过了身份验证，但是不具有访问资源所需的权限。</span><br><span class="line"></span><br><span class="line"><span class="symbol">404 </span><span class="keyword">Not</span> Found：所请求的资源不存在，或不可用。</span><br><span class="line"></span><br><span class="line"><span class="symbol">405 </span>Method <span class="keyword">Not</span> Allowed：用户已经通过身份验证，但是所用的 HTTP 方法不在他的权限之内。</span><br><span class="line"></span><br><span class="line"><span class="symbol">410 </span>Gone：所请求的资源已从这个地址转移，不再可用。</span><br><span class="line"></span><br><span class="line"><span class="symbol">415 </span>Unsupported Media Type：客户端要求的返回格式不支持。比如，API 只能返回 JSON 格式，但是客户端要求返回 XML 格式。</span><br><span class="line"></span><br><span class="line"><span class="symbol">422 </span>Unprocessable Entity ：客户端上传的附件无法处理，导致请求失败。</span><br><span class="line"></span><br><span class="line"><span class="symbol">429 </span>Too Many Requests：客户端的请求次数超过限额。</span><br></pre></td></tr></table></figure>

<h3 id="5xx状态码"><a href="#5xx状态码" class="headerlink" title="5xx状态码"></a>5xx状态码</h3><p><code>5xx</code>状态码表示服务端错误。一般来说，API 不会向用户透露服务器的详细信息，所以只要两个状态码就够了。</p>
<p><code>500 Internal Server Error</code>：客户端请求有效，服务器处理时发生了意外。</p>
<p><code>503 Service Unavailable</code>：服务器无法处理请求，一般用于网站维护状态。</p>
<h2 id="服务器回应"><a href="#服务器回应" class="headerlink" title="服务器回应"></a>服务器回应</h2><h3 id="不要返回纯文本"><a href="#不要返回纯文本" class="headerlink" title="不要返回纯文本"></a>不要返回纯文本</h3><p>API 返回的数据格式，不应该是纯文本，而应该是一个 JSON 对象，因为这样才能返回标准的结构化数据。所以，服务器回应的 HTTP 头的<code>Content-Type</code>属性要设为<code>application/json</code>。</p>
<p>客户端请求时，也要明确告诉服务器，可以接受 JSON 格式，即请求的 HTTP 头的<code>ACCEPT</code>属性也要设成<code>application/json</code>。下面是一个例子。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">GET /orders/<span class="number">2</span> HTTP/<span class="number">1.1</span> </span><br><span class="line">Accept: application/json</span><br></pre></td></tr></table></figure>

<h3 id="发生错误时，不要返回200状态码"><a href="#发生错误时，不要返回200状态码" class="headerlink" title="发生错误时，不要返回200状态码"></a>发生错误时，不要返回200状态码</h3><p>有一种不恰当的做法是，即使发生错误，也返回<code>200</code>状态码，把错误信息放在数据体里面，就像下面这样。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "status": "failure",</span><br><span class="line">  "data": &#123;</span><br><span class="line">    "error": "Expected at least two items in list."</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，解析数据体以后，才能得知操作失败。</p>
<p>这张做法实际上取消了状态码，这是完全不可取的。正确的做法是，状态码反映发生的错误，具体的错误信息放在数据体里面返回。下面是一个例子。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">400</span> Bad Request</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "error": "Invalid payoad.",</span><br><span class="line">  "detail": &#123;</span><br><span class="line">     "surname": "This field is required."</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="提供链接"><a href="#提供链接" class="headerlink" title="提供链接"></a>提供链接</h3><p>API 的使用者未必知道，URL 是怎么设计的。一个解决方法就是，在回应中，给出相关链接，便于下一步操作。这样的话，用户只要记住一个 URL，就可以发现其他的 URL。这种方法叫做 HATEOAS。</p>
<p>举例来说，GitHub 的 API 都在 api.github.com 这个域名。访问它，就可以得到其他 URL。</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="string">"feeds_url"</span>: <span class="string">"https://api.github.com/feeds"</span>,</span><br><span class="line">  <span class="string">"followers_url"</span>: <span class="string">"https://api.github.com/user/followers"</span>,</span><br><span class="line">  <span class="string">"following_url"</span>: <span class="string">"https://api.github.com/user/following&#123;/target&#125;"</span>,</span><br><span class="line">  <span class="string">"gists_url"</span>: <span class="string">"https://api.github.com/gists&#123;/gist_id&#125;"</span>,</span><br><span class="line">  <span class="string">"hub_url"</span>: <span class="string">"https://api.github.com/hub"</span>,</span><br><span class="line">  <span class="string">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的回应中，挑一个 URL 访问，又可以得到别的 URL。对于用户来说，不需要记住 URL 设计，只要从 api.github.com 一步步查找就可以了。</p>
<p>HATEOAS 的格式没有统一规定，上面例子中，GitHub 将它们与其他属性放在一起。更好的做法应该是，将相关链接与其他属性分开。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "status": "In progress",</span><br><span class="line">   "links": &#123;[</span><br><span class="line">    &#123; "rel":"cancel", "method": "delete", "href":"/api/status/12345" &#125; ,</span><br><span class="line">    &#123; "rel":"edit", "method": "put", "href":"/api/status/12345" &#125;</span><br><span class="line">  ]&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Study Note</category>
        <category>Interview Note</category>
      </categories>
      <tags>
        <tag>HTTPS</tag>
        <tag>RESTful</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title>Java GC Study I</title>
    <url>/2020/03/05/Java-GC-Study-I/</url>
    <content><![CDATA[<blockquote>
<p>很多事情不是看到希望才去坚持，而是坚持了才看得到希望。</p>
</blockquote>
<a id="more"></a>

<p>正是因为有垃圾回收机制，才可以让程序员不用考虑程序执行之后对象内存的释放问题，将其交给JVM管理即可。</p>
<h1 id="垃圾回收——标记算法"><a href="#垃圾回收——标记算法" class="headerlink" title="垃圾回收——标记算法"></a>垃圾回收——标记算法</h1><h2 id="怎样的对象会被判定为垃圾？"><a href="#怎样的对象会被判定为垃圾？" class="headerlink" title="怎样的对象会被判定为垃圾？"></a>怎样的对象会被判定为垃圾？</h2><ul>
<li>没有被其他对象引用</li>
</ul>
<p>此时这个对象占据的内存会被释放，此对象也会被销毁。</p>
<h2 id="用什么方法判定对象不被引用了呢？"><a href="#用什么方法判定对象不被引用了呢？" class="headerlink" title="用什么方法判定对象不被引用了呢？"></a>用什么方法判定对象不被引用了呢？</h2><ul>
<li>引用计数算法</li>
<li>可达性分析算法</li>
</ul>
<h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p><strong>通过判断对象的引用数量来决定对象是否可以被回收。</strong></p>
<p>具体执行方法：</p>
<ul>
<li>每个对象实例都有一个引用计数器，被引用则+1，完成引用则-1</li>
<li>任何引用计数为0的对象实例可以被当做垃圾收集</li>
</ul>
<p>引用计数算法的优劣：</p>
<ul>
<li>优点：执行效率高，程序执行受影响较小。因为我们只需要过滤掉引用计数为0的对象，然后将其回收即可，可以交织在程序运行中。由于垃圾回收的过程中可以做到几乎不打断程序的执行，所以这种方法适用于程序需要不被长时间打断的实时环境。</li>
<li>缺点：无法检测出循环引用的情况，导致内存泄漏。这个缺点是很致命的，如果存在父对象与子对象互相引用的情况，那么它们的引用计数永远不可能为零，那么永远都不会被检测到为0，永远不会被释放。</li>
</ul>
<p>由于这种比较致命的缺点，主流JDK没有使用引用计数算法进行垃圾判定，而是用了下面的可达性分析算法。</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p><strong>通过判断对象的引用链是否可达来决定对象是否可以被回收</strong>。</p>
<p>这种方法从图论中引入。程序把所有的引用关系看作是一张图，通过一系列的名为GC Root的对象作为起始点，从这些节点开始向下搜索，搜索经过的路径会被称为”引用链”，即”reference chain”，当某个对象到其他图中的节点都不能相连的时候，也就是说从这个对象到其他部分的GC Root是不可达的，那么就判定这个对象为垃圾。</p>
<p>如图：</p>
<p><img src="https://s2.ax1x.com/2020/03/05/37rfUg.png" alt="可达性分析算法"></p>
<p>蓝色为存活对象，即可达对象，灰色的部分不可达了，为垃圾对象。</p>
<p>什么对象可以作为GC Root的对象呢？</p>
<ul>
<li>虚拟机栈中引用的对象(栈帧中的本地变量表)。比如在方法中new了一个Object，并赋值给了一个局部变量，那么在该局部变量没有被销毁之前，new出来的对象就会是GC Root。</li>
<li>方法区中的常量引用的对象。比如在类中定义了一个常量，而该常量保存的是某个对象的地址，那么被保存的对象也会成为GC的根对象。</li>
<li>方法区中的类静态属性引用的对象。这个和上面常量的情况如出一辙。</li>
<li>本地方法栈中JNI(Native方法)的引用对象</li>
<li>活跃线程的引用对象</li>
</ul>
<h1 id="垃圾回收——回收算法"><a href="#垃圾回收——回收算法" class="headerlink" title="垃圾回收——回收算法"></a>垃圾回收——回收算法</h1><p>判断了哪些对象是垃圾只是第一步，我们还需要解决一个很重要的问题：如何处理这些垃圾？或者说，如果回收这些垃圾？</p>
<p>垃圾回收算法有以下这几种：</p>
<h2 id="标记-清除算法-Mark-and-Sweep"><a href="#标记-清除算法-Mark-and-Sweep" class="headerlink" title="标记-清除算法(Mark and Sweep)"></a>标记-清除算法(Mark and Sweep)</h2><ul>
<li>标记：从根集合进行扫描，对存活的对象进行标记</li>
<li>清除：对堆内存从头到尾进行线性遍历，回收不可达对象内存</li>
</ul>
<p>如图：</p>
<p><img src="https://s2.ax1x.com/2020/03/05/37y678.jpg" alt="标记-清除算法"></p>
<p>如上图所示，经过了Mark阶段到达Sweep阶段的时候，所有不可达的对象都会被当做垃圾回收掉。</p>
<p>但是这种方法会存在一些问题，在标记-清除之后，可能会产生大量不连续的碎片，空间碎片多，可能导致之后开辟大对象空间的时候出现内存不够用的情况。</p>
<h2 id="复制算法-Copying"><a href="#复制算法-Copying" class="headerlink" title="复制算法(Copying)"></a>复制算法(Copying)</h2><p>复制算法将可用的内存按照容量和一定比例划分为两块或多块，并选择其中一块两块作为对象面，其他的作为空闲面。</p>
<ul>
<li>分为对象面和空闲面</li>
<li>对象在对象面上创建 </li>
<li>存活的对象被从对象面复制到空闲面。当被定义为对象面的块的内存用完了，就将还存活着的对象复制到其中一块空闲面上</li>
<li>将对象面所有对象清除</li>
</ul>
<p>这种算法适用于对象存活率低的场景，比如年轻代。这样每次都对内存块进行回收，这样就解决了内存碎片的问题。</p>
<p>推倒重建的过程只需要移动堆顶指针，按顺序分配内容即可。</p>
<p><img src="https://s2.ax1x.com/2020/03/05/37r2b8.png" alt="复制算法"></p>
<p>优势：</p>
<ul>
<li>解决碎片化问题</li>
<li>顺序分配内存，简单高效</li>
<li>适用于对象存活率低的场景(现在很多虚拟机都采用这种方法回收年轻代，因为年轻代每次都只存活10%左右，用复制算法效果不错)</li>
</ul>
<p>但是在老年代不能轻易选用这种算法，因为可能出现存活率特别高的情况。</p>
<h2 id="标记-整理算法-Compacting"><a href="#标记-整理算法-Compacting" class="headerlink" title="标记-整理算法(Compacting)"></a>标记-整理算法(Compacting)</h2><p>这种算法比较适合用于老年代的对象回收。它使用类似”标记-清除”算法的方式进行对象的标记，但是在清除的时候不同。</p>
<ul>
<li>标记：从根集合进行扫描，对存活的对象进行标记</li>
<li>清除：移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收</li>
</ul>
<p>“标记-整理”算法是在”标记-清除”的基础上又进行了对象的移动，因此成本更高，但是能够解决内存碎片的问题。</p>
<p><img src="https://s2.ax1x.com/2020/03/05/37RmRg.png" alt="标记整理算法"></p>
<p>也可以参考这张图：</p>
<p><img src="https://s2.ax1x.com/2020/03/05/37rWVS.png" alt="标记整理算法2"></p>
<p>执行这个算法的时候会把存活的对象压缩到一端，然后将所有可回收的对象清除掉。</p>
<p>这样做的好处：</p>
<ul>
<li>避免内存的不连续性</li>
<li>不用设置两块内存互换</li>
<li>适用于存活率高的场景(比如涉及分代收集算法中老年代的回收)</li>
</ul>
<h2 id="分代收集算法-Generational-Collector"><a href="#分代收集算法-Generational-Collector" class="headerlink" title="分代收集算法(Generational Collector)"></a>分代收集算法(Generational Collector)</h2><p>这是一种比较主流的垃圾回收算法。</p>
<p>可以理解是一套”组合拳”</p>
<ul>
<li>垃圾回收算法的组合拳</li>
<li>按照对象生命周期的不同划分区域以采用不同的垃圾回收算法</li>
<li>目的：提高JVM的回收效率</li>
</ul>
<p>前面已经提过，JDK8之前，比如JDK6和JDK7，里面有年轻代、老年代和永久代，如下图：</p>
<p><img src="https://s2.ax1x.com/2020/03/05/37r5Cj.png" alt="JDK6+7"></p>
<p>但是JDK8之后(包括JDK8)就去掉了永久代：</p>
<p><img src="https://s2.ax1x.com/2020/03/05/37rI8s.png" alt="JDK8后去掉永久代"></p>
<p>可以看到，JDK6、JDK7和JDK8中都有年轻代和老年代。其中年轻代的对象存活率低，采用复制算法。而老年代存活率高，一般使用”标记-清除算法”或者”标记-整理算法”。</p>
<h2 id="GC的分类"><a href="#GC的分类" class="headerlink" title="GC的分类"></a>GC的分类</h2><p>分代收集的GC分为两种：</p>
<ul>
<li>Minor GC。发生在年轻代中的垃圾收集工作，采用复制算法。</li>
<li>Full GC。与老年代的垃圾回收相关。</li>
</ul>
<p>年轻代是所有Java对象出生的地方，即Java对象申请的内存和存放对象，都是在年轻代进行的。</p>
<p>实际上，Java大部分对象都不会长久存活，”朝生夕灭”。新生代是GC发生的频繁区域。</p>
<p>老年代的回收一般伴随着年轻代的垃圾收集，因此第二种垃圾回收方式被命名为”Full GC”</p>
<h2 id="年轻代：尽可能快速地收集掉那些生命周期短的对象"><a href="#年轻代：尽可能快速地收集掉那些生命周期短的对象" class="headerlink" title="年轻代：尽可能快速地收集掉那些生命周期短的对象"></a>年轻代：尽可能快速地收集掉那些生命周期短的对象</h2><ul>
<li>Eden区</li>
<li>两个Survivor区</li>
</ul>
<p>对象刚被创建出来的时候，其内存空间首先被分配在Eden区。如果Eden区放不下新创建的对象的话，对象也有可能被直接放在Survivor甚至是老年代中。</p>
<p>而两个Survivor则分别被定义在from区和to区，并且哪个是from区，哪个是to区，也不是固定的，会随着垃圾回收的进行而相互转换。</p>
<p><img src="https://s2.ax1x.com/2020/03/05/37qRlq.png" alt="年轻代"></p>
<h3 id="年轻代垃圾回收的过程演示"><a href="#年轻代垃圾回收的过程演示" class="headerlink" title="年轻代垃圾回收的过程演示"></a>年轻代垃圾回收的过程演示</h3><p>通过一个实例演示年轻代的垃圾回收过程：</p>
<p>演示过程暂时忽略Eden区和Survivor区的大小比例，并且假设每个对象的大小都是一样的。Eden区最多能保存四个对象，Survivor区最多能保存三个对象。</p>
<p>一开始，如果对象在Eden出生，并且Eden被挤满，如下图：</p>
<p><img src="https://s2.ax1x.com/2020/03/05/3H1hJU.png" alt="3H1hJU.png"></p>
<p>此时会触发一次Minor GC。此时如果对象还存活(绿色的为存活对象)，它就会被复制到一个Survivor区里面，假设是复制到了S0里面，此时我们称S0为from区。复制之后会增加1个年龄。比如图中复制过去之后年龄为1.</p>
<p>然后清理所有使用过的Eden区域，如下图： </p>
<p><img src="https://s2.ax1x.com/2020/03/05/3H1fiT.png" alt="3H1fiT.png"></p>
<p>之后会清空Eden</p>
<p><img src="https://s2.ax1x.com/2020/03/05/3H1RoV.png" alt="3H1RoV.png"></p>
<p>然后过了一段时间，发现Eden区又被填满了，如图：</p>
<p><img src="https://s2.ax1x.com/2020/03/05/3H12d0.png" alt="3H12d0.png"></p>
<p>此时又会触发一次Minor GC，然后将Eden和S0里面的存活的对象都拷贝到S1里面，同时会把存活的对象的年龄都加1。</p>
<p>此时S1从to区变成了from区，而S0从from区变成了to区。</p>
<p><img src="https://s2.ax1x.com/2020/03/05/3H1gZq.png" alt="3H1gZq.png"></p>
<p>拷贝完成后，Eden和S0都会被清空，以此完成了第二次Minor GC。</p>
<p><img src="https://s2.ax1x.com/2020/03/05/3H14WF.png" alt="3H14WF.png"></p>
<p>之后我们假设Eden区又满了：</p>
<p><img src="https://s2.ax1x.com/2020/03/05/3H15z4.png" alt="3H15z4.png"></p>
<p>此时会出发第三次Minor GC，操作行为也和之前一样，年龄加1。同时S1里面如果有一个对象没有被用到，那么也要把它清除。</p>
<p>每次拷贝，存活对象的年龄都要加1.</p>
<p><img src="https://s2.ax1x.com/2020/03/05/3H1oQJ.png" alt="3H1oQJ.png"></p>
<p>拷贝完成后，S1和Eden又会被再次清空：</p>
<p><img src="https://s2.ax1x.com/2020/03/05/3H1Ty9.png" alt="3H1Ty9.png"></p>
<p>周而复始。对象在Survivor区每熬过一次Minor GC，其年龄就会被加1，当对象的年龄达到某个值之后(默认是15岁)，这些对象会成为老年代。</p>
<p>NOTE：这个默认年龄可以通过<code>-XX:MaxTenuringThreshold</code>调整</p>
<p>但这也不是一定的，如果存储的对象过大，Eden区和Survivor区都存不下，可能会需要用到老年代的空间协助存储。</p>
<h3 id="对象如何晋升到老年代"><a href="#对象如何晋升到老年代" class="headerlink" title="对象如何晋升到老年代"></a>对象如何晋升到老年代</h3><p>在分代算法当中，对象如何晋升到老年代？</p>
<ul>
<li>经历一定Minor次数依然存活的对象</li>
<li>Survivor区中村放不下的对象</li>
<li>新生成的大对象(可以用:<code>-XX:+PretenuerSizeThreshold</code>来控制大对象的大小，只要大于这个大小，对象生成之后直接放入老年代)</li>
</ul>
<h3 id="常用的调优参数"><a href="#常用的调优参数" class="headerlink" title="常用的调优参数"></a>常用的调优参数</h3><p>介绍几个常用的用来做性能调优的参数。</p>
<ul>
<li>-XX:SurvivorRatio：Eden和Survivor的比值，默认8:1</li>
<li>-XX:NewRatio：老年代和年轻代内存大小的比例(比如若值为2，则老年代是年轻代大小的两倍，即young generation占据内存的三分之一)。</li>
<li>-XX:MaxTenuringThreshold:对象从年轻代晋升到老生代经历过GC次数的最大阈值</li>
</ul>
<p>新生代和老年代的总内存大小是通过”-Xms”和”-Xmx”来决定的。</p>
<h2 id="老年代：存放生命周期较长的对象"><a href="#老年代：存放生命周期较长的对象" class="headerlink" title="老年代：存放生命周期较长的对象"></a>老年代：存放生命周期较长的对象</h2><p>回顾这副图：</p>
<p><img src="https://s2.ax1x.com/2020/03/05/37qRlq.png" alt="年轻代"></p>
<p>可以看到，老年代占的内存比新生代大，而且大致的比例为2:1</p>
<p>老年代的对象存活率较高，而且没有额外空间做担保，所以老年代主要用的算法为：</p>
<ul>
<li>标记-清理算法</li>
<li>标记-整理算法</li>
</ul>
<p>之前已经详细介绍过这两种算法，这里就不再介绍了。</p>
<h3 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h3><p>当触发老年代的垃圾回收的时候，往往也会伴随对新生代堆内存的回收，即对整个堆进行垃圾回收，也就是所谓的Full GC，或者叫做Major GC。Major GC和Full GC是等价的，即收集所有的GC堆。</p>
<p>主要是因为HotSpot VM发展了很多年，外界对很多名词的解读都已经混乱了，当有人说到了”Major GC”的时候，一定要问清楚，他说的到底是针对所有代的Full GC，还是只是针对老年代的GC。</p>
<p>Full GC比Minor GC慢(慢十倍)，但因为老年代里面元素本身就不容易被淘汰，所以执行频率也会更低。</p>
<h3 id="触发Full-GC的条件"><a href="#触发Full-GC的条件" class="headerlink" title="触发Full GC的条件"></a>触发Full GC的条件</h3><ul>
<li>老年代空间不足——如果创建的对象很大，Eden区域放不下这个对象，会放入到老年代中。如果老年代空间也不足，就会触发Full GC。为了避免这种情况，最好就是不要创建太大的对象。</li>
<li>永久代空间不足——这主要是针对JDK7以及以前的版本。当系统中需要加载和调用的类很多，而同时持久代当中没有足够的空间去存放类的信息和方法信息的时候，就会触发出一次Full GC。而JDK8以后由于取消了永久代，就不存在”永久代空间不足”这种情况了。(这也是JDK8后面用元空间替代永久代的原因之一，为了降低Full GC的频率，减少GC的负担，提升其效率)</li>
<li>CMS GC时出现promotion failed, concurrent mode failure。对于采用CMS 进行老年代GC的程序而言，如果GC日志中出现了这两个字段。如果出现了，可能会触发Full GC。</li>
<li>Minor GC晋升到老年代的平均大小大于老年代的剩余空间</li>
<li>调用System.gc()——这个是我们在程序里面手动调用的，触发Full GC。需要注意这个方法只是提醒虚拟机，程序员希望你在这里回收一下对象。但是具体怎么做还是要看虚拟机自己，程序员没有控制权</li>
<li>使用RMI来进行RPC或管理的JDK应用，每小时执行1次Full GC</li>
</ul>
<p>这些点很多，面试的时候只要能够提到3点，基本可以点到为止了，可以答到老年代空间不足，程序手动调用System.gc()，然后如果用的JDK版本比较老，在JDK8之前的版本，会有永久代空间不足的情况。当然其他的能说出来更好。</p>
<p>需要注意：</p>
<p>1.promotion failed是在进行Minor GC的时候Survivor放不下了，对象只能放入老年代，而此时恰好老年代也放不下，这时候就会造成promotion failed。</p>
<p>2.concurrent mode failure是在执行CMS GC的过程中同时有对象要放入老年代中，而此时老年代空间不足，就会造成这个failure。</p>
<p>而对于Minor GC晋升的这第四点，是比较复杂的触发情况。HotSpot为了避免由于新生代对象晋升到老年代而导致老年代空间不足的现象，在进行Minor GC的时候做了一个判断：如果之前统计所得到的Minor GC晋升到老年代的平均大小大于老年代的剩余空间，就直接触发Full GC。例如，程序第一次触发GC后有6M的对象晋升到老年代，当下一次Minor GC发生的时候，首先先检查老年代的剩余空间是否大于6M，如果小于6M，则执行Full GC。</p>
<h1 id="垃圾回收——垃圾收集器"><a href="#垃圾回收——垃圾收集器" class="headerlink" title="垃圾回收——垃圾收集器"></a>垃圾回收——垃圾收集器</h1><h2 id="Stop-the-World"><a href="#Stop-the-World" class="headerlink" title="Stop-the-World"></a>Stop-the-World</h2><ul>
<li>JVM由于要执行GC而停止了应用程序的执行</li>
<li>会在任何一种GC算法中发生</li>
<li>多数GC优化通过减少Stop-the-World发生的时间来提高程序性能，从而让系统有高吞吐，低停顿的特点</li>
</ul>
<h2 id="Safepoint"><a href="#Safepoint" class="headerlink" title="Safepoint"></a>Safepoint</h2><p>JVM垃圾回收就好比是保洁阿姨在打扫卫生，如果一边打扫一遍有人扔垃圾，那很难能打扫完。怎么办呢？可以在开始打扫之前和所有人说好:”我要开始打扫了！你们不准扔垃圾了！”，这样就可以了。</p>
<ul>
<li>分析过程中对象引用关系不会发生变化的点——这是程序运行过程中的一个特殊点的，在这个点所有线程都被冻结了，不能出现分析过程中对象引用关系还在不断变化的情况。类似函数的可导，我们分析的结果需要在某个节点具备确定性，这个节点就叫做安全点。</li>
<li>产生Safepoint的地方一般是：方法调用；循环跳转；异常跳转等</li>
<li>安全点数量得适中——安全点选择不能太多也不能太少</li>
</ul>
<h2 id="JVM的运行模式"><a href="#JVM的运行模式" class="headerlink" title="JVM的运行模式"></a>JVM的运行模式</h2><p>JVM有两种运行模式：Server和Client。</p>
<p>这两种运行模式的区别在于：Server启动较慢，Client启动较快。但是启动后运行进入稳定期之后，Server模式的程序运行速度比Client更快。</p>
<p>因为Server模式启动的是重量级的虚拟机，对程序采用了更多优化，对比之下Client模式启用的是轻量级的虚拟机。</p>
<p>如果想要查看当前Java是Server模式还是Client模式，可以直接用<code>java -version</code>查看即可.</p>
<h2 id="垃圾收集器之间的联系"><a href="#垃圾收集器之间的联系" class="headerlink" title="垃圾收集器之间的联系"></a>垃圾收集器之间的联系</h2><p>垃圾收集器不存在哪个好那个坏的问题，而是涉及到适合哪个具体的JVM。不同的厂商，不同版本的JVM，提供的选择也不同，这也是HotSpot实现这么多收集器的原因。</p>
<p>一些常见的垃圾收集器、它们之间的关系和它们的适用范围，如图所示：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3b1jC8.png" alt="垃圾收集器之间的联系"></p>
<p>如果两个收集器之间有连线，说明它们可以搭配使用。</p>
<p>我们只需要大致熟悉每一个垃圾收集器的作用即可。</p>
<p>下面分别介绍：</p>
<hr>
<h2 id="年轻代收集器"><a href="#年轻代收集器" class="headerlink" title="年轻代收集器"></a>年轻代收集器</h2><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>可以在程序启动的时候通过<code>-XX:+UseSerialGC</code>设置使用此收集器。使用复制算法。</p>
<p>在JDK1.3之前，是Java虚拟机年轻代收集器的唯一选择。</p>
<p>Java中历史最悠久的收集器。</p>
<ul>
<li>单线程收集，GC时必须暂停所有工作线程</li>
<li>简单高效，Client默认用这个作为年轻代收集器</li>
</ul>
<p>工作过程如下图所示：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3b8lLj.png" alt="Serial收集器工作模拟图"></p>
<p>实际中系统分配给虚拟机管理的内存不会很大，一般就几十兆到一百兆，收集这么多的年轻代的停顿时间也就几十毫秒，一百毫秒左右。只要不是太频繁，这样的停顿是可以接受的。</p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>可以在程序启动的时候通过<code>-XX:+UseParNewGC</code>设置使用此收集器。使用复制算法。</p>
<ul>
<li>除了是多线程收集，其余的行为、特点和Serial收集器一样</li>
<li>单核执行效率不如Serial，在多核下执行才有优势</li>
</ul>
<p>在单核执行的环境中，表现不会比Serial更好，因为存在键程交互开销。但是随着CPU增加，它的表现会更好。它默认开启的收集线程数和CPU数相同。在CPU数量非常多的情况下，可以使用ParGCThreds的参数来限制垃圾收集的线程数</p>
<p>ParNew是Server模式下虚拟机首选的年轻代收集器。因为除了Serial之外，目前只有它可以和CMS收集器配合工作。</p>
<p>ParNew工作过程如下图：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3bG5gU.png" alt="ParNew"></p>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>可以在程序启动的时候通过<code>-XX:+UseParallelGC</code>设置使用此收集器。使用复制算法。</p>
<p>这个收集器和系统吞吐量有关。</p>
<p>什么是系统的吞吐量？</p>
<blockquote>
<p>吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)</p>
</blockquote>
<p>也就是运行用户代码时间/CPU消耗总时间。比如虚拟机一共运行了100分钟，垃圾收集用了2分钟，吞吐量就是98%</p>
<p>Parallel Scavenge收集器有些类似ParaNew收集器，也是多线程，但是与ParNew相比也有不同：</p>
<ul>
<li>相比ParNew，Parallel Scavenge对系统吞吐量的重视程度大于对用户线程停顿的时间的重视程度。虽然停顿时间短比较适合与用户相互的程序，因为响应速度更快可以提升用户体验；但高吞吐量可以高效率利用CPU时间，尽可能快地完成运算任务，比较适合在后台运算而不用和用户交互的任务。</li>
<li>在多核下执行才有优势，Server模式下默认的年轻代收集器</li>
</ul>
<p>Parallel Scavenge和ParNew工作过程基本相同，如下图：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3bG5gU.png" alt="ParNew"></p>
<p>值得一提的是，如果程序员本身对垃圾收集器不太了解，在程序优化过程中遇到了困难的时候，可以这样解决：在启动的时候加上参数<code>-XX:+UseAdaptiveSizePolicy</code>，使用Parallel Scavenge的自适应调节策略，这样就可以把内存管理的调优任务交给虚拟机自己去完成。</p>
<hr>
<h2 id="老年代收集器"><a href="#老年代收集器" class="headerlink" title="老年代收集器"></a>老年代收集器</h2><h3 id="Serial-Old收集器-MSC"><a href="#Serial-Old收集器-MSC" class="headerlink" title="Serial Old收集器(MSC)"></a>Serial Old收集器(MSC)</h3><p>可以在程序启动的时候通过<code>-XX:+UseSerialOldGC</code>设置使用此收集器。使用标记-整理算法。</p>
<p>Serial模式的老年版</p>
<ul>
<li>单线程收集，进行垃圾收集时，必须暂停所有工作线程</li>
<li>简单高效，Client模式下默认的老年代收集器</li>
</ul>
<p>工作流程如图：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3bYz0H.png" alt="Serial Old"></p>
<h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>可以在程序启动的时候通过<code>-XX:+UseParallelOldGC</code>设置使用此收集器。使用标记-整理算法。</p>
<p>这个收集器在JDK6之后才开始提供的。在此之前新生代的Parallel Scavenge收集器一直处在一个比较尴尬的位置，因为如果新生代选了它，老年代就只能选Serial Old收集器了。</p>
<p>Parallel Old收集器的出现就是为了解决这个问题。</p>
<p>直到Parallel Old出现之后，吞吐量优先收集器才有了名副其实的组合。</p>
<ul>
<li>多线程，吞吐量优先</li>
</ul>
<p>在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge + Parallel Old收集器的组合。</p>
<p>工作流程如图：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3bczkV.png" alt="Parallel Old收集器"></p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>可以在程序启动的时候通过<code>-XX:+UseConcMarkSweepGC</code>设置使用此收集器。使用标记-清除算法。</p>
<p>实际上，CMS收集器几乎占据着JVM老年代收集器的半壁江山。它的划时代的意义就是垃圾回收线程几乎能与用户线程做到同时工作——说是”几乎”，是因为它不能完全做到不”Stop-the-World”，它只是能尽可能地缩短停顿时间。需要注意如果你的程序对停顿比较敏感，并且在应用程序运行的时候可以提供更大的内存和更多的CPU，那么用CMS是好的选择。</p>
<p>此外，如果在JVM中有相对较多而且存活时间较长的对象，也更适合使用CMS。</p>
<p>CMS的整个垃圾回收过程可以分为下面六步：</p>
<ol>
<li><font color=#FF0000>初始标记</font>：stop-the-world，JVM停顿正在执行的任务，从垃圾回收的根对象开始，只扫描和根对象直接关联的对象，时间短</li>
<li>并发标记：并发追溯标记，程序不停顿。这个阶段中应用标记的线程和并发标记的线程并发执行，所以用户不会感受到停顿。</li>
<li>并发预清理：查找执行并发标记时晋升老年代的对象。可能有一些对象从新生代晋升到老年代，或者有些对象直接被分配到老年代，通过重新扫描，减少下一个阶段重新标记的工作(因为下一阶段会重新stop-the-world)。这个过程不停顿</li>
<li><font color=#FF0000>重新标记</font>：暂停虚拟机，扫描CMS堆中剩余对象，扫描从根对象开始向下追溯，并处理对象单元。这一步相对较慢</li>
<li>并发清理：清理垃圾对象，程序不停顿</li>
<li>并发重置：重置CMS收集器的数据结构，等待下一次垃圾回收</li>
</ol>
<p>上述过程中，初始标记和重新标记需要短暂的stop-the-world的</p>
<p>工作流程如下图：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3bvBJU.png" alt="CMS垃圾收集器"></p>
<p>并发标记的过程实际上是和用户线程同时工作的，也就是一边丢垃圾，一边打扫。但这也可能产生一个问题，就是某个垃圾如果在打扫之后产生的，那么这个垃圾就只能等到下次垃圾回收才能被收掉，也就是说垃圾打扫完一次后没有完全打扫干净。</p>
<p>但是CMS收集器因为用的是”标记-清除算法”而不是”标记-整理算法”，就不可避免导致了垃圾碎片化的问题。如果此时需要分配较大的对象，那就只能触发一次GC了。</p>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>可以在程序启动的时候通过<code>-XX:+UseG1GC</code>设置使用此收集器。使用多种算法，即”复制算法 + 标记-整理算法”。</p>
<p>G1收集器既用于年轻代，也用于老年代。全称：<font color=#FF0000>Garbage First收集器</font>。</p>
<p>实际上，HotSpot最终的目的是让G1收集器最后能替换掉JDK5发布的CMS收集器。</p>
<p>Garbage First收集器的特点：</p>
<ol>
<li>并行和并发——使用多个CPU来缩短stop-the-world的停顿时间，与用户线程并发执行</li>
<li>分代收集——独立管理整个堆，但是能够采用不同的方式去处理新创建的对象和已经熬过多次GC的旧对象以获得更好的收集效果</li>
<li>空间整合——基于”标记-整理算法”，解决了内存碎片的问题</li>
<li>可预测停顿——能建立可预测的停顿时间模型，设置用户在某个地方的停顿时长不能超过m毫秒，类似这样</li>
</ol>
<p>在Garbage First垃圾收集器之前的收集器，都是只针对年轻代或者老年代的。而Garbage First可以同时针对年轻代和老年代。</p>
<p>在使用Garbage First收集器的时候，Java堆的布局和使用其他垃圾收集器时有很大不同：</p>
<ul>
<li>将整个Java堆内存划分成多个大小相等的Region——虽然还保留新生代和老年代的概念，但是新生代和老年代不再是物理隔离的了</li>
<li>年轻代和老年代不再物理隔离——它们可以是不连续的Region的集合。这也使得分配内存空间的时候可以不是连续的</li>
</ul>
<p><img src="https://s2.ax1x.com/2020/03/06/3qSkGT.png" alt="G1堆内存分配"></p>
<p>也就是说此时在JVM启动的时候不需要决定哪些Region属于老年代，哪些Region属于年轻代。因为随着时间推移，年轻代的Region被回收以后，就会变为可用状态，此时也可以把它分配成老年代。</p>
<p>和其他的HotSpot一样，当一个年轻代GC发生时，整个年轻代会被回收，G1的老年代收集器有所不同，它在老年代不需要整个老年代进行回收，只有一部分Region被调用。</p>
<p>G1的年轻代由Eden Region和Survivor Region组成。当一个JVM分配Eden Region失败后，会触发一个年轻代回收，意味着Eden区满了。之后GC开始释放空间，第一个年轻代收集器会移动所有的存储对象，从Eden Region到Survivor Region,这就是copy to survivor的过程。</p>
<p>JDK11还有研发Epsilon GC和ZGC，这里暂时先不介绍。</p>
<h2 id="回顾一个问题"><a href="#回顾一个问题" class="headerlink" title="回顾一个问题"></a>回顾一个问题</h2><p><img src="https://s2.ax1x.com/2020/03/06/3b1jC8.png" alt="垃圾收集器之间的联系"></p>
<p>如上图，为什么CMS不能和Parallel Scavenge一起工作呢？两者为什么不兼容呢？</p>
<p>CMS是HotSpot在JDK5的时候推出的第一款整整意义上的并发收集器，第一次实现了让垃圾收集线程与用户线程同时工作。</p>
<p>CMS作为老年代收集器不能和Parallel Scavenge一起工作主要是因为Parallel Scavenge和CMS代码框架不同。</p>
<h1 id="GC相关面试题"><a href="#GC相关面试题" class="headerlink" title="GC相关面试题"></a>GC相关面试题</h1><h2 id="Object的finalize-方法的作用是否与C-的析构函数作用相同"><a href="#Object的finalize-方法的作用是否与C-的析构函数作用相同" class="headerlink" title="Object的finalize()方法的作用是否与C++的析构函数作用相同"></a>Object的finalize()方法的作用是否与C++的析构函数作用相同</h2><p>答：</p>
<ul>
<li>finalize()和C++的析构函数不同，析构函数调用的时机是确定的，对象离开作用域后就会调用，然后对象被delete掉。而finalize()具有不确定性，也就是对象还没用完可能就被GC</li>
<li>将未被引用的对象放置于F-Queue队列</li>
<li>方法执行随时可能会被终止</li>
<li>给予对象最后一次重生的机会</li>
</ul>
<p>但是由于finalize()方法代价比较高昂，所以不建议使用。</p>
<h2 id="Java中的强引用、软引用、弱引用、虚引用有什么用"><a href="#Java中的强引用、软引用、弱引用、虚引用有什么用" class="headerlink" title="Java中的强引用、软引用、弱引用、虚引用有什么用"></a>Java中的强引用、软引用、弱引用、虚引用有什么用</h2><h3 id="强引用-Strong-Reference"><a href="#强引用-Strong-Reference" class="headerlink" title="强引用(Strong Reference)"></a>强引用(Strong Reference)</h3><ul>
<li>最普遍的引用：Object obj = new Object()，这里obj就是强引用</li>
<li>抛出OutOfMemoryError终止程序也不会回收具有强引用的对象</li>
<li>通过将对象设置为null来弱化引用，使其被回收</li>
</ul>
<h3 id="软引用-Soft-Reference"><a href="#软引用-Soft-Reference" class="headerlink" title="软引用(Soft Reference)"></a>软引用(Soft Reference)</h3><ul>
<li>对象处在有用但非必须的状态</li>
<li>只有当内存空间不足时，GC会回收该引用的对象的内存</li>
<li>可以用来实现高速缓存——这样我们就可以避免OutOfMemory的问题。因为软引用的内存会在内存不足的情况下回收。</li>
</ul>
<p>强引用和软引用例子如下图：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3qsJ3Q.png" alt="强引用和软引用例子"></p>
<h3 id="弱引用-Weak-Reference"><a href="#弱引用-Weak-Reference" class="headerlink" title="弱引用(Weak Reference)"></a>弱引用(Weak Reference)</h3><ul>
<li>非必须的对象，比软引用更弱一些</li>
<li>生命周期更短，在GC时会被回收——无论当前内存是否紧缺，GC都会回收被弱引用关联的对象</li>
<li>被回收的概率也不大，因为GC线程优先级比较低</li>
<li>弱引用适用于偶尔使用且不影响垃圾收集的对象</li>
</ul>
<p>弱引用案例：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3qyBqI.png" alt="弱引用例子"></p>
<p>弱引用同样可以配合引用队列去使用。</p>
<h3 id="虚引用-Phantom-Reference"><a href="#虚引用-Phantom-Reference" class="headerlink" title="虚引用(Phantom Reference)"></a>虚引用(Phantom Reference)</h3><p>“虚无缥缈”，其生命周期比较不固定</p>
<ul>
<li>不会决定对象的生命周期</li>
<li>任何时候都可能被垃圾收集器回收</li>
<li>跟踪对象被垃圾收集器回收的活动，起哨兵作用</li>
<li>比较特殊，必须和引用队列ReferenceQueue联合使用</li>
</ul>
<p><img src="https://s2.ax1x.com/2020/03/06/3q63lQ.png" alt="虚引用例子"></p>
<p>GC在回收一个对象时，若发现这个对象有虚引用，那么回收前会先将这个引用加入到与之关联的引用队列当中。</p>
<h3 id="四种引用之间的关系"><a href="#四种引用之间的关系" class="headerlink" title="四种引用之间的关系"></a>四种引用之间的关系</h3><p><img src="https://s2.ax1x.com/2020/03/06/3q64pD.png" alt="四种引用之间的关系"></p>
<h3 id="引用类结构层次"><a href="#引用类结构层次" class="headerlink" title="引用类结构层次"></a>引用类结构层次</h3><p><img src="https://s2.ax1x.com/2020/03/06/3qcmjJ.png" alt="引用类结构层次"></p>
<h3 id="引用队列-ReferenceQueue"><a href="#引用队列-ReferenceQueue" class="headerlink" title="引用队列(ReferenceQueue)"></a>引用队列(ReferenceQueue)</h3><p>引用队列名义上是一个队列，但其内部没有实际存储结构。</p>
<ul>
<li>无实际存储结构，存储逻辑依赖于内部节点之间的关系来表达的——类似链表，节点是Reference本身，它自己只存储链表的头结点，而后面的节点都通过Reference指向下一个的next来保持。</li>
<li>存储关联的且被GC的软引用，弱引用以及虚引用</li>
</ul>
]]></content>
      <categories>
        <category>Study Note</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Basic Interview I</title>
    <url>/2020/03/04/Java-Basic-Interview-I/</url>
    <content><![CDATA[<blockquote>
<p>知识犹如人体的血液一样宝贵。——高士其</p>
</blockquote>
<a id="more"></a>

<h2 id="1-JDK和JRE有什么区别？"><a href="#1-JDK和JRE有什么区别？" class="headerlink" title="1.JDK和JRE有什么区别？"></a>1.JDK和JRE有什么区别？</h2><p>• JDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。<br>• JRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。</p>
<p>具体来说 JDK 其实包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 java 程序调试和分析的工具。简单来说：如果你需要运行 java 程序，只需安装 JRE 就可以了，如果你需要编写 java 程序，需要安装 JDK。</p>
<h2 id="2-和equals的区别"><a href="#2-和equals的区别" class="headerlink" title="2.==和equals的区别"></a>2.==和equals的区别</h2><p><font color=#FF000>== 解读</font></p>
<p>对于基本类型和引用类型 == 的作用效果是不同的，如下所示：<br>• 基本类型：比较的是值是否相同；<br>• 引用类型：比较的是引用是否相同；</p>
<p>代码示例：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">String x = <span class="string">"string"</span>;</span><br><span class="line">String y = <span class="string">"string"</span>;</span><br><span class="line">String z = <span class="keyword">new</span> <span class="constructor">String(<span class="string">"string"</span>)</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(x==y); <span class="comment">// true</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(x==z); <span class="comment">// false</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(x.equals(y)); <span class="comment">// true</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(x.equals(z)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>代码解读：因为 x 和 y 指向的是同一个引用，所以 == 也是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为true</p>
<p><font color=#FF000>equals 解读</font></p>
<p>equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。看下面的代码就明白了。</p>
<p>首先来看默认情况下 equals 比较一个有相同值的对象，代码如下：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> &#123;</span>    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(<span class="keyword">String</span> name)</span> </span>&#123;        </span><br><span class="line">	<span class="keyword">this</span>.name = name;    </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">String</span> name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">return</span> name;    </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">String</span> name)</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">this</span>.name = name;    </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Cat c1 = <span class="keyword">new</span> Cat(<span class="string">"王磊"</span>);</span><br><span class="line">Cat c2 = <span class="keyword">new</span> Cat(<span class="string">"王磊"</span>);</span><br><span class="line">System.out.<span class="built_in">println</span>(c1.equals(c2)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原来 equals 本质上就是 ==。</p>
<p>那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">String</span> s1 = <span class="keyword">new</span> <span class="keyword">String</span>(<span class="string">"老王"</span>);</span><br><span class="line"><span class="keyword">String</span> s2 = <span class="keyword">new</span> <span class="keyword">String</span>(<span class="string">"老王"</span>);</span><br><span class="line">System.out.<span class="built_in">println</span>(s1.equals(s2)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">boolean</span> equals(<span class="keyword">Object</span> anObject) &#123;</span><br><span class="line">    <span class="keyword">if</span> (this == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject instanceof String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="type">int</span> n = <span class="keyword">value</span>.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.<span class="keyword">value</span>.length) &#123;</span><br><span class="line">            <span class="type">char</span> v1[] = <span class="keyword">value</span>;</span><br><span class="line">            <span class="type">char</span> v2[] = anotherString.<span class="keyword">value</span>;</span><br><span class="line">            <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n<span class="comment">-- != 0) &#123;</span></span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。</p>
<p>总结 ：== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p>
<h2 id="3-两个对象的hashCode-相同，则equals-也一定为true，对么？"><a href="#3-两个对象的hashCode-相同，则equals-也一定为true，对么？" class="headerlink" title="3.两个对象的hashCode()相同，则equals()也一定为true，对么？"></a>3.两个对象的hashCode()相同，则equals()也一定为true，对么？</h2><p>不对，两个对象的 hashCode()相同，equals()不一定 true。</p>
<p>代码示例：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">"通话"</span>;</span><br><span class="line">String str2 = <span class="string">"重地"</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>format(<span class="string">"str1：%d | str2：%d"</span>,</span><br><span class="line">                                       str1.hash<span class="constructor">Code()</span>, str2.hash<span class="constructor">Code()</span>));</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(str1.equals(str2));</span><br></pre></td></tr></table></figure>


<p>执行的结果：</p>
<p>str1：1179395 | str2：1179395</p>
<p>false</p>
<p>代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode()相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。</p>
<h2 id="4-final在java中有什么作用？"><a href="#4-final在java中有什么作用？" class="headerlink" title="4.final在java中有什么作用？"></a>4.final在java中有什么作用？</h2><p>• final 修饰的类叫最终类，该类不能被继承。<br>• final 修饰的方法不能被重写。<br>• final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</p>
<h2 id="5-java中的Math-round-1-5-等于多少？"><a href="#5-java中的Math-round-1-5-等于多少？" class="headerlink" title="5.java中的Math.round(-1.5)等于多少？"></a>5.java中的Math.round(-1.5)等于多少？</h2><p>等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃。</p>
<h2 id="6-String属于基础的数据类型么？"><a href="#6-String属于基础的数据类型么？" class="headerlink" title="6.String属于基础的数据类型么？"></a>6.String属于基础的数据类型么？</h2><p>String 不属于基础类型，基础类型有 8 种：byte（一个字节，8位）、 boolean（只有true和false两个值，默认false）、char（两个字节，十六位）、short（两个字节，十六位，最大存储值是65536，数据范围是-32768<del>32767之间）、int（四个字节，三十二位，最大存储容量是2的32次方减1，范围是负2的31次方到正的2的31次方减1）、float（四个字节，三十二位，数据范围在3.4e-45</del>1.4e38）、long（八个字节，六十四位，最大存储容量是2的64次方减1,范围是负2的63次方到正2的63次方减1）、double（八个字节，六十四位，数据范围在4.9e-324~1.8e308，赋值时可以加d也可以不加），而 String 属于对象。</p>
<p><img src="https://s2.ax1x.com/2020/03/04/35IdWF.png" alt="Java数据类型"></p>
<p>数据之间的转换：</p>
<p>1.表示值范围小的，可以自动转换成范围大的。比如下面都可以自动转换：</p>
<p>byte b;int i=b; long l=b; float f=b; double d=b;</p>
<p>2.但是如果低级的char向高级类型转换的时候，会转换成对应的ASCII码值。例如：</p>
<p>char c=’c’; int i=c;<br>System.out.println(“output:”+i);输出：output:99;</p>
<p>3.每个包装类中会有形为xxValue()的方法，可以得到其对饮的简单类型数据。利用这种方法，也可以实现不同数值型变量间的转换，例如，对于一个双精度实型类，intValue()可以得到其对应的整型变量，而doubleValue()可以得到其对应的双精度实型变量。</p>
<p>4.字符串和其他类型的转换<br>首先是其他类型向字符串类型转换：</p>
<pre><code>①. 调用类的串转换方法：X.toString();
②. 自动转换：X + &quot;&quot;;
③. 使用String的方法：String.valueOf(X)</code></pre><p>然后字符串作为值，转换成其他类型：</p>
<pre><code>①. 静态parseXXX方法
比如，String s=&quot;1&quot;;
byte b = Byte.parseByte( s );
short t = Short.parseShort( s );
int i = Integer.parseInt( s );
long l = Long.parseLong( s );
Float f = Float.parseFloat( s );
Double d = Double.parseDouble( s );

②. Character的getNumericValue(char ch)方法

③. 先转换成相应的封装类实例，再调用对应的方法转换成其他类型</code></pre><p>例如，字符中”32.1”转换double型的值的格式为:new Float(“32.1”).doubleValue()。也可以用:Double.valueOf(“32.1”).doubleValue()</p>
<p>5.Date类与其他数据类型的转换<br>（暂省略）</p>
<p><strong>小总结：</strong></p>
<p>只有boolean不参与数据类型的转换<br>（1）.自动类型的转换：</p>
<p>a.常数在表数范围内是能够自动类型转换的</p>
<p>b.数据范围小的能够自动数据类型大的转换（注意特例）<br>int到float，long到float，long到double 是不会自动转换的，不然将会丢失精度</p>
<p>c.引用类型能够自动转换为父类的</p>
<p>d.基本类型和它们包装类型是能够互相转换的</p>
<p>（2）.强制类型转换：用圆括号括起来目标类型，置于变量前</p>
<p>注：<font color=#FF0000>java有五种引用类型：数组、类、接口、枚举、标注</font></p>
<p>个人总结：</p>
<p>①：如果是小数类型，而且位数比较小，比如四位，建议用BigDecimal，如果是double类型会有失精度，有时候会用科学技术法表示（比如1.0E-4，不利于人看），而且用double有时候还要对类型进行转换</p>
<p>②： Int  double都是包装类型的，建议使用包装类型，包装类型能区分null 和 0，就像在 spring-mvc接收时使用int类型接收值，如果这个属性不传值，ajax请求会报400错误，而且不能区分这个数值是否为空</p>
<p>③： for 循环中如果要对字符串进行拼接，建议使用 StringBuffer ，如果没有线程安全问题，直接使用 StringBuilder，原因StringBuffer的所有操作是保证线程安全的，可以理解成使用了 synchronized 关键字，对性能是有影响的。</p>
<p>④：对所有包装类进行操作（比如toString()）要进行空指针判断，我们不能保证这个是有值的</p>
<h2 id="7-java中操作字符串都有哪些类？他们之间有什么区别？"><a href="#7-java中操作字符串都有哪些类？他们之间有什么区别？" class="headerlink" title="7.java中操作字符串都有哪些类？他们之间有什么区别？"></a>7.java中操作字符串都有哪些类？他们之间有什么区别？</h2><p>操作字符串的类有：String、StringBuffer、StringBuilder。</p>
<p>String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。</p>
<p>StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。</p>
<h2 id="8-String-str-”i”-与-String-str-new-String-“i”-一样吗？"><a href="#8-String-str-”i”-与-String-str-new-String-“i”-一样吗？" class="headerlink" title="8.String str=”i” 与 String str=new String(“i”) 一样吗？"></a>8.String str=”i” 与 String str=new String(“i”) 一样吗？</h2><p>不一样，因为内存的分配方式不一样。String str=”i”的方式，java 虚拟机会将其分配到常量池中；而 String str=new String(“i”) 则会被分到堆内存中。</p>
<h2 id="9-如何将字符串反转？"><a href="#9-如何将字符串反转？" class="headerlink" title="9.如何将字符串反转？"></a>9.如何将字符串反转？</h2><p>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。</p>
<p>实例代码：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">// <span class="keyword">StringBuffer </span><span class="keyword">reverse</span></span><br><span class="line"><span class="keyword">StringBuffer </span><span class="keyword">stringBuffer </span>= new <span class="keyword">StringBuffer();</span></span><br><span class="line"><span class="keyword">stringBuffer.append("abcdefg");</span></span><br><span class="line"><span class="keyword">System.out.println(stringBuffer.reverse()); </span>// gfedcba</span><br><span class="line">// <span class="keyword">StringBuilder </span><span class="keyword">reverse</span></span><br><span class="line"><span class="keyword">StringBuilder </span><span class="keyword">stringBuilder </span>= new <span class="keyword">StringBuilder();</span></span><br><span class="line"><span class="keyword">stringBuilder.append("abcdefg");</span></span><br><span class="line"><span class="keyword">System.out.println(stringBuilder.reverse()); </span>// gfedcba</span><br></pre></td></tr></table></figure>

<h2 id="10-String类的常用方法都有哪些？"><a href="#10-String类的常用方法都有哪些？" class="headerlink" title="10.String类的常用方法都有哪些？"></a>10.String类的常用方法都有哪些？</h2><p>• indexOf()：返回指定字符的索引。<br>• charAt()：返回指定索引处的字符。<br>• replace()：字符串替换。<br>• trim()：去除字符串两端空白。<br>• split()：分割字符串，返回一个分割后的字符串数组。<br>• getBytes()：返回字符串的 byte 类型数组。<br>• length()：返回字符串长度。<br>• toLowerCase()：将字符串转成小写字母。<br>• toUpperCase()：将字符串转成大写字符。<br>• substring()：截取字符串。<br>• equals()：字符串比较。</p>
<h2 id="11-抽象类必须要有抽象方法吗？"><a href="#11-抽象类必须要有抽象方法吗？" class="headerlink" title="11.抽象类必须要有抽象方法吗？"></a>11.抽象类必须要有抽象方法吗？</h2><p>不需要，抽象类不一定非要有抽象方法。</p>
<p>示例代码：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Cat</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"hi~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码，抽象类并没有抽象方法但完全可以正常运行。</p>
<h2 id="12-普通类和抽象类有哪些区别？"><a href="#12-普通类和抽象类有哪些区别？" class="headerlink" title="12.普通类和抽象类有哪些区别？"></a>12.普通类和抽象类有哪些区别？</h2><p>• 普通类不能包含抽象方法，抽象类可以包含抽象方法。<br>• 抽象类不能直接实例化，普通类可以直接实例化。</p>
<h2 id="13-抽象类能使用final修饰吗？"><a href="#13-抽象类能使用final修饰吗？" class="headerlink" title="13.抽象类能使用final修饰吗？"></a>13.抽象类能使用final修饰吗？</h2><p>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类，如下图所示，编辑器也会提示错误信息：</p>
<p><img src="https://s2.ax1x.com/2020/03/04/35Iwz4.jpg" alt="35Iwz4.jpg"></p>
<h2 id="14-接口和抽象类有什么区别？"><a href="#14-接口和抽象类有什么区别？" class="headerlink" title="14.接口和抽象类有什么区别？"></a>14.接口和抽象类有什么区别？</h2><p>• 实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。<br>• 构造函数：抽象类可以有构造函数；接口不能有。<br>• main 方法：抽象类可以有 main 方法，并且我们能运行它；接口不能有 main 方法。<br>• 实现数量：类可以实现很多个接口；但是只能继承一个抽象类。<br>• 访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。</p>
<h2 id="15-java中的IO流分为几种？"><a href="#15-java中的IO流分为几种？" class="headerlink" title="15.java中的IO流分为几种？"></a>15.java中的IO流分为几种？</h2><p>按功能来分：输入流（input）、输出流（output）。</p>
<p>按类型来分：字节流和字符流。</p>
<p>字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。</p>
<h2 id="16-BIO、NIO、AIO有什么区别？"><a href="#16-BIO、NIO、AIO有什么区别？" class="headerlink" title="16.BIO、NIO、AIO有什么区别？"></a>16.BIO、NIO、AIO有什么区别？</h2><p>• BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。<br>• NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。<br>• AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</p>
<h2 id="17-Files的常用方法有哪些？"><a href="#17-Files的常用方法有哪些？" class="headerlink" title="17.Files的常用方法有哪些？"></a>17.Files的常用方法有哪些？</h2><p>• Files.exists()：检测文件路径是否存在。<br>• Files.createFile()：创建文件。<br>• Files.createDirectory()：创建文件夹。<br>• Files.delete()：删除一个文件或目录。<br>• Files.copy()：复制文件。<br>• Files.move()：移动文件。<br>• Files.size()：查看文件个数。<br>• Files.read()：读取文件。<br>• Files.write()：写入文件。</p>
]]></content>
      <categories>
        <category>Interview Note</category>
      </categories>
      <tags>
        <tag>Interview</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Operating System Interview I</title>
    <url>/2020/02/25/Operating-System-Interview-I/</url>
    <content><![CDATA[<blockquote>
<p>横眉冷对千夫指，俯首甘为孺子牛。——鲁迅</p>
</blockquote>
<a id="more"></a>

<p>操作系统面试相关知识汇总：</p>
<p><img src="https://s2.ax1x.com/2020/02/25/3JaemQ.png" alt="3JaemQ.png"></p>
<p>操作系统知识对于服务问题的排查和定位非常重要。</p>
<h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程的结构如下图所示：</p>
<p><img src="https://s2.ax1x.com/2020/02/25/3t5L5R.png" alt="3t5L5R.png"></p>
<ul>
<li>每个进程都包含线程</li>
<li>进程里面也包含内存。</li>
<li>“句柄“在英文中叫做“handle”，文件和网络资源与内存不同，它是所有进程所共有的，也就是说我这个进程和那个进程都是可以打开同一个文件的，或者都是可以同时去抢同一个网络的端口。</li>
</ul>
<p>是不是把电脑的内存分配一部分给它呢？并不是。<br>这里的内存是逻辑内存。电脑的32位和64位到底是什么意思呢？就是在内存上面，是指它们内存的寻址空间。32位代表2的32次方，也就是4G大小，也就是每个进程都有一个4G内存的一个空间。这只是说它有4G内存的空间可以用，不是说我就把4G的内存分配给你了。</p>
<p>进程之间的内存的独立是合理且必须的，举个例子，如果我的进程的指针可以改一改，指向你正在输入银行卡密码的进程，那么我就可以得到你微信或者网上银行的内存了，那就很不安全，甚至恐怖了。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程的结构如下图所示：</p>
<p><img src="https://s2.ax1x.com/2020/02/25/3tIprD.png" alt="3tIprD.png"></p>
<p>我制作的这张图可以说比较形象地说明了线程的内部结构。</p>
<p>首先，线程里面包含栈。我们习惯说“调用堆栈”，实际上这里“堆“没有意义，这里的调用“堆栈”其实就是调用栈。</p>
<ul>
<li><p>栈里面有什么？——主线程中的main函数会进行各种调用，每次调用，会把所有的参数和返回的地址压到栈里面，一层一层地放入栈。包括每个函数地局部变量也都会放在栈里面。</p>
</li>
<li><p>线程还有很重要的一个东西“PC”——program counter的意思，里面存放的是下一个要执行的指令的地址。所以总的来说，我们的操作系统运行的是一个一个的线程，进程只是一个容器，线程才是真正运行的东西</p>
</li>
<li><p>TLS——thread local storage——每个进程都有自己的一块内存，那么线程有没有呢？也是有的，就是这个TLS。我们可以在TLS中分配内存，存放变量，这些数据就是我们的线程所独有的数据</p>
</li>
</ul>
<p>总得来说，线程才是我们操作的系统真正运行的，进程只是一个容器，他把一部分东西放在一起，旁边放了一个很强的隔离，把不同的程序隔离开来。</p>
<h2 id="进程和线程的区别和联系？"><a href="#进程和线程的区别和联系？" class="headerlink" title="进程和线程的区别和联系？"></a>进程和线程的区别和联系？</h2><p>从宏观上来回答：</p>
<p>a. 进程是系统资源分配的最小单位，线程是程序执行的最小单位</p>
<p>b.进程使用独立的数据空间，而线程共享进程的数据空间</p>
<p>但是这只是很宏观的角度，我们需要从更细的角度去钻研一下，进程(process)和线程(thread)的区别。而且面试官可能会从你的回答来继续后面的问题。</p>
<p>比如面试者回答说”它们的内存结构不同，进程之间不能共享内存，线程之间可以共享内存”，那面试官可以问与内存有关的内容，比如我们<strong>如何寻址</strong>？</p>
<p>再比如面试者回答“线程之间通信很方便，但是进程之间通信比较复杂”，那么面试官会问<strong>进程间通信有哪些方法，比较一下优劣点</strong>，等等。</p>
<ul>
<li><p>共享内存，因为进程间不能共享内存，所以我们会用一些进程间相互交互的方案，比较常见的就是通过TCP/IP的端口来实现。也有其他方案，但是TCP/IP是最通用的，其他方案可能和某个特定操作系统的相关性要更大一些。</p>
</li>
<li><p>线程间通信就很简单了，只要两个线程的指针指向同一块内存，它们之间就可以通信。</p>
</li>
<li><p>In terms of 开销，进程的开销当然比较大，因为我们要给它分配很多内存，而线程我们只是给它分配一个栈，分配一个PC指针(program counter)就可以了。此外，进程之间切换的开销会大于线程之间切换的开销。</p>
</li>
</ul>
<h2 id="进程间通信-IPC"><a href="#进程间通信-IPC" class="headerlink" title="进程间通信(IPC)"></a>进程间通信(IPC)</h2><p>之前已经介绍了进程和线程之间的区别，进程就像一个container,里面有很多的线程。而除了有很多线程，更重要的一点，它有一块自己的内存。这块内存是这个进程里面所有线程之间共享的，所以线程之间共享数据很方便——我开一块内存，告诉你地址，你也能用，当然如果同时读写的话会有线程安全性问题，需要加一些同步的机制来防止线程安全性的问题。</p>
<p>但是进程和进程之间都有一块自己独立的内存，这块内存的大小和物理内存大小无关，和系统是32位还是64位有关。进程之间是不能互相看到信息的。</p>
<p>这里列举进程之间通信的7种方法：</p>
<ol>
<li>文件</li>
<li>管道/命名管道</li>
<li>Signal</li>
<li>共享内存</li>
<li>消息队列</li>
<li>同步机制，如信号量(semaphore)</li>
<li>Socket</li>
</ol>
<h3 id="1-写一个文件：最简单的方法，一个进程写一个文件，另一个进程去访问这个文件，由此两个进程之间可以交换信息，得以通信。"><a href="#1-写一个文件：最简单的方法，一个进程写一个文件，另一个进程去访问这个文件，由此两个进程之间可以交换信息，得以通信。" class="headerlink" title="1.写一个文件：最简单的方法，一个进程写一个文件，另一个进程去访问这个文件，由此两个进程之间可以交换信息，得以通信。"></a>1.写一个文件：最简单的方法，一个进程写一个文件，另一个进程去访问这个文件，由此两个进程之间可以交换信息，得以通信。</h3><h3 id="2-管道：两个进程之间建立消息通信的通道。不命名的管道一般是单向的，一方可以向另一方从管道里发送数据；命名管道可以单向也可以双向。"><a href="#2-管道：两个进程之间建立消息通信的通道。不命名的管道一般是单向的，一方可以向另一方从管道里发送数据；命名管道可以单向也可以双向。" class="headerlink" title="2.管道：两个进程之间建立消息通信的通道。不命名的管道一般是单向的，一方可以向另一方从管道里发送数据；命名管道可以单向也可以双向。"></a>2.管道：两个进程之间建立消息通信的通道。不命名的管道一般是单向的，一方可以向另一方从管道里发送数据；命名管道可以单向也可以双向。</h3><p>比如：<br>-打印一个日志文件：cat XXX</p>
<p>-查找带有某个字符串内容：grep -e “ERROR” –color</p>
<p>此外，如果还用统计，可以用wc（word count）命令</p>
<h3 id="3-Signal：linux系统中最常用。一个进程给另一个进程发送信号，一般是一串数字，这个数字有自己特定的含义。比如”kill”可以-send-a-signal-to-a-process-强行”kill”掉。"><a href="#3-Signal：linux系统中最常用。一个进程给另一个进程发送信号，一般是一串数字，这个数字有自己特定的含义。比如”kill”可以-send-a-signal-to-a-process-强行”kill”掉。" class="headerlink" title="3.Signal：linux系统中最常用。一个进程给另一个进程发送信号，一般是一串数字，这个数字有自己特定的含义。比如”kill”可以 send a signal to a process,强行”kill”掉。"></a>3.Signal：linux系统中最常用。一个进程给另一个进程发送信号，一般是一串数字，这个数字有自己特定的含义。比如”kill”可以 send a signal to a process,强行”kill”掉。</h3><h3 id="4-共享内存：虽然进程之间是彼此独立的，但是操作系统可以提供一个机制，两个进程可以约定好，打开一个文件，这个文件映射到内存中，也就是多个进程使用同一块内存。"><a href="#4-共享内存：虽然进程之间是彼此独立的，但是操作系统可以提供一个机制，两个进程可以约定好，打开一个文件，这个文件映射到内存中，也就是多个进程使用同一块内存。" class="headerlink" title="4.共享内存：虽然进程之间是彼此独立的，但是操作系统可以提供一个机制，两个进程可以约定好，打开一个文件，这个文件映射到内存中，也就是多个进程使用同一块内存。"></a>4.共享内存：虽然进程之间是彼此独立的，但是操作系统可以提供一个机制，两个进程可以约定好，打开一个文件，这个文件映射到内存中，也就是多个进程使用同一块内存。</h3><p><strong>共享内存方式适用于进程间数据共享的场景</strong>。</p>
<h3 id="5-消息队列：一个进程可以向另一个进程发消息。"><a href="#5-消息队列：一个进程可以向另一个进程发消息。" class="headerlink" title="5.消息队列：一个进程可以向另一个进程发消息。"></a>5.消息队列：一个进程可以向另一个进程发消息。</h3><p><strong>进程间数据交换的场景可以使用Unix Socket或者消息队列</strong>。</p>
<h3 id="6-同步机制，信号量。"><a href="#6-同步机制，信号量。" class="headerlink" title="6.同步机制，信号量。"></a>6.同步机制，信号量。</h3><p>很经典的知识点。如果进程或者线程进入之后，可能不是在进行写操作，而是进行读之类的操作，此时没必要只限制一个进程或者线程去执行。</p>
<p>信号量用一个整型(sem)表示，它是一个有符号数。针对信号量有两个原子操作：</p>
<ul>
<li><font color=#FF0000><strong>P()</strong></font>(Perlaag(荷兰语，减少))<ul>
<li>sem减1</li>
<li>若sem &lt; 0,进入等待，否则继续</li>
</ul>
</li>
<li><font color=#FF0000><strong>V()</strong></font>(Verhoog(荷兰语，增加))<ul>
<li>sem加1</li>
<li>若sem&lt;=0,唤醒一个等待进程</li>
</ul>
</li>
</ul>
<p>可以用火车站台举例子，如果只有两个车站和站台，只有2个资源的信号量，那么一开始sem是2。来了一辆车，sem会减1，若sem减小到了0，那么再来的资源就只能等待了。</p>
<p>信号量有两种：二进制信号量(0或1)、一般/计数信号量(可以取任何非负值)</p>
<p>P()操作可能会让进程阻塞挂起、V()操作可能可以唤醒进程。</p>
<p>在临界区之前用P()操作，在临界区之后用V()操作加回去。</p>
<p>使用二值信号量的一个例子：如果要设置两个Thread的同步关系，那么可以把condition初始化值设置为0：<code>condition = new Semaphore(0)</code>，<br>让Thread在执行条件(比如condition())之前执行减法P()操作，这样condition就不得不暂停，直到condition里面的信号量回到0才能继续执行。此时可以在ThreadB中执行V()操作，此时才可以把ThreadA唤醒，使得Thread继续执行。</p>
<p><strong>也可以用信号量解决有缓冲区的生产者-消费者问题</strong>。此时需要用到计数信号量。</p>
<p><img src="https://s2.ax1x.com/2020/02/26/3U1SYV.png" alt="3U1SYV.png"></p>
<p>图中的情况和Lock完全不同。生产者可能生产很多内容都往buffer里面”挤”，但是作为消费者的线程，可能不能一口气消耗掉所有buffer里面的数据。</p>
<p>有关生产者消费者模型的问题，有以下要求(约束)：</p>
<ul>
<li>在任何一个时间只能有一个线程操作缓冲区(互斥)</li>
<li>当缓冲区为空，消费者必须等待生产者(调度/同步约束)</li>
<li>当缓存区满，生产者必须等待消费者(调度/同步约束)</li>
</ul>
<p>解决这三个约束的办法，就是定义三个信号量，每个约束单独用一个信号量控制：</p>
<ul>
<li>二进制信号量(处理互斥)</li>
<li>一般信号量fullBuffers(一开始为0，取不到数据，标记消费者是否可以去取数据了)</li>
<li>一般信号量emptyBuffers(一开始为n，可以用P()函数去取)</li>
</ul>
<p>具体定义操作：</p>
<p><img src="https://s2.ax1x.com/2020/02/26/3U6nhT.png" alt="3U6nhT.png"></p>
<p>上面这两个函数中，即用到了互斥机制，也用到了同步机制，来解决生产者和消费者的问题。</p>
<p>fullBuffers一开始是0。emptyBuffers里面一开始设置可以放入n。</p>
<p>生产者函数：Deposit、消费者函数：Remove()</p>
<p>需要注意初始值的赋值，需要知道一开始Buffer是不是空的。</p>
<p>一个问题：上述生产者消费者模型中，<strong>P、V操作的顺序有影响吗？</strong>——答：因为V操作不会阻塞，所以交换V操作没有问题。</p>
<p>但是生产者的P操作不能交换，因为P操作是阻塞的，可能产生死锁。比如生产者很快，Buffer满了，生产者先执行mutex的P操作，可以执行。但是之后执行emptyBuffer()的时候，因为此时Buffer满了，emptyBuffers已经是0了，所以再执行P操作之后，Deposit会进入到睡眠状态。之后消费者如果P顺序不变，第一个fullBuufers操作没问题，但是第二个mutex会卡住，导致最后不能执行到emptyBuffers操作的V操作，无法唤醒生产者的操作，产生死锁。</p>
<p>所以，对信号量的操作的顺序需要注意。</p>
<h3 id="7-Socket：最后一种，而且没回答出来这个其实整个答案都不算好。因为前面6种只能作为同一个机器的进程之间的通信，而Socket可以是不同机器的进程之间的通信。"><a href="#7-Socket：最后一种，而且没回答出来这个其实整个答案都不算好。因为前面6种只能作为同一个机器的进程之间的通信，而Socket可以是不同机器的进程之间的通信。" class="headerlink" title="7.Socket：最后一种，而且没回答出来这个其实整个答案都不算好。因为前面6种只能作为同一个机器的进程之间的通信，而Socket可以是不同机器的进程之间的通信。"></a>7.Socket：最后一种，而且没回答出来这个其实整个答案都不算好。因为前面6种只能作为同一个机器的进程之间的通信，而<strong>Socket可以是不同机器的进程之间的通信</strong>。</h3><p>可以在机器上开一个端口，作为一个服务器，让用户连接。这种通信包含了网络上的服务端和服务器的这种结构。</p>
<p>用浏览器去访问一个网站，这时<strong>浏览器的进程</strong>和<strong>远端服务器的进程要进行通信</strong>。</p>
<p>Socket可以作为不同机器之间进程的通信——通过客户端，服务器的方法。这里面走的一般是TCP的协议或者UDP的协议。</p>
<h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><p>介绍两个调度算法：<strong>时间片轮转调度算法</strong>和<strong>动态优先级调度算法</strong></p>
<p>时间片轮转调度是一种最古老，最简单而且最公平的算法，每个进程被分配一段时间，称作是时间片，轮流分享CPU的计算资源。这个时间片的设置比较讲究。比如linux早期是百分之一秒，现在设置为千分之一秒。</p>
<p>和之前做过的堆机场吞吐量优化的项目类似，动态优先级调度算法就是给每个进程都设置一个权值，而且这个权值会随自变量而改变，而系统会根据每个进程的优先级来判断之后优先调度哪一个进程。</p>
<h1 id="存储和寻址"><a href="#存储和寻址" class="headerlink" title="存储和寻址"></a>存储和寻址</h1><p>存储整体结构如下图：</p>
<p><img src="https://s2.ax1x.com/2020/02/26/3UostH.png" alt="3UostH.png"></p>
<p>最底层是硬盘，可以长久存放程序，而且一般都比较大。</p>
<p>然后是内存，它里面存放的数据断电就会没有，但是它可以更加快速地随机地进行访问。</p>
<p>再往上就进入了CPU。CPU除了运算模块，还有缓存。缓存也有各种级别，有些缓存是共有的，有些是自己独有的。</p>
<p>再往上就是离CPU运算单元更近的，寄存器。</p>
<p>这些存储单元的存储速度有什么特点？从上到下由快到慢。寄存器是最快的因为他就在运算模块的旁边。硬盘是最慢的。价格也是由贵到便宜。</p>
<p>谷歌的搜索会把整个互联网放在它们的内存中，尤其是对访问量高的网页。访问量低的网页才会被放在硬盘里。这样基于内存的搜索引擎肯定是又快又好的。</p>
<h2 id="寻址过程"><a href="#寻址过程" class="headerlink" title="寻址过程"></a>寻址过程</h2><p>那么我们操作系统是如何寻址的？——也就是说给定一个地址之后，操作系统是怎么在这个层次性的结构中找到需要的数据呢？</p>
<p>需要结合寻址空间：</p>
<ul>
<li>寻址空间：每一个<strong>进程</strong>里面的指针可以取到的地址的范围。这个寻址空间和我们机器上装了多少存储空间，某时刻有多少个进程，都没有关系。每个进程都有自己独立的寻址空间。</li>
</ul>
<p>那这个寻址空间有多大呢？一般会考虑到两种大小的寻址空间：32位和64位。</p>
<p>32位：2的32次方位字节(Byte,注意不是Bit，也就说不是位或者比特)。1G=2^10 M =2^10 * 2^10 K = 2^10 * 2^10 * 2^10 B，所以32位为 2^32/2^10/2^10/2^10 = 2^2 = 4G</p>
<p>64位：可以有10^19次方Byte的寻址空间，这个空间非常大，一时半会不需要考虑不够用……</p>
<p>举一个寻址的例子：<code>int n = *p;</code>，这段代码翻译成汇编，其实就是：<code>MOV EAX, [EBX]</code></p>
<p>具体流程如下图所示：</p>
<p><img src="https://s2.ax1x.com/2020/02/26/3ay5IP.png" alt="3ay5IP.png"></p>
<p>这段代码,int n = <em>p，p代表一个地址，</em>p表示把指向int类型的数据的指针p指向的内容读取出来，赋值给n</p>
<p>图中虚线表示，逻辑内存对应到物理内存是不一定对应得出来的，有可能它在物理内存里面（直接取出来就可以），也可能不在物理内存里面，在虚拟内存里面。操作系统会在硬盘上开辟一个空间作为虚拟内存，虚拟内存不会把具体多少字节放过去，而是把p的分页放进去（通常几k或者几兆这样，根据操作系统配置而定）。</p>
<p>通常硬盘是比较大的，只要放得下，可以不断把内存中的东西放到硬盘上去。</p>
<p>如果想要放入物理内存但是发现物理内存不够，那么就只能用算法在物理内存里面找到一块很久没有用过的地方，用新的分页部分把它替换出来，这个过程称作是“分页”或“交换”，这个时候p就进入了物理内存里面。</p>
<p>如果在win的C盘发现有一块空间（几百兆或者几G）是不能访问的，那么这是win分配的虚拟内存的块空间。<br>在Linux中用户也是没有权限看到这块空间的，然后物理内存里面有了p的数据，我们可以把它取出来，放到寄存器里面。</p>
<p>一个运行良好的系统，绝大部分数据都是在物理内存里面的，这样能够很快。但是物理内存使用过多会造成过度分页，由于硬盘很慢，这样的话系统就会变得很慢。</p>
<h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><ul>
<li><p><strong>中断的概念</strong>：中断指处理机处理程序运行中出现的紧急事件的整个过程.程序运行过程中，系统外部、系统内部或者现行程序本身若出现紧急事件，处理机立即中止现行程序的运行，自动转入相应的处理程序(中断服务程序)，待处理完后，再返回原来的程序运行，这整个过程称为程序中断。</p>
</li>
<li><p><strong>中断的流程</strong>：改变工作模式至中断模式 -&gt; 保存现场 -&gt; 分析中断原因，跳到中断起始地址处理中断 -&gt; 返回到原来模式 -&gt; 恢复现场继续执行原来的程序。</p>
</li>
</ul>
<h1 id="操作系统问题集合"><a href="#操作系统问题集合" class="headerlink" title="操作系统问题集合"></a>操作系统问题集合</h1><ul>
<li>进程和线程的区别和相同点？</li>
</ul>
<p>-可以结合上面的内容。线程是进程的一部分，进程是程序的一部分。线程和进程之间的相同点：进程和线程都有ID/寄存器组、状态和优先权、信息块，创建后都可更改自己的属性，都可与父进程共享资源、都不能直接访问其他无关进程或线程的资源。</p>
<ul>
<li>简单说说寻址的过程？</li>
</ul>
<p>-可以结合上述内容。</p>
<ul>
<li>32位操作系统和64位操作系统区别是什么？</li>
</ul>
<p>-32位和64位是它们的寻址空间大小的区别，这和系统物理内存大小无关。</p>
<ul>
<li>说出你知道的进程间通信机制？</li>
</ul>
<p>-参考上述七种方法，最重要的是socket，最容易忽略的是“读写文件”（读文件和写文件）。</p>
<ul>
<li>说一下中断的概念和流程？<br>参考上面内容。</li>
</ul>
]]></content>
      <categories>
        <category>Interview Note</category>
      </categories>
      <tags>
        <tag>Interview</tag>
        <tag>operating system</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer Networks Interview I</title>
    <url>/2020/02/25/Computer-Networks-Interview-I/</url>
    <content><![CDATA[<blockquote>
<p>知识犹如人体的血液一样宝贵。——高士其</p>
</blockquote>
<a id="more"></a>

<p>本文内容参考一些网络文章：<a href="https://juejin.im/post/5d5414cb6fb9a06b20055e27" target="_blank" rel="noopener">Henry_Jeannie</a></p>
<h1 id="OSI七层网络协议和TCP-IP四层网络协议"><a href="#OSI七层网络协议和TCP-IP四层网络协议" class="headerlink" title="OSI七层网络协议和TCP/IP四层网络协议"></a>OSI七层网络协议和TCP/IP四层网络协议</h1><p>首先需要理解OSI七层和TCO/IP四层网络协议，这个4/7模型是网络知识的基础。</p>
<p>但是我觉得，首先，我们可以思考一下，为什么要弄得这么麻烦，这么多层去传输数据？为什么不可以在物理层就设计好呢？<br>——这个想法是合理的，但是网络的发展过程中实际上是理论基础不强的，都是解决一个一个小问题来发展的。所以这是历史发展的角度，当时为了解决这些问题才出现这个层的。虽然从理论上可能能够更好，但是当时为了解决当时的问题才出现这个层和结构的。</p>
<p>其他的，比如我们的java语言，支持泛型这一点就是在过去的基础上堆砌出来的，而不是从头设计的机制。</p>
<h2 id="OSI开放式互联参考模型-OSI七层参考模型"><a href="#OSI开放式互联参考模型-OSI七层参考模型" class="headerlink" title="OSI开放式互联参考模型(OSI七层参考模型)"></a>OSI开放式互联参考模型(OSI七层参考模型)</h2><p>OSI七层网络模型如下图所示：</p>
<p><img src="https://s2.ax1x.com/2020/02/27/3dZDTf.png" alt="3dZDTf.png"></p>
<p>整个运行的流程是先自上而下，后自下而上地处理数据头部。</p>
<p>由下往上来看：</p>
<ol>
<li>物理层：定义网络设备的标准，包括：网线类型、接口类型、传输介质的类型，将他们转化成电流强弱来进行传输，比特转换（数模和模数转换）</li>
</ol>
<ol start="2">
<li>数据链路层：传输数据的时候会产生传输的数据不完整等可能。数据链路层定义了如何格式化数据来进行传输。以及控制如何对物理介质进行访问。也提供错误检测和纠正，以确保数据传输的可靠性。这一层把比特数据转换成了“帧”，<font color=#FF0000>交换机</font>工作在这一层，并对帧进行解码。根据帧中包含的信息把数据发送到正确的接收方。</li>
</ol>
<ol start="3">
<li>网络层：这一层的协议<strong>把网络地址翻译成对应的物理地址</strong>，并决定如何将发送的数据从发送方路由到接收方。由于路由器工作在网络各段，所以<font color=#FF0000>路由器</font>工作在这一层。（关注IP协议）</li>
</ol>
<ol start="4">
<li>传输层（OSI模型中最重要的一层）：解决主机间的数据传输问题。为了保证传输体量大的数据的准确性，可能需要对数据进行切割，切割成一个一个的段落进行发送。（关注TCP和UDP协议）</li>
</ol>
<ol start="5">
<li>会话层：可以不用每次都去寻址，发送底层的包。会话层是用来建立和管理应用程序之间的通信。</li>
</ol>
<ol start="6">
<li>表示层：比如win的很多文件在linux上不能执行，vice verser, 用来解决不同操作系统之间的通信语法问题。这一层中数据将按照网络能理解的方式进行格式化，</li>
</ol>
<ol start="7">
<li>应用层：规定发送方和接收方必须使用一个固定长度的消息头，消息头也必须使用某种固定的结构。消息头必须记录消息的长度等一系列信息，以方便接收方能接受发送方所发送的数据。应用层方便用户利用网络中接收到的数据。没有这一层，你在不同电脑中传递的数据都是“1”和“0”.  这一层中要关注的是 TCP/IP中的HTTP协议</li>
</ol>
<p>需要注意，OSI不是一个标准，而是制定标准的时候使用的概念性框架。</p>
<p>记忆方法，就记开头的第一个字，更容易记住！</p>
<p>应、表、会、传、网、数、物</p>
<h2 id="OSI的实现：TCP-IP模型-TCP-IP四层参考模型"><a href="#OSI的实现：TCP-IP模型-TCP-IP四层参考模型" class="headerlink" title="OSI的实现：TCP/IP模型(TCP/IP四层参考模型)"></a>OSI的实现：TCP/IP模型(TCP/IP四层参考模型)</h2><p><img src="https://s2.ax1x.com/2020/02/27/3dKMaq.png" alt="3dKMaq.png"></p>
<h1 id="TCP传输协议"><a href="#TCP传输协议" class="headerlink" title="TCP传输协议"></a>TCP传输协议</h1><h2 id="TCP协议简介"><a href="#TCP协议简介" class="headerlink" title="TCP协议简介"></a>TCP协议简介</h2><p>TCP协议是一个基于连接的协议，在连接的基础上可以达到一个可靠的传输。怎样是可靠的传输？我们的数据包是按照顺序收到的，也就是说我发出的数据包的顺序和你收到数据包的顺序一定是一样的。</p>
<p>-此外，我们要保证我发出的包和你收到的包是一样的，是不出错的。</p>
<p>-还有其他的重要的功能，包括流量控制和拥塞控制。<br>流量控制可以保证不会发生：发送端发送数据太快，接收端来不及接收。拥塞控制指网络出现拥塞的时候，情况不会恶化。</p>
<p>TCP 链接一旦建立，就可以在链接上进行双向的通信。</p>
<p>具体细节：</p>
<ul>
<li>面向连接的、可靠的、基于字节流(不是基于报文，可以根据字节大小进行编号)的传输层通信协议</li>
<li>将应用层的数据流分割成报文段并发送给目标节点的TCP层</li>
<li>数据包都有序号，对方受到则发送ACK确认，未收到则重传</li>
</ul>
<p>TCP的报文格式：</p>
<p><img src="https://s2.ax1x.com/2020/02/27/3dLdBR.jpg" alt="3dLdBR.jpg"></p>
<p>接下来介绍TCP的三次握手和四次挥手。</p>
<p>首先，我们要用网络化的思想方法（这个网络化的思想方法是非常工程化的思想方法）。我们首先承认现实，网络是不可靠的，任何包都可能丢，我们设计TCP协议的过程中，一定要牢记这句话，因为如果不是基于这个事实，那么所有的设计其实都是过于复杂的，都是没有意义的。</p>
<p>然后，我们需要秉持工程化的思路，我们就是会不断遇到问题，然后解决问题。之后很可能再遇到新的问题，再解决这个新的问题。通过这种思想，我们会不断遇到问题，解决问题，不断迭代。通过这样做，我们得到的其实不是一个完美的协议，而是一个能用就好的东西。</p>
<p>这就是网络相关问题的现实：不断遇到问题，然后解决问题，长此以往不断迭代，迭代到能用即可。</p>
<p>这种思想不会是普适的，有些问题是需要我们通过理论上完美解决才好的，比如数据库，数据库就是通过理论去解决问题的。</p>
<h2 id="TCP三次握手和四次挥手需要用到的符号变量"><a href="#TCP三次握手和四次挥手需要用到的符号变量" class="headerlink" title="TCP三次握手和四次挥手需要用到的符号变量"></a>TCP三次握手和四次挥手需要用到的符号变量</h2><ul>
<li><strong>序列号</strong><code>seq</code>： 用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号<code>seq</code>就是这个报文段中的第一个字节的数据编号。</li>
</ul>
<ul>
<li><strong>确认号</strong><code>ack</code>： 期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。</li>
</ul>
<ul>
<li><strong>确认</strong><code>ACK</code>： 仅当<code>ACK=1</code>时，确认号字段才有效。<code>ACK=0</code>时，确认号无效</li>
</ul>
<ul>
<li><p><strong>同步</strong><code>SYN</code>： 连接建立时用于同步序号。当<code>SYN=1</code>，<code>ACK=0</code>时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得<code>SYN=1</code>，<code>ACK=1</code>。因此，<code>SYN=1</code>表示这是一个连接请求，或连接接受报文。<code>SYN</code>这个标志位只有在<code>TCP</code>建产连接时才会被置1，握手完成后<code>SYN</code>标志位被置0。</p>
</li>
<li><p><strong>终止</strong><code>FIN</code>： 用来释放一个连接。<code>FIN=1</code>表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接</p>
</li>
</ul>
<h2 id="TCP三次握手-建立连接"><a href="#TCP三次握手-建立连接" class="headerlink" title="TCP三次握手(建立连接)"></a>TCP三次握手(建立连接)</h2><p>首先需要记得，TCP的三次握手，需要用到两个类型的变量：<strong>SYN、ACK</strong>。它们的作用分别是：</p>
<ul>
<li>ACK：确认。仅当ACK=1时确认号字段才有效。当ACK=0时，确认号无效。TCP规定，在连接建立后所有的传送的报文段都必须把ACK置1.</li>
<li>FIN：终止。用来释放一个连接。当FIN=1时，表明此报文段的发送方的数据已经发送完毕，并要求释放运输连接。</li>
</ul>
<p>接下来看 TCP 建连的三次握手。TCP 是基于链接的，所以在传输数据前需要先建立链接，TCP 在传输上是双工传输，不区分 Client 端与 Server 端，为了便于理解，我们把主动发起建连请求的一端称作 Client 端，把被动建立链接的一端称作 Server 端。</p>
<p><img src="https://i.loli.net/2020/03/12/Lja9iFcHx2hubp8.jpg" alt="TCP三次握手"></p>
<p>一开始，Server端先监听端口，其初始状态是LISTEN。Client端主动打开连接，开始三次握手。</p>
<p><strong>第一次握手</strong>：客户端向服务器发出连接请求报文，这时报文首部中的同部位<code>SYN=1</code>，同时随机生成初始序列号 <code>seq=x</code>，此时，客户端进程进入了 <code>SYN-SENT</code>状态，等待服务器的确认。</p>
<p><strong>第二次握手</strong>：服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 <code>ACK=1</code>，<code>SYN=1</code>，确认号是<code>ack=x+1</code>，同时也要为自己随机初始化一个序列号 <code>seq=y</code>，此时，服务器进程进入了<code>SYN-RCVD</code>状态，询问客户端是否做好准备。；</p>
<p><strong>第三次握手</strong>：客户端进程收到确认后，还要向服务器给出确认。确认报文的<code>ACK=1</code>，<code>ack=y+1</code>，此时，连接建立，客户端进入<code>ESTABLISHED</code>状态，服务器端也进入<code>ESTABLISHED</code>状态。</p>
<p>后面双方可以进行数据传输。</p>
<p>三次握手的简化流程图为：(建连的时序是从上到下，左右两边的绿色字分别代表 Client 端与 Server 端当时的链接状态。)</p>
<p><img src="https://i.loli.net/2020/03/12/aihnWwjl18HIRtE.png" alt="TCP三次握手简化.png"></p>
<p><font color=#FF0000>在面试时需要明白三次握手是为了建立双向的链接，需要记住 Client 端和 Server 端的链接状态变化。</font></p>
<p>其他问题：</p>
<ul>
<li>首次握手时候的隐患：SYN超时——针对SYN Flood的防护措施。</li>
</ul>
<p>——<font color=#FF0000>面试回答建连的问题时，可以提到 SYN 洪水攻击发生的原因，就是 Server 端收到 Client 端的 SYN 请求后，发送了 ACK 和 SYN，但是 Client 端不进行回复，导致 Server 端大量的链接处在 SYN_RCVD 状态，进而影响其他正常请求的建连。可以设置 tcp_synack_retries = 0 加快半链接的回收速度，或者调大 tcp_max_syn_backlog 来应对少量的 SYN 洪水攻击。因为是Server端接收到了Client端的SYN包之后的回复的时候出现的问题，所以可以认为是首次握手时候产生的隐患。</font></p>
<ul>
<li>建立连接后，Client出现故障怎么办？</li>
</ul>
<p>——保活机制：1.相对方发送保活探测报文，如果未接收到相应则继续发送。2.尝试次数达到了设定的保活探测次数但是仍未收到响应的话，则中断连接。</p>
<h2 id="TCP四次挥手-终止连接"><a href="#TCP四次挥手-终止连接" class="headerlink" title="TCP四次挥手(终止连接)"></a>TCP四次挥手(终止连接)</h2><p>TCP四次挥手同样需要使用两个类型的变量：FIN和ACK。</p>
<p><img src="https://i.loli.net/2020/03/12/P76skMIGWAO3Ntv.jpg" alt="TCP四次挥手"></p>
<p>从图中看出，通信中 Client 和 Server 两端的链接都是 ESTABLISHED 状态。实际上，TCP 链接的关闭，通信双方都可以先发起，我们暂且把先发起的一方看作 Client</p>
<p><strong>第一次挥手</strong>：客户端进程发出连接释放<code>FIN</code>报文，并且停止发送数据。释放数据报文首部，<code>FIN=1</code>，其序列号为<code>seq=x</code>,此时，客户端进入<code>FIN_WAIT_1</code>（终止等待1）状态。</p>
<p><strong>第二次挥手</strong>：服务端进程收到连接释放<code>FIN</code>报文，发出确认<code>ACK</code>报文，<code>ACK=1</code>，<code>ack=x+1</code>，并且带上自己的序列号<code>seq=y</code>，此时，服务端就进入了<code>CLOSE_WAIT</code>（关闭等待）状态。此时，服务端通知高层的应用进程，客户端向服务端的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务端若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个<code>CLOSE_WAIT</code>状态持续的时间。客户端收到服务端的确认请求后，此时，客户端就进入<code>FIN_WAIT_2</code>（终止等待2）状态，等待服务器发送连接释放报文，在这之前依然可以接收服务端发送过来的最后的数据。</p>
<p><strong>第三次挥手</strong>：服务端将最后的数据发送给客户端完成后，就向客户端发送连接释放<code>FIN</code>报文，<code>FIN=1</code>，<code>ack=x+1</code>，此时的序列号为<code>seq=z</code>，此时，服务端就进入了<code>LAST-ACK</code>（最后确认）状态，等待客户端的确认。</p>
<p><strong>第四次挥手</strong>：客户端接收到服务端的连接释放<code>FIN</code>报文后，必须发出确认报文，<code>ACK=1</code>，<code>ack=z+1</code>，而自己的序列号是<code>seq=x+1</code>，此时，客户端就进入了<code>TIME_WAIT</code>（时间等待）状态。此时服务端收到客户端发送过来的确认报文，就立即撤销自己的传输控制块<code>TCB</code>,进入<code>CLOSED</code>状态，<strong>注意此时的TCP连接还没有释放，必须经过2MSL（最长报文段寿命）的时间后，客户端没有收到服务端发来的任何数据，证明服务端已正常关闭，此时客户端会撤销相应传输控制块<code>TCB</code>后，进入<code>CLOSED</code>状态</strong>。至此，TCP的连接才真正的断开了。（服务端结束TCP连接的时间要比客户端稍微早一些）</p>
<p>这里面试官比较可能会问：为什么需要等待2倍的最大报文生存时间之后Client再关闭链接？原因有两个：</p>
<ol>
<li>保证TCP协议的全双工连接能够可靠关闭；</li>
<li>保证这次连接的重复数据段从网络中消失，防止端口被重用时可能产生数据混淆。</li>
</ol>
<p>TCP四次挥手的简化图：</p>
<p><img src="https://i.loli.net/2020/03/12/jU8sIKLGTvMmpBy.png" alt="TCP四次挥手简化.png"></p>
<p>需要注意，在四次挥手的过程中，可以提到在实际应用中有可能遇到大量Socket处在TIME_WAIT或者CLOSE_WAIT状态的问题。一般开启 <code>tcp_tw_reuse</code> 和 <code>tcp_tw_recycle</code> 能够加快 TIME-WAIT 的 Sockets 回收；而大量 CLOSE_WAIT 可能是被动关闭的一方存在代码 bug，没有正确关闭链接导致的。</p>
<h2 id="TCP三次握手和四次挥手的对比总结"><a href="#TCP三次握手和四次挥手的对比总结" class="headerlink" title="TCP三次握手和四次挥手的对比总结"></a>TCP三次握手和四次挥手的对比总结</h2><p>无论是建连还是断连，都是需要在两个方向上进行，只不过建连时，Server 端的 SYN 和 ACK 合并为一次发送，而断链时，<strong>两个方向上数据发送停止的时间可能不同，所以不能合并发送 FIN 和 ACK</strong>。</p>
<h2 id="TCP要三次握手的原因"><a href="#TCP要三次握手的原因" class="headerlink" title="TCP要三次握手的原因"></a>TCP要三次握手的原因</h2><p>TCP的握手为什么要三次呢？最后一次不要了，改为两次握手，可以么？</p>
<p>假如现在客户端想向服务端进行握手，它发送了第一个连接的请求报文，但是由于网络信号差或者服务器负载过多，这个请求没有立即到达服务端，而是在某个网络节点中长时间的滞留了，以至于滞留到客户端连接释放以后的某个时间点才到达服务端，那么这就是一个失效的报文，但是服务端接收到这个失效的请求报文后，就误认为客户端又发了一次连接请求，服务端就会想向客户端发出确认的报文，表示同意建立连接。</p>
<p>假如不采用三次握手，那么只要服务端发出确认，表示新的建立就连接了。但是现在客户端并没有发出建立连接的请求，其实这个请求是失效的请求，一切都是服务端在自相情愿，因此客户端是不会理睬服务端的确认信息，也不会向服务端发送确认的请求，但是服务器却认为新的连接已经建立起来了，并一直等待客户端发来数据，这样的情况下，服务端的很多资源就没白白浪费掉了。</p>
<p>采用三次握手的办法就是为了防止上述这种情况的发生，比如就在刚才的情况下，客户端不会向服务端发出确认的请求，服务端会因为收不到确认的报文，就知道客户端并没有要建立连接，那么服务端也就不会去建立连接，这就是三次握手的作用。</p>
<p>NOTE:用更专业的内容可以说，之前发送过程中滞留的包，是”<strong>已失效的连接请求报文段</strong>“</p>
<h2 id="TCP要四次挥手的原因"><a href="#TCP要四次挥手的原因" class="headerlink" title="TCP要四次挥手的原因"></a>TCP要四次挥手的原因</h2><p>TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工 模式，这就意味着，在客户端想要断开连接时，客户端向服务端发送<code>FIN</code>报文，只是表示客户端已经没有数据要发送了，但是这个时候客户端还是可以接收来自服务端的数据。</p>
<p>当服务端接收到<code>FIN</code>报文，并返回<code>ACK</code>报文，表示服务端已经知道了客户端要断开连接，客户端已经没有数据要发送了，但是这个时候服务端可能依然有数据要传输给客户端。</p>
<p>当服务端的数据传输完之后，服务端会发送<code>FIN</code>报文给客户端，表示服务端也没有数据要传输了，服务端同意关闭连接，之后，客户端收到<code>FIN</code>报文，立即发送给客户端一个<code>ACK</code>报文，确定关闭连接。在之后，客户端和服务端彼此就愉快的断开了这次的<code>TCP</code>连接。</p>
<p>或许会有疑问，为什么服务端的<code>ACK</code>报文和<code>FIN</code>报文都是分开发送的，但是在三次握手的时候却是<code>ACK</code>报文和<code>SYN</code>报文是一起发送的，因为在三次握手的过程中，当服务端收到客户端的SYN连接请求报文后，可以直接发送<code>SYN</code>+<code>ACK</code>报文。其中<code>ACK</code>报文是用来应答的，<code>SYN</code>报文是用来同步的。但是在关闭连接时，当服务端接收到<code>FIN</code>报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个<code>ACK</code>报文，告诉客户端，你发的<code>FIN</code>报文我收到了，只有等到服务端所有的数据都发送完了，才能发送<code>FIN</code>报文，因此<code>ACK</code>报文和<code>FIN</code>报文不能一起发送。所以断开连接的时候才需要四次挥手来完成。</p>
<h1 id="UDP传输协议"><a href="#UDP传输协议" class="headerlink" title="UDP传输协议"></a>UDP传输协议</h1><h2 id="UDP报文"><a href="#UDP报文" class="headerlink" title="UDP报文"></a>UDP报文</h2><p><img src="https://s2.ax1x.com/2020/02/27/30kC5D.jpg" alt="UDP报文"></p>
<p>可以看出，UDP和TCP报文一样，都有源端口号、目的端口号等内容。</p>
<h2 id="UDP协议特点"><a href="#UDP协议特点" class="headerlink" title="UDP协议特点"></a>UDP协议特点</h2><ul>
<li>面向非连接</li>
<li>不维护连接状态，支持同时向多个客户端传输相同的消息</li>
<li>数据包报头只有8个字节，额外开销较小</li>
<li>吞吐量只受限于数据生成速率、传输速率以及机器性能</li>
<li>尽最大努力交付，不保证可靠交付，不需要维持复杂度的连接状态表</li>
<li>面向报文，不对应用程序提交的报文信息进行拆分或者合并</li>
</ul>
<h1 id="TCP和UDP的比较"><a href="#TCP和UDP的比较" class="headerlink" title="TCP和UDP的比较"></a>TCP和UDP的比较</h1><p>这个问题比较大，但是其实比较好回答，结合以下几个方面回答即可：</p>
<ul>
<li>面向连接 vs 无连接</li>
<li>可靠性</li>
<li>有序性</li>
<li>速度</li>
<li>量级</li>
</ul>
<h1 id="TCP滑动窗口"><a href="#TCP滑动窗口" class="headerlink" title="TCP滑动窗口"></a>TCP滑动窗口</h1><h2 id="TCP滑动窗口解决了什么问题"><a href="#TCP滑动窗口解决了什么问题" class="headerlink" title="TCP滑动窗口解决了什么问题"></a>TCP滑动窗口解决了什么问题</h2><p>解决的问题，最基本的就是，如果我们每发送一个包都要得到ACK，那么网络延迟很长的话会很浪费。于是我们可以采用滑动窗口，在窗口中发送过去，让它来ACK，这样可以更好地利用我们的带宽。此外，它还能做到流量控制（流控），我们可以保证两边的收发速度相对一致。</p>
<h2 id="TCP滑动窗口原理介绍"><a href="#TCP滑动窗口原理介绍" class="headerlink" title="TCP滑动窗口原理介绍"></a>TCP滑动窗口原理介绍</h2><p>TCP主要使用滑动窗口机制来实现流量控制，这个滑动窗口对于有包发送和接收顺序要求的TCP来说，非常重要。</p>
<p>首先，对于TCP，假设如果没有滑动窗口，每个包只能一个一个，按照序号发送，那么为了满足TCP这个要求，我们只能如图这么设计：</p>
<p><img src="https://s2.ax1x.com/2020/02/27/30UCo8.png" alt="使用滑动窗口前"></p>
<p>但是这个方案缺点很明显，如果1号没发成功，2号根本不能发，否则乱序了，导致吞吐量太低。</p>
<p>使用滑动窗口方案改进之后的示意图如下：</p>
<p><img src="https://s2.ax1x.com/2020/02/27/30U9df.png" alt="使用滑动窗口后"></p>
<p>但是，一次发送2个包过去，如何能够解决确认收到的问题呢？</p>
<p>这就是用到了滑动窗口了，滑动窗口是一个长度被设定好的”窗口”，举例子说明：</p>
<p><img src="https://s2.ax1x.com/2020/02/27/30dtIK.png" alt="滑动窗口1"></p>
<p>灰色是已经发送了的包。黄色和绿色都是在窗口里面的包，黄色是在窗口中已经发送但是没有收到确认的包。绿色是在窗口中同时没有发送的包。</p>
<p>过一段时间之后，情况变成下图所示：</p>
<p><img src="https://s2.ax1x.com/2020/02/27/30dUPO.png" alt="滑动窗口2"></p>
<p>新加入了没有发送的11号包，然后在这段时间内，又发送了8和9号包。</p>
<p>再往后，5发送之后，会读入12；6发送之后，会再读入13，以此类推。</p>
<p>再来看看丢包的情况：我这个包发送过去对方发了ACK，但是我没收到。或者我这个包根本就没法送出去。总之，从发送方角度来看，就是我没有收到ACK。</p>
<p>而做法就是，我如果等了一段时间，没有收到ACK，我会把10和11号包也都发送掉。</p>
<p><img src="https://s2.ax1x.com/2020/02/27/30dYa6.png" alt="滑动窗口3"></p>
<p>但是此时我的窗口已经发满了，不能再读入12，我就只能等到ACK的接收。</p>
<p>如果我始终得不到，就会激发超时重传。</p>
<p>需要注意，ACK的按照顺序的ACK，对方一定会等到5号包出现才会发送ACK，哪怕先收到了6号，7号的包，在TCP协议下，对方也不会发送ACK</p>
<p>如此一来，我们就能保证滑动窗口发送和接收的顺序。</p>
<p>此时可能发生：</p>
<p><img src="https://s2.ax1x.com/2020/02/27/30dJVx.png" alt="滑动窗口4"></p>
<p>此时是之前6，7和8都已经收到了，并且对方想要发送ACK，但是无奈5号包没有收到。此时在我们这边发送了5号包过去，对方收到了之后，会把5,6,7，8一起发送过来，并且 新把12,13,14,15加入到窗口中。</p>
<p>窗口协议的概念整体就是这样的，书上写得比较复杂，但是从工程学角度还是很好理解的。</p>
<p>我们为了优化TCP四次握手的吞吐量问题，我们把数据包一起发送，此时会有窗口的问题产生，我们为了更加有效运用吞吐量，我们使用滑动窗口这个数据结构来解决。这个其实是很朴素的想法。</p>
<p>油管上搬运来的TCP滑动窗口的实现示意动画： <a href="https://www.bilibili.com/video/av71309262?from=search&seid=14837245094414199121" target="_blank" rel="noopener">点击此处</a></p>
<h2 id="TCP滑动窗口具体变量和计算过程"><a href="#TCP滑动窗口具体变量和计算过程" class="headerlink" title="TCP滑动窗口具体变量和计算过程"></a>TCP滑动窗口具体变量和计算过程</h2><p>首先，滑动窗口有两个计算的变量：RTT和RTO</p>
<ul>
<li>RTT：发送一个数据包到收到对应的ACK所花费的时间。<font color=#FF0000>就是发送数据到接收到ACK的时间差</font></li>
<li>RTO：重传时间间隔。<font color=#FF0000>通过RTT计算得到。设置一个RTO作为间隔时间，超过了RTO就重传，没超过RTO就等待ACK</font></li>
</ul>
<p>相关计算公式和示意图：</p>
<p><img src="https://s2.ax1x.com/2020/02/27/30BxyQ.png" alt="窗口数据的计算和示意图1"></p>
<p><img src="https://s2.ax1x.com/2020/02/27/30BvQg.png" alt="窗口数据的计算和示意图2"></p>
<p><img src="https://s2.ax1x.com/2020/02/27/30BjSS.png" alt="窗口数据的计算和示意图3"></p>
<p><font color=#FF0000>需要注意，TCP的滑动窗口大小可以为0.当然这是一种特殊情况，如果接收方正在忙，可以先让滑动窗口的大小为0，等到后面再重新调整。</font></p>
<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>HTTP全名为<strong>“超文本传输协议”</strong>，支持客户/服务器模式，即Client发送请求给Server，Server发送响应回去。大部分目前都是基于HTTP1.1的。</p>
<h2 id="HTTP的请求结构"><a href="#HTTP的请求结构" class="headerlink" title="HTTP的请求结构"></a>HTTP的请求结构</h2><p>请求报文如下图所示：</p>
<p><img src="https://s2.ax1x.com/2020/02/28/30H6jH.png" alt="HTTP请求报文"></p>
<p>举一个用Wireshark抓HTTP请求报文的例子：</p>
<p><img src="https://s2.ax1x.com/2020/02/28/30Hgud.png" alt="HTTP请求抓包实例"></p>
<h2 id="HTTP的响应结构"><a href="#HTTP的响应结构" class="headerlink" title="HTTP的响应结构"></a>HTTP的响应结构</h2><p>响应报文如下图所示：</p>
<p><img src="https://s2.ax1x.com/2020/02/28/30Hs3D.png" alt="HTTP响应报文"></p>
<p>举一个用Wireshark抓HTTP响应报文的例子：</p>
<p><img src="https://s2.ax1x.com/2020/02/28/30Hyge.png" alt="HTTP请求抓包实例"></p>
<h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><p>一共有五种取值可能：</p>
<ul>
<li>1xx：指示信息——表示请求已经接收，继续处理，<font color=#FF0000>但是整个请求还没成功</font></li>
<li>2xx：成功——表示请求已被成功接收、理解、接受，已经成功处理了请求的状态代码</li>
<li>3xx：重定向——要完成请求，但是需要进一步操作(往往要再跳转一步)</li>
<li>4xx：客户端错误——请求有语法错误或请求无法实现</li>
<li>5xx：服务器错误——服务器未能实现合法的请求，表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求的错误。</li>
</ul>
<p>常见HTTP状态码及其作用：</p>
<p>200 OK：正常返回信息</p>
<p>400 Bad Request：客户端请求有语法错误，不能被服务器所理解</p>
<p>401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用</p>
<p>403 Forbidden：服务器收到请求，但拒绝提供服务(比如IP被禁了)</p>
<p>404 Note Found：请求资源不存在，eg.输入了错误的URL</p>
<p>500 Internal Server Error：服务器发生不可预期的错误</p>
<p>503 Server Unabaliable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常</p>
<h2 id="GET请求和POST请求的区别"><a href="#GET请求和POST请求的区别" class="headerlink" title="GET请求和POST请求的区别"></a>GET请求和POST请求的区别</h2><p>可以从三个层面解释：</p>
<ul>
<li>HTTP报文层面：GET将请求信息放在URL中，POST放在报文体中。</li>
<li>数据库层面：GET符合<strong>幂等性 <em>(对数据库的多次操作效果一样，PUT也是幂等的)</em></strong>和<strong>安全性 <em>(操作不会改变数据库中的数据)</em></strong>，POST不符合。</li>
<li>其他层面：GET可以被缓存、被存储，而POST不行</li>
</ul>
<h2 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h2><h3 id="Cookie简介"><a href="#Cookie简介" class="headerlink" title="Cookie简介"></a>Cookie简介</h3><p>举一个使用Cookie的最简单的例子：登录某个网站后，勾选了同意记录信息只有，客户端发送HTTP响应的同时也会发送客户端的信息，下次再登录就可以通过记忆，不用再输入密码了。</p>
<ul>
<li>Cookie由服务器发送给客户端的特殊信息，以文本的形式存放在客户端</li>
<li>客户端再次请求的时候，会把Cookie回发</li>
<li>服务器接收到后，会解析Cookie生成与客户端相对应的内容</li>
</ul>
<h3 id="Cookie实现方式"><a href="#Cookie实现方式" class="headerlink" title="Cookie实现方式"></a>Cookie实现方式</h3><p>示意图如下：</p>
<p><img src="https://s2.ax1x.com/2020/02/28/3BJhXq.png" alt="Cookie实现示意图"></p>
<h3 id="Session简介"><a href="#Session简介" class="headerlink" title="Session简介"></a>Session简介</h3><ul>
<li>服务器端的机制，在服务器上保存的信息</li>
<li>解析客户端请求并操作session id，按需保存状态信息</li>
</ul>
<h3 id="Session实现方式"><a href="#Session实现方式" class="headerlink" title="Session实现方式"></a>Session实现方式</h3><p>如下图：</p>
<p><img src="https://s2.ax1x.com/2020/02/28/3BJIBV.png" alt="3BJIBV.png"></p>
<p>实际上，Session有两种实现方式：</p>
<ul>
<li>使用Cookie实现</li>
<li>使用URL回写实现</li>
</ul>
<p>TOMCAT一开始同时支持Cookie和URL回写两种方式，之后如果发现浏览器支持Cookie，就停止URL回写。</p>
<h3 id="Cookie和Session的区别"><a href="#Cookie和Session的区别" class="headerlink" title="Cookie和Session的区别"></a>Cookie和Session的区别</h3><ul>
<li>Cookie数据存放在客户端的浏览器上，Session数据放在服务器上</li>
<li>Session相对于Cookie更安全(<font color=#FF0000>Session保存在服务器端，更安全，但是占用服务器的资源</font>)</li>
<li>若考虑减轻服务器负担，应当使用Cookie</li>
</ul>
<h1 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h1><p>简而言之，HTTPS是更加安全版本的HTTP，多了一层SSL或TLS。</p>
<p>HTTP和HTTPS结构图如下所示：</p>
<p><img src="https://s2.ax1x.com/2020/02/28/3BwxRU.png" alt="HTTP和HTTPS结构"></p>
<h2 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h2><p><strong>SSL(Security Sockets Layer,安全套阶层)</strong></p>
<ul>
<li>为网络通信提供安全及数据完整性的一种安全协议</li>
<li>操作系统对外的API，SSL3.0后更名为TLS</li>
<li>采用身份验证和数据加密保证网络通信的安全和数据的完整性</li>
</ul>
<h2 id="加密方式"><a href="#加密方式" class="headerlink" title="加密方式"></a>加密方式</h2><ul>
<li>对称加密：加密和解密都使用同一个秘钥</li>
<li>非对称加密(区块链常用)：加密使用的秘钥和解密使用的秘钥是不相同的</li>
<li>哈希算法(常用MD5)：将任意长度的信息转换为固定长度的值，算法不可逆</li>
<li>数字签名：证明某个消息或者文件是某人发出/认同的</li>
</ul>
<h2 id="HTTPS数据传输流程"><a href="#HTTPS数据传输流程" class="headerlink" title="HTTPS数据传输流程"></a>HTTPS数据传输流程</h2><ul>
<li>浏览器将支持的加密算法信息发送给服务器</li>
<li>服务器选择一套浏览器支持的加密算法，以证书的形式回发给浏览器</li>
<li>浏览器验证证书合法性，并验证证书公钥加密信息发送给服务器</li>
<li>服务器使用私钥解密信息，验证哈希，加密响应消息回发浏览器</li>
<li>浏览器解密响应信息，并对消息进行验真，之后进行加密交互数据</li>
</ul>
<h2 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h2><ul>
<li>HTTPS需要到CA申请证书，HTTP不需要</li>
<li>HTTPS密文传输，HTTP明文传输</li>
<li>连接方式不同，HTTPS默认使用443端口，HTTP默认使用80端口</li>
<li>HTTPS=HTTP+加密+认证+完整性保护，比HTTP更安全</li>
</ul>
<h2 id="HTTPS真的很安全么"><a href="#HTTPS真的很安全么" class="headerlink" title="HTTPS真的很安全么"></a>HTTPS真的很安全么</h2><p>也不能肯定，很多浏览器默认会填充http://，网页需要从HTTP跳转到HTTPS，这个过程有被劫持的风险</p>
<p>可以使用HSTS(HTTP Strict Transport Security)进行优化</p>
<h1 id="常见题：在浏览器输入URL，按下回车之后经历的流程"><a href="#常见题：在浏览器输入URL，按下回车之后经历的流程" class="headerlink" title="常见题：在浏览器输入URL，按下回车之后经历的流程"></a>常见题：在浏览器输入URL，按下回车之后经历的流程</h1><p>答案：<font color=#FF0000>一共有六步</font></p>
<ol>
<li>DNS解析。——<font color=#FF0000>浏览器进行DNS解析</font></li>
<li>TCP连接。——<font color=#FF0000>浏览器向服务器发送TCP连接，过程参考TCP三次握手</font></li>
<li>发送HTTP请求——<font color=#FF0000>浏览器向服务器发送HTTP请求，内容参考前面HTTP请求包结构</font></li>
<li>服务器处理请求并返回HTTP报文——<font color=#FF0000>服务器返回HTTP报文，结构参考前面HTTP响应包结构</font></li>
<li>浏览器解析渲染页面</li>
<li>连接结束——<font color=#FF0000>参考TCP四次挥手</font></li>
</ol>
<p><strong>需要注意，这里的第五步和第六步几乎是同时进行的。</strong></p>
<p>DNS缓存由近到远分别是：浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存根，域名服务器缓存，顶级域名服务器缓存，过程中从哪个缓存中找到了对应的服务器IP，就直接返回，不再继续查询后面的缓存。</p>
]]></content>
      <categories>
        <category>Interview Note</category>
      </categories>
      <tags>
        <tag>Interview</tag>
        <tag>Networks</tag>
      </tags>
  </entry>
  <entry>
    <title>Java JVM Study I</title>
    <url>/2020/02/25/Java-JVM-Study-I/</url>
    <content><![CDATA[<blockquote>
<p>知识犹如人体的血液一样宝贵。——高士其</p>
</blockquote>
<a id="more"></a>

<p>每种语言都有其独特的优势和特点。对于Java来说，其独特之处主要可以从六个方面来说：</p>
<ul>
<li>平台无关性</li>
<li>面向对象</li>
<li>GC(垃圾回收)</li>
<li>类库</li>
<li>语言特性和异常处理</li>
</ul>
<p>而Java的JVM最值得学习的点，是：<font color=#FF0000>JVM内存结构模型和GC</font></p>
<h1 id="Java的平台无关性如何实现"><a href="#Java的平台无关性如何实现" class="headerlink" title="Java的平台无关性如何实现"></a>Java的平台无关性如何实现</h1><p>平台无关性，实际上就是java代码”编译一次，到处执行”这个特点的简称。</p>
<p><img src="https://s2.ax1x.com/2020/02/28/3DqNYq.png" alt="3DqNYq.png"></p>
<p>可以说，生成”.class”文件，是java跨平台的基础。</p>
<p><strong>为什么JVM不把java解析成机器码然后执行呢？</strong></p>
<p>主要是两个原因，一个是如果解析成机器码，需要大量准备工作，每次执行都需要根据机器的内部构造去设定值。另一个原因是，解析成class文件，可以让JVM虚拟机发挥更大的作用，比如Scala语言也可以通过解析成class文件来通过JVM虚拟机运行。</p>
<h1 id="JVM如何加载class文件"><a href="#JVM如何加载class文件" class="headerlink" title="JVM如何加载class文件"></a>JVM如何加载class文件</h1><p>Java是跨平台的，这意味着 Java 开发出来的程序经过编译后，可以在 Linux 上运行，也可以在 Windows 上运行；可以在 PC、服务器上运行，也可以在手机上运行；可以在 X86 的 CPU 上运行，也可以在 ARM 的 CPU 上运行。</p>
<p>不同操作系统，特别是不同 CPU 架构，是不可能执行相同的指令的。Java之所以拥有能够在不同平台运行的神奇特性，就是因为 Java 编译的字节码文件不是直接在底层的系统平台上运行的，而是在 Java 虚拟机 JVM 上运行，JVM 屏蔽了底层系统的不同，为 Java 字节码文件构造了一个统一的运行环境。JVM 本质上也是一个应用程序，启动以后加载执行 Java 字节码文件。</p>
<p>JVM的是内存中的虚拟机。</p>
<p>JVM的详细的内存结构模型如图：</p>
<p><img src="https://s2.ax1x.com/2020/03/04/3503A1.jpg" alt="JVM详细内存结构模型"></p>
<p>只要符合class Loader的格式要求就能加载。</p>
<p>因为java执行效率不如C和C++，有时候需要用Native Interface去调用别的语言的库。</p>
<p><code>Class.forName()</code>作用：返回与给定字符串名称相关联的类或者接口对应的class对象。</p>
<h2 id="类从编译到执行的过程"><a href="#类从编译到执行的过程" class="headerlink" title="类从编译到执行的过程"></a>类从编译到执行的过程</h2><ul>
<li>编译器将**.java源文件编译为.class字节码文件</li>
<li>ClassLoader将字节码转化为JVM的Class对象</li>
<li>JVM利用Class对象实例化Robot对象</li>
</ul>
<p>对上图进行简化之后可以得到：</p>
<p><img src="https://s2.ax1x.com/2020/03/04/3508tx.png" alt="JVM简化内存结构模型"></p>
<h1 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h1><p>理论上来说：</p>
<p><strong>Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为Java语言的反射机制。</strong></p>
<p>但是这里回答比较理论，最好可以列举几个常用的反射函数，或者写反射的例子。</p>
<p>重要的部分：Class、Class.forName、newInstance()、Method、getDeclareMethod、setAccessible()、invoke()</p>
<p>NOTE:</p>
<ul>
<li>“getDeclardeMethod”可以获取public, private, protected的方法，但是不能获取继承的方法和实现接口的方法</li>
<li>“getMethod”可以获取public方法，此外还可以获取继承的方法和实现接口的方法</li>
<li>反射就是把java中的各种成分映射成java对象，比如这里映射成了class,filed,method</li>
</ul>
<h1 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h1><h2 id="类从编译到执行的过程-1"><a href="#类从编译到执行的过程-1" class="headerlink" title="类从编译到执行的过程"></a>类从编译到执行的过程</h2><p>以Robot.java这个源文件的执行流程举例：</p>
<ul>
<li>编译器将Robot.java源文件编译为Robot.class字节码文件</li>
<li>ClassLoader将字节码转换为JVM中的Class<Robot>对象</li>
<li>JVM利用Class<Robot>对象实例化为Robot对象</li>
</ul>
<h2 id="谈谈ClassLoader"><a href="#谈谈ClassLoader" class="headerlink" title="谈谈ClassLoader"></a>谈谈ClassLoader</h2><p>ClassLoader在Java中有着非常重要的作用，他主要工作在Class装载的加载阶段，它的主要作用是从系统外部获得Class二进制数据流。它是Java的核心组件，<strong>所有Class都将由ClassLoader进行加载，ClassLoader负责通过将Class文件里的二进制数据流装载进系统，然后交给Java虚拟机进行连接、初始化等操作。</strong></p>
<p>ClassLoader是一个抽象类(abstract class)。</p>
<ul>
<li>BootStrapClassLoader：C++编写，加载核心库java.*</li>
<li>ExtClassLoader：Java编写，加载扩展库javax.*</li>
<li>AppClassLoader：Java编写，加载程序所在目录，类路径</li>
<li>自定义ClassLoader：Java编写，定制化加载</li>
</ul>
<p>回答流程：ClassLoader的作用 -&gt; 本质 -&gt; 种类</p>
<h1 id="类加载器-ClassLoader-的双亲委派机制"><a href="#类加载器-ClassLoader-的双亲委派机制" class="headerlink" title="类加载器(ClassLoader)的双亲委派机制"></a>类加载器(ClassLoader)的双亲委派机制</h1><p>首先需要明确，不同的ClassLoader加载类的方式和路径有所不同，为了提高效率，各自有各自的分工，各自有各自负责的区块，使得逻辑更加明确，我们才能够有各种能够相互共存的ClassLoader。</p>
<p>实际上不同的ClassLoader在执行任务的时候都是各司其职，所谓我们需要一个机制，让各种类加载器之间能够相互协作，形成一个整体，这个机制就是双亲委派机制。</p>
<p>整体原理如图：</p>
<p><img src="https://s2.ax1x.com/2020/03/04/3ISDZ8.png" alt="3ISDZ8.png"></p>
<ol>
<li>自底向上检查类是否已经加载</li>
<li>自顶向下尝试加载类</li>
</ol>
<h2 id="为什么要用双亲委派机制去加载类？"><a href="#为什么要用双亲委派机制去加载类？" class="headerlink" title="为什么要用双亲委派机制去加载类？"></a>为什么要用双亲委派机制去加载类？</h2><p>双亲委派机制能避免多份同样字节码的加载。</p>
<p>比如常用的System.out.println()，我们其实只需要一个System的静态class，而且只需要一份，然后反复用即可。如果不用委托的方式，类A用的时候要加载一次，类B再用的时候又要再加载一份System字节码。这样内存中就会存在多份System字节码。相反如果用了委托机制，每次使用的时候都会由下往上逐层查找，看哪一个ClassLoader装载过这个类。对于System类来说，因为它是属于Bootstrap ClassLoader管辖范围内的，假设A是第一次调用，那么这时候会用Bootstrap ClassLoader将System类装载进去。在B调用的时候，也会逐层查找。查找过程会发现之前已经被Bootstrap加载过了，就会直接拿过来用即可了。</p>
<h1 id="loadClass和forName的区别"><a href="#loadClass和forName的区别" class="headerlink" title="loadClass和forName的区别"></a>loadClass和forName的区别</h1><h2 id="类的加载方式"><a href="#类的加载方式" class="headerlink" title="类的加载方式"></a>类的加载方式</h2><ul>
<li>隐式加载：new，这种方法比较常用。程序运行过程中通过new定义对象的时候，隐式调用类加载器，加载对应的类到JVM中。使用了new之后不再需要调用class对象的newInstance()方法再去获得对象的实例了。</li>
<li>显示加载：loadClass、forName等。对于显示加载来说，在我们获取到了class对象之后，需要调用class对象的newInstance()方法来生成对象的实例。</li>
</ul>
<p>此外，new支持调用带参数的构造器来生成对象实例。而class对象的newInstance()方法则不支持传入参数，需要反射，调用构造器的newInstance()方法才能支持参数。</p>
<h2 id="类的装载过程"><a href="#类的装载过程" class="headerlink" title="类的装载过程"></a>类的装载过程</h2><p>之前我们说的类的装载和加载都是一个意思(都是表示加载)。但是这里为了区分，我们用<strong>装载</strong>表示class对象的生成过程，<strong>加载只是其中的一个部分</strong>。</p>
<p>Java类装载有三个部分：</p>
<p><img src="https://s2.ax1x.com/2020/03/04/3ImatI.png" alt="Java类装载过程"></p>
<h2 id="loadClass和forName的区别-1"><a href="#loadClass和forName的区别-1" class="headerlink" title="loadClass和forName的区别"></a>loadClass和forName的区别</h2><p>这两个方法俩都是显示加载。</p>
<p>首先，他们俩都能在运行的时候知道某个类的所有属性和方法。</p>
<p>但是他俩存在区别：</p>
<ul>
<li>Class.forName得到的class是已经初始化完成的</li>
<li>Classloader.loadClass得到的class是还没有链接的，还没有初始化的。</li>
</ul>
<p>loadClass和forName的区别在实际中的作用：比如我们要在程序中连接MySQL，这个时候需要加载driver。此时我们就不能用loadClass而必须用forName。</p>
<p>为什么呢？因为MySQL的jar包里面的代码，Driver初始化是写在static代码块里的，所以必须调用forName才能执行它，进而实例化Driver对象，创建数据库驱动。</p>
<p>那么什么时候要用到loadClass呢？——Spring IOC中，在资源加载器获取要读入的资源的时候，其读取一些bean的配置文件的时候，如果以classpath的方式加载，就需要使用classLoader.loadClass来加载了。因为Spring IOC大量使用了延时加载，也就是懒加载。为了加快加载速度，Spring IOC大量使用了延时加载技术，而使用classLoader不需要执行类的初始化代码和链接步骤，这样可以加快类的初始化速度，把类的初始化工作留到实际使用这个类的时候再去做。</p>
<h1 id="Java内存模型-Java-Memory-Model"><a href="#Java内存模型-Java-Memory-Model" class="headerlink" title="Java内存模型(Java Memory Model)"></a>Java内存模型(Java Memory Model)</h1><p>Java内存模型具体指的实际就是上面的”Runtime Data Area”,或者叫”运行期数据区”</p>
<h2 id="内存简介"><a href="#内存简介" class="headerlink" title="内存简介"></a>内存简介</h2><p>计算机所有程序都是在内存中运行的，只是这个”内存”包括虚拟内存，也包括”硬盘”这样的外存支持。</p>
<p>在程序运行的过程中，需要不断将内存的逻辑地址和物理地址进行映射，找到相关的指令和数据去执行。</p>
<p><img src="https://s2.ax1x.com/2020/03/04/3IR6AO.png" alt="内存简介"></p>
<h2 id="地址空间的划分"><a href="#地址空间的划分" class="headerlink" title="地址空间的划分"></a>地址空间的划分</h2><p>内核是主要的操作系统程序与C运行时的空间，包含用于连接计算机硬件，调度程序与提供联网和虚拟内存服务的逻辑和基于C的进程。</p>
<p>用户空间才是Java进程实际运行时使用的内存空间。</p>
<p>如图：</p>
<p><img src="https://s2.ax1x.com/2020/03/04/3IRg4e.png" alt="3IRg4e.png"></p>
<p>32位系统进程最多可以访问3GB，内核代码可以访问所有物理内存。64位系统进程最多可以访问512GB，内核代码同样可以访问所有物理内存。</p>
<h2 id="线程独占部分"><a href="#线程独占部分" class="headerlink" title="线程独占部分"></a>线程独占部分</h2><p>哪些是线程独占的，哪些部分又是线程共享的呢？</p>
<p>以JDK8为例进行分析(JDK其他版本也有类似之处)。</p>
<p><img src="https://s2.ax1x.com/2020/03/04/3I5ko6.png" alt="JDK8内存模型"></p>
<p>下面对每一块线程独占的部分都进行介绍：</p>
<h3 id="程序计数器-Program-Counter-Register-即PC"><a href="#程序计数器-Program-Counter-Register-即PC" class="headerlink" title="程序计数器(Program Counter Register,即PC)"></a>程序计数器(Program Counter Register,即PC)</h3><ol>
<li><p>它是一块较小的内存空间，它可以看做是<strong>当前线程所执行的字节码行号指示器(逻辑)</strong>。</p>
</li>
<li><p>在虚拟机的概念模型里，字节码解释器工作时，通过改变计数器的值来选取下一条需要执行的字节码指令。包括分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成。</p>
</li>
<li><p>由于JVM的多线程是通过线程之间的来回切换，并且分配处理器执行时间的方式来实现的，所以在任何一个确定的时刻，一个处理器只会执行一条线程中的指令。因此，为了确保线程在切换后能回到正确的位置，每条线程都需要有一个独立的程序计数器，并且各条线程之间的计数器互不影响，独立存储。我们称这样的内存为”线程私有”的内存，这个计数器的值也和线程之间是一对一的关系。</p>
</li>
<li><p>如果一个线程正在执行Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址，那么如果正在执行的是Native方法，则计数器值会为<code>&quot;Undefined&quot;</code></p>
</li>
<li><p>此外，由于只是记录行号，程序计数器不会存暴掉，即程序计数器不会存在内存泄漏的问题。</p>
</li>
</ol>
<p>小总结：<strong>程序计数器是逻辑计数器，而不是物理计数器。为了线程切换后都能回到正确的执行位置，每个线程都有一个独立的程序计数器，它是线程独立的，并且只为Java方法计数。Native方法对应的程序计数器则是Undefined。使用程序计数器，不用担心会发生内存泄漏的问题。</strong></p>
<ul>
<li>当前线程所执行的字节码行号指示器</li>
<li>改变计数器的值来选取下一条需要执行的字节码指令</li>
<li>和线程一一对应</li>
<li>只对Java方法计数，如果是Native方法则计数器值为Undefined</li>
<li>不会发生内存泄漏</li>
</ul>
<h3 id="Java虚拟机栈-Stack"><a href="#Java虚拟机栈-Stack" class="headerlink" title="Java虚拟机栈(Stack)"></a>Java虚拟机栈(Stack)</h3><p>Java虚拟机栈也是线程私有的，是Java方法执行的内存模型。每个方法被执行的时候都会创建一个栈帧，结构如下图：</p>
<p><img src="https://s2.ax1x.com/2020/03/04/3IqmNR.png" alt="3IqmNR.png"></p>
<p>图中的局部变量表和操作数栈有什么区别？</p>
<ul>
<li>局部变量表：包含方法执行过程中的所有变量，包含this引用、所有方法参数，其他局部变量(包括布尔值、Byte、char、long、short、int、float、double等等类型)</li>
<li>操作数栈：在执行字节码指令过程中被用到，这种方式类似原生CPU寄存器。大部分JVM字节码把时间花费在操作数栈的操作上，包括入栈、出栈、复制、交换、产生消费变量</li>
</ul>
<p>栈本身是一个后进先出的数据结构。因此当前执行的方法在栈的顶部，每次方法调用时一个新的栈帧创建，并压入栈顶。当方法正常返回或抛出未捕获的异常时，栈帧就会出栈。除了栈帧的压栈和出栈，栈不能被直接操作。</p>
<p>解读Java可能出现的异常</p>
<p><strong>java.lang.StackOverflowError</strong></p>
<p>递归为什么会引发java.lang.StackOverflowError异常？</p>
<p>递归执行次数过多，栈帧过高。每次调用递归，都会创建一个对应的栈帧，并把建立的栈帧压入虚拟机栈中。</p>
<ol>
<li>如果递归层数过高，不断调用自身，每新调用一次方法，就会生成一个栈帧。</li>
<li>它会保存当前方法的栈帧状态</li>
<li>栈帧上下文切换的时候会切换到最新的方法栈帧当中</li>
</ol>
<p>如果递归调用过多，则会产生过多的栈帧，栈帧超过虚拟栈深度限制，就会报错。</p>
<p>解决的方法主要是限制递归的次数，或者可以直接用循环替换递归。</p>
<p><strong>java.lang.OutOfMemoryError</strong></p>
<p>虚拟机栈过多会引发java.lang.OutOfMemoryError异常。当虚拟机栈可以动态扩展时，如果无法申请足够多的内存，就会抛出这个异常。</p>
<p>如果虚拟机栈可以动态扩展，并超出内存，就会报这个错误。</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><ul>
<li>与虚拟机栈类似，主要作用于标注了native的方法</li>
</ul>
<p>带有native关键字的方法，比如之前的forName0()之类的方法，用的是本地方法栈。</p>
<h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>虚拟机栈是Java虚拟机自动管理的。栈类似一个集合，但是有容量限制，由多个栈帧组合而成。编写代码的时候，每调用一个方法，Java虚拟机就为其分配一块空间，就增加一层栈帧。<font color=#FF0000>而当方法调用结束后，对应的栈帧就会被自动释放掉。这就是为什么栈不需要GC，但是堆需要</font>。</p>
<h2 id="线程共享部分"><a href="#线程共享部分" class="headerlink" title="线程共享部分"></a>线程共享部分</h2><p>从之前”JDK8内存模型”这张图中可以看到，JVM里线程共享的主要是两个部分：MataSpace和Java堆</p>
<h3 id="元空间-MetaSpace-与永久代-PermGen-的区别"><a href="#元空间-MetaSpace-与永久代-PermGen-的区别" class="headerlink" title="元空间(MetaSpace)与永久代(PermGen)的区别"></a>元空间(MetaSpace)与永久代(PermGen)的区别</h3><p>JDK8之后，MetaSpace开始把类的元数据放在本地堆内存中，这段区域在JDK7以及以前，都是属于永久代的。</p>
<p>元空间和永久代都用来存储class的相关信息，包括class对象的方法和filed等。</p>
<p>元空间永久代都是方法区的实现，实现方法不同。方法区只是一种JVM的规范。</p>
<p>Java7之后，把原先位于方法区的字符串常量池移动到了Java堆中，并且在JDK8之后，使用源空间替代了永久代。</p>
<p>这一替代不仅是名字上的替代，两者最大的区别是：<strong>元空间使用本地内存，而永久代使用的是JVM的内存</strong>。这样设置的一个好处就是解决了内存不足的问题，<code>java.lang.OutOfMemoryError:PemGen space</code>这个错误将不复存在。因为此时MetaSpace的大小取决于本地内存的大小。本地内存有多大，MetaSpace就有多大。当然，实际运行的时候不可能放任MetaSpace的壮大，JVM在运行的时候会根据需要动态地设置其大小。</p>
<p><strong>MetaSpace相比PermGen的优势</strong></p>
<ul>
<li>字符串常量池存在永久代中，容易出现性能问题和内存溢出</li>
<li>永久代类和方法的信息大小难以确定，给永久代的大小指定带来困难</li>
<li>永久代会为GC带来不必要的复杂性，而且回收效率可能较低</li>
<li>用元空间方便HotSpot与其他JVM如Jrockit的集成</li>
</ul>
<p><font color=#FF0000>重点记住：元空间和永久代的主要区别，是前者内存空间主要使用的是本机内存。</font>MetaSpace没有了字符串常量池，它在JDK7中已经被移动到了堆中。MetaSpace其他存储的东西，包括类文件，在JVM运行时候的数据结构，以及class相关的内容，如method,filed，大体上都与永久代一样，只是划分上更加合理。比如类元素的生命周期与类加载器一致，每个类加载器(classLoader)都会分配一个单独的存储空间。</p>
<h3 id="Java堆-Heap"><a href="#Java堆-Heap" class="headerlink" title="Java堆(Heap)"></a>Java堆(Heap)</h3><p>对于大多数应用来说，Java堆是Java虚拟机所管理的内存中最大的一块。Java堆是被所有内存共享的一块内存区域。在虚拟机启动时创建此内存区域的唯一目的，就是存放对象实例，几乎所有的对象实例都在这里分配内存。</p>
<p>以一个32位处理器的Java内存布局为例：</p>
<p><img src="https://s2.ax1x.com/2020/03/05/3TNVFx.png" alt="32位处理器的Java内存布局"></p>
<p>可以看到，Java堆会占用非常大的一块内存。</p>
<p>此外，Java堆是垃圾收集器管理的主要区域，因此很多时候也被称为GC堆。</p>
<p>如果从内存回收的角度看，由于现在的收集器基本都采用分代收集的算法，所以Java堆中还可以细分为新生代和老年代。</p>
<p>可以参见下图：</p>
<p><img src="https://s2.ax1x.com/2020/03/05/3TNefK.png" alt="GC堆"></p>
<h1 id="Java内存模型常考题解析"><a href="#Java内存模型常考题解析" class="headerlink" title="Java内存模型常考题解析"></a>Java内存模型常考题解析</h1><h2 id="JVM三大性能条有参数：-Xms-Xmx-Xss的含义"><a href="#JVM三大性能条有参数：-Xms-Xmx-Xss的含义" class="headerlink" title="JVM三大性能条有参数：-Xms -Xmx -Xss的含义"></a>JVM三大性能条有参数：-Xms -Xmx -Xss的含义</h2><p>在调用java指令执行程序的时候，我们可以使用这三个参数去调整Java堆和线程所占内存的大小。它们的作用分别是：</p>
<ul>
<li>-Xss：规定了每个线程虚拟机栈(堆栈)的大小</li>
<li>-Xms：堆的初始值</li>
<li>-Xmx：堆能达到的最大值</li>
</ul>
<p>-Xss一般来说256K就够了，此配置会影响此进程中并发线程数的大小。</p>
<p>-Xms为初始的Java堆的大小，即该进程刚创建出来的时候它的专属Java堆的大小。一旦对象容量超过了Java堆的初始容量，Java堆会自动扩容，扩容至-Xmx的大小。</p>
<p>在很多情况下，我们通常将-Xms和-Xmx设置成一样大，因为当Heap不够用而发生扩容时，会发生内存抖动，影响程序运行时的稳定性。</p>
<p>当程序运行比较慢，或者频繁报出内存方面的错误的时候，可以试着从这三个参数入手，尝试调整堆和线程的大小，以求程序性能可以达到要求，但是在程序性能还能满足要求的时候没必要调整。</p>
<h2 id="Java内存模型中堆和栈的区别——内存分配策略"><a href="#Java内存模型中堆和栈的区别——内存分配策略" class="headerlink" title="Java内存模型中堆和栈的区别——内存分配策略"></a>Java内存模型中堆和栈的区别——内存分配策略</h2><ul>
<li>静态存储：编译时确定每个数组目标在运行时的存储空间需求。这种方式不允许程序中有可变数据结构的存在，也不允许有递归和嵌套的结构出现，因为它们都会导致编译程序无法计算准确的存储空间。</li>
<li>栈式存储：数据区需求在编译时未知，运行时模块入口前确定。这种方式也可以被称为动态的存储方式。分配过程和栈一样，先进后出的方式。</li>
<li>堆式存储：编译时或运行时模块入口都无法确定，动态分配。比如可变长度串和对象实例。</li>
</ul>
<h2 id="Java内存模型中堆和栈的区别"><a href="#Java内存模型中堆和栈的区别" class="headerlink" title="Java内存模型中堆和栈的区别"></a>Java内存模型中堆和栈的区别</h2><ul>
<li>两者联系：引用对象、数组时，栈里定义变量保存堆中目标的首地址。</li>
</ul>
<p>创建好的数组和对象都会保存在堆中，想要引用堆中的某个对象或者数组，可以在栈中定义一个特殊的变量，让栈中的这个变量保存目标对象或者数组在堆中的首地址，由此一来，栈中的这个变量就是数组或者对象的引用变量，以后就可以在程序中使用栈的这个引用变量来访问堆中的数组或者对象。引用变量相当于是为数组或者对象起的一个名称。</p>
<p>引用变量也是一个普通变量，在程序运行到其作用域之外后就会被释放掉。而数组和对象本身在堆中分配，即使程序运行到了其范围之外，它们本身也不会被释放掉。它们在没有引用变量指向的时候，才会变成垃圾，在后面被GC掉。</p>
<p>如图：</p>
<p><img src="https://s2.ax1x.com/2020/03/05/3TyMCj.png" alt="堆和栈的区别"></p>
<p>具体区别：</p>
<ul>
<li>管理方式：栈可以自动释放，堆需要GC</li>
<li>空间大小：栈比堆小。栈存储地址，堆在Java程序中占的空间总是比较大，因为要存储对象实例和数组。</li>
<li>碎片相关：栈产生的碎片远小于堆。堆虽然有GC，但是不是实时的，随着使用就会积攒起来碎片。而栈的操作基本都是一一对应的，而且每一个最小单位和堆空间里面复杂的结构不同。所以栈在使用过程中很少出现内存碎片。</li>
<li>分配方式：栈空间支持静态和动态分配两种方式，而堆仅支持动态分配。而且栈空间分配的内存完全不需要考虑释放的问题，而堆空间虽然有GC，但是我们还是要考虑其垃圾释放的问题。</li>
<li>效率：栈的效率比堆高</li>
</ul>
<p>栈空间只有两个操作：入栈和出栈。</p>
<p>栈空间相比堆空间，弱点是灵活度不高，尤其是在动态网页的时候。而堆空间优点在于动态分配，实现方式可能是动态链表的结构，所以其管理的时候操作方式也比栈空间复杂很多。但是也使得堆空间的效率不如栈空间，而且要低很多。</p>
<h2 id="元空间-Meta-Space-、堆、线程独占部分间的联系——内存角度"><a href="#元空间-Meta-Space-、堆、线程独占部分间的联系——内存角度" class="headerlink" title="元空间(Meta Space)、堆、线程独占部分间的联系——内存角度"></a>元空间(Meta Space)、堆、线程独占部分间的联系——内存角度</h2><p>以一段程序为例：</p>
<p><img src="https://s2.ax1x.com/2020/03/05/3TRPXR.png" alt="样例程序"></p>
<p>hw就是存在于虚拟机栈上面的一个变量，它指向我们真正创建好的HelloWorld实例。我们通过对hw的引用就可以定位到堆中的HelloWorld实例的地址，调用它的setName方法将”test”赋值到name这个成员变量里面。</p>
<p>样例程序执行过程：</p>
<p><img src="https://s2.ax1x.com/2020/03/05/3TRpp4.png" alt="样例程序执行过程"></p>
<p>面试官可能会抓住不同版本的JDK的差异来做文章，其中比较有代表性的就是String的intern()方法。它的差异主要体现在JDK6和JDK6之后。</p>
<p>解释一下JDK6和JDK6之后版本的intern()方法的区别？</p>
<p><img src="https://s2.ax1x.com/2020/03/05/3TR91J.png" alt="JDK版本问题"></p>
<p>总的来说，JDK6和JDK6+版本的区别在于JDK6中通过intern()方法仅会在字符串常量池里添加字符串对象，而JDK6+不仅可以向池中添加字符串对象，还能添加字符串对象在堆中的引用。</p>
<p>可以举个例子，用JDK6，调用intern()方法，当字符串常量池被挤爆了之后，会报<code>java.lang.OutOfMemoryError:PemGen space</code>这个错。</p>
]]></content>
      <categories>
        <category>Study Note</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java JVM+GC Interview I</title>
    <url>/2020/02/25/Java-JVM-Interview-I/</url>
    <content><![CDATA[<blockquote>
<p>知识犹如人体的血液一样宝贵。——高士其</p>
</blockquote>
<a id="more"></a>

<p>JVM面试相关知识汇总：</p>
<p><img src="https://s2.ax1x.com/2020/03/04/35Lr90.png" alt="35Lr90.png"></p>
<p>上图中，内存模型、类加载机制、GC垃圾回收是比较重点的内容。</p>
<h1 id="1-简单描述JVM的内存模型"><a href="#1-简单描述JVM的内存模型" class="headerlink" title="1. 简单描述JVM的内存模型"></a>1. 简单描述JVM的内存模型</h1><p>回答这个问题，要答出两个要点：一个是各部分的功能，另一个是哪些线程共享，哪些线程独占。</p>
<p><img src="https://i.loli.net/2020/03/16/CcQiorLdHl4w9EK.png" alt="Java内存模型.png"></p>
<ul>
<li>栈，也叫方法栈，是线程私有的，线程在执行每个方法时都会同时创建一个栈帧，用来存储局部变量表、操作栈、动态链接、方法出口等信息。调用方法时执行入栈，方法返回时执行出栈。</li>
<li>本地方法栈与栈类似，也是用来保存线程执行方法时的信息，不同的是，执行 Java 方法使用栈，而执行 native 方法使用本地方法栈。</li>
<li>程序计数器保存着当前线程所执行的字节码位置，每个线程工作时都有一个独立的计数器。程序计数器为执行 Java 方法服务，执行 native 方法时，程序计数器为空。</li>
</ul>
<p>以上三个部分：栈、本地方法栈、程序计数器，都是线程独占的。</p>
<ul>
<li>堆是JVM管理的内存中最大的一块，堆被所有线程共享，目的是为了存放对象实例，几乎所有的对象实例都在这里分配。当堆内存没有可用的空间时，会抛出OOM异常。根据对象存活的周期不同，JVM把堆内存进行分代管理，由垃圾回收器来进行对象的回收管理。</li>
<li>方法区也是各个线程共享的内存区域，又叫非堆区。用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，JDK1.7中的永久代和JDK1.8中的Metaspace都是方法区的一种实现。</li>
</ul>
<h1 id="2-Java类加载器有几种，关系是怎样的？"><a href="#2-Java类加载器有几种，关系是怎样的？" class="headerlink" title="2.Java类加载器有几种，关系是怎样的？"></a>2.Java类加载器有几种，关系是怎样的？</h1><h1 id="3-双亲委派机制的加载流程是怎样的，有什么好处？"><a href="#3-双亲委派机制的加载流程是怎样的，有什么好处？" class="headerlink" title="3.双亲委派机制的加载流程是怎样的，有什么好处？"></a>3.双亲委派机制的加载流程是怎样的，有什么好处？</h1><h1 id="4-简单描述一下GC的分代回收"><a href="#4-简单描述一下GC的分代回收" class="headerlink" title="4.简单描述一下GC的分代回收"></a>4.简单描述一下GC的分代回收</h1><h1 id="5-G1垃圾回收算法与CMS的区别有哪些？"><a href="#5-G1垃圾回收算法与CMS的区别有哪些？" class="headerlink" title="5.G1垃圾回收算法与CMS的区别有哪些？"></a>5.G1垃圾回收算法与CMS的区别有哪些？</h1><h1 id="6-对象引用有哪几种方式，有什么特点？"><a href="#6-对象引用有哪几种方式，有什么特点？" class="headerlink" title="6.对象引用有哪几种方式，有什么特点？"></a>6.对象引用有哪几种方式，有什么特点？</h1><h1 id="7-使用过哪些JVM调试工具，主要分析哪些内容？"><a href="#7-使用过哪些JVM调试工具，主要分析哪些内容？" class="headerlink" title="7.使用过哪些JVM调试工具，主要分析哪些内容？"></a>7.使用过哪些JVM调试工具，主要分析哪些内容？</h1>]]></content>
      <categories>
        <category>Interview Note</category>
      </categories>
      <tags>
        <tag>Interview</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Concurrent-Programming-Study-I</title>
    <url>/2020/02/25/Java-Concurrent-Programming-Study-I/</url>
    <content><![CDATA[<blockquote>
<p>盼望一件事会发生的人祈祷；相信一件事将发生的人专注；让一件事能发生的人行动</p>
</blockquote>
<a id="more"></a>

<h1 id="Java进程和线程的关系"><a href="#Java进程和线程的关系" class="headerlink" title="Java进程和线程的关系"></a>Java进程和线程的关系</h1><ul>
<li>Java对操作系统提供的功能进行封装，包括进程和线程</li>
<li>运行一个Java程序会产生一个进程，一个进程包含至少一个线程</li>
<li>每一个Java进程对应一个JVM实例，而每一个JVM实例会唯一对应一个堆。每个线程都有自己私有的栈</li>
<li>Java采用单线程编程模型，如果程序不声明创建线程，程序会自动创建主线程——进程就好像投资者，线程才是真正干活的人。</li>
<li>当Java程序启动时，主线程立刻运行。主线程可以创建子线程，原则上要后于子线程完成执行。</li>
</ul>
<p>因为主要干活的都是线程，所以后面分析都以线程为主，进程为辅。</p>
<h1 id="Thread中的start和run方法的区别"><a href="#Thread中的start和run方法的区别" class="headerlink" title="Thread中的start和run方法的区别"></a>Thread中的start和run方法的区别</h1><p>用run()方法会沿用主线程执行方法，用start()会新创建一个子线程。</p>
<p>如下图所示：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3qXBa6.png" alt="3qXBa6.png"></p>
<p>总结来是：</p>
<ul>
<li>调用start()方法会创建一个新的子线程并启动</li>
<li>run()方法只是Thread的一个普通方法的调用</li>
</ul>
<p>如果结合源码，会发现调用start的时候，会调用到thread_entry这个方法，会新创建内容。如下图所示：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3qXjZq.png" alt="3qXjZq.png"></p>
<h1 id="Thread和Runnable的关系"><a href="#Thread和Runnable的关系" class="headerlink" title="Thread和Runnable的关系"></a>Thread和Runnable的关系</h1><ul>
<li>Thread是一个类，而Runnable是一个接口。具体来说，Thread是实现了Runnable接口的类，使得run支持多线程。</li>
<li>由于Java类的单一继承原则，推荐多使用Runnable接口</li>
</ul>
<p>Thread是一个类：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3qjBOs.png" alt="3qjBOs.png"></p>
<p>Runnable是一个接口：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3qjwlQ.png" alt="3qjwlQ.png"></p>
<p>实际上Runnable里面并没有多线程的特性，而是依赖实现它的Thread去调用start()方法来创建新线程的，然后再在这个子线程里面调用Thread实现好的run方法来执行相应的业务逻辑。</p>
<h1 id="如何实现处理线程的返回值"><a href="#如何实现处理线程的返回值" class="headerlink" title="如何实现处理线程的返回值"></a>如何实现处理线程的返回值</h1><h2 id="如何给run-传参"><a href="#如何给run-传参" class="headerlink" title="如何给run()传参"></a>如何给run()传参</h2><p>一般来说和线程相关的业务逻辑需要放在run()里面去执行。但是既然run()没有参数，那么如何给run()传参数呢？</p>
<p>主要有三种方法：</p>
<ul>
<li>构造函数传参</li>
<li>成员变量传参——用setName之类的方法给成员变量赋值</li>
<li>回调函数传参</li>
</ul>
<h2 id="实现处理线程的返回值是痛点"><a href="#实现处理线程的返回值是痛点" class="headerlink" title="实现处理线程的返回值是痛点"></a>实现处理线程的返回值是痛点</h2><p>这里考查的是有没有活用线程相关的知识。</p>
<p>实现方式也是有三种：</p>
<ol>
<li><strong>主线程等待法——让主线程循环等待，直到目标子线程返回值为止。缺点是需要自己手动实现等待的逻辑。</strong></li>
</ol>
<p>代码实例：</p>
<p>一开始按照原先的多线程的案例去尝试打印，发现只让线程sleep()一下，我们不能精准控制等到start()子任务执行完返回结果的时候才执行下一条语句。</p>
<p>如下图所示：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3LSdNq.png" alt="3LSdNq.png"></p>
<p>在这个例子中，主线程在执行完t.start()之后，没有等run()里面sleep()执行完，而是直接往下走去执行打印的语句了，所以最后打印出来的结果，cw.value是null。</p>
<p>那如何让其等到子线程的返回值再执行打印呢？——我们可以用主线程等待法。</p>
<p>如下图所示：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3LpHzT.png" alt="3LpHzT.png"></p>
<p>但是因为需要自己手动实现这个等待的逻辑，所以当需要等待的变量很多的时候，代码会变得臃肿。更致命的是，具体要等待多久比较难把握，比较难有精准的控制。</p>
<ol start="2">
<li><strong>使用Thread类的join()阻塞当前线程以等待子线程处理完毕</strong></li>
</ol>
<p>如下图所示：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3L9Ine.png" alt="3L9Ine.png"></p>
<p>只需要加一行<code>t.join()</code>代码即可成功等待，并且也不需要让线程去等待了。</p>
<p>join()等待法可以做到比主线程等待法更精准的控制，实现起来也更简单。</p>
<p>但是缺点是粒度不够细。</p>
<ol start="3">
<li><strong>通过Callable接口实现：通过FutureTask 或 线程池获取</strong></li>
</ol>
<p>在JDK5之前，线程是没有返回值的。</p>
<h1 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h1><p>按照官方的说法，线程的状态一共有如下图所示的留个状态：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3LiilV.png" alt="3LiilV.png"></p>
<p>具体来说：</p>
<ol>
<li>新建(New)：创建后尚未启动的线程的状态。刚创建的线程，如果还没有调用start()方法，那么这个线程会处于New状态。</li>
<li>运行(Runnable)：包含Running和Ready。处于此状态的进程可能正在执行，也可能正在等待CPU为它分配执行时间。</li>
<li>无限期等待(Waiting)：不会被分配CPU执行时间，需要显式被唤醒</li>
</ol>
<p>让线程进入无限期等待有三种方法：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3LFpHe.png" alt="3LFpHe.png"></p>
<ol start="4">
<li>限期等待(Timed Waiting)：在一定时间后会由系统自动唤醒。处于这种状态的进程也不会被CPU分配执行时间，但是不用显示唤醒，过一段时间后系统会自动唤醒它们。</li>
</ol>
<p>让线程进入限期等待主要有六种方法：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3LFsv6.png" alt="3LFsv6.png"></p>
<ol start="5">
<li>阻塞(Blocked):等待获取排它锁。</li>
</ol>
<p>阻塞状态和等待状态的区别是，阻塞状态在等待获取一个排它锁(这会在另一个线程放弃这个锁的时候发生)。而等待状态就是等时间或者被唤醒，不用等其他线程的锁。</p>
<p>比如说，当某个线程进入到了synchronized修饰的方法或者代码块，即获取锁去执行的时候，其他想进入此方法或者代码块的线程就只能等待，他们的状态就都是blocked</p>
<ol start="6">
<li>结束(Terminated)：已终止线程的状态，线程已经结束执行。</li>
</ol>
<p>当线程的run()或者主线程的main()完成时，我们就认为它终止了。这个线程对象虽然可能还是活的，但是它已经不是一个单独执行的线程了。</p>
<p>线程只要终止了，就不能再复生。在一个终止的线程上调用start()会抛出<code>java.lang.IllegalThreadStateException</code>这个异常。 </p>
<p>程序举例：</p>
<p><img src="https://s2.ax1x.com/2020/03/06/3L8a6S.png" alt="3L8a6S.png"></p>
<p>在关闭了线程之后再次启动，也无法执行。</p>
<h1 id="sleep和wait的区别"><a href="#sleep和wait的区别" class="headerlink" title="sleep和wait的区别"></a>sleep和wait的区别</h1><h2 id="基本的差别"><a href="#基本的差别" class="headerlink" title="基本的差别"></a>基本的差别</h2><ul>
<li>sleep是Thread类的方法，wait是Object类中定义的方法</li>
<li>sleep()方法可以在任何地方使用</li>
<li>wait()方法只能在synchronized方法或synchronized块中使用</li>
</ul>
<h2 id="最主要的本职区别"><a href="#最主要的本职区别" class="headerlink" title="最主要的本职区别"></a>最主要的本职区别</h2><ul>
<li>Thread.sleep只会让出CPU，不会导致锁行为的改变</li>
<li>Object.wait不仅让出CPU，还会释放已经占有的同步资源锁</li>
</ul>
<h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><h2 id="线程安全问题的主要诱因"><a href="#线程安全问题的主要诱因" class="headerlink" title="线程安全问题的主要诱因"></a>线程安全问题的主要诱因</h2><ul>
<li>存在共享数据(也称临界资源)</li>
<li>存在多条线程共同操作这些共享数据</li>
</ul>
<h2 id="解决问题的根本方法"><a href="#解决问题的根本方法" class="headerlink" title="解决问题的根本方法"></a>解决问题的根本方法</h2><p>同一时刻有且只有一个线程在操作共享数据，其他线程必须等到该线程处理完数据后再对共享数据进行操作</p>
<h2 id="互斥锁的特性"><a href="#互斥锁的特性" class="headerlink" title="互斥锁的特性"></a>互斥锁的特性</h2><p>互斥锁可以达到互斥访问的目的。简单来说就是某个共享数据如果在某时刻正在被一个线程访问，如果数据被当前访问的数据加了互斥锁，那么在同一时刻其他线程只能处于等待状态，直到当前线程处理完释放掉该锁。</p>
<p>互斥锁有两种特性：</p>
<ol>
<li>互斥性：即在同一时间只允许一个线程持有某个对象锁，通过这种特性来实现多线程的协调机制，这样在同一时间只有一个线程对需要同步的代码块(符合操作)进行访问。互斥性也称为操作的原子性。</li>
<li>可见性：必须确保在锁被释放之前，对共享变量所做的修改，对随后获得该锁的另一个线程是可见的(即在获得锁时应获得最新共享变量的值)，否则另一个线程可能是在本地缓存的某个副本上继续操作，从而引起不一致。</li>
<li>synchronized锁的不是代码，而是<strong>对象</strong>。</li>
</ol>
<p>之前已经知道了，JVM的堆存储空间是线程间共享的，所以恰当地、合理地给一个线程上锁，是解决线程安全问题的关键。</p>
<h2 id="根据获取的锁的分类：获取对象锁和获取类锁"><a href="#根据获取的锁的分类：获取对象锁和获取类锁" class="headerlink" title="根据获取的锁的分类：获取对象锁和获取类锁"></a>根据获取的锁的分类：获取对象锁和获取类锁</h2><p>获取对象锁的两种用法：</p>
<ol>
<li>同步代码块(synchronized(this), synchronized(类实例对象))，锁是小括号()中的实例对象。</li>
<li>同步非静态方法(synchronized method)，锁是当前对象的实例对象</li>
</ol>
<p>获取类锁的两种用法</p>
<ol>
<li>同步代码块(synchronized (类.class))，锁是小括号()中的类对象(Class对象)。</li>
<li>同步静态方法(synchronized static method)，锁是当前对象的类对象(Class对象)。</li>
</ol>
<h2 id="对象锁和类锁的总结"><a href="#对象锁和类锁的总结" class="headerlink" title="对象锁和类锁的总结"></a>对象锁和类锁的总结</h2><ol>
<li>有线程访问对象的同步代码块时，另外的线程可以访问该对象的非同步代码块；</li>
<li>若锁住的是同一个对象，一个线程在访问对象的同步代码块时，另一个访问对象的同步代码块的线程会被阻塞；</li>
<li>若锁住的是同一个对象，一个线程在访问对象的同步方法时，另一个访问对象同步方法的线程会被阻塞；</li>
<li>若锁住的是同一个对象，一个线程在访问对象的同步代码块时，另一个访问对象同步方法的线程会被阻塞，反之亦然；</li>
<li>同一个类的不同对象的对象锁互不干扰；</li>
<li>类锁由于也是一种特殊的对象锁，因此表现和上述1,2,3,4一致，而由于一个类只有一把对象锁，所以同一个类的不同对象使用类锁将会是同步的；</li>
<li>类锁和对象锁互不干扰</li>
</ol>
<h1 id="synchronized底层实现原理"><a href="#synchronized底层实现原理" class="headerlink" title="synchronized底层实现原理"></a>synchronized底层实现原理</h1><ul>
<li>Java对象头</li>
<li>Monitor</li>
</ul>
<h1 id="synchronized和ReentrantLock的区别"><a href="#synchronized和ReentrantLock的区别" class="headerlink" title="synchronized和ReentrantLock的区别"></a>synchronized和ReentrantLock的区别</h1><p>Java5之前只有synchronized，Java5之后开始提供ReentrantLock(再入锁)。ReentrantLock的语义和synchronized基本相同</p>
<p>ReentrantLock位于<code>java.util.concurrent.locks</code>包下，也就是业界著名的”JUC”。</p>
<p>ReentrantLock和CountDownLatch、FutureTask、Semaphore一样都是基于AQS实现的。</p>
]]></content>
      <categories>
        <category>Study Note</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Concurrent Programming Interview II</title>
    <url>/2020/02/24/Java-Concurrent-Programming-Interview-II/</url>
    <content><![CDATA[<blockquote>
<p>耐心和恒心总会得到报酬的。——爱因斯坦</p>
</blockquote>
<a id="more"></a>

<h2 id="1-并行和并发有什么区别？"><a href="#1-并行和并发有什么区别？" class="headerlink" title="1.并行和并发有什么区别？"></a>1.并行和并发有什么区别？</h2><p>• 并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。<br>• 并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。<br>• 在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群。</p>
<p>所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。</p>
<h2 id="2-线程和进程的区别？"><a href="#2-线程和进程的区别？" class="headerlink" title="2.线程和进程的区别？"></a>2.线程和进程的区别？</h2><p>简而言之，进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源，减少切换次数，从而效率更高。线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位。同一进程中的多个线程之间可以并发执行。</p>
<h2 id="3-守护进程是什么？"><a href="#3-守护进程是什么？" class="headerlink" title="3.守护进程是什么？"></a>3.守护进程是什么？</h2><p>守护线程（即daemon thread），是个服务线程，准确地来说就是服务其他的线程。</p>
<h2 id="4-创建线程有哪几种方式？"><a href="#4-创建线程有哪几种方式？" class="headerlink" title="4.创建线程有哪几种方式？"></a>4.创建线程有哪几种方式？</h2><p>1.继承Thread类创建线程类<br>• 定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。<br>• 创建Thread子类的实例，即创建了线程对象。<br>• 调用线程对象的start()方法来启动该线程。</p>
<p>2.通过Runnable接口创建线程类<br>• 定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。<br>• 创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。<br>• 调用线程对象的start()方法来启动该线程。</p>
<p>3.通过Callable和Future创建线程<br>• 创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。<br>• 创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。<br>• 使用FutureTask对象作为Thread对象的target创建并启动新线程。<br>• 调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。</p>
<h2 id="5-说一下runnable-和-callable-有什么区别？"><a href="#5-说一下runnable-和-callable-有什么区别？" class="headerlink" title="5.说一下runnable 和 callable 有什么区别？"></a>5.说一下runnable 和 callable 有什么区别？</h2><p>有点深的问题了，也看出一个Java程序员学习知识的广度。<br>• Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；<br>Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</p>
<h2 id="6-线程有哪些状态？"><a href="#6-线程有哪些状态？" class="headerlink" title="6.线程有哪些状态？"></a>6.线程有哪些状态？</h2><p>线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。<br>• 创建状态。在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态。<br>• 就绪状态。当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。<br>• 运行状态。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。<br>• 阻塞状态。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致线程阻塞。<br>• 死亡状态。如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪</p>
<h2 id="7-sleep-和-wait-有什么区别？"><a href="#7-sleep-和-wait-有什么区别？" class="headerlink" title="7.sleep() 和 wait() 有什么区别？"></a>7.sleep() 和 wait() 有什么区别？</h2><p>sleep()：方法是线程类（Thread）的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。因为sleep() 是static静态的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep() 方法，线程虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象。</p>
<p>wait()：wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程</p>
<h2 id="8-notify-和-notifyAll-有什么区别？"><a href="#8-notify-和-notifyAll-有什么区别？" class="headerlink" title="8.notify() 和 notifyAll() 有什么区别？"></a>8.notify() 和 notifyAll() 有什么区别？</h2><p>• 如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。<br>• 当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争。<br>• 优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。</p>
<h2 id="9-线程的run-和-start-有什么区别？"><a href="#9-线程的run-和-start-有什么区别？" class="headerlink" title="9.线程的run() 和 start() 有什么区别？"></a>9.线程的run() 和 start() 有什么区别？</h2><p>每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，方法run()称为线程体。通过调用Thread类的start()方法来启动一个线程。</p>
<p>start()方法来启动一个线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码；这时此线程是处于就绪状态， 并没有运行。然后通过此Thread类调用方法run()来完成其运行状态， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。</p>
<p>run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的。 如果直接调用run(),其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。</p>
<h2 id="10-创建线程池有哪几种方式？"><a href="#10-创建线程池有哪几种方式？" class="headerlink" title="10.创建线程池有哪几种方式？"></a>10.创建线程池有哪几种方式？</h2><p>1.newFixedThreadPool(int nThreads)</p>
<p>创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程。</p>
<p>2.newCachedThreadPool()</p>
<p>创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制。</p>
<ol start="3">
<li>newSingleThreadExecutor()</li>
</ol>
<p>这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的顺序来串行执行。</p>
<ol start="4">
<li>newScheduledThreadPool(int corePoolSize)</li>
</ol>
<p>创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。</p>
]]></content>
      <categories>
        <category>Interview Note</category>
      </categories>
      <tags>
        <tag>Interview</tag>
        <tag>Java</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Concurrent Programming Interview I</title>
    <url>/2020/02/24/Java-Concurrent-Programming-Interview-I/</url>
    <content><![CDATA[<a id="more"></a>

]]></content>
      <categories>
        <category>Interview Note</category>
      </categories>
      <tags>
        <tag>Interview</tag>
        <tag>Java</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>DataBase Interview II(Mysql)</title>
    <url>/2020/02/20/Database-Interview-II/</url>
    <content><![CDATA[<blockquote>
<p>人真正的强大，不是维护着自尊心的时候，而是抛开自尊心的时候——《请回答1988》</p>
</blockquote>
<a id="more"></a>

<h2 id="1-数据库的三范式是什么？"><a href="#1-数据库的三范式是什么？" class="headerlink" title="1. 数据库的三范式是什么？"></a>1. 数据库的三范式是什么？</h2><p>第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。</p>
<p>第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。</p>
<p>第三范式：任何非主属性不依赖于其它非主属性。</p>
<h2 id="2-一张自增表里面总共有17条数据，删除了最后2条数据，重启mysql数据库，又插入了一条数据，此时id是几？"><a href="#2-一张自增表里面总共有17条数据，删除了最后2条数据，重启mysql数据库，又插入了一条数据，此时id是几？" class="headerlink" title="2.一张自增表里面总共有17条数据，删除了最后2条数据，重启mysql数据库，又插入了一条数据，此时id是几？"></a>2.一张自增表里面总共有17条数据，删除了最后2条数据，重启mysql数据库，又插入了一条数据，此时id是几？</h2><p>• 表类型如果是 MyISAM ，那 id 就是 18。<br>• 表类型如果是 InnoDB，那 id 就是 15。</p>
<p>InnoDB 表只会把自增主键的最大 id 记录在内存中，所以重启之后会导致最大 id 丢失。</p>
<h2 id="3-如何获取当前数据库版本？"><a href="#3-如何获取当前数据库版本？" class="headerlink" title="3.如何获取当前数据库版本？"></a>3.如何获取当前数据库版本？</h2><p>使用 select version() 获取当前 MySQL 数据库版本。</p>
<h2 id="4-说一下ACID是什么？"><a href="#4-说一下ACID是什么？" class="headerlink" title="4.说一下ACID是什么？"></a>4.说一下ACID是什么？</h2><p>• Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。<br>• Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等<br>• Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</p>
<p>• Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失</p>
<h2 id="5-char和varchar的区别是什么？"><a href="#5-char和varchar的区别是什么？" class="headerlink" title="5.char和varchar的区别是什么？"></a>5.char和varchar的区别是什么？</h2><p>char(n) ：固定长度类型，比如订阅 char(10)，当你输入”abc”三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。</p>
<p>chat 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。</p>
<p>varchar(n) ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。</p>
<p>所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。</p>
<h2 id="6-float和double的区别是什么？"><a href="#6-float和double的区别是什么？" class="headerlink" title="6.float和double的区别是什么？"></a>6.float和double的区别是什么？</h2><p>• float 最多可以存储 8 位的十进制数，并在内存中占 4 字节。<br>• double 最可可以存储 16 位的十进制数，并在内存中占 8 字节。</p>
<h2 id="7-mysql的内连接、左连接、右连接有什么区别"><a href="#7-mysql的内连接、左连接、右连接有什么区别" class="headerlink" title="7.mysql的内连接、左连接、右连接有什么区别?"></a>7.mysql的内连接、左连接、右连接有什么区别?</h2><p>内连接关键字：inner join；左连接：left join；右连接：right join。</p>
<p>内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。</p>
<h2 id="8-mysql的索引是什么实现的？"><a href="#8-mysql的索引是什么实现的？" class="headerlink" title="8.mysql的索引是什么实现的？"></a>8.mysql的索引是什么实现的？</h2><p>索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。</p>
<p>具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。</p>
<h2 id="9-怎么验证mysql的索引是否满足需求？"><a href="#9-怎么验证mysql的索引是否满足需求？" class="headerlink" title="9.怎么验证mysql的索引是否满足需求？"></a>9.怎么验证mysql的索引是否满足需求？</h2><p>使用 explain 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。</p>
<p>explain 语法：explain select * from table where type=1。</p>
<h2 id="10-说一下数据库的事务隔离？"><a href="#10-说一下数据库的事务隔离？" class="headerlink" title="10.说一下数据库的事务隔离？"></a>10.说一下数据库的事务隔离？</h2><p>MySQL 的事务隔离是在 MySQL. ini 配置文件里添加的，在文件的最后添加：transaction-isolation = REPEATABLE-READ</p>
<p>可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。<br>• READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。<br>• READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。<br>• REPEATABLE-READ：可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。<br>• SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</p>
<p>脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</p>
<p>不可重复读 ：是指在一个事务内，多次读同一数据。</p>
<p>幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p>
<h2 id="11-说一下Mysql常用的引擎？"><a href="#11-说一下Mysql常用的引擎？" class="headerlink" title="11.说一下Mysql常用的引擎？"></a>11.说一下Mysql常用的引擎？</h2><p>InnoDB 引擎：InnoDB 引擎提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。</p>
<p>MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 select count(*) from table 指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。</p>
<p>MyIASM 引擎：MySQL 的默认引擎，但不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。</p>
<h2 id="12-说一下mysql的行锁和表锁？"><a href="#12-说一下mysql的行锁和表锁？" class="headerlink" title="12.说一下mysql的行锁和表锁？"></a>12.说一下mysql的行锁和表锁？</h2><p>MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。<br>• 表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。<br>• 行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。</p>
<h2 id="13-说一下乐观锁和悲观锁？"><a href="#13-说一下乐观锁和悲观锁？" class="headerlink" title="13.说一下乐观锁和悲观锁？"></a>13.说一下乐观锁和悲观锁？</h2><p>• 乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。<br>• 悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。</p>
<p>数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。 </p>
<h2 id="14-mysql问题排查都有哪些手段？"><a href="#14-mysql问题排查都有哪些手段？" class="headerlink" title="14.mysql问题排查都有哪些手段？"></a>14.mysql问题排查都有哪些手段？</h2><p>• 使用 show processlist 命令查看当前所有连接信息。<br>• 使用 explain 命令查询 SQL 语句执行计划。<br>• 开启慢查询日志，查看慢查询的 SQL。</p>
<h2 id="15-如何做mysql的性能优化？"><a href="#15-如何做mysql的性能优化？" class="headerlink" title="15.如何做mysql的性能优化？"></a>15.如何做mysql的性能优化？</h2><p>• 为搜索字段创建索引。<br>• 避免使用 select *，列出需要查询的字段。<br>• 垂直分割分表。<br>选择正确的存储引擎。</p>
]]></content>
      <categories>
        <category>Interview Note</category>
      </categories>
      <tags>
        <tag>DataBase</tag>
        <tag>Interview</tag>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>DataBase Interview I</title>
    <url>/2020/02/19/DataBase-Interview/</url>
    <content><![CDATA[<blockquote>
<p>才能一旦让懒惰支配，它就一无可为。——克雷洛夫</p>
</blockquote>
<a id="more"></a>

<h2 id="数据库架构设计"><a href="#数据库架构设计" class="headerlink" title="数据库架构设计"></a>数据库架构设计</h2><p>如果提问：如何设计一个关系型数据库？实际上是考察你对数据库模块化的划分能力，当然也包括对数据库的概念的理解程度。</p>
<p>要开发数据库需要以下模块：</p>
<p><img src="https://s2.ax1x.com/2020/02/19/3Ax1HO.png" alt="3Ax1HO.png"></p>
<ul>
<li><p>存储管理模块可以控制IO次数，因为读取次数会非常花时间，在实际中，一次读取多行的效率远比多次读取(每次读取一两行)要省时间的多。</p>
</li>
<li><p>非常常用的一种方法，就是引入缓存机制，把取出来的数据块存放在缓存里，下次需要的时候直接从内存返回，而不用发生IO。管理缓存的方法很多，可以使用比如LRU等。注意，我们的缓存不宜过大，而且算法中需要有淘汰机制。</p>
</li>
</ul>
<p>总的来说，要回答如何设计一个关系型数据库(RDBMS：Relational Database Management System),首先要将其划分成两大部分，一个是存储部分，该部分类似一个文件系统，将数据持久化到存储设备当中。另一个是程序实例模块来对存储进行管理。而在程序实例模块中，需要包含下面八个模块：</p>
<p>①. 将数据的逻辑关系转换成物理存储关系的存储管理模块；</p>
<p>②. 优化执行效率的缓存机制模块</p>
<p>③. 将SQL语句进行解析的SQL解析模块</p>
<p>④. 记录操作的日志管理模块</p>
<p>⑤. 进行多用户权限管理的权限划分模块</p>
<p>⑥. 灾难恢复的容灾模块</p>
<p>⑦. <strong>优化查询效率的索引管理模块</strong> (重点)</p>
<p>⑧. <strong>使数据库支持并发操作的锁模块</strong> (重点)</p>
<p>实际上，数据库开发设计的模块结构和我们自己设计和开发的软件系统很相似，这个架构是很经典的，对程序的开发和设计也是很有借鉴意义的。</p>
<h2 id="索引相关问题"><a href="#索引相关问题" class="headerlink" title="索引相关问题"></a>索引相关问题</h2><h3 id="为什么要使用索引？"><a href="#为什么要使用索引？" class="headerlink" title="为什么要使用索引？"></a>为什么要使用索引？</h3><p>索引(Index)是可以帮助MYSQL高效获取数据的数据结构。如果数据量很小，那么哪怕是全表扫描，也可能比加了索引之后更快。但是如果数据量很大，那么全表扫描将是噩梦。</p>
<p>实际上，可以理解索引的灵感来自于”字典”，通过类似”偏旁部首”之类的”索引”可以更快速地找到要查的词。</p>
<p>具体作用描述：</p>
<ol>
<li>索引能极大地减少存储引擎需要扫描的数据量</li>
<li>索引可以把随机IO变成顺序IO</li>
<li>索引可以帮助我们在进行分组、排序等操作时，避免使用临时表</li>
</ol>
<h3 id="什么样的信息能成为索引？"><a href="#什么样的信息能成为索引？" class="headerlink" title="什么样的信息能成为索引？"></a>什么样的信息能成为索引？</h3><ul>
<li>主键、唯一键及普通键等，只要能让数据具备一定区分性的字段，都可以成为索引。</li>
</ul>
<h3 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h3><p>在选择建并且生成索引之后，可以选择不同的数据结构进行索引的查找。一般常用的是二分查找树进行二分查找、建立B-树结构查找、建立B+树查找(MySQL选择的结构)、建立Hash结构查找。下面简单介绍每种结构的细节。</p>
<p>回答：<font color=#FF0000>通常来说，索引的数据结构是B+树，比较小众的也有哈希结构、BitMap(位图)等</font></p>
<h4 id="二叉查找树结构进行索引查找"><a href="#二叉查找树结构进行索引查找" class="headerlink" title="二叉查找树结构进行索引查找"></a>二叉查找树结构进行索引查找</h4><p>大体的结构：</p>
<p><img src="https://s2.ax1x.com/2020/02/19/3VOG60.png" alt="3VOG60.png"></p>
<ul>
<li>二叉查找树符合左小右大的规则，查找的时候使用二分查找</li>
<li>检索深度每增加1，就会增加1次IO。但是需要注意的是整个树是通过很多数据块组合而成的，当许多数据块组合在一起的时候，会造成二叉树的深度很大，从而基本上没法避免多次的IO，从而造成很悲剧的后果：使用了索引，速度甚至可能比不用更慢，因为IO次数太多了。</li>
</ul>
<h4 id="B-树结构进行索引查找"><a href="#B-树结构进行索引查找" class="headerlink" title="B- 树结构进行索引查找"></a>B- 树结构进行索引查找</h4><p>B-树又称作”多路平衡查找树”</p>
<p><img src="https://s2.ax1x.com/2020/02/19/3VXkEF.png" alt="3VXkEF.png"></p>
<p>定义：</p>
<ul>
<li>根节点至少包括两个孩子</li>
<li>树中每个结点最多含有m个孩子(m&gt;=2)</li>
<li>除根节点和叶节点外，其他每个节点至少有ceil(m/2)个孩子(ceil为取上限，举例，1.2和1.5，都是取2)</li>
<li>所有叶子节点都位于同一层(即叶子节点高度都相同)</li>
</ul>
<h4 id="B-树结构进行索引查找-1"><a href="#B-树结构进行索引查找-1" class="headerlink" title="B+树结构进行索引查找"></a>B+树结构进行索引查找</h4><p><img src="https://s2.ax1x.com/2020/02/19/3Vvr1s.png" alt="3Vvr1s.png"></p>
<p>B+树实际上是B树的变体，其定义和B树不同的地方为：</p>
<ul>
<li>非叶子节点的子树指针与关键字个数相同</li>
<li>非叶子节点的子树指针P[i]，指向关键字值[K[i],K[i+1])<font color=#FFF0000>(左闭右开，即可以大于等于K[i]，但必须大于K[i+1]  )</font>的子树</li>
<li>非叶子节点仅用来索引，数据都保存在叶子节点中。<font color=#FFF0000>所有的数据实际都存储在叶子节点上，所以每一次遍历都必须遍历到叶子节点上。</font>这也使得B+树的层级可以更少，树可以更矮。</li>
<li>所有叶子节点均有一个链指针指向下一个叶子节点。<font color=#FFF0000>搜索的实际是上图中粉色的块的部分。</font>这个链指针主要服务于<strong>范围统计</strong>，定位到了某个叶指针之后，可以快速横向地去做统计。比如要统计索引&gt;10的，找到了第二个Q之后，直接统计后面所有的Q内容即可。</li>
</ul>
<p>结论：B+树相比B树更适合用来做存储索引</p>
<ul>
<li>B+树的磁盘读写代价更低。B+树内部只存储索引(或者说叶子节点的指针)，B树需要不断在父节点和叶子节点之间来回移动，所以B+树的高度能降低。</li>
<li>B+树查询效率更加稳定。因为所有实质内容都存储在根节点上，所以几乎所有数据的查询的时间都是稳定的：O(n)</li>
<li>B+树更有利于对数据库的扫描。B+树只需要遍历叶子节点就可以实现全部关键字信息的扫描。比如之前提到的，数据库中频繁使用的范围查询，使用B+树查询能够大大增加效率。</li>
</ul>
<h4 id="Hash结构进行索引查找"><a href="#Hash结构进行索引查找" class="headerlink" title="Hash结构进行索引查找"></a>Hash结构进行索引查找</h4><p>和哈希表的原理类似，通过一个哈希函数，将不同的key通过某种哈希映射得到value，然后存储在不同的链表节点上。如图：</p>
<p><img src="https://s2.ax1x.com/2020/02/20/3ZCI3D.png" alt="3ZCI3D.png"></p>
<p>哈希索引在理论上性能优于B+树。</p>
<p>但是哈希表相比B+树有一些缺点，却是更需要重视的：</p>
<ul>
<li>仅仅能满足”=”,”IN”，不能使用范围查询。因为哈希运算后得到的值之间的大小关系是根本不能保证和哈希运算前一样的，所以不能进行范围比较，只能进行具体的值的大小的比较。</li>
<li>无法被用来避免数据的排序操作</li>
<li>不能利用部分索引键查询</li>
<li>不能避免表扫描</li>
<li>遇到大量Hash值相等的情况后性能并不一定就会比B树索引高</li>
</ul>
<h4 id="BitMap索引"><a href="#BitMap索引" class="headerlink" title="BitMap索引"></a>BitMap索引</h4><p>需要注意，目前比较少的主流数据库支持位图索引，比较出名的是Oracl。位图索引不是主流索引。</p>
<p><img src="https://s2.ax1x.com/2020/02/20/3ZP7GT.png" alt="3ZP7GT.png"></p>
<p>这个索引可以算是一个”神器”。当表中的某个字段只有几种可能值的时候，比如性别，此时如果要实现性别统计，使用位图索引可以说是最佳选择。</p>
<p>位图索引比较类似B+树。</p>
<ul>
<li>锁的力度大，不适合高并发的联机数据处理系统(OLTP系统)，适合并发较少，且统计较多的OLAP系统</li>
</ul>
<h3 id="密集索引和稀疏索引的区别"><a href="#密集索引和稀疏索引的区别" class="headerlink" title="密集索引和稀疏索引的区别"></a>密集索引和稀疏索引的区别</h3><ul>
<li>密集索引文件中的每个搜索码值都对应一个索引值</li>
<li>稀疏索引文件只为索引码的某些值建立索引项</li>
</ul>
<p>密集索引和稀疏索引如下图所示：</p>
<p><img src="https://s2.ax1x.com/2020/02/20/3ZY1eA.png" alt="3ZY1eA.png"></p>
<p>一个表只能创建一个密集索引。</p>
<p>针对Mysql进行分析，其主要有两种存储引擎：MyISAM和InnoDB：</p>
<ul>
<li>MyISAM(数据和索引是分开的，文件后缀为.MYI、.MYD,前者存储索引，后者存储数据)：主键索引、唯一建索引和普通索引，全部都是稀疏索引。</li>
<li>InnoDB(数据和索引是合在一起的，文件后缀为.idb)则有且仅有一个密集索引。</li>
</ul>
<p>对于InnoDB的索引的额外知识：</p>
<ul>
<li>若一个主键被定义，该主键则作为密集索引</li>
<li>若没有主键被定义，该表的第一个唯一非空索引则作为密集索引</li>
<li>若没有主键，也没有合适的唯一索引，innodb内部会生成一个隐藏主键(是一个6字节的列，该列的值会随着数据的插入而自增)(密集索引)</li>
<li>非主键索引存储相关键位和其对应的主键值，包含两次查找(一次查找次级索引自身，一次查找主键)</li>
</ul>
<p><img src="https://s2.ax1x.com/2020/02/20/3ZagE9.png" alt="3ZagE9.png"></p>
<h3 id="索引额外的问题，以mysql为例"><a href="#索引额外的问题，以mysql为例" class="headerlink" title="索引额外的问题，以mysql为例"></a>索引额外的问题，以mysql为例</h3><h4 id="如何定位并优化慢查询Sql"><a href="#如何定位并优化慢查询Sql" class="headerlink" title="如何定位并优化慢查询Sql"></a>如何定位并优化慢查询Sql</h4><p>这个问题主要考察有没有做过sql优化，需要具体场景具体分析，这里给出大致思路</p>
<ul>
<li>根据慢日志定位慢查询sql</li>
<li>使用explain等工具分析sql</li>
<li>修改sql或尽量让sql走索引</li>
</ul>
<p>下面具体分析：</p>
<ul>
<li>根据慢日志定位慢查询sql</li>
</ul>
<p>什么是慢日志？——用来记录一些执行比较慢的sql</p>
<p><code>show variables like &#39;%quer%&#39;;//查看相关变量</code></p>
<p>查询结果：</p>
<p><img src="https://s2.ax1x.com/2020/02/20/3ZXX0f.png" alt="3ZXX0f.png"></p>
<p>其中需要重点关注三个变量：</p>
<p><code>show_query_log</code>(慢日志是否打开),</p>
<p><code>slow_query_log_file</code>(日志写入的文件路径)，</p>
<p><code>long_query_time</code>(多少秒以上的sql语句会被当做慢语句记录到文件中,一般设置为1秒)</p>
<p>一般来说可以用set设置慢查询开关和阈值时间(路径一般不迫切更改)</p>
<blockquote>
<p>set global slow_query_log = on;</p>
<p>set global long_query_time = 1;//必须重连才能生效</p>
</blockquote>
<p>但是如果想要永久生效，最好是去配置文件里面配好，而不是用set的方式。</p>
<p>查看系统慢查询的数量的语句：<code>show status like &#39;%slow_queries%&#39;</code>，能够把运行下来执行慢的语句数量统计出来。</p>
<p>通过查看慢日志的具体值，可以在分析之后进行调优。</p>
<ul>
<li>使用explain等工具分析sql</li>
</ul>
<p>在分析查询性能的时候explain关键字非常管用，一般放在select语句前面，用于描述mysql如何执行查询操作。以及mysql返回的结果和需要查询的行数。</p>
<p><img src="https://s2.ax1x.com/2020/02/20/3er9iQ.png" alt="3er9iQ.png"></p>
<p>重点介绍看两个字段：type和extra</p>
<ol>
<li>type：如果出现了index或all，表示语句进行了全表扫描，需要优化</li>
<li>extra：类型很多，其中using filesort/Using temporary出现的话，会对性能产生较大影响，必须优化：</li>
</ol>
<p><img src="https://s2.ax1x.com/2020/02/20/3erzOx.png" alt="3erzOx.png"></p>
<ul>
<li>修改sql或者尽量让sql走索引</li>
</ul>
<p>当我们进行查询的时候，如果一开始用的属性是没有索引的，可以更改成有索引的对象，可以减少查询时间。</p>
<p>但是有时候我们就是不能用带索引的属性，那么只能在新的需要查询的属性中加上索引了。</p>
<p>Mysql的索引优化器本质上也是一个软件，在不同的查询条件下可能就算你用了主键，查询效果也不够好。这个时候可以利用关键字<code>force index(primary)</code>进行对比，综合判断哪个索引的值最适合做此次的查询。</p>
<p>举一个调优的最简单的例子：如果我们是用户表，其中有用户账号account和用户名name，其中account有索引，则如果我们用name查询用了10s，用account查询用了6秒，那么实际我们将此次mysql查询的性能优化了40%</p>
<h4 id="联合索引的最左匹配原则的成因"><a href="#联合索引的最左匹配原则的成因" class="headerlink" title="联合索引的最左匹配原则的成因"></a>联合索引的最左匹配原则的成因</h4><p>什么是联合索引？——由多列组成的索引</p>
<p>假设将数据库某张表中的A列和B列设置成联合索引，查询的时候在where语句中调用(where A=** and B=**)的时候会走A和B这个组合索引；而且如果单独用A查询，也会走AB联合索引。<font color=#FF0000>但是如果直接select B，则会走”ALL”，即不走索引，全表扫描。</font></p>
<ul>
<li>最左匹配原则本身很重要。简单理解，是Mysql会从左一直向右匹配直到遇到范围查询(&gt;,&lt;,between,like)就停止匹配。比如a=3 and b=4 and c&gt;5 and d=6,如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到。其中a,b,d的顺序可以任意调整，比如(b,a,d,c),(a,d,b,c)，结果都是一样的。注意这里不是没有用到索引，而是最多只用到了(a)(a,b),(a,b,c)索引，没有能够用到(a,b,c,d)索引</li>
<li>=和in可以乱序的。比如a = 1 and b = 2 and c = 3建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。</li>
</ul>
<p>对于(a,b,c,d)这个例子，mysql创建复合索引的规则是首先会对复合索引的最左边的，也就是第一个a字段的数据进行排序，在第一个字段的排序基础上，然后再对后面第二个的b字段进行排序，如果此时c是范围查询的话，则没法获取到有序的d，因此是不行的。</p>
<h4 id="索引是建立得越多越好么？"><a href="#索引是建立得越多越好么？" class="headerlink" title="索引是建立得越多越好么？"></a>索引是建立得越多越好么？</h4><p>当然不是：</p>
<ul>
<li>数据量小的表不需要建立索引，增加额外的索引开销(比如看一两页的宣传手册，谁会需要索引呢？)</li>
<li>数据变更需要维护索引，因此更多的索引意味着更多的维护成本</li>
<li>更多的索引以为这也需要更多的空间(一本100页的书，目录不能是50页呀)</li>
</ul>
<h2 id="锁相关问题"><a href="#锁相关问题" class="headerlink" title="锁相关问题"></a>锁相关问题</h2><h3 id="MyISAM与InnoDB关于锁方面的区别是什么"><a href="#MyISAM与InnoDB关于锁方面的区别是什么" class="headerlink" title="MyISAM与InnoDB关于锁方面的区别是什么"></a>MyISAM与InnoDB关于锁方面的区别是什么</h3><ul>
<li><p>MyISAM默认用的是表级锁，不支持行级锁</p>
</li>
<li><p>InnoDB默认用的是行级锁，但是也支持表级锁</p>
</li>
</ul>
<p>分别来说：</p>
<h4 id="MyISAM默认用的是表级锁，不支持行级锁"><a href="#MyISAM默认用的是表级锁，不支持行级锁" class="headerlink" title="MyISAM默认用的是表级锁，不支持行级锁"></a>MyISAM默认用的是表级锁，不支持行级锁</h4><p>当使用MyISAM作为Mysql引擎时，对一个表进行操作时，会锁住整张表，其他session不能操作</p>
<p>读锁（共享锁）不释放，无法增加写锁</p>
<p>读锁（共享锁）不释放，可以增加读锁</p>
<p>写锁（排他锁）不释放，无法增加读锁</p>
<p>写锁 (排它锁) 不释放，无法增加写锁</p>
<p>给表加上读锁写锁或者读锁的写法：</p>
<blockquote>
<p>lock tables *** read | write;<br>unlock tables;</p>
</blockquote>
<h4 id="InnoDB默认用的是行级锁，但是也支持表级锁"><a href="#InnoDB默认用的是行级锁，但是也支持表级锁" class="headerlink" title="InnoDB默认用的是行级锁，但是也支持表级锁"></a>InnoDB默认用的是行级锁，但是也支持表级锁</h4><p>InnoDB使用的是二段锁，也就是加锁和解锁分成两个步骤进行，就像军训走正步一样，一个动作全部加锁，一个动作全部解锁。</p>
<p>InnoDB的行级锁会把某张表中的某一行锁住，这样如果你锁住了第3行，那么操作第4行是不会受影响的。</p>
<p>需要注意，InnoDB在sql没有用到索引的时候，会自动走表级锁。但是如果sql用到了索引，就会转为使用行级锁。</p>
<h4 id="MyISAM和InnoDB各自适合的场景"><a href="#MyISAM和InnoDB各自适合的场景" class="headerlink" title="MyISAM和InnoDB各自适合的场景"></a>MyISAM和InnoDB各自适合的场景</h4><ul>
<li><p>MyISAM适合的场景：</p>
<ul>
<li>频繁执行全表count语句(InnoDB不保存表的具体行数，但MyISAM会使用一个变量保存整张表的行数，执行count的时候可以调用之前保存过的变量,)</li>
<li>对数据进行增删改的频率不高，查询非常频繁(增删改设计锁表操作)</li>
<li>没有事务</li>
</ul>
</li>
<li><p>InnoDB适合的场景：</p>
<ul>
<li>数据增删改查都频繁(每次只锁行)</li>
<li>可靠性要求高</li>
<li>需要支持事务</li>
</ul>
</li>
</ul>
<h4 id="数据库锁的分类"><a href="#数据库锁的分类" class="headerlink" title="数据库锁的分类"></a>数据库锁的分类</h4><ul>
<li>按锁的粒度划分，可分为<strong>表级锁、行级锁、页级锁</strong>。InnoDB默认支持行级锁，同时支持表级锁。MyISAM只支持表级锁。</li>
<li>按锁的级别划分，可分为共享锁、排它锁</li>
<li>按加锁方式划分，可分为自动锁(mysql自动加上的锁)、显式锁(用语句加上的锁)</li>
<li>按操作划分，可分为DML锁(对数据操作)、DDL锁(对表结构操作)</li>
<li>按使用方式划分，可分为乐观锁(基于数据版本)、悲观锁(利用数据库提供的功能，对外界修改保守态度)</li>
</ul>
<p>其中，乐观锁和悲观锁不仅在数据库中会使用，在程序中也经常用到。悲观锁实际上会拒绝所有外部的修改。对于并发，悲观锁实际上也是先取锁，后访问的保守策略。为数据处理的安全提供了保证。但是对于数据库，处理过多的锁可能会给数据库造成额外的开销，并且增加产生死锁的机会，所以对于事务要不要加锁需要谨慎。</p>
<p>乐观锁认为数据一般不会造成冲突，所以只会在数据提交更新的时候才会检测数据是否冲突。如果发现冲突，则返回用户错误的信息。<strong>悲观锁一般需要使用数据库提供的锁机制，但是乐观锁一般不用。</strong>乐观锁一般记录数据库版本。记录版本的方式一般也有两种，一个是使用<strong>版本号</strong>，另一个是使用<strong>时间戳</strong>。添加版本号，可以通过添加一个int类型的version变量实现。</p>
<h3 id="数据库事务的四大特性"><a href="#数据库事务的四大特性" class="headerlink" title="数据库事务的四大特性"></a>数据库事务的四大特性</h3><p><strong>ACID</strong></p>
<ul>
<li>Atomicity：<strong>原子性</strong>，要么都做，要么都不做。比如银行取钱，我这边还没取完，你就不能操作我的账户。比较相似的是，如果一个用户正在操作他的账户，而且他的账户里面的钱的金额很大，可能出现的情况就是他点确认了，但是数据要处理几秒，那么这段时间这个账户也是不能被操作的。</li>
<li>Consistency，<strong>一致性</strong>，一个事务要持续做完。这个事务一般情况下需要满足既定好的假设，满足各种条件约束。</li>
<li>Isolation，<strong>隔离性</strong>，事务之间是互相独立的。一个事务的执行不能影响其他事务。</li>
<li>Durability，<strong>持久性</strong>，事务需要是持久的，比如介质受损了，比如断电之后，数据也还能保存。</li>
</ul>
<p>其中，Isolation，隔离性，是最关键的一个属性。</p>
<p>事务隔离级别有四个。事务会先begin transaction，然后开始做。</p>
<ul>
<li>Read uncommitted，事务的隔离级别非常低，别的事务完成到了一半还没committ的时候，就能够被我读出来。（不能避免脏读）</li>
<li>Read Committed，顾名思义，只能读取到别人已经Committed的内容。但是如果你已经读取了，在你读取之后别人又有了修改，别人修改之后你再读，读取到的是别人修改之后的内容，隔离性相对来说也不是很强。(可以避免脏读)</li>
<li>Repeatable Reads,这个针对上一个，这种读法始终只能读取到我自己begin transaction时候的值。</li>
<li>Serializable， 两个事务同时发生的时候，一定只会读取到其中一个的结果。</li>
</ul>
<h3 id="事务隔离级别以及各级别下的并发访问问题"><a href="#事务隔离级别以及各级别下的并发访问问题" class="headerlink" title="事务隔离级别以及各级别下的并发访问问题"></a>事务隔离级别以及各级别下的并发访问问题</h3><h4 id="事务并发访问引起的问题以及如何避免"><a href="#事务并发访问引起的问题以及如何避免" class="headerlink" title="事务并发访问引起的问题以及如何避免"></a>事务并发访问引起的问题以及如何避免</h4><ul>
<li>更新丢失(lost update)，即数据库的一个更新覆盖掉了另一个更新的内容。但是现在Mysql所有事务隔离级别在数据库层面上均可避免这个问题。</li>
</ul>
<p>举一个银行取款存款事务的例子：</p>
<p><img src="https://s2.ax1x.com/2020/02/23/3lQIZ4.png" alt="3lQIZ4.png"></p>
<ul>
<li>脏读(Dirty Read)，指一个事务读到了另一个事务未提交的更新数据。这个问题可以在READ-COMMITTED事务隔离级别以上才能避免。</li>
</ul>
<p>查看事务隔离级别：</p>
<blockquote>
<p>select @@tx_isolation</p>
</blockquote>
<p>NOTE:tx就是事务(transaction)缩写</p>
<p>设置事务隔离级别：</p>
<blockquote>
<p>set session transaction isolation level read committed;</p>
</blockquote>
<p>开启事务：</p>
<blockquote>
<p>start tansaction;</p>
</blockquote>
<ul>
<li>不可重复读(None repeatable read),事务A多次读取了数据，但是事务B在事务A读取的过程中有操作数据，导致事务A多次读取出来的数据不一致。把事务隔离级别修改成REPEATABLE-READ级别以上可以避免这个问题。</li>
</ul>
<p>InnoDB默认的隔离级别就是REPEATABLE-READ，支持多次读也<br>能读取到相同结果。</p>
<p>设置事务隔离级别为REPEATABLE-READ：</p>
<blockquote>
<p>set session transaction isolation level repeatable read;</p>
</blockquote>
<p>事务的隔离级别设置到REPEATABLE-READ以上，就可以避免不可重复度的问题。</p>
<p>实际上，InnoDB引擎默认的事务隔离级别就是REPEATABLE-READ。</p>
<ul>
<li>幻读(Phantom read)：事务A读取与搜索条件相匹配的若干行，而事务B同时进行了添加、删除的操作，导致A每次结果都不一样，貌似出现了幻觉。设置事务隔离级别为SERIALIZABLE可以解决。</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><ul>
<li>更新丢失——Mysql所有事务隔离级别在数据库层面上均可避免。</li>
<li>脏读——READ-COMMITTED事务隔离级别以上可以避免</li>
<li>不可重复读——REPEATABLE-READ事务隔离级别以上可以避免</li>
<li>幻读——SERIALIZABLE事务隔离级别可避免</li>
</ul>
<p>如下图：</p>
<p><img src="https://s2.ax1x.com/2020/02/23/33EMr9.png" alt="33EMr9.png"></p>
<p>感觉上不可重复度和幻读这两个问题很相似。实际上，不可重复读侧重对同一数据的修改。幻读则侧重添加和删除。</p>
<p>数据库事务隔离级别越高，串行度越高。虽然可以避免错误的发生，但其并发性能会降低，效率会降低。Oracle默认为Read Committed、MySQL默认为REPETABLE READ。</p>
<h3 id="InnoDB可重复读隔离级别下如何避免幻读"><a href="#InnoDB可重复读隔离级别下如何避免幻读" class="headerlink" title="InnoDB可重复读隔离级别下如何避免幻读"></a>InnoDB可重复读隔离级别下如何避免幻读</h3><p><strong>表象：快照读(非阻塞读)——伪MVCC(多版本并发控制)</strong></p>
<p>表象不是真正原因。</p>
<p>当前读有以下操作：</p>
<blockquote>
<p>select … lock in share mode, select … for update </p>
<p>update, delete, insert</p>
</blockquote>
<p>当前读是加了锁的增删改查语句，不论是加了共享锁还是排它锁，都是当前读。当前读的特点是读取当前最新的记录，并且锁住当前数据使得其他事务不能修改数据。</p>
<p>当前读的操作原理：</p>
<p><img src="https://s2.ax1x.com/2020/02/23/33JNzd.png" alt="33JNzd.png"></p>
<ul>
<li>快照读：简单的select操作，不加锁的非阻塞读。<font color=#FF0000>当然，“不加锁”的前提是事务隔离级别不为Serializable，否则都是串行执行的，快照读就退化为当前读了。</font></li>
</ul>
<h4 id="RC、RR级别下的InnoDB的非阻塞读如何实现"><a href="#RC、RR级别下的InnoDB的非阻塞读如何实现" class="headerlink" title="RC、RR级别下的InnoDB的非阻塞读如何实现"></a>RC、RR级别下的InnoDB的非阻塞读如何实现</h4><ul>
<li><p>数据行里DB_TRX_ID, DB_ROLL_PTR, DB_ROW_ID字段</p>
<ul>
<li>DB_TRX_ID：最后一次对本行数据做修改的事务ID</li>
<li>DB_ROLL_PTR：回滚指针，undo日志记录</li>
<li>DB_ROW_ID：行号，单调递增。</li>
</ul>
</li>
<li><p>undo日志：当用户对数据产生变更时，就会产生undo记录。undo记录中存储的是老版数据。</p>
</li>
</ul>
<p>undo log包含两种：Insert undo log和update undo log。其中Insert undo log会记录Insert的操作，用于回滚，并且在commit只后可以立即丢弃，它不是重点。重点是update undo log。 事务对数据进行delete、update的时候会产生update undo log，它不仅在事务回滚的时候需要，快照读也需要，它不能随便删除，只有当数据库不需要此类日志的时候才会删除。</p>
<p>事务对某行的数据更新的过程：</p>
<p><img src="https://s2.ax1x.com/2020/02/24/33tSun.png" alt="33tSun.png"></p>
<p>流程：</p>
<ol>
<li>锁定该行</li>
<li>将该行的数据拷贝一份到undo log中</li>
<li>修改当前行的值</li>
<li>使用回滚指针指向undo log中修改前的行</li>
</ol>
<p>后面如果要对历史数据操作，可以去undo log里面找。</p>
<ul>
<li>read view：用来做可见性判断。当我们执行快照读select的时候，会针对查询的数据创建特定的read view来决定可以查看当前哪一个版本的数据。</li>
</ul>
<p>MVCC(Multi Version Concurrency Control)：多版本并发控制，读写不冲突。</p>
<h4 id="Gap锁"><a href="#Gap锁" class="headerlink" title="Gap锁"></a>Gap锁</h4><ul>
<li><p>Gap锁会用在非唯一索引或者不走索引的当前读中</p>
</li>
<li><p>走非唯一索引</p>
</li>
</ul>
<p><img src="https://s2.ax1x.com/2020/02/24/33I4ns.png" alt="33I4ns.png"></p>
<p>官方文档有介绍，给出需要修改的索引，会对对象的周边进行上锁，上锁的范围会是左开右闭的区间。</p>
<p><img src="https://s2.ax1x.com/2020/02/24/33oVud.png" alt="33oVud.png"></p>
<ul>
<li>不走索引</li>
</ul>
<p>若当前读不走索引，它会对所有的Gap都上锁，就类似锁表了，同样可以达到防止幻读的效果。</p>
<p><img src="https://s2.ax1x.com/2020/02/24/38SGWj.png" alt="38SGWj.png"></p>
<p>但是相比表锁，这样上锁的代价更大，会降低数据库的效率。</p>
<h4 id="锁模块之RR如何避免幻读"><a href="#锁模块之RR如何避免幻读" class="headerlink" title="锁模块之RR如何避免幻读"></a>锁模块之RR如何避免幻读</h4><p><strong>内在：next-key锁(行锁+gap锁)</strong></p>
<ul>
<li>行锁：对单个行记录上的锁</li>
<li>Gap锁：防止同一事务两次读，防止出现幻读</li>
</ul>
<p>主键或者唯一索引会用Gap锁么？——视情况而定</p>
<ul>
<li>如果where条件全部命中，则不用Gap锁，只会加记录锁</li>
<li>如果where条件部分命中或者全不命中，则会加Gap锁。Gap锁用在非唯一索引或不走索引的当前读中。</li>
</ul>
<p>需要注意，加锁的时候，如果我们走的时候主键之外的索引，那么我们需要对当前索引以及主键索引对应的记录都上锁。</p>
<p>加锁的具体情况举例：</p>
<p>当where条件全部命中的时候，不会加gap锁，只加记录锁。</p>
<p><img src="https://s2.ax1x.com/2020/02/24/33gGuV.png" alt="33gGuV.png"></p>
<h4 id="锁模块小结"><a href="#锁模块小结" class="headerlink" title="锁模块小结"></a>锁模块小结</h4><p>常见问题：</p>
<ul>
<li>MyISAM与InnoDB关于锁方面的区别是什么</li>
<li>数据库事务的四大特性</li>
<li>事务隔离级别以及各级别下的并发访问问题</li>
<li>InnoDB可重复读隔离级别下如何避免幻读</li>
<li>RC、RR级别下的InnoDB的非阻塞读如何实现</li>
</ul>
<h3 id="关键语法"><a href="#关键语法" class="headerlink" title="关键语法"></a>关键语法</h3><p>很多复杂的SQL都和查询、筛选相关。</p>
<ul>
<li>GROUP BY</li>
<li>HAVING</li>
<li>统计相关：COUNT, SUM, MAX, MIN, AVG</li>
</ul>
<p>和他们相关的，都是完成一些统计的任务。</p>
<h4 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h4><p>作用：根据给定数据列的每个成员，对查询结果进行分组统计，最终得到一个分组汇总表。</p>
<p>条件：</p>
<ul>
<li>满足”SELECT子句中的列明必须为分组列或列函数”。说白了意思就是，如果你用了GROUP BY,那么查询的结果要么包含GRAOUP BY使用的列，要么带有统计函数(COUNT, SUM, MAX ,MIN ,AVG等)相关的列。而且这个条件只针对同一张表成立。</li>
<li>列函数对于GROUP BY子句定义的每个组返回一个结果</li>
</ul>
<p>举一个例子，首先看举例的三张表之间的关系</p>
<p><img src="https://s2.ax1x.com/2020/02/24/38uMnS.png" alt="38uMnS.png"></p>
<p>其中学生通过主键student_id与score连接，course通过主键course_id和score连接。</p>
<p>不同表的建立语句：</p>
<p>student表：<br><img src="https://s2.ax1x.com/2020/02/24/38voG9.png" alt="38voG9.png"></p>
<p>course表：<br><img src="https://s2.ax1x.com/2020/02/24/38v7x1.png" alt="38v7x1.png"></p>
<p>score表：<br><img src="https://s2.ax1x.com/2020/02/24/38vT2R.png" alt="38vT2R.png"></p>
<p>完成查询的功能：</p>
<blockquote>
<p>查询所有同学的学号、选课数、总成绩</p>
</blockquote>
<p>解决这类写SQL问题的技巧之一，就是根据题目描述，写出所有可能的子SQL，然后再把这些子SQL拼接起来，达到要求。</p>
<p>比如这里要查询所有同学，所以要用学生表的主键: group by student_id</p>
<p>然后需要查询学生的学号、选课数、总成绩，所以需要select:<br>select student_id,count(course_id),sum(score);</p>
<p>而同时出现了学生、课程和分数的表，只有score表：from score</p>
<p>整合上面这些子SQL，可以写出：</p>
<blockquote>
<p>select student_id,count(course_id),sum(score)</p>
<p>from score</p>
<p>group by student_id;</p>
</blockquote>
<p>group by 会按照student_id把学生进行分组，然后count()和sum()函数会针对每个组进行聚合计算。</p>
<p>列函数会对于group by子句定义的每个组各返回一个结果。</p>
<p>如果选了group by,那么你的select 语句中选出的列要么是你group by里用到的列，要么就是带有之前sum,count等列函数的列。<font color=#FF0000>但是这个理论只针对同一张表有效。</font></p>
<p>比如要解决这个查询问题：</p>
<blockquote>
<p>查询所有同学的学号、姓名、选课数、总成绩</p>
</blockquote>
<p>相比之前的查询，多了一个姓名。此时只从score中查询就不够了，需要联合student表取出列名。</p>
<blockquote>
<p>select s.studnet_id, stu.name, count(s.course_id),sum(s.score)</p>
<p>from</p>
<p>score s, student stu</p>
<p>where</p>
<p>s.studnet_id = stu.student_id</p>
<p>group by s.student_id; </p>
</blockquote>
<p>注意，where一定要写在group by前面，</p>
<p>结合这个新的例子，我们可以知道：group by里面出现某个表的字段，select里面的列要么是该group by里出现的列，要么是别的表的列或者带有函数的列。</p>
<h4 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h4><p>如果没有group by子句，那么having和where是可以互换的。</p>
<ul>
<li>通常与group by一起使用。当它与group by一起使用时，可以放在group by 后面作为过滤的条件。HAVING相当于所有where的操作符</li>
<li>WHERE过滤行，HAVING过滤组</li>
<li>出现在同一sql的顺序：WHERE &gt; GROUP BY &gt; HAVING</li>
</ul>
<p>还是以之前三张表为例，完成这个查询：<strong>查询平均成绩大于60分的同学的学号和平均成绩</strong></p>
<blockquote>
<p>select student_id,avg(score)</p>
<p>from score</p>
<p>group by student_id</p>
<p>having avg(score)&gt;60 </p>
</blockquote>
<p><strong>取出studnet_id为1的学生的成绩情况</strong></p>
<blockquote>
<p>select * from score where student_ir=1;</p>
</blockquote>
<p>下面这个写法结果相同：</p>
<blockquote>
<p>select * from score having student_id=1;</p>
</blockquote>
<p><strong>查询没有学全所有课的同学的学号、姓名</strong></p>
<blockquote>
<p>select studnet_id,name</p>
<p>from</p>
<p>studnet stu,</p>
<p>score s</p>
<p>where stu.studnet_id = s.student_id</p>
<p>group by s.student_id</p>
<p>having count( * )&lt;(select count( * ) from course)</p>
</blockquote>
<p>最后需要结合大量实战题目，才能提升编写SQL的能力和基本功。</p>
]]></content>
      <categories>
        <category>Interview Note</category>
      </categories>
      <tags>
        <tag>DataBase</tag>
        <tag>Interview</tag>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Analysis of LeetCode High Frequency Problems IV</title>
    <url>/2020/02/12/Analysis-of-LeetCode-High-Frequency-Problems-IV/</url>
    <content><![CDATA[<p>详细讲解LeetCode考察较多的3道题目：336、340、407。</p>
<a id="more"></a>

<h2 id="336-Palindrome-Pairs-回文对-Hard"><a href="#336-Palindrome-Pairs-回文对-Hard" class="headerlink" title="336.Palindrome Pairs(回文对)(Hard)"></a><a href="https://leetcode-cn.com/problems/palindrome-pairs/" target="_blank" rel="noopener">336.Palindrome Pairs(回文对)(Hard)</a></h2><h2 id="340-longest-Substring-with-at-most-k-distinct-characters-至多包含K个不同字符的最长子串-Hard"><a href="#340-longest-Substring-with-at-most-k-distinct-characters-至多包含K个不同字符的最长子串-Hard" class="headerlink" title="340.longest Substring with at most k distinct characters(至多包含K个不同字符的最长子串)(Hard)"></a><a href="https://leetcode-cn.com/problems/longest-substring-with-at-most-k-distinct-characters/" target="_blank" rel="noopener">340.longest Substring with at most k distinct characters(至多包含K个不同字符的最长子串)(Hard)</a></h2><h2 id="407-Trapping-rain-water-ii-接雨水-II-Hard"><a href="#407-Trapping-rain-water-ii-接雨水-II-Hard" class="headerlink" title="407.Trapping rain water ii(接雨水 II)(Hard)"></a><a href="https://leetcode-cn.com/problems/trapping-rain-water-ii/" target="_blank" rel="noopener">407.Trapping rain water ii(接雨水 II)(Hard)</a></h2>]]></content>
      <categories>
        <category>Algorithms Note</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Analysis of LeetCode High Frequency Problems III</title>
    <url>/2020/02/12/Analysis-of-LeetCode-High-Frequency-Problems-III/</url>
    <content><![CDATA[<p>详细讲解LeetCode考察较多的3道题目：10、84、28。</p>
<a id="more"></a>

<h2 id="10-regular-expression-matching-正则表达式匹配-Hard"><a href="#10-regular-expression-matching-正则表达式匹配-Hard" class="headerlink" title="10.regular-expression-matching(正则表达式匹配)(Hard)"></a><a href="https://leetcode-cn.com/problems/regular-expression-matching/" target="_blank" rel="noopener">10.regular-expression-matching(正则表达式匹配)(Hard)</a></h2><h2 id="84-Largest-Rectangle-in-Histogram-柱状图中最大的矩形-Hard"><a href="#84-Largest-Rectangle-in-Histogram-柱状图中最大的矩形-Hard" class="headerlink" title="84.Largest Rectangle in Histogram(柱状图中最大的矩形)(Hard)"></a><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">84.Largest Rectangle in Histogram(柱状图中最大的矩形)(Hard)</a></h2><h2 id="28-implement-strstr-实现strStr-Easy"><a href="#28-implement-strstr-实现strStr-Easy" class="headerlink" title="28.implement-strstr(实现strStr())(Easy)"></a><a href="https://leetcode-cn.com/problems/implement-strstr/" target="_blank" rel="noopener">28.implement-strstr(实现strStr())(Easy)</a></h2>]]></content>
      <categories>
        <category>Algorithms Note</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Analysis of LeetCode High Frequency Problems II</title>
    <url>/2020/02/12/Analysis-of-LeetCode-High-Frequency-Problems-II/</url>
    <content><![CDATA[<p>详细讲解LeetCode考察较多的3道题目：56、435、269。</p>
<a id="more"></a>


<h2 id="56-Merge-Intervals-合并区间-Mid"><a href="#56-Merge-Intervals-合并区间-Mid" class="headerlink" title="56.Merge Intervals(合并区间)(Mid)"></a><a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">56.Merge Intervals(合并区间)(Mid)</a></h2><h2 id="435-Non-Overlapping-Intervals-无重叠区间-Mid"><a href="#435-Non-Overlapping-Intervals-无重叠区间-Mid" class="headerlink" title="435.Non Overlapping Intervals(无重叠区间)(Mid)"></a><a href="https://leetcode-cn.com/problems/non-overlapping-intervals" target="_blank" rel="noopener">435.Non Overlapping Intervals(无重叠区间)(Mid)</a></h2><h2 id="269-Alien-Dictionary-火星词典-Hard"><a href="#269-Alien-Dictionary-火星词典-Hard" class="headerlink" title="269.Alien Dictionary(火星词典)(Hard)"></a><a href="https://leetcode-cn.com/problems/alien-dictionary/" target="_blank" rel="noopener">269.Alien Dictionary(火星词典)(Hard)</a></h2>]]></content>
      <categories>
        <category>Algorithms Note</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Analysis of LeetCode High Frequency Problems I</title>
    <url>/2020/02/12/Analysis-of-LeetCode-High-Frequency-Problems-I/</url>
    <content><![CDATA[<p>详细讲解LeetCode考察较多的3道题目：03、04、23。</p>
<a id="more"></a>

<h2 id="3-Longest-Substring-Without-Repeating-Characters-无重复字符的最长子串-Mid"><a href="#3-Longest-Substring-Without-Repeating-Characters-无重复字符的最长子串-Mid" class="headerlink" title="3.Longest Substring Without Repeating Characters(无重复字符的最长子串)(Mid)"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3.Longest Substring Without Repeating Characters(无重复字符的最长子串)(Mid)</a></h2><p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">Input: <span class="string">"abcabcbb"</span></span><br><span class="line">Output: <span class="number">3</span> </span><br><span class="line">Explanation: The answer <span class="keyword">is</span> <span class="string">"abc"</span>, <span class="keyword">with</span> <span class="keyword">the</span> <span class="built_in">length</span> <span class="keyword">of</span> <span class="number">3.</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">Input: <span class="string">"bbbbb"</span></span><br><span class="line">Output: <span class="number">1</span></span><br><span class="line">Explanation: The answer <span class="keyword">is</span> <span class="string">"b"</span>, <span class="keyword">with</span> <span class="keyword">the</span> <span class="built_in">length</span> <span class="keyword">of</span> <span class="number">1.</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Input: <span class="string">"pwwkew"</span></span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is <span class="string">"wke"</span>, with the length of 3. </span><br><span class="line">            <span class="built_in"> Note </span>that the answer must be a substring, <span class="string">"pwke"</span> is a subsequence <span class="keyword">and</span> <span class="keyword">not</span> a substring.</span><br></pre></td></tr></table></figure>

<hr>
<p>解：<strong>解法一：暴力法</strong></p>
<p>找到所有子串，然后每一个子串都一个一个地去判断是否有重复的字符。</p>
<p>要分析这个方法的时间复杂度，首先我们需要弄清楚一些问题，假设字符串长度为n，那么它有多少个非空子串？</p>
<p>答案是 n*(n+1)/2 个。</p>
<p>怎么计算出来的？</p>
<ul>
<li>长度为1的子串，有n个</li>
<li>长度为2的子串，有n-1个</li>
<li>长度为3的子串，有n-2个</li>
</ul>
<p>…</p>
<ul>
<li>长度为k的子串，有n-k+1个</li>
<li>当k=n时，n-k+1=1，即长度为n的子串就是1个</li>
</ul>
<p>所有情况相加，可以得到：<br>n+(n-1)+(n-2)+(n-3)+…+2+1 = n(n+1)/2<br>算上空字符串，一共有：(n(n+1)/2) + 1</p>
<p>在这里可以进行对比，子串和子序列的区别。比如，对于长度为n的字符串，一共有多少子序列？</p>
<p>答案是2^n</p>
<p>怎么计算得到的？</p>
<ul>
<li><p>子序列不同于子串</p>
</li>
<li><p>子序列中的元素不需要相互挨着</p>
</li>
<li><p>长度为1的子序列有n个，即：C(1,n)</p>
</li>
<li><p>长度为2的子序列有C(2,n)个</p>
</li>
<li><p>长度为3的子序列有C(3,n)个</p>
</li>
</ul>
<p>…</p>
<ul>
<li>长度为k的子序列有C(k,n)个</li>
<li>所有子序列的个数(包括空序列)为：C(0,n) + C(1,n) + C(2,n) + C(3,n) + … + C(n,n) = 2^n</li>
</ul>
<p>这里有关统计字符串的子串和子序列的过程和方法，和结果，务必熟悉和记下来，对于分析各种问题能有帮助。</p>
<p>如果对所有的子串进行判断，从每个子串里寻找最长且没有重复字符的，复杂度为：O(n* (n+1)/2 * n) = O(n^3)</p>
<p>当然，这不是最好的办法。</p>
<p><strong>解法二：线性法</strong></p>
<ul>
<li>把每次遍历到的字符放入到一个哈希集合中，这样每次判断当前遍历过的内容中是否包含下一个要遍历的字符的时候，用哈希表的contains方法，时间复杂度为O(1),比不放到哈希表中的O(n)的速度能够得到提高。</li>
</ul>
<p>具体解法：</p>
<ul>
<li>定义一个哈希集合set</li>
<li>从给定字符串的头开始，每次检查当前字符是否在集合内。如果不在，说明该字符不会造成冲突和重复，将其加入到集合中，并统计当前集合长度，或许为最长子串</li>
</ul>
<p>如果出现了重复的子串，处理方法是定义两个指针，i为慢指针，j为快指针。</p>
<p>当 j 遇到一个重复出现的字符时，我们从慢指针开始一个一个地将 i 指针指向的字符从集合中删除，然后判断是否可以把新字符加入到集合而不会重复。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="keyword">String</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义一个哈希集合set,初始化结果max为0</span></span><br><span class="line">        Set&lt;Character&gt; <span class="built_in">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 利用快慢指针i(慢)和j(快)扫描一遍字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; j &lt; s.length(); j++) &#123;</span><br><span class="line">            <span class="comment">// 如果快指针指向的字符已经出现在哈希集合中,不断尝试将慢指针指向的字符从哈希集合中删除</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">set</span>.contains(s.charAt(j))) &#123;</span><br><span class="line">                <span class="built_in">set</span>.<span class="built_in">remove</span>(s.charAt(i));</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 当快指针的字符终于能加入到哈希集合的时候，更新结果max</span></span><br><span class="line">            <span class="built_in">set</span>.add(s.charAt(j));</span><br><span class="line">            <span class="built_in">max</span> = Math.<span class="built_in">max</span>(<span class="built_in">max</span>, <span class="built_in">set</span>.<span class="built_in">size</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历完毕后，返回结果max</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度分析：O(n)。使用了快慢指针策略，字符串最多被遍历两次。快指针会被添加到哈希表集合，慢指针遇到的字符会从哈希集合中删除。哈希集合操作时间为O(1)，因此整个算法复杂度为：n * O(1) + n*O(1) = O(n)</li>
<li>空间复杂度分析：O(n)。由于使用到哈希集合，最坏的情况下，即给定的字符串没有任何重复的字符，我们需要把每个字符都加入集合。</li>
</ul>
<p><strong>解法三：优化的线性法</strong></p>
<p>基于方法二的线性法。也就是，如果我们在遍历过程中遇到了set已经有的字符的时候，如何不让慢指针一步一步移动，而是直接移动到重复元素的后面呢？这样可以大大减少比较次数。</p>
<p>这样一来我们需要能够记录每个字符出现的下标位置，可以用哈希表记录，因为查找过程时间复杂度也是O(1)</p>
<p>而且此时，我们不能像之前一样去数哈希集合的元素作为max的结果。比如可能出现一种情况，就是当前快指针j遍历到的元素在之前已经出现过了，那么此时不能让i又跳回到前面去呀！所以i的值需要有max计算得到：i = Math.max(i, map.get(s.charAt(j) + 1));</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="keyword">String</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义一个哈希表map用来记录上次某字符出现的位置,初始化结果max为0</span></span><br><span class="line">        Map&lt;Character, Integer&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 利用快慢指针i(慢)和j(快)扫描一遍字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; j &lt; s.length(); j++) &#123;</span><br><span class="line">            <span class="comment">// 如果发现快指针所对应的字符已经出现过，慢指针就进行跳跃</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.containsKey(s.charAt(j))) &#123;</span><br><span class="line">                i = Math.<span class="built_in">max</span>(i, <span class="built_in">map</span>.<span class="built_in">get</span>(s.charAt(j)) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 把快指针所对应的字符添加到哈希表中，更新结果max</span></span><br><span class="line">            <span class="built_in">map</span>.<span class="built_in">put</span>(s.charAt(j), j);</span><br><span class="line">            <span class="built_in">max</span> = Math.<span class="built_in">max</span>(<span class="built_in">max</span>, j - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历完毕后，返回结果max</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-Median-of-Two-Sorted-Arrays-寻找两个有序数组的中位数-Hard"><a href="#4-Median-of-Two-Sorted-Arrays-寻找两个有序数组的中位数-Hard" class="headerlink" title="4.Median of Two Sorted Arrays(寻找两个有序数组的中位数)(Hard)"></a><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays" target="_blank" rel="noopener">4.Median of Two Sorted Arrays(寻找两个有序数组的中位数)(Hard)</a></h2><p>There are two sorted arrays <strong>nums1</strong> and <strong>nums2</strong> of size m and n respectively.</p>
<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
<p>You may assume <strong>nums1</strong> and <strong>nums2</strong> cannot be both empty.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">nums1 = [<span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">nums2 = [<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">The median <span class="keyword">is</span> <span class="number">2.0</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">nums1 = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">nums2 = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">The median <span class="keyword">is</span> (<span class="number">2</span> + <span class="number">3</span>)/<span class="number">2</span> = <span class="number">2.5</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：解法一：暴力法</p>
<ul>
<li>利用归并排序的思想将它们合并成一个长度为m+n的有序数组</li>
<li>合并的时间复杂度为 m+n，从中选取中位数，整体时间复杂度为O(m+n)，要大于题目要求的O(log(m+n))，不符合要求</li>
</ul>
<p>解法二：切分法，比较偏重数学</p>
<p>这种方法需要考虑m+n为奇数还是偶数。假设m+n=L，</p>
<ul>
<li>如果L为奇数，即两个数组元素总个数为奇数，则中位数为第：int(L/2)+1小的数。</li>
<li>如果L为偶数，则中位数为第 int(L/2) 小于int(L/2)+1小的数求和的平均值。</li>
</ul>
<p>所以我们的问题转变成了，在两个有序数组中寻找第k小的数，f(k)</p>
<ul>
<li>当L为奇数时，若令 k=L/2，则结果为f(k+1)</li>
<li>当L为偶数时，结果为：(f(k) + f(k+1))/2</li>
</ul>
<p>那么接下来的问题是，怎么从两个排好序的数组中找到第k小的数呢？</p>
<p>假设nums1[] = {a0, a1, a2, a3, a4}、nums2[] = {b0, b1, b2, b3}<br>举例，如果从nums1和nums2中分别取出k1和k2个元素：</p>
<p><img src="https://s2.ax1x.com/2020/02/17/3iuZt0.png" alt="3iuZt0.png"></p>
<ol>
<li>a2=b1，这种算是最舒服的情况了,此时a2或者b1就是我们要找的第k小的数。因为此时我们如果把a0, a1, a2, b0, b1按照大小顺序合并在一起，那么a2和b1肯定排在最后，a0, a1 和b0都排在前面，不需要考虑这三个的大小关系。</li>
<li>a2&lt;b1， 这种情况开始不舒服了，我们无法肯定a2和b1是第五小的数。但是这种情况下我们可以确定，第五小的数一定不会是a0, a1, a2中的一个，同时也不会是b2和b3中的一个。所以，整个的搜索范围可以缩小为：{a3, a4, b0, b1}</li>
<li>a2&gt;b1，我们同样无法肯定a2和b1是第五小的数。但是这种情况下我们可以确定，第五小的数不可能是b0, b1和a3, a4。所以这种情况下，整个搜索范围可以缩小为：{a0, a1, a2, b2, b3}</li>
</ol>
<p>代码：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public double find<span class="constructor">MedianSortedArrays(<span class="params">int</span>[] <span class="params">nums1</span>, <span class="params">int</span>[] <span class="params">nums2</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据两个字符串长度的总和判断如何调用递归函数以及返回结果</span></span><br><span class="line">        <span class="built_in">int</span> m = nums1.length, n = nums2.length;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> k = (m + n) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>((m+n) % <span class="number">2</span><span class="operator"> == </span><span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 当总长度为奇数时，返回正中间的数</span></span><br><span class="line">            return find<span class="constructor">Kth(<span class="params">nums1</span>, 0, <span class="params">m</span>-1, <span class="params">nums2</span>, 0, <span class="params">n</span>-1, <span class="params">k</span>+1)</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当总长度为偶数时，返回两个数的平均值</span></span><br><span class="line">            return (find<span class="constructor">Kth(<span class="params">nums1</span>, 0, <span class="params">m</span>-1, <span class="params">nums2</span>, 0, <span class="params">n</span>-1, <span class="params">k</span>)</span> + </span><br><span class="line">                    find<span class="constructor">Kth(<span class="params">nums1</span>, 0, <span class="params">m</span>-1, <span class="params">nums2</span>, 0, <span class="params">n</span>-1, <span class="params">k</span>+1)</span>)<span class="operator"> / </span><span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进入findKth,这个函数目的是寻找第k小的元素</span></span><br><span class="line">    public double find<span class="constructor">Kth(<span class="params">int</span>[] <span class="params">nums1</span>, <span class="params">int</span> <span class="params">start1</span>, <span class="params">int</span> <span class="params">end1</span>, <span class="params">int</span>[] <span class="params">nums2</span>, <span class="params">int</span> <span class="params">start2</span>, <span class="params">int</span> <span class="params">end2</span>, <span class="params">int</span> <span class="params">k</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> m = end1 - start1 + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> n = end2 - start2 + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果nums1数组的长度大于nums2数组的长度，将二者互换，加快程序结束的速度</span></span><br><span class="line">        <span class="keyword">if</span>(m &gt; n) &#123;</span><br><span class="line">            return find<span class="constructor">Kth(<span class="params">nums2</span>, <span class="params">start2</span>, <span class="params">end2</span>, <span class="params">nums1</span>, <span class="params">start1</span>, <span class="params">end1</span>, <span class="params">k</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当nums1数组长度为0的时候，直接返回nums2数组中第k小的数</span></span><br><span class="line">        <span class="keyword">if</span>(m<span class="operator"> == </span><span class="number">0</span>) &#123;</span><br><span class="line">            return nums2<span class="literal">[<span class="identifier">start2</span> + <span class="identifier">k</span> - <span class="number">1</span>]</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当k == 1时，返回两个数组中的最小值</span></span><br><span class="line">        <span class="keyword">if</span>(k<span class="operator"> == </span><span class="number">1</span>) &#123;</span><br><span class="line">            return <span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>min(nums1<span class="literal">[<span class="identifier">start1</span>]</span>, nums2<span class="literal">[<span class="identifier">start2</span>]</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 分别选两个数组的中间数</span></span><br><span class="line">        <span class="built_in">int</span> na = <span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>min(k/<span class="number">2</span>, m);</span><br><span class="line">        <span class="built_in">int</span> nb = k - na;</span><br><span class="line">        <span class="built_in">int</span> va = nums1<span class="literal">[<span class="identifier">start1</span> + <span class="identifier">na</span> -<span class="number">1</span>]</span>;</span><br><span class="line">        <span class="built_in">int</span> vb = nums2<span class="literal">[<span class="identifier">start2</span> + <span class="identifier">nb</span> -<span class="number">1</span>]</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 比较下两者的大小</span></span><br><span class="line">        <span class="comment">// 如果相等，表明中位数已经找到，返回该值即可</span></span><br><span class="line">        <span class="keyword">if</span>(va<span class="operator"> == </span>vb) &#123;</span><br><span class="line">            return va;</span><br><span class="line">            <span class="comment">// 如果不相等，进行剪枝处理</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(va &lt; vb) &#123;</span><br><span class="line">            return find<span class="constructor">Kth(<span class="params">nums1</span>, <span class="params">start1</span> + <span class="params">na</span>, <span class="params">end1</span>, <span class="params">nums2</span>,<span class="params">start2</span>,  <span class="params">start2</span> + <span class="params">nb</span> - 1, <span class="params">k</span> - <span class="params">na</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            return find<span class="constructor">Kth(<span class="params">nums1</span>, <span class="params">start1</span>, <span class="params">start1</span> + <span class="params">na</span> - 1, <span class="params">nums2</span>, <span class="params">start2</span> + <span class="params">nb</span>, <span class="params">end2</span>, <span class="params">k</span> - <span class="params">nb</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="23-Merge-k-Sorted-Lists-合并K个排序链表-Hard"><a href="#23-Merge-k-Sorted-Lists-合并K个排序链表-Hard" class="headerlink" title="23.Merge k Sorted Lists(合并K个排序链表)(Hard)"></a><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">23.Merge k Sorted Lists(合并K个排序链表)(Hard)</a></h2><p>Merge <em>k</em> sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>,</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>,</span><br><span class="line">  <span class="number">2</span>-&gt;<span class="number">6</span></span><br><span class="line">]</span><br><span class="line">Output: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span></span><br></pre></td></tr></table></figure>
<hr>
<p>解：<strong>解法一：暴力法</strong></p>
<ul>
<li>用一个数组保存所有链表中的数，之后进行排序，再从头到尾将数组遍历，生成一个排好序的链表</li>
<li>假设每个链表平均长度为n,整体时间复杂度为O(nk * log(nk))，偏大</li>
</ul>
<p><strong>解法二：最小堆</strong></p>
<ul>
<li>每次比较k个链表头，时间复杂度为O(k)</li>
<li>对k个链表头创建一个大小为k的最小堆<ul>
<li>创建一个大小为k的最小堆所需时间为O(k)</li>
<li>从堆中取最小的数，所需时间都是O(logk)</li>
<li>如果每个链表平均长度为n，则共有nk个元素，即用大小为k的最小堆过滤nk个元素</li>
<li>整体时间复杂度为O(nk*log(k))</li>
<li>空间复杂度为O(k)，我们有k个list，占据k个空间</li>
</ul>
</li>
</ul>
<p>我们一直维护这个大小为k的最小堆，直到遍历完所有链表的节点</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode mergeKLists(ListNode[] lists) &#123;</span><br><span class="line">        <span class="comment">// 如果输入为[]，边界条件</span></span><br><span class="line">        <span class="keyword">if</span>(lists.length == <span class="number">0</span> || lists == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 利用一个空的链表头方便我们插入节点</span></span><br><span class="line">        ListNode fakeHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>), p = fakeHead;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义一个最小堆来保存k个链表节点</span></span><br><span class="line">        <span class="keyword">int</span> k = lists.length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将k个链表的头放到最小堆中,因为使用ListNode数据结构，所以重新定义比较器</span></span><br><span class="line">        PriorityQueue&lt;ListNode&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k, <span class="keyword">new</span> Comparator&lt;ListNode&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">int</span> compare(ListNode a, ListNode b) &#123;</span><br><span class="line">                <span class="keyword">return</span> a.val - b.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从k个链表中将当前最小节点取出，插入到结果链表中</span></span><br><span class="line">        <span class="comment">// 每条链表都会有一个指针i，这个for把每条链表的第一个加入到小顶堆中</span></span><br><span class="line">        <span class="comment">// 因为本身就有k个链表，所以相当于初始化的步骤</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(lists[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                heap.offer(lists[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 真正使用最小堆的操作，将堆中元素一个一个取出，插入到结果链表中</span></span><br><span class="line">        <span class="keyword">while</span>(!heap.isEmpty()) &#123;</span><br><span class="line">            ListNode node = heap.poll();</span><br><span class="line">            </span><br><span class="line">            p.<span class="keyword">next</span> = node;</span><br><span class="line">            p = p.<span class="keyword">next</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// p是结果链表节点，node是当前遍历的节点</span></span><br><span class="line">            <span class="comment">// 如果当前链表有后续节点，在poll()了它之后自然要访问它后续节点</span></span><br><span class="line">            <span class="keyword">if</span>(node.<span class="keyword">next</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">                heap.offer(node.<span class="keyword">next</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 最后返回结果链表</span></span><br><span class="line">        <span class="keyword">return</span> fakeHead.<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述定义小顶堆的代码也可以用Lambda表达式简化：</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">PriorityQueue&lt;ListNode&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(</span><br><span class="line">    (a,b) -&gt; a.val - b.val</span><br><span class="line">);</span><br></pre></td></tr></table></figure>


<p><strong>解法三：分治法</strong></p>
<p>利用分治思想，非常类似归并排序操作。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主函数非常类似归并排序的过程</span></span><br><span class="line"><span class="keyword">public</span> ListNode mergeKLists(ListNode[] lists, int low, int high) &#123;</span><br><span class="line">    <span class="comment">// 如果输入为[]，边界条件</span></span><br><span class="line">    <span class="keyword">if</span>(lists.length == <span class="number">0</span> || lists == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(low == high) <span class="keyword">return</span> lists[low];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从中间切一刀</span></span><br><span class="line">    int middle = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归地处理坐标和右边的列表，最后合并起来</span></span><br><span class="line">    <span class="keyword">return</span> mergeTwoLists(</span><br><span class="line">        mergeKLists(lists, low, middle),</span><br><span class="line">        mergeKLists(lists, middle + <span class="number">1</span>, high)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ListNode mergeTwoLists(ListNode a, ListNode b) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span>) <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">null</span>) <span class="keyword">return</span> a;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(a.<span class="keyword">val</span> &lt;= b.<span class="keyword">val</span>) &#123;</span><br><span class="line">        a.next = mergeTwoLists(a.next, b);</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    b.next = mergeTwoLists(a, b.next);</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(nk * log(k))</li>
<li>空间复杂度：O(1)，可以直接在链表上进行操作</li>
</ul>
]]></content>
      <categories>
        <category>Algorithms Note</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Practice by Categories Others</title>
    <url>/2020/01/13/LeetCode-Practice-by-Categories-Others/</url>
    <content><![CDATA[<blockquote>
<p>时间像海绵里的水，只要你愿意挤，总还是有的。——鲁迅</p>
</blockquote>
<p>LeetCode其他题目其解决思路和具体代码。</p>
<a id="more"></a>

<h2 id="169-Majority-Element-多数元素-Easy"><a href="#169-Majority-Element-多数元素-Easy" class="headerlink" title="169. Majority Element(多数元素)(Easy)"></a><a href="https://leetcode-cn.com/problems/majority-element/description/" target="_blank" rel="noopener">169. Majority Element(多数元素)(Easy)</a></h2><p>Given an array of size n, find the majority element. The majority element is the element that appears more than <code>⌊ n/2 ⌋</code> times.</p>
<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">Output: <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">Output: <span class="number">2</span></span><br></pre></td></tr></table></figure>
<hr>
<p>解：题目名字是”多数元素”，实际上，就是众数。</p>
<p>思路一：如果你头脑足够灵活，数学感觉足够好，那么实际上抓住一个点就可以：题目问的多数元素，其实不算真正的众数。这里的多数元素出现的次数必须大于 <code>n/2</code> ，所以，如果一个数组中一定有众数，那么这个数组排好序之后，下标为 <code>nums.length/2</code> 的那个元素，就是众数。利用排序，排好序之后返回下标为 <code>nums.length/2</code>的元素，就是这道题需要的结果。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> majorityElement(<span class="built_in">int</span>[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为用到了系统自带的排序方法，所以这种方法的时间复杂度是O(NlogN)。</p>
<p>方法二：开两个变量，result为最后返回的结果，count用于统计，因为按照题目定义，众数出现次数一定大于 n/2 ，所以count只要回到了0，说明当前result不可能是最后的众数。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> majorityElement(<span class="built_in">int</span>[] nums) &#123;</span><br><span class="line">        <span class="built_in">int</span> result = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">0</span>) </span><br><span class="line">                result = num;</span><br><span class="line">            <span class="keyword">if</span>(result != num) </span><br><span class="line">                count --;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                count ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h2 id="7-Reverse-Integer-整数反转-Mid"><a href="#7-Reverse-Integer-整数反转-Mid" class="headerlink" title="7. Reverse Integer(整数反转)(Mid)"></a><a href="https://leetcode-cn.com/problems/reverse-integer/" target="_blank" rel="noopener">7. Reverse Integer(整数反转)(Mid)</a></h2><p>Given a 32-bit signed integer, reverse digits of an integer.</p>
<p><strong>Example 1</strong>:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="number">123</span></span><br><span class="line"><span class="attr">Output:</span> <span class="number">321</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2</strong>:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="number">-123</span></span><br><span class="line"><span class="attr">Output:</span> <span class="number">-321</span></span><br></pre></td></tr></table></figure>
<p><strong>Example 3</strong>:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="number">120</span></span><br><span class="line"><span class="attr">Output:</span> <span class="number">21</span></span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong><br>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31,  2^31 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p>
<hr>
<p>解：x最大可以取2^31-1，但是当x取最大值的时候，再reverse之后的数字大小会超出原本Integer能够保存的最大2^31-1的范围了，会报错移除。所以我们需要考虑到如何解决这个溢出的问题。</p>
<p>需要注意：1，翻转后的数字是否会溢出、2，有关负数的处理</p>
<ol>
<li><p>如果不发生溢出，每次的当前结果可以得到是<code>x0*10+y=x1</code>，x1为计算之后得到的新的值。此时我们可以转换一下，解出来x的值：<code>x=(x1-y)/10</code>，可以想到，如果整个计算结果不发生溢出，这个式子是成立的。但是如果计算结果发生了溢出(比如到了2^31-1)，那么这个式子会不成立，我们可以通过这个方式检查当前数字反转之后是否会溢出。</p>
</li>
<li><p>比如传入的是-123，那么<code>-123/10=-12</code>，而且<code>-123%10=-3</code>，然后<code>result*10+x%10</code>这个公式实际上也是负数之间的计算，所以对于负数，不用单独考虑，就用一样的公式计算即可。</p>
</li>
</ol>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> reverse(<span class="built_in">int</span> x) &#123;</span><br><span class="line">        <span class="built_in">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 用一个公式的正和反是否相等来判断当前数字是否溢出</span></span><br><span class="line">            <span class="comment">// result表示以前的数字，乘10再加上新来的数字即为翻转后的数newReverse</span></span><br><span class="line">            <span class="built_in">int</span> newReverse = result * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>((newReverse - x % <span class="number">10</span>) / <span class="number">10</span> != result) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 溢出则返回0</span></span><br><span class="line">            result = newReverse;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-Palindrome-Number-回文数-Mid"><a href="#9-Palindrome-Number-回文数-Mid" class="headerlink" title="9. Palindrome Number(回文数)(Mid)"></a><a href="https://leetcode-cn.com/problems/palindrome-number/" target="_blank" rel="noopener">9. Palindrome Number(回文数)(Mid)</a></h2><p>Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="number">121</span></span><br><span class="line"><span class="attr">Output:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">Input: <span class="number">-121</span></span><br><span class="line">Output: <span class="literal">false</span></span><br><span class="line">Explanation: From left <span class="built_in">to</span> <span class="literal">right</span>, <span class="keyword">it</span> reads <span class="number">-121.</span> From <span class="literal">right</span> <span class="built_in">to</span> left, <span class="keyword">it</span> becomes <span class="number">121</span>-. Therefore <span class="keyword">it</span> is <span class="keyword">not</span> <span class="keyword">a</span> palindrome.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">Output:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">Explanation:</span> <span class="string">Reads</span> <span class="number">01</span> <span class="string">from</span> <span class="string">right</span> <span class="string">to</span> <span class="string">left.</span> <span class="string">Therefore</span> <span class="string">it</span> <span class="string">is</span> <span class="string">not</span> <span class="string">a</span> <span class="string">palindrome.</span></span><br></pre></td></tr></table></figure>

<p><strong>Follow up:</strong></p>
<p>Coud you solve it without converting the integer to a string?</p>
<hr>
<p>解：为了避免溢出问题(如果给的数字本身不是回文，翻转之后有可能大于int.MAX,造成溢出)，直接比较反转的int数的一半即可。</p>
<p>首先要处理临界情况，所有的负数都不可能是回文(这就可以过滤到很多啦！)。</p>
<p>后面的操作就是取出来数字了，取个位可以用对10取余，取十位可以用除以10之后再对10取余。</p>
<p>判断是否到了原始数字的一半，可以让原始数字除以10，再让反转后的数字乘上10。此时如果原始数字小于反转后的数字，就意味着我们已经处理了一半位数的数字了。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span>ean isPalindrome(<span class="built_in">int</span> x) &#123;</span><br><span class="line">        <span class="comment">// 处理特殊情况</span></span><br><span class="line">        <span class="comment">// 所有负数都一定不是回文数</span></span><br><span class="line">        <span class="comment">// 如果某一个数字最后一位是0，那么如果它是回文数，</span></span><br><span class="line">        <span class="comment">// 那么开头也一定要是0，只有0符合</span></span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> revertedNumber  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( x &gt; revertedNumber ) &#123;</span><br><span class="line">            revertedNumber  = revertedNumber  * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x = x/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。</span></span><br><span class="line">        <span class="comment">// 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，</span></span><br><span class="line">        <span class="comment">// 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。</span></span><br><span class="line">        <span class="keyword">return</span> (x == revertedNumber  || x == revertedNumber /<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(log10(N))，因为每次迭代，我们会将输入除以10，因此时间复杂度为O(log10(N))</li>
<li>空间复杂度：O(1)</li>
</ul>
<h2 id="1109-Corporate-Flight-Bookings-航班预订统计-Mid"><a href="#1109-Corporate-Flight-Bookings-航班预订统计-Mid" class="headerlink" title="1109. Corporate Flight Bookings(航班预订统计)(Mid)"></a><a href="https://leetcode-cn.com/problems/corporate-flight-bookings/" target="_blank" rel="noopener">1109. Corporate Flight Bookings(航班预订统计)(Mid)</a></h2><p>There are <code>n</code> flights, and they are labeled from <code>1</code> to <code>n</code>.</p>
<p>We have a list of flight bookings.  The <code>i</code>-th booking <code>bookings[i] = [i, j, k]</code> means that we booked <code>k</code> seats from flights labeled <code>i</code> to <code>j</code> inclusive.</p>
<p>Return an array <code>answer</code> of length <code>n</code>, representing the number of seats booked on each flight in order of their label.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: bookings = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">20</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">25</span>]], n = <span class="number">5</span></span><br><span class="line">Output: [<span class="number">10</span>,<span class="number">55</span>,<span class="number">45</span>,<span class="number">25</span>,<span class="number">25</span>]</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= bookings.length &lt;= 20000</code></li>
<li><code>1 &lt;= bookings[i][0] &lt;= bookings[i][1] &lt;= n &lt;= 20000</code></li>
<li><code>1 &lt;= bookings[i][2] &lt;= 10000</code></li>
</ul>
<hr>
<p>解：这道题利用很经典的”上下车”的思路，可以把<code>booking[i]=[i, j, k]</code>理解成在<code>i</code>站上车<code>k</code>人，这些人乘坐到了第<code>j</code>站，然后在<code>j+1</code>站下车，我们要返回的是按照顺序的每一站上车的人数。</p>
<p>根据上面的思路，定义一个<code>counter[]</code>数组来记录每站人数的变化，<strong><code>counter[i]</code>表示第i+1站</strong>。遍历<code>bookings[],bookings[i]=[i,j,k]</code>表示在i站增加<code>k</code>人,即<code>counter[i-1] += k</code>，在<code>j+1</code>站减少<code>k</code>人，即<code>counter[j] -= k</code></p>
<p>最后遍历counter[]数组，得到每站的总人数：每站的总人数为前一站人数加上当前人数变化：counter[i] += counter[i-1]</p>
<p>重点：第i站上车、第j+1站下车。一开始counter只用于记录某一站人数的变化，后面counter用于保存每一站总共的人数。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>[] corpFlightBookings(<span class="built_in">int</span>[][] bookings, <span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="comment">// 需要注意：counter记录的是人数变化量</span></span><br><span class="line">        <span class="built_in">int</span>[] counter = new <span class="built_in">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span>[] booking : bookings) &#123;</span><br><span class="line">            <span class="comment">// counter[i]表示第i-1站上车，上车人数是booking[2]</span></span><br><span class="line">            counter[booking[<span class="number">0</span>] - <span class="number">1</span>] += booking[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(booking[<span class="number">1</span>] &lt; n) &#123; <span class="comment">// 如果在最后一站或者最后一站之前下车，就要减去</span></span><br><span class="line">                counter[booking[<span class="number">1</span>]] -= booking[<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 统计最后每一站的人数的结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            counter[i] += counter[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n),n是航班的数量</li>
<li>空间复杂度：O(n)</li>
</ul>
<h2 id="135-Candy-分发糖果-Hard"><a href="#135-Candy-分发糖果-Hard" class="headerlink" title="135. Candy(分发糖果)(Hard)"></a><a href="https://leetcode-cn.com/problems/candy/" target="_blank" rel="noopener">135. Candy(分发糖果)(Hard)</a></h2><p>There are <em>N</em> children standing in a line. Each child is assigned a rating value.</p>
<p>You are giving candies to these children subjected to the following requirements:</p>
<ul>
<li>Each child must have at least one candy.</li>
<li>Children with a higher rating get more candies than their neighbors.</li>
</ul>
<p>What is the minimum candies you must give?</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>]</span><br><span class="line">Output: <span class="number">5</span></span><br><span class="line">Explanation: You can allocate to the first, second <span class="keyword">and</span> third child with <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span> candies respectively.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">Output: <span class="number">4</span></span><br><span class="line">Explanation: You can allocate <span class="built_in">to</span> <span class="keyword">the</span> <span class="keyword">first</span>, <span class="keyword">second</span> <span class="keyword">and</span> <span class="keyword">third</span> child <span class="keyword">with</span> <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span> candies respectively.</span><br><span class="line">             The <span class="keyword">third</span> child gets <span class="number">1</span> candy because <span class="keyword">it</span> satisfies <span class="keyword">the</span> above <span class="literal">two</span> conditions.</span><br></pre></td></tr></table></figure>

<hr>
<p>解：需要注意题目说的是，评分高的children分到的candy是比他的<strong>neighbors</strong>多，而不是比其他所有评分比他低的小孩多</p>
<p>一个比较巧妙的方法是，可以从左往右和从右往左两次遍历，改变当前结果数组candy需要遵循这个公式：<code>candy[i] = Math.max(candy[i],candy[i+1]+1)</code></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> candy(<span class="built_in">int</span>[] ratings) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ratings == <span class="literal">null</span> || ratings.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> len = ratings.length;</span><br><span class="line">        <span class="comment">// 最后的结果数组</span></span><br><span class="line">        <span class="built_in">int</span>[] result = new <span class="built_in">int</span>[len];</span><br><span class="line">        <span class="comment">// 初始化每个小孩至少有一个糖果</span></span><br><span class="line">        Arrays.fill(result, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 然后开始遍历，一次从前往后，一次从后往前</span></span><br><span class="line">        <span class="comment">// 两次遍历的过程中第一个都不用管，因为在下一次遍历中会遍历到的</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从左往右,从第2个小孩开始直到最后一个</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前小孩评分比他右边的小孩高，他分到的糖果数</span></span><br><span class="line">            <span class="comment">// 就比他右边的小孩多1个</span></span><br><span class="line">            <span class="keyword">if</span>(ratings[i] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                result[i] = result[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从右往左，从倒数第二个小孩开始直到第一个</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 如果当前小孩评分比他左边小孩低，他左边小孩分到的</span></span><br><span class="line">            <span class="comment">// 糖果数是其本身存储的值和当前右边小孩糖果数+1的最大值</span></span><br><span class="line">            <span class="keyword">if</span>(ratings[i] &gt; ratings[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                result[i] = Math.max(result[i], result[i + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> temp : result) sum += temp;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="146-LRU-Cache-LRU缓存机制-Mid"><a href="#146-LRU-Cache-LRU缓存机制-Mid" class="headerlink" title="146. LRU Cache(LRU缓存机制)(Mid)"></a><a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">146. LRU Cache(LRU缓存机制)(Mid)</a></h2><p>Design and implement a data structure for <strong>Least Recently Used (LRU)</strong> cache. It should support the following operations: <code>get</code> and <code>put</code>.</p>
<p><code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br><code>put(key, value)</code> - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</p>
<p>The cache is initialized with a <strong>positive</strong> capacity.</p>
<p><strong>Follow up:</strong></p>
<p>Could you do both operations in <strong>O(1)</strong> time complexity?</p>
<p><strong>Example:</strong></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">LRUCache <span class="keyword">cache</span> = new LRUCache( <span class="number">2</span> <span class="comment">/* capacity */</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">cache</span>.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">cache</span>.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">cache</span>.get(<span class="number">1</span>);       // <span class="keyword">returns</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">cache</span>.put(<span class="number">3</span>, <span class="number">3</span>);    // evicts key <span class="number">2</span></span><br><span class="line"><span class="keyword">cache</span>.get(<span class="number">2</span>);       // <span class="keyword">returns</span> <span class="number">-1</span> (<span class="keyword">not</span> <span class="built_in">found</span>)</span><br><span class="line"><span class="keyword">cache</span>.put(<span class="number">4</span>, <span class="number">4</span>);    // evicts key <span class="number">1</span></span><br><span class="line"><span class="keyword">cache</span>.get(<span class="number">1</span>);       // <span class="keyword">returns</span> <span class="number">-1</span> (<span class="keyword">not</span> <span class="built_in">found</span>)</span><br><span class="line"><span class="keyword">cache</span>.get(<span class="number">3</span>);       // <span class="keyword">returns</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">cache</span>.get(<span class="number">4</span>);       // <span class="keyword">returns</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：本质上，这个替换算法和现在的推荐系统有异曲同工之妙。</p>
<p>推荐算法就是根据之前元素被使用的频次和被使用的时间，来预测新来的元素为某一个老元素的概率是多少。</p>
<p>现代计算机中，替换算法越来越使用人工智能来做了，而不是简单基于逻辑式的公式。</p>
<p>LRU cache源自于用得非常多的缓存的思想。它有两个比较重要的策略：大小和替换策略。除了LRU(Least Recently Used)，还有一种可以和它相似的，只是替换策略不同的缓存机制：LFU(Least Frequently Used)，具体区别可以从名字中看出。</p>
<p>按照题目的要求，我们自己完成的LRU cache应当保证<strong>查询</strong>与<strong>修改</strong>的时间复杂度都为O(1)。</p>
<p>如果最朴素的，全部自己实现，那么就是哈希表加双向链表。这样就训练一下双向链表怎么写。</p>
<p>所有双向链表或者单向链表的题目，没有巧，就是多练，即可。</p>
<p>在现实工作中，其实不太可能去手写一个链表、map、set或者排序，都是有现成的库。</p>
<p>有些公司可能比较刻板，需要多练一些基本功。</p>
<p>官方题解中，给出了两种解法，<a href="https://leetcode-cn.com/problems/lru-cache/solution/lru-huan-cun-ji-zhi-by-leetcode/" target="_blank" rel="noopener">详情可以点击这里</a></p>
<p>方法一：使用<strong>有序字典</strong>这个数据结构，它综合了哈希表和链表。对于java，系统使用了LinkedHashMap这个类实现；对于Python，系统使用了OrderedDict实现字典序。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">LRUCache</span> <span class="symbol">extends</span> <span class="symbol">LinkedHashMap</span>&lt;<span class="symbol">Integer, <span class="symbol">Integer</span></span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> capacity;</span><br><span class="line">    <span class="keyword">public</span> LRUCache(<span class="built_in">int</span> capacity) &#123;</span><br><span class="line">        <span class="keyword">super</span>(capacity, <span class="number">0.75</span>F, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> <span class="keyword">get</span>(<span class="built_in">int</span> key) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getOrDefault(key, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> put(<span class="built_in">int</span> key, <span class="built_in">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">super</span>.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">bool</span>ean removeEldestEntry(Map.Entry&lt;Integer, Integer&gt; eldest) &#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; capacity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p><strong>拓展:</strong>linkedhashmap和hashmap有什么区别？<br>HashMap就只是一个哈希表，键值对对应，最多允许一条记录的键值为Null，而且HashMap不支持线程同步，即任一时刻如果多个线程同时写HashMap，可能导致数据的不一致性。如果需要同步，对于HashMap，可以用Collections的synchronizedMap方法使HashMap拥有同步的能力。</p>
<p>LinkedHashMap也是一个HashMap，<strong>但是它内部维持了一个双向链表</strong>，可以保持顺序。</p>
<p>总之，LinkedHashMap的内部实现原理，就是一个双向的LinkedList+HashMap,所以名字是：LinkedHashMap。</p>
]]></content>
      <categories>
        <category>Algorithms Note</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Practice by Categories String Algorithm</title>
    <url>/2020/01/13/LeetCode-Practice-by-Categories-String-Algorithm/</url>
    <content><![CDATA[<blockquote>
<p>世界上最快乐的事，莫过于为理想而奋斗——苏格拉底</p>
</blockquote>
<p>LeetCode字符串相关题目，其解决思路和具体代码。</p>
<a id="more"></a>

<h2 id="面试题：如何把一个String类型的ip地址保存到一个int类型的整型数组里？注意输入的String可能含有非法字符，比如空格等。"><a href="#面试题：如何把一个String类型的ip地址保存到一个int类型的整型数组里？注意输入的String可能含有非法字符，比如空格等。" class="headerlink" title="面试题：如何把一个String类型的ip地址保存到一个int类型的整型数组里？注意输入的String可能含有非法字符，比如空格等。"></a>面试题：如何把一个String类型的ip地址保存到一个int类型的整型数组里？注意输入的String可能含有非法字符，比如空格等。</h2><p>解：传入的String本身已经有分隔符”.”分好了，所以这道题不需要额外做LeetCode93题那样的额外的IP地址复原操作，直接利用位运算保存到int里面即可。</p>
<p><strong>当然，后面面试官可能会加大难度，这时候就要去做LeetCode93题那样的复原工作了</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">IPV4ToInt</span><span class="params">(<span class="keyword">String</span> ipv4_string)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 过滤非法字符</span></span><br><span class="line">		<span class="keyword">String</span> ipv4_string0 = ipv4_string.replaceAll(<span class="string">"\\s+"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 切分获取IP各段</span></span><br><span class="line">		<span class="keyword">String</span>[] ipv4_string1 = ipv4_string0.split(<span class="string">"\\."</span>);</span><br><span class="line">		<span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = ipv4_string1.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">			<span class="keyword">int</span> sliceTemp = Integer.<span class="built_in">parseInt</span>(ipv4_string1[i]) &lt;&lt; <span class="number">8</span> * i;</span><br><span class="line">			result |= sliceTemp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="125-Valid-Palindrome-验证回文串-Easy"><a href="#125-Valid-Palindrome-验证回文串-Easy" class="headerlink" title="125.Valid Palindrome(验证回文串)(Easy)"></a><a href="https://leetcode-cn.com/problems/valid-palindrome/" target="_blank" rel="noopener">125.Valid Palindrome(验证回文串)(Easy)</a></h2><p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p>
<p><strong>Note</strong>: For the purpose of this problem, we define empty string as valid palindrome.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">Input:</span> <span class="string">"A man, a plan, a canal: Panama"</span></span><br><span class="line"><span class="string">Output:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">Input:</span> <span class="string">"race a car"</span></span><br><span class="line"><span class="string">Output:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：双指针法（LeetCode国际站）</p>
<p>需要提前学习，Java的Character包装类中有两个对这道题很有用的方法：</p>
<ol>
<li>Character.isLetterOrDigit()，判断当前内容是否是全英文或数字。但是这有个坑，如果用了中文，识别不出来(默认提供unicode的支持)，可以用Apache Commons子项目中的lang库，CharUtils的<code>isAsciiAlpha(char)</code>、<code>isAsciiNumeric(char)</code>、<code>isAsciiAlphanumberic(char)</code>等对字符进行字母，大小写字母，数字等的判断。——实际上commons项目是一个大宝库，里面提供了很多对JDK增强的API，lang库就是对java.lang的增强。比如使用反射生成toString的ToStringBuilder，使用反射生成hashCode的HashCodeBuilder等。</li>
<li>Character.toLowerCase()，这个方法可以将大写字符转换为小写字符。</li>
</ol>
<p>具体代码：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public boolean is<span class="constructor">Palindrome(String <span class="params">s</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 双指针法</span></span><br><span class="line">        <span class="keyword">if</span>(s.length<span class="literal">()</span> &lt;= <span class="number">1</span>) return <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">char</span><span class="literal">[]</span> c = s.<span class="keyword">to</span><span class="constructor">CharArray()</span>;</span><br><span class="line">        <span class="comment">// i为头，j为尾(最后一个为长度减1)</span></span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">0</span>, j = c.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j<span class="operator"> &amp;&amp; </span>!<span class="module-access"><span class="module"><span class="identifier">Character</span>.</span></span>is<span class="constructor">LetterOrDigit(<span class="params">c</span>[<span class="params">i</span>])</span>) <span class="comment">//剔除所有非字母或数字的字符</span></span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j<span class="operator"> &amp;&amp; </span>!<span class="module-access"><span class="module"><span class="identifier">Character</span>.</span></span>is<span class="constructor">LetterOrDigit(<span class="params">c</span>[<span class="params">j</span>])</span>)</span><br><span class="line">                j--;</span><br><span class="line">            <span class="keyword">if</span>(<span class="module-access"><span class="module"><span class="identifier">Character</span>.</span></span><span class="keyword">to</span><span class="constructor">LowerCase(<span class="params">c</span>[<span class="params">i</span><span class="operator">++</span>])</span> != <span class="module-access"><span class="module"><span class="identifier">Character</span>.</span></span><span class="keyword">to</span><span class="constructor">LowerCase(<span class="params">c</span>[<span class="params">j</span>--])</span>) <span class="comment">// 统一转换成小写字母再比较</span></span><br><span class="line">                return <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以用for循环来写，这样变量直接定义在循环里面，代码更简洁：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public boolean is<span class="constructor">Palindrome(String <span class="params">s</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// corner case    </span></span><br><span class="line">        <span class="keyword">if</span>(s.length<span class="literal">()</span> &lt;= <span class="number">1</span>) return <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">char</span><span class="literal">[]</span> c = s.<span class="keyword">to</span><span class="constructor">CharArray()</span>;</span><br><span class="line">        for(<span class="built_in">int</span> i = <span class="number">0</span>, j = c.length-<span class="number">1</span>; i &lt; j;) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="module-access"><span class="module"><span class="identifier">Character</span>.</span></span>is<span class="constructor">LetterOrDigit(<span class="params">c</span>[<span class="params">i</span>])</span>) i++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="module-access"><span class="module"><span class="identifier">Character</span>.</span></span>is<span class="constructor">LetterOrDigit(<span class="params">c</span>[<span class="params">j</span>])</span>) j--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="module-access"><span class="module"><span class="identifier">Character</span>.</span></span><span class="keyword">to</span><span class="constructor">LowerCase(<span class="params">c</span>[<span class="params">i</span><span class="operator">++</span>])</span> != <span class="module-access"><span class="module"><span class="identifier">Character</span>.</span></span><span class="keyword">to</span><span class="constructor">LowerCase(<span class="params">c</span>[<span class="params">j</span>--])</span>) return <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>后记</strong>：受到这道题的启发，当我们需要去解决输入的一个字符串是否为回文串的时候，我们需要向面试官确认三点：空字符串是否为定义为回文串？输入是否会有空格、分隔符等非法字符？输入为字母的话是否都为大写或者小写字母？(数字不用担心，直接用就行)。</p>
<p>前两点对应Character.isLetterOrDigit()方法，第三点对应Character.toLowerCase()方法</p>
<h2 id="680-Valid-Palindrome-II-验证回文串-II-Easy"><a href="#680-Valid-Palindrome-II-验证回文串-II-Easy" class="headerlink" title="680.Valid Palindrome II(验证回文串 II)(Easy)"></a><a href="https://leetcode-cn.com/problems/valid-palindrome-ii/" target="_blank" rel="noopener">680.Valid Palindrome II(验证回文串 II)(Easy)</a></h2><p>Given a non-empty string <code>s</code>, you may delete <strong>at most</strong> one character. Judge whether you can make it a palindrome.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="string">"aba"</span></span><br><span class="line"><span class="attr">Output:</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Input</span>: "abca"</span><br><span class="line">Output: <span class="keyword">True</span></span><br><span class="line">Explanation: You could <span class="keyword">delete</span> the <span class="type">character</span> <span class="string">'c'</span>.</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ol>
<li>The string will only contain lowercase characters a-z. The maximum length of the string is 50000.</li>
</ol>
<hr>
<p>解：这道题虽然是125的进化版，但是输入已经约定是都是lowercase的character，所以不需要像上面那样再调用Character.isLetterOrDigit了。</p>
<p>解决这道题也可以用双指针，一头一尾。但是这里主要要考虑可以删除一个字符的情况，可以选择左边指针删除或者右边指针删除</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public boolean valid<span class="constructor">Palindrome(String <span class="params">s</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> left = <span class="number">0</span>, right = s.length<span class="literal">()</span>-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 左右两边的字符不相等的时候，可以跳过一次左边或者右边的字符</span></span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">char</span><span class="constructor">At(<span class="params">left</span>)</span> != s.<span class="built_in">char</span><span class="constructor">At(<span class="params">right</span>)</span>) &#123;</span><br><span class="line">                return is<span class="constructor">Palindrome(<span class="params">s</span>, <span class="params">left</span>+1, <span class="params">right</span>)</span><span class="operator"> || </span>is<span class="constructor">Palindrome(<span class="params">s</span>,<span class="params">left</span>, <span class="params">right</span>-1)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left++; right--;</span><br><span class="line">        &#125;</span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean is<span class="constructor">Palindrome(String <span class="params">s</span>, <span class="params">int</span> <span class="params">left</span>, <span class="params">int</span> <span class="params">right</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right ) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">char</span><span class="constructor">At(<span class="params">left</span><span class="operator">++</span>)</span> != s.<span class="built_in">char</span><span class="constructor">At(<span class="params">right</span>--)</span>) &#123;</span><br><span class="line">                return <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-Longest-Palindromic-Substring-最长回文子串-Mid"><a href="#5-Longest-Palindromic-Substring-最长回文子串-Mid" class="headerlink" title="5.Longest Palindromic Substring(最长回文子串)(Mid)"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5.Longest Palindromic Substring(最长回文子串)(Mid)</a></h2><p>Given a string <strong>s</strong>, find the longest palindromic substring in <strong>s</strong>. You may assume that the maximum length of <strong>s</strong> is 1000.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Input</span>: "babad"</span><br><span class="line">Output: "bab"</span><br><span class="line">Note: "aba" <span class="keyword">is</span> <span class="keyword">also</span> a <span class="keyword">valid</span> answer.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Input:</span> <span class="string">"cbbd"</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="string">"bb"</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：完整分析参考<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/" target="_blank" rel="noopener">这篇文章</a></p>
<p>首先要明确回文子串的定义，单个字符，比如”a”，本身就是回文子串。然后如果多于一个字符了，比如两个字符，那必须是”aa”才能是回文子串，三个的话”aba”是回文子串，以此类推。</p>
<p>这道题是647的扩展，647只要求找到有多少回文子串，而这道题要返回最长的回文子串。</p>
<p>方法一：暴力法，枚举所有长度大于2的子串，一共有O(n^2)个，然后对每一个子串进行验证，需要O(n)，总共的时间复杂度为O(n^3)，太大了。</p>
<p>方法二：优化的暴力法</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> lo, maxLen;</span><br><span class="line">    </span><br><span class="line">    public String longest<span class="constructor">Palindrome(String <span class="params">s</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 优化后的暴力穷举</span></span><br><span class="line">        <span class="built_in">int</span> len = s.length<span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>) return s;</span><br><span class="line">        </span><br><span class="line">        for(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            extend<span class="constructor">Palindrome(<span class="params">s</span>, <span class="params">i</span> ,<span class="params">i</span>)</span>; <span class="comment">// odd length</span></span><br><span class="line">            extend<span class="constructor">Palindrome(<span class="params">s</span>, <span class="params">i</span>, <span class="params">i</span>+1)</span>; <span class="comment">// even length</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 摘取出来s的最长回文</span></span><br><span class="line">        return s.substring(lo, lo + maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void extend<span class="constructor">Palindrome(String <span class="params">s</span>, <span class="params">int</span> <span class="params">j</span>, <span class="params">int</span> <span class="params">k</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// j是向左扩散，k是向右扩散。只要j和k上面的字符相同，就不断地走</span></span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span><span class="operator"> &amp;&amp; </span>k &lt; s.length<span class="literal">()</span><span class="operator"> &amp;&amp; </span>s.<span class="built_in">char</span><span class="constructor">At(<span class="params">j</span>)</span><span class="operator"> == </span>s.<span class="built_in">char</span><span class="constructor">At(<span class="params">k</span>)</span>) &#123;</span><br><span class="line">            j--; k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 走完之后，判断当前遍历到的是不是最长的子串，如果是，就更新max长度，同时记录</span></span><br><span class="line">        <span class="comment">//当前遍历的最左边的位置，也就是起点</span></span><br><span class="line">        <span class="keyword">if</span>(maxLen &lt; k - j - <span class="number">1</span>) &#123;</span><br><span class="line">            lo = j + <span class="number">1</span>;</span><br><span class="line">            maxLen = k - j - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法三：动态规划。</p>
<p>动态规划用空间换时间，<strong>而且对于这种字符串来说，针对字符串的动态规划一般套路是把字符串放到行和列上，处理这个”二维矩阵”的每个字符串之间的关系</strong>。</p>
<p>动态规划最关键的步骤是想出来”状态转移方程”，而事实上，”回文”天然就是具有”状态转移”性质的。</p>
<p>可以知道，一个长度为1的字符本身就是回文串、如果长度为2，那么是回文串的条件必须是</p>
<p><strong>定义的状态</strong>：用一个boolean[][]类型的二维数组，dp[i][j]表示子串s[i,j]是否为回文子串，具体说来是从下标为i的字符到下标为j的字符的substring是否为回文子串</p>
<p>因为整个遍历的过程，i始终会小于j(一前一后两个指针)，所以在dp的二维矩阵中实际只填写上半部分即可。</p>
<p>初始化可以用一个循环把对角线上所有值都赋为true，但是实际这一步也可以省略，因为单个字符本身就是回文，而后面dp[i][i]也根本不会被参考的。</p>
<p><strong>状态转移方程</strong>：<code>dp[i][j] = (s[i]==s[j]) and dp[i+1][j-1]</code></p>
<ol>
<li>看到dp[i+1][j-1]就要考虑边界情况，边界条件是[i+1][j-1]不能构成区间，即长度为2，<strong>参考”篮子王”的处理边界的思路，可以处理所有长度为2的字符串，即可，不需要额外考虑判断条件</strong>。</li>
</ol>
<p><strong>考虑输出</strong>：只要一得到<code>dp[i][j]==true</code>，就记录子串的长度和起始位置。注意没必要截取它，因为截取字符串也要消耗性能，只要记录此时的回文串的”起始位置(start)”和”回文长度(maxLen)”即可</p>
<p><strong>具体思路</strong>：</p>
<ol>
<li>在子串左边界j逐渐扩大的过程中，枚举左边界可能出现的位置</li>
<li>左边界枚举的时候可以从小到大，也可以从大到小</li>
</ol>
<p>这两种思路代码差别仅在于内层循环。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String longestPalindrome(String s) &#123;</span><br><span class="line">        <span class="comment">// 方法二，DP</span></span><br><span class="line">        <span class="comment">// corner case</span></span><br><span class="line">        <span class="built_in">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span> || s == <span class="literal">null</span>) <span class="keyword">return</span> s;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 记录最长子串的长度的maxLen和起始位置start</span></span><br><span class="line">        <span class="built_in">int</span> maxLen = <span class="number">1</span>, start = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">bool</span>ean[][] dp = new <span class="built_in">bool</span>ean[len][len];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化，对角线都为单个元素,全部为true</span></span><br><span class="line">        <span class="comment">// 但是这个初始化过程可以省略，因为只有一个字符的时候肯定是回文</span></span><br><span class="line">        <span class="comment">// dp[i][i]根本不会被其他状态值所参考</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// i &lt; len-1 是因为最后要加到i+1，也就是下标为len-1的位置</span></span><br><span class="line">        <span class="comment">// 处理长度为2的边界条件，长度为2时i+1和j-1会越界</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == s.charAt(i+<span class="number">1</span>)) &#123;</span><br><span class="line">                dp[i][i+<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                maxLen = <span class="number">2</span>;</span><br><span class="line">                start = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">2</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span> ;i &lt; j - <span class="number">1</span>; i++) &#123; <span class="comment">// i &lt; j的话长度为2，之前已经处理过了</span></span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 只要dp[i][j]是true,就证明此时子串s[i,j]是回文串</span></span><br><span class="line">                <span class="comment">// 记录此时回文长度和起始位置,用substring的时候下标从1开始</span></span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] == <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="built_in">int</span> tempLen = j - i + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(tempLen &gt; maxLen) &#123;</span><br><span class="line">                        maxLen = tempLen;</span><br><span class="line">                        start = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start, start+maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(n^2)</li>
</ul>
<p>还有一个马拉车算法，暂时不讲，面试很难写完。</p>
<p><strong>总而言之</strong>，”马拉车算法”虽然很著名，但是对待这种字符串的问题，最常用的还是二维的动态规划。实际上，碰到字符串问题，只要牵扯到动态规划，一般都是把这个字符串复制一份，分别放到行和列上。</p>
<p>对于这道题，需要注意：</p>
<ol>
<li>用一个boolean[][]的二维数组来做动态规划</li>
<li>实际只需要填写上半区域的空</li>
<li>因为<strong>“一个回文去掉两头以后，剩下的部分依然是回文(不讨论边界)”</strong>，所以状态转移方程可以知道为：<code>dp[i][j]=(s[i] == s[j]) and dp[i+1][j-1]</code>,在矩形坐标上来看就是，只要不在边界上，一个为回文的子串的[i][j]位置一定和其左下角的[i+1][j-1]一致</li>
<li>注意考虑边界问题，即[i+1][j-1]不能组成区间的情况。我们可以单独处理这个情况。实际上这个边界情况就是目标子串长度为2的情况。我们用一个循环单独处理即可</li>
</ol>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a><strong>后记</strong></h3><p>这确实是一道很经典的有关字符串回文子串处理的题目，经过在LeetCode国际站上的学习，除去中心扩散法，找到了一个很简洁的动态规划版本的代码。我上面提供的代码虽然思路很清晰，但是有些冗长或者啰嗦了。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> static String longestPalindrome(String s) &#123;</span><br><span class="line">        <span class="built_in">int</span> n = s.length();</span><br><span class="line">        String res = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">int</span> palindromeStartsAt = <span class="number">0</span>, maxLen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">bool</span>ean[][] dp = new <span class="built_in">bool</span>ean[n][n];</span><br><span class="line">        <span class="comment">// dp[i][j] indicates whether substring s starting at index i and ending at j is palindrome</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// keep increasing the possible palindrome string</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = i; j &lt; n; j++) &#123; <span class="comment">// find the max palindrome within this window of (i,j)</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//check if substring between (i,j) is palindrome</span></span><br><span class="line">                dp[i][j] = (s.charAt(i) == s.charAt(j)) <span class="comment">// chars at i and j should match</span></span><br><span class="line">                           &amp;&amp; </span><br><span class="line">                           ( j-i &lt; <span class="number">3</span>  <span class="comment">// if window is less than or equal to 3, just end chars should match</span></span><br><span class="line">                             || dp[i+<span class="number">1</span>][j<span class="number">-1</span>]  ); <span class="comment">// if window is &gt; 3, substring (i+1, j-1) should be palindrome too</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//update max palindrome string</span></span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] &amp;&amp; (j-i+<span class="number">1</span> &gt; maxLen)) &#123;</span><br><span class="line">                    palindromeStartsAt = i;</span><br><span class="line">                    maxLen = j-i+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(palindromeStartsAt, palindromeStartsAt+maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="647-Palindromic-Substrings-回文子串-Mid"><a href="#647-Palindromic-Substrings-回文子串-Mid" class="headerlink" title="647.Palindromic Substrings(回文子串)(Mid)"></a><a href="https://leetcode-cn.com/problems/palindromic-substrings/" target="_blank" rel="noopener">647.Palindromic Substrings(回文子串)(Mid)</a></h2><p>Given a string, your task is to count how many palindromic substrings in this string.</p>
<p>The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">Input:</span> <span class="string">"abc"</span></span><br><span class="line"><span class="string">Output:</span> <span class="number">3</span></span><br><span class="line"><span class="string">Explanation:</span> Three palindromic <span class="string">strings:</span> <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">Input:</span> <span class="string">"aaa"</span></span><br><span class="line"><span class="string">Output:</span> <span class="number">6</span></span><br><span class="line"><span class="string">Explanation:</span> Six palindromic <span class="string">strings:</span> <span class="string">"a"</span>, <span class="string">"a"</span>, <span class="string">"a"</span>, <span class="string">"aa"</span>, <span class="string">"aa"</span>, <span class="string">"aaa"</span>.</span><br></pre></td></tr></table></figure>

<hr>
<p>解：这道题可以完全参考第五题的思路。只是最后输出要求不同，第五题要记录最长的子串，这道题要统计所有子串的数量而已。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> countSubstrings(String s) &#123;</span><br><span class="line">        <span class="comment">//corner case</span></span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span> || s == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> result = <span class="number">0</span>, len = s.length();</span><br><span class="line">        <span class="built_in">bool</span>ean[][] dp = new <span class="built_in">bool</span>ean[len][len];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化对角线</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; len ; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理长度为2的边界条件，长度为2时i+1和j-1会越界</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == s.charAt(i+<span class="number">1</span>)) &#123;</span><br><span class="line">                dp[i][i+<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">2</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; j<span class="number">-1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(dp[i][j] == <span class="literal">true</span>) result++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同上，给出简化的动态规划的代码来解决这道647题：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> countSubstrings(String s) &#123;</span><br><span class="line">        <span class="built_in">int</span> len = s.length();</span><br><span class="line">        <span class="built_in">int</span> result = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>) <span class="keyword">return</span> len;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">bool</span>ean[][] dp = new <span class="built_in">bool</span>ean[len][len];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = i; j &lt; len; j++) &#123;</span><br><span class="line">                dp[i][j] = s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt; <span class="number">3</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(dp[i][j]) result++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="820-Short-Encoding-of-Words-单词的压缩编码-Mid"><a href="#820-Short-Encoding-of-Words-单词的压缩编码-Mid" class="headerlink" title="820.Short Encoding of Words(单词的压缩编码)(Mid)"></a><a href="https://leetcode-cn.com/problems/short-encoding-of-words/" target="_blank" rel="noopener">820.Short Encoding of Words(单词的压缩编码)(Mid)</a></h2><p>Given a list of words, we may encode it by writing a reference string S and a list of indexes A.</p>
<p>For example, if the list of words is <code>[&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;]</code>, we can write it as <code>S = &quot;time#bell#&quot;</code> and <code>indexes = [0, 2, 5]</code>.</p>
<p>Then for each index, we will recover the word by reading from the reference string from that index until we reach a <code>&quot;#&quot;</code> character.</p>
<p>What is the length of the shortest reference string S possible that encodes the given words?</p>
<p><strong>Example:</strong></p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Input:</span> words = [<span class="string">"time"</span>, <span class="string">"me"</span>, <span class="string">"bell"</span>]</span><br><span class="line"><span class="symbol">Output:</span> <span class="number">10</span></span><br><span class="line"><span class="symbol">Explanation:</span> S = <span class="string">"time#bell#"</span> <span class="keyword">and</span> indexes = [<span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>].</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ol>
<li><code>1 &lt;= words.length &lt;= 2000.</code></li>
<li><code>1 &lt;= words[i].length &lt;= 7.</code></li>
<li>Each word has only lowercase letters.</li>
</ol>
<hr>
<p>解：根据题意，如果单词<code>Y</code>是另一个单词<code>X</code>的一部分，那么Y就不用考虑了，因为X编码之后里面一定包含Y。反过来说，如果单词Y不在任何别的单词X的后缀中出现，那么Y一定是编码字符串的一部分。</p>
<p>因此，此题的目标就是移除words里的所有单词，使得words里没有一个单词是另一个单词的后缀，最后的结果就是<code>sum(word.length + 1 for word in words)</code></p>
<p>因为题目条件说到words里面的每一个单词长度都不大于7，所以我们可以枚举所有单词，对于每个后缀，我们都将其从words列表中删除。为了查询的高效，可以用哈希表来存储，这里用HashSet</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumLengthEncoding</span><span class="params">(<span class="keyword">String</span>[] words)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化set</span></span><br><span class="line">        Set&lt;<span class="keyword">String</span>&gt; <span class="built_in">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(words));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">String</span> <span class="keyword">word</span> : words) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; <span class="keyword">word</span>.length(); k++) &#123;</span><br><span class="line">                <span class="comment">// 若当前word中包含了k，将这个单词移除，因为它可以被包含</span></span><br><span class="line">                <span class="built_in">set</span>.<span class="built_in">remove</span>(<span class="keyword">word</span>.substring(k));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">String</span> <span class="keyword">word</span> : <span class="built_in">set</span>) &#123;</span><br><span class="line">            <span class="comment">// 加1即为"#"</span></span><br><span class="line">            ans += <span class="keyword">word</span>.length() + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后返回总的长度即可</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="43-Multiply-Strings-字符串相乘-Mid"><a href="#43-Multiply-Strings-字符串相乘-Mid" class="headerlink" title="43.Multiply Strings(字符串相乘)(Mid)"></a><a href="https://leetcode-cn.com/problems/multiply-strings/" target="_blank" rel="noopener">43.Multiply Strings(字符串相乘)(Mid)</a></h2><p>Given two non-negative integers <code>num1</code> and <code>num2</code> represented as strings, return the product of <code>num1</code> and <code>num2</code>, also represented as a string.</p>
<p><strong>Example 1</strong>:</p>
<p>Input: num1 = “2”, num2 = “3”<br>Output: “6”</p>
<p><strong>Example 2</strong>:</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Input:</span> num1 = <span class="string">"123"</span>, num2 = <span class="string">"456"</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="string">"56088"</span></span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ol>
<li>The length of both <code>num1</code> and <code>num2</code> is &lt; 110.</li>
<li>Both <code>num1</code> and <code>num2</code> contain only digits 0-9.</li>
<li>Both <code>num1</code> and <code>num2</code> do not contain any leading zero, except the number 0 itself.</li>
<li>You <strong>must not use any built-in BigInteger library or convert the inputs to integer</strong> directly.</li>
</ol>
<hr>
<p>解：如果只是普通的数字之间的乘法，那是非常简单的。但是需要注意一个规律：<font color=#FF0000>两个数字相乘，得到的结果的位数一定不超过相乘的这两个数的长度之和</font>。</p>
<p>所以我们可以直接开辟一个num1.length()+num2.length()的数组。</p>
<p>接下来求结果，基本思路是一个数一个数之间的相乘。</p>
<p>注意传入的字符的位的位置，低位，比如个位，在下标很大的地方，而高位，比如百位，在下标很小的地方，所以循环可以选择从后面开始。</p>
<p>此外，还要注意保存结果的位置，因为低位保存在右边，也就是int数组下标大的位置，(没错，数字的个位、十位、百位的计位方式刚好和数组的0,1,2,3相反，真的很容易晕掉，晕掉了就怀疑人生了……)。总之最后表现出的结果就是posLow的值反而是比posHigh大1的。</p>
<p>每当两个数之间相乘，就让计算的结果的位数往前错开1，具体内容就是，低位的<code>powLow</code>放到<code>j+i+1</code>的位置，高位<code>posHigh</code>放到<code>i+j</code>的位置。然后要计算与mul的和的情况，mul用于保存每次相乘计算之后的结果。</p>
<p>确定了posLow和posHigh之后，针对mul的操作有三步：mul与result[posLow]的位直接相加得到新的mul结果，然后将低位和高位保存到result里面对应的位置上</p>
<p>如果计算的结果前面有0，则需要干掉这些0然后返回。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String multiply(String num1, String num2) &#123;</span><br><span class="line">        <span class="comment">// corner case</span></span><br><span class="line">        <span class="built_in">int</span> len1 = num1.length(), len2 = num2.length();</span><br><span class="line">        <span class="keyword">if</span>(len1 == <span class="number">0</span> || len2 == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="comment">// 存储结果</span></span><br><span class="line">        <span class="built_in">int</span>[] result = new <span class="built_in">int</span>[len1 + len2];</span><br><span class="line">        <span class="comment">// 两个for循环嵌套，为了从num1和num2中依次取一位，然后依次做乘法</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = len1 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = len2 - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="comment">// 从num1和num2中依次取一位做乘法</span></span><br><span class="line">                <span class="comment">// 取出来单个char后减去'0'，自动转换成ASCII码的计算，得到int值</span></span><br><span class="line">                <span class="built_in">int</span> mul = (num1.charAt(i) - <span class="string">'0'</span>) * (num2.charAt(j) - <span class="string">'0'</span>);</span><br><span class="line">                <span class="comment">// posLow和posHigh相差1，这两个数表示取出来的数每次相乘之后</span></span><br><span class="line">                <span class="comment">// 要填的result的位置</span></span><br><span class="line">                <span class="built_in">int</span> posLow = i+j+<span class="number">1</span>;</span><br><span class="line">                <span class="built_in">int</span> posHigh = i+j;</span><br><span class="line">                <span class="comment">// 两数相乘之后还要加上再之前计算所得到的进位，才是当前计算的最终结果</span></span><br><span class="line">                mul += result[posLow];</span><br><span class="line">                result[posLow] = mul % <span class="number">10</span>;</span><br><span class="line">                result[posHigh] += mul / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理结果，用长度可变的StringBuilder</span></span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        <span class="comment">// 忽略所有leading zero，只有当前位不为0而且</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> res : result) &#123;</span><br><span class="line">            <span class="comment">// 如果sb为空而且此时res为0，那么此时res就是leading 0,要跳过</span></span><br><span class="line">            <span class="keyword">if</span>(!(sb.length() == <span class="number">0</span> &amp;&amp; res == <span class="number">0</span>)) sb.append(res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果最后算结果是0，那么直接返回0，解决了乘数是0的case</span></span><br><span class="line">        <span class="keyword">return</span> (sb.length() == <span class="number">0</span>) ? <span class="string">"0"</span> : sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(len1 * len2)</p>
<h2 id="93-Restore-IP-Addresses-复原IP地址-Mid"><a href="#93-Restore-IP-Addresses-复原IP地址-Mid" class="headerlink" title="93.Restore IP Addresses(复原IP地址)(Mid)"></a><a href="https://leetcode-cn.com/problems/restore-ip-addresses/" target="_blank" rel="noopener">93.Restore IP Addresses(复原IP地址)(Mid)</a></h2><p>Given a string containing only digits, restore it by returning all possible valid IP address combinations.</p>
<p><strong>Example:</strong></p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Input:</span> <span class="string">"25525511135"</span></span><br><span class="line"><span class="symbol">Output:</span> [<span class="string">"255.255.11.135"</span>, <span class="string">"255.255.111.35"</span>]</span><br></pre></td></tr></table></figure>

<hr>
<p>解：方法一，暴力解决。但是这个暴力的解法本身也是非常巧妙的，枚举所有可能的情况。因为Input本身就不复杂，所以情况并不会非常非常多。</p>
<p>暴力法是一种面试的时候完全可以考虑使用的方法(如果只考虑把题目解出来……)</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public List&lt;String&gt; restore<span class="constructor">IpAddresses(String <span class="params">s</span>)</span> &#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">        StringBuilder ip = <span class="keyword">new</span> <span class="constructor">StringBuilder()</span>;</span><br><span class="line">        </span><br><span class="line">        for(<span class="built_in">int</span> a = <span class="number">1</span>; a &lt; <span class="number">4</span>; a++) &#123;</span><br><span class="line">            for(<span class="built_in">int</span> b = <span class="number">1</span>; b &lt; <span class="number">4</span>; b++) &#123;</span><br><span class="line">                for(<span class="built_in">int</span> c = <span class="number">1</span>; c &lt; <span class="number">4</span>; c++) &#123;</span><br><span class="line">                    for(<span class="built_in">int</span> d = <span class="number">1</span>; d &lt; <span class="number">4</span>; d++) &#123;</span><br><span class="line">                                                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         * 1、保障下面subString不会越界</span></span><br><span class="line"><span class="comment">                         * 2、保障截取的字符串与输入字符串长度相同</span></span><br><span class="line"><span class="comment">                         * //1、2比较好理解，3比较有意思</span></span><br><span class="line"><span class="comment">                         * 3、不能保障截取的字符串转成int后与输入字符串长度相同</span></span><br><span class="line"><span class="comment">                         * 如：字符串010010，a=1，b=1，c=1，d=3，对应字符串0，1，0，010</span></span><br><span class="line"><span class="comment">                         * 转成int后seg1=0，seg2=1，seg3=0，seg4=10</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        <span class="keyword">if</span>(a + b + c + d<span class="operator"> == </span>s.length<span class="literal">()</span>) &#123;</span><br><span class="line">                            <span class="built_in">int</span> n1 = <span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span>parse<span class="constructor">Int(<span class="params">s</span>.<span class="params">substring</span>(0,<span class="params">a</span>)</span>);</span><br><span class="line">                            <span class="built_in">int</span> n2 = <span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span>parse<span class="constructor">Int(<span class="params">s</span>.<span class="params">substring</span>(<span class="params">a</span>,<span class="params">a</span>+<span class="params">b</span>)</span>);</span><br><span class="line">                            <span class="built_in">int</span> n3 = <span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span>parse<span class="constructor">Int(<span class="params">s</span>.<span class="params">substring</span>(<span class="params">a</span>+<span class="params">b</span>,<span class="params">a</span>+<span class="params">b</span>+<span class="params">c</span>)</span>);</span><br><span class="line">                            <span class="built_in">int</span> n4 = <span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span>parse<span class="constructor">Int(<span class="params">s</span>.<span class="params">substring</span>(<span class="params">a</span>+<span class="params">b</span>+<span class="params">c</span>)</span>);</span><br><span class="line">                            <span class="comment">// 四个段数值满足0~255</span></span><br><span class="line">                            <span class="keyword">if</span>(n1 &lt;= <span class="number">255</span><span class="operator"> &amp;&amp; </span>n2 &lt;= <span class="number">255</span><span class="operator"> &amp;&amp; </span>n3 &lt;= <span class="number">255</span><span class="operator"> &amp;&amp; </span>n4 &lt;= <span class="number">255</span>) &#123;</span><br><span class="line">                                ip.append(n1).append(<span class="character">'.'</span>)</span><br><span class="line">                                    .append(n2).append(<span class="character">'.'</span>)</span><br><span class="line">                                    .append(n3).append(<span class="character">'.'</span>)</span><br><span class="line">                                    .append(n4);</span><br><span class="line">                                <span class="comment">// 保障截取的字符串转成int后与输入字符串长度相同</span></span><br><span class="line">                                <span class="comment">// 这个判断用于处理特殊情况，即比如输入为 010010，分割成0,1,0,10</span></span><br><span class="line">                                <span class="keyword">if</span>(ip.length<span class="literal">()</span><span class="operator"> == </span>s.length<span class="literal">()</span>+<span class="number">3</span>) result.add(ip.<span class="keyword">to</span><span class="constructor">String()</span>);</span><br><span class="line">                                ip.delete(<span class="number">0</span>,ip.length<span class="literal">()</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，递归回溯</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; restoreIpAddresses(String s) &#123;</span><br><span class="line">        LinkedList&lt;String&gt; result = new LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span> &amp;&amp; s.length() &gt; <span class="number">12</span>) <span class="keyword">return</span> result;</span><br><span class="line">        restoreHelper(result, s, <span class="string">""</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> restoreHelper(List&lt;String&gt; result, String s, String current, <span class="built_in">int</span> field) &#123;</span><br><span class="line">        <span class="comment">// field:0, 1, 2, 3, 4 means all done</span></span><br><span class="line">        <span class="comment">// 用field判断当前有几段，即几个field，满了4段即为IP地址的格式</span></span><br><span class="line">        <span class="keyword">if</span>(field == <span class="number">4</span> &amp;&amp; s.length() == <span class="number">0</span>) result.add(current.substring(<span class="number">1</span>)); <span class="comment">// remove the prefixed "."</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(field == <span class="number">4</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> ;<span class="comment">//not valid combination</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            restoreHelper(result, s.substring(<span class="number">1</span>), current + <span class="string">"."</span> + s.substring(<span class="number">0</span>,<span class="number">1</span>), field + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(<span class="number">0</span>) != <span class="string">'0'</span> &amp;&amp; s.length() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                restoreHelper(result, s.substring(<span class="number">2</span>), current + <span class="string">"."</span> + s.substring(<span class="number">0</span>,<span class="number">2</span>),field + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(s.length() &gt; <span class="number">2</span> &amp;&amp; Integer.valueOf(s.substring(<span class="number">0</span>,<span class="number">3</span>)) &lt;= <span class="number">255</span>) </span><br><span class="line">                    restoreHelper(result, s.substring(<span class="number">3</span>),current+<span class="string">"."</span>+s.substring(<span class="number">0</span>,<span class="number">3</span>),field+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong>重点看暴力法</p>
]]></content>
      <categories>
        <category>Algorithms Note</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Practice by Categories Sort</title>
    <url>/2020/01/13/LeetCode-Practice-by-Categories-Sort/</url>
    <content><![CDATA[<blockquote>
<p>所谓爱一个人，不是宽裕了想要给予，而是恳切地必须给予。<br>所谓爱一个人，不是喜欢对方的体温，而是要跟对方的体温越来越接近。所谓爱一个人，是即便对方一直折磨你，你想要的一直讨厌对方，但怎么也讨厌不起来。所谓爱一个人，真的是一件难事。所谓爱，不是不讨厌，而是绝对不能讨厌的意思。<br>——《请回答1988》</p>
</blockquote>
<p>由浅入深介绍和分析各种排序算法，重点给出快排和归并排序的实现思路。</p>
<a id="more"></a>

<p>国内面试中经常会问到排序方面问题。如果开放性强的话，可能直接问你有关排序，可以畅所欲言。但是考察得更多的应该还是排序的的思路和代码，尤其是快排、归并。</p>
<p>首先，排序分为比较类排序和非比较类排序，如下图所示：</p>
<p><img src="https://s2.ax1x.com/2020/02/13/1O9RkF.png" alt="1O9RkF.png"></p>
<h2 id="如何理解比较类排序和非比较类排序？"><a href="#如何理解比较类排序和非比较类排序？" class="headerlink" title="如何理解比较类排序和非比较类排序？"></a><strong>如何理解比较类排序和非比较类排序？</strong></h2><ol>
<li>比较类排序： 通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn), 因此也称为非线性时间比较类排序。</li>
</ol>
<ul>
<li>在高级语言里，大家直接调用系统的排序函数的时候，你可以传入一个参数：comparator(java语言，其他语言可能叫做cmp之类的函数)。也就是说，它比较的对象不一定必须是实数或者int之类的类型，可以是任何结构体或者类的对象。你只需要给它传入一个可以比较两个object之间的前后关系的类型，都可以通过排序算法得到。</li>
</ul>
<p>像这种通过比较来决定元素间的相对次序，数学上已经证明，时间复杂度不会超过O(logn)，而我们经常用到的，都是这种比较类排序。</p>
<ol start="2">
<li>非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也成为线性时间非比较类排序。</li>
</ol>
<ul>
<li>一般对于整型元素来做的，也就是说可以用线性时间来完成。它可以突破基于比较排序的时间下界，以线性时间完成。</li>
</ul>
<p><strong>但是非比较类排序的缺点是</strong>：一般只能用于整型相关的数据类型。也就是说对于一些比如字符串的排序，或者对象之间的排序，非比较类排序是无能为力的。而且非比较类排序一般需要辅助的内存空间。</p>
<p>非比较类排序基本都是把结果放入到数组中，统计不同元素出现的次数来排序。</p>
<p>常用的排序算法的复杂度分析和稳定性，如下表：</p>
<p><img src="https://s2.ax1x.com/2020/02/14/1jSh4g.png" alt="1jSh4g.png"></p>
<p>从重要程度来说，更重要的是比较类排序，因为它是泛型的，也是工业编程中用得最多的。</p>
<hr>
<p><strong>初级排序</strong>：O(n^2)</p>
<ol>
<li>选择排序(Selection Sort)</li>
</ol>
<p>每次选择最小值，然后放到待排序数组的起始位置。</p>
<ol start="2">
<li>插入排序(Insertion Sort)</li>
</ol>
<p>从前到后逐步构建有序序列;对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<ol start="3">
<li>冒泡排序(Bubble Sort)</li>
</ol>
<p>嵌套循环，每次查看相邻的元素，如果逆序，则交换。</p>
<p>这三种初级排序没有太大差别，其实是异曲同工的原理。</p>
<p><font color=#FF0000>而面试中，考察技术能力的时候，他考察的一般也都是O(nlogn)的排序，所以准备过程中也应该尽量多花时间去看时间复杂度为O(nlogn)的排序算法。</font>主要是三个：堆排序、快速排序、归并排序。</p>
<hr>
<h2 id="高级排序-——-O-N-logN"><a href="#高级排序-——-O-N-logN" class="headerlink" title="高级排序 —— O(N*logN)"></a><strong>高级排序</strong> —— O(N*logN)</h2><h3 id="快速排序-Quick-Sort"><a href="#快速排序-Quick-Sort" class="headerlink" title="快速排序(Quick Sort)"></a><strong>快速排序(Quick Sort)</strong></h3><p>数组取标杆pivot，将比pivot小的元素放到pivot左边，比它大的元素放在它的右边，然后依次对左边和右边的子数组继续快排；以达到整个序列有序。</p>
<p>快排用到了<strong>分治</strong>的思想，首先，如果想要把排序的时间复杂度从O(n^2)降到O(N logN)，那么分治毫无疑问是要考虑的问题。</p>
<p><font color=#FF0000>快排的方法：拿到一个pivot的位置，将所有小于pivot的元素移动到左边去，大于pivot的移动到右边去，且分别对左右侧再进行递归，调用快排。</font>可以通过主定理，证明整个递归下来的时间复杂度为O(N logN)。</p>
<p>快排的样例代码：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] <span class="built_in">array</span>, <span class="keyword">int</span> <span class="built_in">begin</span>, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">end</span> &lt;= <span class="built_in">begin</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> pivot = partition(<span class="built_in">array</span>, <span class="built_in">begin</span>, <span class="built_in">end</span>);</span><br><span class="line">    quickSort(<span class="built_in">array</span>, <span class="built_in">begin</span>, pivot - <span class="number">1</span>);</span><br><span class="line">    quickSort(<span class="built_in">array</span>, pivot + <span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> <span class="built_in">begin</span>, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// pivot: 标杆位置，counter: 小于a[pivot]的元素的个数</span></span><br><span class="line">    <span class="keyword">int</span> pivot = <span class="built_in">end</span>, counter = <span class="built_in">begin</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">begin</span>; i &lt; <span class="built_in">end</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; a[pivot]) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = a[counter]; a[counter] = a[i]; a[i] = temp;</span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> temp = a[pivot]; a[pivot] = a[counter]; a[counter] = temp;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>稍微复杂的过程是partition，它做的是，返回一个下标pivot，且能够保证pivot之前的元素都小于pivot，pivot之后的元素都大于pivot。(但是需要注意，每次partition只能保证pivot前面的是小于它的，后面是大于它的，前面和后面不能保证是有序的)</p>
<p>这段代码其实是非常考验基本功的。</p>
<p>实现过程中，我们可以申请一个新的数组，通过比较，把小的元素放到数组的左边，大的元素放到数组的右边。但是如果不能申请一个新的数组，那么这段代码是非常巧妙的。</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (int i = <span class="keyword">begin</span>; i &lt; <span class="keyword">end</span>; i++) <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    if (a[i] &lt; a[pivot]) &#123;</span></span><br><span class="line"><span class="comment">        int temp = a[counter]; a[counter] = a[i]; a[i] = temp;</span></span><br><span class="line"><span class="comment">        counter++;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一开始把pivot定义在传入的数组的最后的位置，然后根据情况改变pivot的位置。counter用于统计小于a[pivot]的元素的个数。这里的关键是，只要a[i] &lt; a[pivot]，说明a[counter]要和a[i]交换位置。</p>
<p>这里一开始我也没能理解，但是用纸笔模拟了一下之后，发现真的很巧妙。一开始counter和i都是begin，是从相同的地方开始的，然后counter用于指在最后一个小于a[pivot]的元素上，i的值来进行循环，如果碰到比末尾的pivot值大的值，就跳过（因为这个是要留给counter进行交换的,counter此时的作用是把大的元素和后面的i位置的，而且比a[pivot]小元素进行交换），i只要碰到了小于a[pivot]的，就让前面的counter和这个小于a[pivot]的元素交换，从而让大的元素移到后面去，然后把counter往后移，如果此时a[counter]的元素是大于a[pivot]的，那么此时counter所指的元素是为了进行下次交换的。保证counter前面的所有值都是小于a[pivot]的。</p>
<p>一直这样下去，直到begin和end都遍历完了，然后交换a[pivot]和a[counter]，由此一来，绝对可以保证a[piovot]成为一个分水岭，pivot成为一个标杆，a[pivot]左边所有的元素都会是小于a[pivot]的，右边都是大于a[pivot]的。</p>
<p>快排就是这样，大家写的时候，就是把这一段记好，多写几次，多写几次，记住关键的pivot和counter以及它们的作用。</p>
<p><strong>但是需要注意快排的缺陷</strong>：如果一个数组本身已经排好序了，那么每一轮排序的时候都会以最后一个数字作为比较的标准，此时快排的效率退化成了O(n^2)。所以，在面试中只要碰到了和排序有关的问题，一定要问清楚具体环境，有哪些条件约束，在得到足够多的信息之后再选择最合适的排序算法。</p>
<h3 id="归并排序-Merge-Sort"><a href="#归并排序-Merge-Sort" class="headerlink" title="归并排序(Merge Sort)"></a><strong>归并排序(Merge Sort)</strong></h3><p>归并排序也用到了<strong>分治</strong>的思想。</p>
<p>归并具体流程：</p>
<ol>
<li>把待排序的数组从中间一分为二，注意这个分只是从中间直接”劈开”，不用做任何交换元素的操作。</li>
<li>对这两个子序列先分别调用归并排序，这样可以保证左边的子序列和右边的子序列在自己的片段区间中是有序的。</li>
<li>将两个排好序的子序列合并。</li>
</ol>
<p>归并和快排刚好相反，可以把归并排序看做是快排的逆向操作。为什么？</p>
<p>具体做法不同。归并：先把数组一分为二，在左边和右边都分别调用了排序方法排好序之后，再把左右排好序的两个子数组合并成一个。</p>
<p>快排：先用partition排好序从而找到pivot的位置，然后再用pivot进行大小的”分隔”，和归并排序是完全相反的操作。</p>
<p>然后看代码，首先是mergeSort的主函数部分：</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">public static void mergeSort(<span class="built_in">int</span>[] array, <span class="built_in">int</span> <span class="built_in">left</span>, <span class="built_in">int</span> <span class="built_in">right</span>) &#123;</span><br><span class="line">    <span class="built_in">if</span> (<span class="built_in">right</span> &lt;= <span class="built_in">left</span>) return;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">mid</span> = (<span class="built_in">left</span> + <span class="built_in">right</span>) &gt;&gt; <span class="number">1</span>; // (<span class="built_in">left</span> + <span class="built_in">right</span>) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    mergeSort(array, <span class="built_in">left</span>, <span class="built_in">mid</span>);</span><br><span class="line">    mergeSort(array, <span class="built_in">mid</span> + <span class="number">1</span>, <span class="built_in">right</span>);</span><br><span class="line">    merge(array, <span class="built_in">left</span>, <span class="built_in">mid</span>, <span class="built_in">right</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先直接从中间一分为二地”劈开”, 得到mid，然后递归，每次都切分一次。最后在每次递归的终止的地方将切分并且排好序的两部分合并。</p>
<p>然后对于merge的逻辑怎么写，之前写过的，把两个有序的链表怎么合并，那里已经知道用O(n)就可以解决。</p>
<p>在这里的情况是，给你一个数组，它的两半部分全部都是排好序的，你怎么把它合并起来？你也可以想象，给你两个数组，这两个数组都是排好序的，怎么把它合并起来。</p>
<p>这种程序题目，逻辑相对来说比较简单，但是对于基础编码功底要求很高。</p>
<p>经过挑选出来的合并的代码，应该是最精简，最漂亮的代码。</p>
<p>如果之前没写过这段代码，多多少少是要花一些功夫的。</p>
<p>应当把这种，<strong>把两个有序的数组合并在一起（或者在这里称之为归并）</strong>，的方法，当成一个代码的模板，记在脑子里。最好能够灵活运用。这是提高你最基础的内容的很重要的一个部分。</p>
<p>merge方法部分：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> static <span class="type">void</span> merge(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right) &#123;</span><br><span class="line">        <span class="type">int</span>[] <span class="keyword">temp</span> = <span class="built_in">new</span> <span class="type">int</span>[right - left + <span class="number">1</span>]; // 中间数组</span><br><span class="line">        <span class="type">int</span> i = left, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">temp</span>[k++] = arr[i] &lt;= arr[j] ? arr[i++] : arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid)   <span class="keyword">temp</span>[k++] = arr[i++];</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= right) <span class="keyword">temp</span>[k++] = arr[j++];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">0</span>; p &lt; <span class="keyword">temp</span>.length; p++) &#123;</span><br><span class="line">            arr[left + p] = <span class="keyword">temp</span>[p];</span><br><span class="line">        &#125;</span><br><span class="line">        // 也可以用 <span class="keyword">System</span>.arraycopy(a, start1, b, start2, length)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这段代码具体在做什么呢？</p>
<p>首先，从left到mid和从mid到right都已经有序了。把这两个子序列合并在一起。</p>
<p>你可以想象为，有两个数组，第一个数组从left到mid，第二个数组是从mid到right。这两个数组分别是有序的，怎样合并起来。</p>
<p>首先，要申请一段额外的内存空间（归并排序必须要申请一块额外的内存空间出来）</p>
<p><code>int[] temp = new int[right - left + 1]; // 中间数组</code></p>
<p>需要的大小也没什么好说的，很多申请数组的大小都是要有这么一个+1的内容。</p>
<p>接下来，定义了两个下标i和j, i就是left，j是mid+1，也就是，i表示第一个数组的起始位置，j表示第二个数组的起始位置。k指的是temp这个数组里面已经填入的元素的个数。</p>
<p>关于合并：<font color=#FF0000>在看了这段之后，一定要养成一个习惯：要合并两个有序的数组，它永远是这种三段式写法：</font></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">i</span> &lt;= mid &amp;&amp; <span class="built_in">j</span> &lt;= right) &#123;</span><br><span class="line">    temp[k++] = arr[<span class="built_in">i</span>] &lt;= arr[<span class="built_in">j</span>] ? arr[<span class="built_in">i</span>++] : arr[<span class="built_in">j</span>++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">i</span> &lt;= mid)   temp[k++] = arr[<span class="built_in">i</span>++];</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">j</span> &lt;= right) temp[k++] = arr[<span class="built_in">j</span>++];</span><br></pre></td></tr></table></figure>

<p>具体分析：</p>
<p>第一个while：保证i没有循环完且j也没有循环完（所以有i&lt;=mid和j&lt;=right），然后比较a[i]和a[j]中的较小者，把较小者拿出来放到temp[k]里面去。同时，用了a[i]，就让i++（因为要再去用下一个元素了），用了a[j]，就让j++（同理），然后放入到temp[k]之后，毫无疑问k也要k++。</p>
<p>上面的这一大段逻辑，就三行写完，很是巧妙：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">i</span> &lt;= mid &amp;&amp; <span class="built_in">j</span> &lt;= right) &#123;</span><br><span class="line">    temp[k++] = arr[<span class="built_in">i</span>] &lt;= arr[<span class="built_in">j</span>] ? arr[<span class="built_in">i</span>++] : arr[<span class="built_in">j</span>++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color=#FF0000>但是，强调，这句话不是奇技淫巧！对于编程写得比较多的人，这句话是经常用的！</font></p>
<p>所以要习惯于写这么一句话。这句话的逻辑是非常清晰的，而且简明扼要。它做得事情就是，比较a[i]和a[j]中的较小者，取出来之后，把较小者赋值给temp[k]，同时a[i]或者a[j]谁被用到，就让下标加一用于下次使用，然后k也要移动用于下一次使用。</p>
<p>这个循环写完之后，可以保证一点，就是i全部走完子数组，或者j全部走完了子数组。</p>
<p>接下来要做的，如果i没有走完，那么把i的剩余部分赋值到temp[k]里面去，或者j没有走完的话，把j剩余部分复制到temp[k]里面去。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">i</span> &lt;= mid)   temp[k++] = arr[<span class="built_in">i</span>++];</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">j</span> &lt;= right) temp[k++] = arr[<span class="built_in">j</span>++];</span><br></pre></td></tr></table></figure>

<p>在这两个while循环也写完之后，你可以发现，整个数组已经完成了归并，放到了temp[]里面了。</p>
<p>因为我们在merge这个函数里面是要对arr[]进行排序，所以我们要再把temp里面的所有元素再拷贝回array里面去。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> p = <span class="number">0</span>; p &lt; temp.length; p++) &#123;</span><br><span class="line">    arr[left + p] = temp[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 也可以用 System.arraycopy(a, start1, b, start2, length)</span></span><br></pre></td></tr></table></figure>

<p>对于归并排序的代码，希望大家多多练习，把这段代码写得更细腻。</p>
<p>以及，<font color=#FF0000>把这段很能体现编程内力的代码可以在白板上写出来，面试官肯定会刮目相看的。</font></p>
<hr>
<h3 id="给出一个时间复杂度为O-n-的排序算法？"><a href="#给出一个时间复杂度为O-n-的排序算法？" class="headerlink" title="给出一个时间复杂度为O(n)的排序算法？"></a>给出一个时间复杂度为O(n)的排序算法？</h3><p>理论上是不太合理的，但是如果这么问，那么我们一定要多问问题，问清楚O(n)排序算法的环境和背景。比如要给一个公司的几万名员工按照年龄进行排序，那么，首先，年龄的范围可以定位18-99，这是个有限大小的范围，我们可以申请这么大的数组(但是空间复杂度为O(1)，因为是确定的。)然后遍历一遍所有员工，每次在年龄对应的下标上加1，即可完成按照年龄的排序了。</p>
<h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><p>归并 和 快排 具有相似性，但步骤顺序相反。</p>
<ul>
<li>归并：线排序左右子数组，然后合并两个有序子数组。</li>
<li>快排：先调配出左右子数组，然后对左右子数组进行合并。</li>
</ul>
<p>快排先调配左右子数组，就是让左边的数组的所有元素都小于右边数组的所有元素（中间的元素为pivot，就是pivot左边的所有元素都小于pivot，右边的所有元素都大于pivot）。但是左、右的元素在这个时候仍然还是无序的，那么然后对于左、右子数组分别调用排序的函数进行分治。</p>
<p><font color=#FF0000>快排和归并排序都讲完了，这两个是高级排序的面试的重点，一定要细细品味，多过遍数。</font></p>
<ul>
<li><strong>堆排序(Merge Sort)</strong></li>
</ul>
<p>堆插入时间复杂度为O(logN)，取堆顶，最大/小值，时间复杂度为O(1)。但是取完元素之后需要进行Heapify，所以要额外乘上O(n)的时间复杂度，整个的时间复杂度为O(N*logN)</p>
<p>堆排序的过程：</p>
<ol>
<li>对元素依次建立最小堆</li>
<li>依次取堆顶元素，并删除</li>
</ol>
<p>堆本身是一种很有意思的数据结构，使用数组存储一个树状结构，通过自身的规律，可以用简单的公式获取到当前某个节点的父节点或者左右孩子节点(注意起始坐标是0还是1，公式有区别)。</p>
<p>关键点就是，每次你在调整之前，儿子节点如果大于父亲节点，两者就交换，一直到当前节点小于其他祖宗节点。</p>
<p><strong>非比较类排序</strong></p>
<ul>
<li>计数排序(Counting Sort)</li>
</ul>
<p>计数排序要求输入的数据必须是有确定范围的整数。将输入的数据值转化为键存储在额外开辟的数组空间中；然后依次把计数大于1的填充回原数组。<font color=#FF0000>总之，你的元素必须是整数，而且元素值不能太大，否则浪费空间。</font></p>
<ul>
<li>桶排序(Bucket Sort)</li>
</ul>
<p>工作原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序(有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序)。</p>
<ul>
<li>基数排序(Radix Sort)</li>
</ul>
<p>按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。<font color=#FF0000>先按照个位进行排序，也就是放到0,1,2…9的位置，把低位先排好序。然后再排十位，再按照0-9的值排上去。然后百位，以此类推。这样一来，排序的数组只需要存储0-9的数字，这是比较巧妙的地方。但是基数排序也是有一个短板，就是只能存储整数，不能存储小数的值。<br></font></p>
]]></content>
      <categories>
        <category>Algorithms Note</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Practice by Categories Bitwise Operation</title>
    <url>/2020/01/13/LeetCode-Practice-by-Categories-Bitwise-Operation/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>LeetCode Practice by Categories Dynamic Programming</title>
    <url>/2020/01/13/LeetCode-Practice-by-Categories-Dynamic-Programming/</url>
    <content><![CDATA[<blockquote>
<p>每个人都是自己命运的主宰——斯蒂尔斯</p>
</blockquote>
<p>LeetCode大量动态规划相关题目，其解决思路和具体代码。</p>
<a id="more"></a>

<p>动态规划不是空中楼阁。</p>
<p>dynamic programming最常用的场景就是当你的结果存在大量重复的过程的时候，可以用DP利用你在过程中得到的结果。</p>
<h2 id="70-Climbing-stairsl-爬楼梯-Easy"><a href="#70-Climbing-stairsl-爬楼梯-Easy" class="headerlink" title="70. Climbing-stairsl(爬楼梯)(Easy)"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. Climbing-stairsl(爬楼梯)(Easy)</a></h2><p>You are climbing a stair case. It takes n steps to reach to the top.</p>
<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>
<p>Note: Given <em>n</em> will be a positive integer.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">Output:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">Explanation:</span> <span class="string">There</span> <span class="string">are</span> <span class="string">two</span> <span class="string">ways</span> <span class="string">to</span> <span class="string">climb</span> <span class="string">to</span> <span class="string">the</span> <span class="string">top.</span></span><br><span class="line"><span class="number">1</span><span class="string">.</span> <span class="number">1</span> <span class="string">step</span> <span class="string">+</span> <span class="number">1</span> <span class="string">step</span></span><br><span class="line"><span class="number">2</span><span class="string">.</span> <span class="number">2</span> <span class="string">steps</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">Output:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">Explanation:</span> <span class="string">There</span> <span class="string">are</span> <span class="string">three</span> <span class="string">ways</span> <span class="string">to</span> <span class="string">climb</span> <span class="string">to</span> <span class="string">the</span> <span class="string">top.</span></span><br><span class="line"><span class="number">1</span><span class="string">.</span> <span class="number">1</span> <span class="string">step</span> <span class="string">+</span> <span class="number">1</span> <span class="string">step</span> <span class="string">+</span> <span class="number">1</span> <span class="string">step</span></span><br><span class="line"><span class="number">2</span><span class="string">.</span> <span class="number">1</span> <span class="string">step</span> <span class="string">+</span> <span class="number">2</span> <span class="string">steps</span></span><br><span class="line"><span class="number">3</span><span class="string">.</span> <span class="number">2</span> <span class="string">steps</span> <span class="string">+</span> <span class="number">1</span> <span class="string">step</span></span><br></pre></td></tr></table></figure>
<hr>
<p>解：爬楼梯很经典，变型也很多。首先结论是，单纯的这道题，通过数学归纳的思路(或者说递归的思路)，不难发现其实结果就是前两个元素为1,2的斐波那契数列。(斐波那契数列为509题，因为类似这里就不记录了，链接<a href="https://leetcode-cn.com/problems/fibonacci-number/" target="_blank" rel="noopener">点击这里</a>)</p>
<p>方法一：递归，可以画出递归树发现，因为每个层级都会在上一层的数量基础上多出2倍的节点，所以时间复杂度为O(2^n)，指数级别，不可以接受。而且实际测试中在N为44的时候会出现超时。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> climbStairs(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> climbHelper(<span class="number">0</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> climbHelper(<span class="built_in">int</span> curr, <span class="built_in">int</span> target) &#123;</span><br><span class="line">        <span class="comment">// terminator</span></span><br><span class="line">        <span class="comment">// 跨过了目标阶梯，不算入方法</span></span><br><span class="line">        <span class="keyword">if</span>(curr &gt; target) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 刚好攀登到某个位置</span></span><br><span class="line">        <span class="keyword">if</span>(curr == target) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> climbHelper(curr + <span class="number">1</span>, target) + climbHelper(curr + <span class="number">2</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>方法二：基于递归，加上备忘录，进行有记忆的递归，可以把之前计算过的结果保存下来，有很好的剪枝效果。因为有记录所有的过程，所以子问题的数量就是f(1),f(2)…，为O(n),而且每个子问题解决的时间为O(n)</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> climbStairs(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="comment">// 基于暴力递归，进行有记忆的递归，把每一步的结果存储在mem数组之中，每当有函数被再次调用，就直接从memo数组返回结果，减少计算次数</span></span><br><span class="line">        <span class="built_in">int</span>[] memo = new <span class="built_in">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> climbHelper(<span class="number">0</span>,n,memo);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> climbHelper(<span class="built_in">int</span> curr, <span class="built_in">int</span> target, <span class="built_in">int</span>[] memo) &#123;</span><br><span class="line">        <span class="comment">// terminator</span></span><br><span class="line">        <span class="comment">// 跨过了目标阶梯，不算入方法</span></span><br><span class="line">        <span class="keyword">if</span>(curr &gt; target) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 刚好攀登到某个位置</span></span><br><span class="line">        <span class="keyword">if</span>(curr == target) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果当前N阶梯数量已经计算过，直接从memo返回</span></span><br><span class="line">        <span class="keyword">if</span>(memo[curr] &gt; <span class="number">0</span>) <span class="keyword">return</span> memo[curr];</span><br><span class="line">        </span><br><span class="line">        memo[curr] =  climbHelper(curr + <span class="number">1</span>, target, memo) + climbHelper(curr + <span class="number">2</span>, target, memo);</span><br><span class="line">        <span class="keyword">return</span> memo[curr];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>方法三：常规动态规划，时间复杂度为O(n)，空间复杂度也为O(n)</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> climbStairs(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// dp[i]表示爬到第i阶共有的爬法</span></span><br><span class="line">        <span class="built_in">int</span>[] dp = new <span class="built_in">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>; dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法四：基于常规动态规划的优化。在空间复杂度上可以提升到O(1)。实际上在一开始的时间复杂度的基础上都可以进行空间的优化，比如O(n)可以优化到O(1),O(m*n)可以优化到O(n)。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> climbStairs(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> f1 = <span class="number">1</span>, f2 = <span class="number">2</span>, f3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            f3 = f1 + f2;</span><br><span class="line">            f1 = f2;</span><br><span class="line">            f2 = f3;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="322-Coin-Change-零钱兑换-Mid"><a href="#322-Coin-Change-零钱兑换-Mid" class="headerlink" title="322. Coin Change(零钱兑换)(Mid)"></a><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">322. Coin Change(零钱兑换)(Mid)</a></h2><p>You are given coins of different denominations and a total amount of money <em>amount</em>. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return <code>-1</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="string">coins</span> <span class="string">=</span> <span class="string">[1,</span> <span class="number">2</span><span class="string">,</span> <span class="number">5</span><span class="string">],</span> <span class="string">amount</span> <span class="string">=</span> <span class="number">11</span></span><br><span class="line"><span class="attr">Output:</span> <span class="number">3</span> </span><br><span class="line"><span class="attr">Explanation:</span> <span class="number">11</span> <span class="string">=</span> <span class="number">5</span> <span class="string">+</span> <span class="number">5</span> <span class="string">+</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="string">coins</span> <span class="string">=</span> <span class="string">[2],</span> <span class="string">amount</span> <span class="string">=</span> <span class="number">3</span></span><br><span class="line"><span class="attr">Output:</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>


<p><strong>Note:</strong></p>
<p>You may assume that you have an infinite number of each kind of coin.</p>
<hr>
<p>解：这道题其实和之前的爬楼梯问题是异曲同工之处，可以看成每次可以走coins数组里面的步伐，最后要到达amount的高度，有多少种走法。当然这里有点变化，就是比如112和121，在爬楼梯问题是不同方法，而在这里coin change则是相同的，一种方法。但是写DP方程的话差不多了。</p>
<p>方法一：暴力法，用递归的方式。</p>
<p><img src="https://s2.ax1x.com/2020/02/21/3uunUK.png" alt="3uunUK.png"></p>
<p>题目变成：在状态树中找到叶子节点为0的，并且层数最小的。<br>可以用树的广度优先遍历，直到碰到数值为0的节点，当前层数就是最小硬币数，就是我们的答案。</p>
<p>但是这个方法会存在指数级别的时间复杂度。</p>
<p>方法二：DP</p>
<p>a. subproblems</p>
<p>b. DP array：f(n) = min{f(n-k), for k in [1,2,5]} + 1, 遍历可以选择的面值的数组，直到n被减到0为止，然后取得到的硬币数的最小值。加一是因为一开始的n-k没有被算入，后面补上。</p>
<p>c. DP方程</p>
<p>代码：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> coinChange(<span class="built_in">int</span>[] coins, <span class="built_in">int</span> amount) &#123;</span><br><span class="line">        <span class="comment">// amount + 1 是无法到达的，以此判断最后是否不能到达amount</span></span><br><span class="line">        <span class="built_in">int</span> max = amount+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// dp数组的下标是当前金额，里面的值是需要的硬币的个数，初始化是不可达的max</span></span><br><span class="line">        <span class="built_in">int</span>[] dp = new <span class="built_in">int</span>[max];</span><br><span class="line">        <span class="comment">// 初始化dp,初始化考虑只有面值为1的硬币，需要max个</span></span><br><span class="line">        Arrays.fill(dp,max);</span><br><span class="line">        <span class="comment">// 当拿到的amount是0的时候，需要0个硬币，类似爬楼梯，初始化就在0级台阶</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 外层，遍历所有下标的元素，也就是当前凑到的面值数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">            <span class="comment">// 每次都从coins里面取元素出来，比如coins是[1,2,5]，每次在要凑下标</span></span><br><span class="line">            <span class="comment">// 值的时候，都会把1,2,5取出来进行值的拼凑</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; coins.length; j++) &#123;</span><br><span class="line">                <span class="comment">// 如果当前coins里面取出来的值比下标小，才能用。否则比如你下标是3，</span></span><br><span class="line">                <span class="comment">// 即当前要凑到3的值，但当前conis里面硬币值是10，那肯定不用这个</span></span><br><span class="line">                <span class="keyword">if</span>(coins[j] &lt;= i) &#123;</span><br><span class="line">                    <span class="comment">// 用DP方程进行递推</span></span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[i-coins[j]] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果最后一个没有被修改，则没办法组成这个金额。否则返回最后amount下标的值</span></span><br><span class="line">        <span class="keyword">return</span> dp[amount] == max ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态规划一般脱离递归，直接由循环迭代完成计算。</p>
<p>动态规划问题最难的就是写出状态转移方程。</p>
<p>时间复杂度：O(m*n)</p>
<h2 id="343-Integer-Break-整数拆分-Mid"><a href="#343-Integer-Break-整数拆分-Mid" class="headerlink" title="343. Integer Break(整数拆分)(Mid)"></a><a href="https://leetcode-cn.com/problems/integer-break/" target="_blank" rel="noopener">343. Integer Break(整数拆分)(Mid)</a></h2><p>Given a positive integer n, break it into the sum of <strong>at least</strong> two positive integers and maximize the product of those integers. Return the maximum product you can get.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">Output:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">Explanation:</span> <span class="number">2</span> <span class="string">=</span> <span class="number">1</span> <span class="string">+</span> <span class="number">1</span><span class="string">,</span> <span class="number">1</span> <span class="string">×</span> <span class="number">1</span> <span class="string">=</span> <span class="number">1</span><span class="string">.</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">Output:</span> <span class="number">36</span></span><br><span class="line"><span class="attr">Explanation:</span> <span class="number">10</span> <span class="string">=</span> <span class="number">3</span> <span class="string">+</span> <span class="number">3</span> <span class="string">+</span> <span class="number">4</span><span class="string">,</span> <span class="number">3</span> <span class="string">×</span> <span class="number">3</span> <span class="string">×</span> <span class="number">4</span> <span class="string">=</span> <span class="number">36</span><span class="string">.</span></span><br></pre></td></tr></table></figure>

<p><strong>Note</strong>:You may assume that <em>n</em> is not less than 2 and not larger than 58</p>
<p><strong>注</strong>：这道题和剑指offer上第14，剪绳子，题目不同，但是考察内容非常类似。链接可以<a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/" target="_blank" rel="noopener">点击这里</a></p>
<hr>
<p>解：这道题可以用纯数学思路和动态规划两种方法解决</p>
<p>方法一：纯数学，其实就是通过分析之后用贪心法。可以用数学归纳法证明，目标是拆分成多个3的乘积，并且能拆分成2*2就不拆分成 1 * 3。</p>
<p>详细内容可以参考<a href="https://leetcode-cn.com/problems/integer-break/solution/343-zheng-shu-chai-fen-tan-xin-by-jyd/" target="_blank" rel="noopener">这篇题解</a></p>
<p>简而言之，要尽可能把数字拆分成3或者3的倍数。但是按照题目要求，至少要剪一次，至少要两段，所以边界条件值(n小于等于3的时候)可以考虑返回n-1.</p>
<p>因为拆分成2比拆分成3乘积更小，所以3优先级大于2,2大于1</p>
<p>然后要求出n除以3的整数部分a和余数部分b(即<code>n=3*a+b</code>)，要分成三种情况：</p>
<ol>
<li>当b=0时，直接返回3^a;</li>
<li>当b=1时，要将一个1+3转换成2+2，因为2*2 &gt; 1 * 3，因此返回 3^(a-1) * 4;</li>
<li>当b=2时，返回3^n*2即可</li>
</ol>
<p>代码如下：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> <span class="built_in">int</span>egerBreak(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">3</span>) <span class="keyword">return</span> n<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">int</span> a = n / <span class="number">3</span>, b = n % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> (<span class="built_in">int</span>)Math.pow(<span class="number">3</span>,a);</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">1</span>) <span class="keyword">return</span> (<span class="built_in">int</span>)Math.pow(<span class="number">3</span>, a<span class="number">-1</span>) * <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">int</span>)Math.pow(<span class="number">3</span>,a) * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度为O(1)，仅有求整、取余、次方计算操作</li>
<li>空间复杂度：O(1)，只需要变量a和b和常数大小的额外空间</li>
</ul>
<h2 id="221-Maximal-Square-最大正方形-Mid"><a href="#221-Maximal-Square-最大正方形-Mid" class="headerlink" title="221.  Maximal Square(最大正方形)(Mid)"></a><a href="https://leetcode-cn.com/problems/maximal-square/" target="_blank" rel="noopener">221.  Maximal Square(最大正方形)(Mid)</a></h2><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area.</p>
<p><strong>Example:</strong></p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Input</span>: </span><br><span class="line"></span><br><span class="line">1 0 1 0 0</span><br><span class="line">1 0 1 1 1</span><br><span class="line">1 1 1 1 1</span><br><span class="line">1 0 0 1 0</span><br><span class="line"></span><br><span class="line"><span class="attribute">Output</span>: 4</span><br></pre></td></tr></table></figure>

<hr>
<p>解：别误读了题意，输入只是二维matrix，要找Square而已！</p>
<p>这道题看上去和”Stack-Queue”系列的84、85题好像很类似，但是做法和思路完全不同，而且也比那两道题更简单……主要的原因是正方形比矩形性质好用太多，直接用动态规划的思想即可。</p>
<p>发现规律：申请一个dp[][][]二维数组，通过找规律和观察，可以发现，如果某个位置的值为1，那么这个位置上的值取决于它的<font color=#FF0000>上面、左上角、左边</font>三个值的最小值加1.</p>
<p>然后每次都检查当前存储的值是否可以替换掉之前的maxSquare值即可。</p>
<p>因为最后求的是area，所以直接返回<code>maxSquare*maxSquare</code>即可。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> maximalSquare(char[][] matrix) &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 注意rows和cols的值，别弄反了</span></span><br><span class="line">        <span class="built_in">int</span> rows = matrix.length, cols = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// 最大边长</span></span><br><span class="line">        <span class="built_in">int</span> maxSquare = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 申请dp数组，大小比行和列都多1，这样可以防止处理的时候越界</span></span><br><span class="line">        <span class="comment">// 申请的时候多申请1，这道题可以不用考虑边界情况，直接把</span></span><br><span class="line">        <span class="comment">// 原本的数组重新"填"到dp数组里，值是当前能组成的最大Square</span></span><br><span class="line">        <span class="built_in">int</span>[][] dp = new <span class="built_in">int</span>[rows + <span class="number">1</span>][cols + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">1</span>; j &lt;= cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i - <span class="number">1</span>][j - <span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    <span class="comment">// 取当前左、上、左上三个方向的最小值，再加1</span></span><br><span class="line">                    <span class="comment">// Math.min函数一次最多只能有两个参数，要注意</span></span><br><span class="line">                    dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>],Math.min(dp[i][j - <span class="number">1</span>],dp[i - <span class="number">1</span>][j])) + <span class="number">1</span>;</span><br><span class="line">                    maxSquare = Math.max(maxSquare, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSquare * maxSquare;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="303-Range-Sum-Query-Immutable-区域和检索-数组不可变-Easy"><a href="#303-Range-Sum-Query-Immutable-区域和检索-数组不可变-Easy" class="headerlink" title="303.Range Sum Query-Immutable(区域和检索-数组不可变)(Easy)"></a><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/" target="_blank" rel="noopener">303.Range Sum Query-Immutable(区域和检索-数组不可变)(Easy)</a></h2><p>Given an integer array <em>nums</em>, find the sum of the elements between indices i and j (<em>i</em> ≤ <em>j</em>), inclusive.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Given nums = [<span class="number">-2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">-5</span>, <span class="number">2</span>, <span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">sumRange(<span class="number">0</span>, <span class="number">2</span>) -&gt; <span class="number">1</span></span><br><span class="line">sumRange(<span class="number">2</span>, <span class="number">5</span>) -&gt; <span class="number">-1</span></span><br><span class="line">sumRange(<span class="number">0</span>, <span class="number">5</span>) -&gt; <span class="number">-3</span></span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ol>
<li>You may assume that the array does not change.</li>
<li>There are many calls to sumRange function.</li>
</ol>
<hr>
<p>解：动态规划的思路解决，预先将所有的相加可能的结果计算出来并存储起来，然后调用它来找到即可。注意下标问题。</p>
]]></content>
      <categories>
        <category>Algorithms Note</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Practice by Categories Search</title>
    <url>/2020/01/13/LeetCode-Practice-by-Categories-Search/</url>
    <content><![CDATA[<blockquote>
<p>轻财足以聚人，律己足以服人，量宽足以得人，身先足以率人。——陈继儒</p>
</blockquote>
<p>LeetCode搜索相关题目，其解决思路和具体代码。内容也包括二分查找。</p>
<a id="more"></a>

<p>在树的章节中已经包括了很多有关DFS和BFS的题目，比如，非常经典和重要的，树的层次遍历(102)和树的一些遍历。之前重复的在这里先不再写了。</p>
<h2 id="74-Search-a-2D-Matrix-搜索二维矩阵-Mid"><a href="#74-Search-a-2D-Matrix-搜索二维矩阵-Mid" class="headerlink" title="74. Search a 2D Matrix(搜索二维矩阵)(Mid)"></a><a href="https://leetcode-cn.com/problems/search-a-2d-matrix/" target="_blank" rel="noopener">74. Search a 2D Matrix(搜索二维矩阵)(Mid)</a></h2><p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p>
<ul>
<li>Integers in each row are sorted from left to right.</li>
<li>The first integer of each row is greater than the last integer of the previous row.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">matrix = [</span><br><span class="line">  [<span class="number">1</span>,   <span class="number">3</span>,  <span class="number">5</span>,  <span class="number">7</span>],</span><br><span class="line">  [<span class="number">10</span>, <span class="number">11</span>, <span class="number">16</span>, <span class="number">20</span>],</span><br><span class="line">  [<span class="number">23</span>, <span class="number">30</span>, <span class="number">34</span>, <span class="number">50</span>]</span><br><span class="line">]</span><br><span class="line">target = <span class="number">3</span></span><br><span class="line">Output: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">matrix = [</span><br><span class="line">  [<span class="number">1</span>,   <span class="number">3</span>,  <span class="number">5</span>,  <span class="number">7</span>],</span><br><span class="line">  [<span class="number">10</span>, <span class="number">11</span>, <span class="number">16</span>, <span class="number">20</span>],</span><br><span class="line">  [<span class="number">23</span>, <span class="number">30</span>, <span class="number">34</span>, <span class="number">50</span>]</span><br><span class="line">]</span><br><span class="line">target = <span class="number">13</span></span><br><span class="line">Output: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：这道题和下一道题几乎是兄弟模样，但是比240更简单，主要因为properties的第二条——他在保证了每一行为递增的之外，还保证下一行的第一个元素一定大于上一行的最后一个。</p>
<p>经典的二分查找的思想，把整个二维数组当成是一个排好序的数组对待即可。</p>
<p>需要注意的一个很有用的公式：</p>
<ul>
<li>把m*n的二维矩阵转换成一个数组：matrix[x][y] =&gt; array[x * n + y]</li>
<li>把一个array转换成m*n的二维矩阵：array[x] =&gt; matrix[x/n][x%n]</li>
</ul>
<p>抓住了上面这个转换机制，就抓住了关键</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span>ean searchMatrix(<span class="built_in">int</span>[][] matrix, <span class="built_in">int</span> target) &#123;</span><br><span class="line">        <span class="comment">// corner case</span></span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// start为开始的位置，end为当前终止的位置</span></span><br><span class="line">        <span class="comment">// rows为行数，cols为列数</span></span><br><span class="line">        <span class="built_in">int</span> start = <span class="number">0</span>, rows = matrix.length, cols = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="built_in">int</span> end = rows * cols - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start &lt;= end) &#123;</span><br><span class="line">            <span class="comment">// 找到当前中间位置的元素mid</span></span><br><span class="line">            <span class="built_in">int</span> mid = (end + start) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 最关键的是用start和end与二维矩阵matrix之间的转换公式</span></span><br><span class="line">            <span class="comment">// 二维矩阵转换中最重要的是列数，这个和定义二维数组的时候，可以没有</span></span><br><span class="line">            <span class="comment">// 行数，但是必须声明列数的道理是一样的</span></span><br><span class="line">            <span class="keyword">if</span>(matrix[mid / cols][mid % cols] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果当前mid比target小，那么target一定在mid右边，就要把start右移</span></span><br><span class="line">            <span class="comment">// vice versa</span></span><br><span class="line">            <span class="keyword">if</span>(matrix[mid / cols][mid % cols] &lt; target) &#123;</span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：标准的二分查找，时间复杂度为O(log(m*n))</li>
<li>空间复杂度：O(1)</li>
</ul>
<h2 id="240-Search-a-2D-Matrix-II-搜索二维矩阵-Mid"><a href="#240-Search-a-2D-Matrix-II-搜索二维矩阵-Mid" class="headerlink" title="240. Search a 2D Matrix II(搜索二维矩阵)(Mid)"></a><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/" target="_blank" rel="noopener">240. Search a 2D Matrix II(搜索二维矩阵)(Mid)</a></h2><p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p>
<ul>
<li>Integers in each row are sorted in ascending from left to right.</li>
<li>Integers in each column are sorted in ascending from top to bottom.</li>
</ul>
<p><strong>Example:</strong></p>
<p>Consider the following matrix:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,   <span class="number">4</span>,  <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>],</span><br><span class="line">  [<span class="number">2</span>,   <span class="number">5</span>,  <span class="number">8</span>, <span class="number">12</span>, <span class="number">19</span>],</span><br><span class="line">  [<span class="number">3</span>,   <span class="number">6</span>,  <span class="number">9</span>, <span class="number">16</span>, <span class="number">22</span>],</span><br><span class="line">  [<span class="number">10</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">17</span>, <span class="number">24</span>],</span><br><span class="line">  [<span class="number">18</span>, <span class="number">21</span>, <span class="number">23</span>, <span class="number">26</span>, <span class="number">30</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>Given target = <code>5</code>, return <code>true</code>.</p>
<p>Given target = <code>20</code>, return <code>false</code>.</p>
<hr>
<p>解：和74的区别是，此题输入的数组下一行的首元素和上一行相比不是递增的，而是在行和列这两个方向上是递增的，这样一来解题思路和上一题就完全不同了。上一题因为存储方式和二维矩阵与数组的转换方式有吻合之处所以可以用二分法，这里也可以，但是没有上一题那么容易解了。</p>
<p>但是不难发现，因为在行和列这两个方向是递增的，所以右上角成为了突破口。右上角的元素如果大于target，那么再次查找target的时候可以排除之前的一列；如果右上角元素小于target，那么再次查找的时候可以排除之前元素的这一行。</p>
<p>写法一：从右上角开始突破。</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean searchMatrix(int[][] <span class="built_in">matrix</span>, int target) &#123;</span><br><span class="line">        // corner case</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">matrix</span> == null || <span class="built_in">matrix</span>.<span class="built_in">length</span> == <span class="number">0</span>) <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">        // 从右上角开始</span><br><span class="line">        // start our pointer fron top-right</span><br><span class="line">        int <span class="built_in">row</span> = <span class="number">0</span>, <span class="built_in">col</span> = <span class="built_in">matrix</span>[<span class="number">0</span>].<span class="built_in">length</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">col</span> &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">row</span> &lt;= <span class="built_in">matrix</span>.<span class="built_in">length</span> - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">matrix</span>[<span class="built_in">row</span>][<span class="built_in">col</span>] == target) &#123; // found it</span><br><span class="line">                <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">matrix</span>[<span class="built_in">row</span>][<span class="built_in">col</span>] &lt; target) &#123;</span><br><span class="line">                <span class="built_in">row</span>++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">col</span>--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理，其实从左下角开始也可以，可以把左下角当做搜索的突破口，若当前元素小于target，那么下次从当前元素的右边开始，剔除掉当前元素在的列；如果当前元素大于target,下次从当前元素上一个开始，剔除掉当前元素在的行。</p>
<p>写法二：从左下角开始突破</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean searchMatrix(int[][] <span class="built_in">matrix</span>, int target) &#123;</span><br><span class="line">        // corner case</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">matrix</span> == null || <span class="built_in">matrix</span>.<span class="built_in">length</span> == <span class="number">0</span>) <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">        // 从左下角开始</span><br><span class="line">        // start our pointer fron bottom-left</span><br><span class="line">        int <span class="built_in">col</span> = <span class="number">0</span>, <span class="built_in">row</span> = <span class="built_in">matrix</span>.<span class="built_in">length</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">row</span> &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">col</span> &lt;= <span class="built_in">matrix</span>[<span class="number">0</span>].<span class="built_in">length</span> - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">matrix</span>[<span class="built_in">row</span>][<span class="built_in">col</span>] == target) <span class="built_in">return</span> <span class="literal">true</span>; // found it</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">matrix</span>[<span class="built_in">row</span>][<span class="built_in">col</span>] &lt; target) &#123;</span><br><span class="line">                <span class="built_in">col</span>++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">row</span>--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(m + n)。时间复杂度分析的关键是注意到在每次迭代（我们不返回 true）时，行或列都会精确地递减/递增一次。由于行只能减少 mm 次，而列只能增加 nn 次，因此在导致 while 循环终止之前，循环不能运行超过 n+mn+m 次。因为所有其他的工作都是常数，所以总的时间复杂度在矩阵维数之和中是线性的。</p>
</li>
<li><p>空间复杂度：O(1)。因为这种方法都只需要处理几个指针，所以内存占用是恒定的。</p>
</li>
</ul>
<h2 id="127-Word-Ladder-单词接龙-Mid"><a href="#127-Word-Ladder-单词接龙-Mid" class="headerlink" title="127. Word Ladder(单词接龙)(Mid)"></a><a href="https://leetcode-cn.com/problems/word-ladder/" target="_blank" rel="noopener">127. Word Ladder(单词接龙)(Mid)</a></h2><p>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary’s word list, find the length of shortest transformation sequence from <em>beginWord</em> to <em>endWord</em>, such that:</p>
<ol>
<li>Only one letter can be changed at a time.</li>
<li>Each transformed word must exist in the word list. Note that <em>beginWord</em> is not a <em>transformed</em> word.</li>
</ol>
<p><strong>Note:</strong></p>
<ul>
<li>Return 0 if there is no such transformation sequence.</li>
<li>All words have the same length.</li>
<li>All words contain only lowercase alphabetic characters.</li>
<li>You may assume no duplicates in the word list.</li>
<li>You may assume beginWord and endWord are non-empty and are not the same.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">beginWord = <span class="string">"hit"</span>,</span><br><span class="line">endWord = <span class="string">"cog"</span>,</span><br><span class="line">wordList = [<span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span>,<span class="string">"cog"</span>]</span><br><span class="line"></span><br><span class="line">Output: <span class="number">5</span></span><br><span class="line"></span><br><span class="line">Explanation: As one shortest transformation <span class="keyword">is</span> <span class="string">"hit"</span><span class="function"> -&gt;</span> <span class="string">"hot"</span><span class="function"> -&gt;</span> <span class="string">"dot"</span><span class="function"> -&gt;</span> <span class="string">"dog"</span><span class="function"> -&gt;</span> <span class="string">"cog"</span>,</span><br><span class="line"><span class="keyword">return</span> its length <span class="number">5.</span></span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">Input:</span></span><br><span class="line">beginWord = <span class="string">"hit"</span></span><br><span class="line">endWord = <span class="string">"cog"</span></span><br><span class="line">wordList = [<span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span>]</span><br><span class="line"></span><br><span class="line"><span class="section">Output: 0</span></span><br><span class="line"></span><br><span class="line"><span class="section">Explanation: The endWord "cog" is not in wordList, therefore no possible transformation.</span></span><br></pre></td></tr></table></figure>
<hr>
<p>解：<strong>这道题是面试中经常会出现的问题</strong>。一般思路，可以使用初级搜索，即单向BFS。但是这里着重介绍使用双向BFS的方法，从beginWord和endWord中更小的那个开始扩散。为什么这样扩散比单向扩散效率更高？</p>
<p>因为同时从beginWord和endWord开始，然后每次从更短的一段开始继续搜索，那么因为是更小的Set，所以辐射的内容会更少，如果需要剪枝或者回溯，代价也可以更小。</p>
<p>比如，打仗的时候一方总会派出侦察兵，这些侦察兵往往身上负重很轻，因为这样他们才可以移动迅速，累赘小。而如果他们被抓了，需要被放弃，那么少量的武器，也能成为更小的损失和代价。</p>
<p>实际上，双向BFS是属于<strong>高级搜索</strong>的范畴的。对于初级搜索(BFS和DFS)，一般来说优化的思路有两个：<strong>一是让搜索过程去掉重复以及尽早剪枝</strong>，<strong>二是</strong>让它在搜索方向上加强。</p>
<p>事实上，双向BFS在高级搜索中用得比较多，而且代码并不难。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(<span class="keyword">String</span> beginWord, <span class="keyword">String</span> endWord, List&lt;<span class="keyword">String</span>&gt; wordList)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!wordList.contains(endWord)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 用Set代替Queue进行BFS, 是为了更方便查询单词是否在wordList中</span></span><br><span class="line">        <span class="comment">// 如果不用哈希，直接的list查询时间复杂度为O(n),使用Set之后时间复杂度为O(1)</span></span><br><span class="line">        Set&lt;<span class="keyword">String</span>&gt; wordListSet = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// beginSet是从beginWord开始扩散的，endSet是从endWord开始扩散的</span></span><br><span class="line">        Set&lt;<span class="keyword">String</span>&gt; beginSet = <span class="keyword">new</span> HashSet&lt;&gt;(), endSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里和单向BFS中一开始往queue中加入元素的操作类似,加入初始元素</span></span><br><span class="line">        <span class="comment">// 可以看出，beginSet和endSet本质没有先后顺序,先扩散小的可以更快收敛</span></span><br><span class="line">        beginSet.add(beginWord);</span><br><span class="line">        endSet.add(endWord);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 转换次数，这是细节，由于beingWord != endWord, 所以至少一步</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// visited 表示这个BFS节点是否已经被访问过了</span></span><br><span class="line">        Set&lt;<span class="keyword">String</span>&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// BFS start here</span></span><br><span class="line">        <span class="keyword">while</span>( !beginSet.isEmpty() ) &#123;</span><br><span class="line">            <span class="comment">// 扩散的时候优先选择小的Set</span></span><br><span class="line">            <span class="comment">// 如果beginSet更小，就扩散它</span></span><br><span class="line">            <span class="comment">// 否则如果beginSet更大，交换这两个Set,还是小的Set开始扩散</span></span><br><span class="line">            <span class="comment">// 核心：控制当前循环从哪个方向进行bfs；让begin指向size更小的集合，这样不会一直从一个方向BFS</span></span><br><span class="line">            <span class="keyword">if</span>(beginSet.<span class="built_in">size</span>() &gt; endSet.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                Set&lt;<span class="keyword">String</span>&gt; <span class="built_in">set</span> = beginSet;</span><br><span class="line">                beginSet = endSet;</span><br><span class="line">                endSet = <span class="built_in">set</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// neighbor 这个set表示每一次要扩散的set的内容</span></span><br><span class="line">            Set&lt;<span class="keyword">String</span>&gt; neighbor = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            <span class="comment">// 模板中这里会开始控制次数的for循环，但这里的HashSet和模板的queue是一样的含义,只是更方便查找</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">String</span> <span class="keyword">word</span> : beginSet) &#123;</span><br><span class="line">                <span class="comment">// 对每一个单词，变化它的字符位</span></span><br><span class="line">                <span class="keyword">char</span>[] chs = <span class="keyword">word</span>.toCharArray();</span><br><span class="line">                <span class="comment">// 用字母表遍历当前chs的每一个字母</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">char</span> c = <span class="string">'a'</span>; c &lt;= <span class="string">'z'</span>; c++) &#123;</span><br><span class="line">                        <span class="comment">// 保存chs的当前位置的字母</span></span><br><span class="line">                        <span class="keyword">char</span> old = chs[i];</span><br><span class="line">                        <span class="comment">// 然后替换成当前遍历到的字母表的字母</span></span><br><span class="line">                        chs[i] = c;</span><br><span class="line">                        <span class="comment">// 转换回String，从而使用endSet中的contains方法</span></span><br><span class="line">                        <span class="comment">// 否则不能对char[]使用contains方法</span></span><br><span class="line">                        <span class="keyword">String</span> target = <span class="keyword">String</span>.valueOf(chs);</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 因为endSet是从endWord那边扩散过来的，如果我们替换过程中产生的target也在</span></span><br><span class="line">                        <span class="comment">// 这个Set里，说明从begin扩散过来的Set和从end扩散过来的set，在这里相交了</span></span><br><span class="line">                        <span class="comment">// 这个相交的word就是target</span></span><br><span class="line">                        <span class="keyword">if</span>(endSet.contains(target)) &#123;</span><br><span class="line">                            <span class="keyword">return</span> len + <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 如果当时没找到target，则继续扩散其他的target,且把target追加到下一次</span></span><br><span class="line">                        <span class="comment">// 要扩散的set里面去，这里的neighbor set就是后面要扩散的set</span></span><br><span class="line">                        <span class="keyword">if</span>(!visited.contains(target) &amp;&amp; wordListSet.contains(target)) &#123;</span><br><span class="line">                            neighbor.add(target);</span><br><span class="line">                            <span class="comment">// 标记target 为 visited, 表示访问过了</span></span><br><span class="line">                            visited.add(target);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 把单词本身还原</span></span><br><span class="line">                        chs[i] = old;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理完beign中的元素之后，让begin指向begin中的元素的邻居</span></span><br><span class="line">            beginSet = neighbor;</span><br><span class="line">            <span class="comment">// 路径长度++</span></span><br><span class="line">            len ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有转换的路径</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="126-单词接龙-II-Hard"><a href="#126-单词接龙-II-Hard" class="headerlink" title="126. (单词接龙 II)(Hard)"></a><a href="https://leetcode-cn.com/problems/word-ladder-ii/" target="_blank" rel="noopener">126. (单词接龙 II)(Hard)</a></h2><h2 id="433-Minimum-Genetic-Mutation-最小基因变化-Mid"><a href="#433-Minimum-Genetic-Mutation-最小基因变化-Mid" class="headerlink" title="433. Minimum Genetic Mutation(最小基因变化)(Mid)"></a><a href="https://leetcode-cn.com/problems/minimum-genetic-mutation/" target="_blank" rel="noopener">433. Minimum Genetic Mutation(最小基因变化)(Mid)</a></h2><p>A gene string can be represented by an 8-character long string, with choices from <code>&quot;A&quot;, &quot;C&quot;, &quot;G&quot;, &quot;T&quot;</code>.</p>
<p>Suppose we need to investigate about a mutation (mutation from “start” to “end”), where ONE mutation is defined as ONE single character changed in the gene string.</p>
<p>For example, <code>&quot;AACCGGTT&quot; -&gt; &quot;AACCGGTA&quot;</code> is 1 mutation.</p>
<p>Also, there is a given gene “bank”, which records all the valid gene mutations. A gene must be in the bank to make it a valid gene string.</p>
<p>Now, given 3 things - start, end, bank, your task is to determine what is the minimum number of mutations needed to mutate from “start” to “end”. If there is no such a mutation, return -1.</p>
<p><strong>Note:</strong></p>
<ol>
<li>Starting point is assumed to be valid, so it might not be included in the bank.</li>
<li>If multiple mutations are needed, all mutations during in the sequence must be valid.</li>
<li>You may assume start and end string is not the same.</li>
</ol>
<p><strong>Exmaple 1:</strong></p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">start:</span> <span class="string">"AACCGGTT"</span></span><br><span class="line"><span class="symbol">end:</span>   <span class="string">"AACCGGTA"</span></span><br><span class="line"><span class="symbol">bank:</span> [<span class="string">"AACCGGTA"</span>]</span><br><span class="line"></span><br><span class="line"><span class="symbol">return:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">start:</span> <span class="string">"AACCGGTT"</span></span><br><span class="line"><span class="symbol">end:</span>   <span class="string">"AAACGGTA"</span></span><br><span class="line"><span class="symbol">bank:</span> [<span class="string">"AACCGGTA"</span>, <span class="string">"AACCGCTA"</span>, <span class="string">"AAACGGTA"</span>]</span><br><span class="line"></span><br><span class="line"><span class="symbol">return:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">start:</span> <span class="string">"AAAAACCC"</span></span><br><span class="line"><span class="symbol">end:</span>   <span class="string">"AACCCCCC"</span></span><br><span class="line"><span class="symbol">bank:</span> [<span class="string">"AAAACCCC"</span>, <span class="string">"AAACCCCC"</span>, <span class="string">"AACCCCCC"</span>]</span><br><span class="line"></span><br><span class="line"><span class="symbol">return:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：这道题实际和单词接龙属于一种类型的题目，都是通过BFS解决状态图搜索问题。</p>
<h2 id="200-Number-of-Islands-岛屿数量-Mid"><a href="#200-Number-of-Islands-岛屿数量-Mid" class="headerlink" title="200. Number of Islands(岛屿数量)(Mid)"></a><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">200. Number of Islands(岛屿数量)(Mid)</a></h2><p>Given a 2d grid map of <code>&#39;1&#39;</code>s (land) and <code>&#39;0&#39;</code>s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span></span><br><span class="line"><span class="number">11110</span></span><br><span class="line"><span class="number">11010</span></span><br><span class="line"><span class="number">11000</span></span><br><span class="line"><span class="number">00000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Output:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span></span><br><span class="line"><span class="number">11000</span></span><br><span class="line"><span class="number">11000</span></span><br><span class="line"><span class="number">00100</span></span><br><span class="line"><span class="number">00011</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Output:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：参考油管上Kevin大神的代码，思路非常清晰。</p>
<p>这道题在面试中经常会考到，主要思想是利用dfs，每碰到一个”1”，都将其周围的所有”1”击沉掉，也就是全部重新设置为0，然后总的岛屿数量加1，这样持续下去可以每次将一块岛击沉。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> numIslands(char[][] grid) &#123;</span><br><span class="line">        <span class="comment">// error checking</span></span><br><span class="line">        <span class="keyword">if</span>(grid == <span class="literal">null</span> || grid.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       </span><br><span class="line">        <span class="built_in">int</span> numIslands = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; grid[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    numIslands += dfs(grid, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numIslands;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 沉岛法,将i和j相邻的所有为1的点全部置为0</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> dfs(char[][] grid, <span class="built_in">int</span> i, <span class="built_in">int</span> j) &#123;</span><br><span class="line">        <span class="comment">// terminator</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= grid.length || j &lt; <span class="number">0</span> || j &gt;= grid[i].length || grid[i][j] == <span class="string">'0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//sink</span></span><br><span class="line">        grid[i][j] = <span class="string">'0'</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// down</span></span><br><span class="line">        dfs(grid, i+<span class="number">1</span>, j);</span><br><span class="line">        <span class="comment">// right</span></span><br><span class="line">        dfs(grid, i, j+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// up</span></span><br><span class="line">        dfs(grid, i<span class="number">-1</span>, j);</span><br><span class="line">        <span class="comment">// left</span></span><br><span class="line">        dfs(grid, i, j<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="17-Letter-Combinations-of-a-Phone-Number-电话号码的字母组合-Mid"><a href="#17-Letter-Combinations-of-a-Phone-Number-电话号码的字母组合-Mid" class="headerlink" title="17. Letter Combinations of a Phone Number(电话号码的字母组合)(Mid)"></a><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">17. Letter Combinations of a Phone Number(电话号码的字母组合)(Mid)</a></h2><p>Given a string containing digits from <code>2-9</code> inclusive, return all possible letter combinations that the number could represent.</p>
<p>A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png" alt=""></p>
<p><strong>Example:</strong></p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Input:</span> <span class="string">"23"</span></span><br><span class="line"><span class="symbol">Output:</span> [<span class="string">"ad"</span>, <span class="string">"ae"</span>, <span class="string">"af"</span>, <span class="string">"bd"</span>, <span class="string">"be"</span>, <span class="string">"bf"</span>, <span class="string">"cd"</span>, <span class="string">"ce"</span>, <span class="string">"cf"</span>].</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong><br>Although the above answer is in lexicographical order(字典序), your answer could be in any order you want.</p>
<hr>
<p>解：这道题是比较经典的搜索问题。深搜和广搜都可以。</p>
<p>方法一：</p>
]]></content>
      <categories>
        <category>Algorithms Note</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Practice by Categories Tree+Recursion</title>
    <url>/2020/01/13/LeetCode-Practice-by-Categories-Tree/</url>
    <content><![CDATA[<blockquote>
<p>世界上最快乐的事，莫过于为理想而奋斗——苏格拉底</p>
</blockquote>
<p>LeetCode树、递归相关题目，其解决思路和具体代码。</p>
<a id="more"></a>

<p>首先可以使用递归来解决的问题，一般具有如下特点： 1. 该问题可以被分解成若干个重复的子问题； 2. 该问题与它分解出的子问题可以使用相同的算法来解决； 3. 有明确的终止条件。</p>
<p>树这种数据结构的特点和上述三个特点高度一致，一棵树的每个非叶子节点的子节点也都是一棵树，都是树自然可以使用相同的算法来处理，因为没有环所以天然具有终止条件。 另外一方面，树本身是一种非线性的数据结构，循环遍历不易。当然循环遍历也是可以做，树是一种特殊的图，我们完全可以使用图的广度优先遍历算法一层一层的循环遍历整棵树。 综上，我们一般还是选择递归的方式来解决树的问题。</p>
<p>因为树的操作的特性，很多题目可以用递归相关轻易解决，比如树的前中后序遍历。但是非递归的方式同样重要。</p>
<p>除了树，还有分治，回溯和递归相关题目。分治和回溯本质就是递归，递归和回溯是特殊的递归。</p>
<p>有关树的时间复杂度和空间复杂度分析，可以参考下面这张图：</p>
<p><img src="https://s2.ax1x.com/2020/01/19/1CsVMT.png" alt="1CsVMT.png"></p>
<p>可以发现，因为二叉树每层最多两个元素，按照层级扩散，所以与树相关的结构平均下来的时间复杂度大多是 <code>O(logN)</code> 级别的。</p>
<p>针对递归，一般人们的认识是递归的时间复杂度非常高。但是具体说来，递归算法的时间复杂度如何计算呢？——<strong>子问题个数乘以解决一个子问题需要的时间。</strong></p>
<h2 id="94-Binary-Tree-Inorder-Traversal-二叉树中序遍历-Mid"><a href="#94-Binary-Tree-Inorder-Traversal-二叉树中序遍历-Mid" class="headerlink" title="94. Binary Tree Inorder Traversal(二叉树中序遍历)(Mid)"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. Binary Tree Inorder Traversal(二叉树中序遍历)(Mid)</a></h2><p>Given a binary tree, return the inorder traversal of its nodes’ values.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="literal">null</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">   <span class="number">1</span></span><br><span class="line">    \</span><br><span class="line">     <span class="number">2</span></span><br><span class="line">    /</span><br><span class="line">   <span class="number">3</span></span><br><span class="line"></span><br><span class="line">Output: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>


<p><strong>Follow up:</strong> Recursive solution is trivial(简单), could you do it iteratively?</p>
<hr>
<p>解：方法一，递归，时间复杂度较高。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; inorder<span class="constructor">Traversal(TreeNode <span class="params">root</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root<span class="operator"> == </span>null) return <span class="keyword">new</span> ArrayList&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">        travel<span class="constructor">Helper(<span class="params">root</span>, <span class="params">result</span>)</span>;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void travel<span class="constructor">Helper(TreeNode <span class="params">root</span>, List&lt;Integer&gt; <span class="params">result</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root<span class="operator"> == </span>null) return ;</span><br><span class="line">        travel<span class="constructor">Helper(<span class="params">root</span>.<span class="params">left</span>, <span class="params">result</span>)</span>;</span><br><span class="line">        result.add(root.<span class="keyword">val</span>);</span><br><span class="line">        travel<span class="constructor">Helper(<span class="params">root</span>.<span class="params">right</span>, <span class="params">result</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，非递归，用一个栈解决。</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">class Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; result = <span class="literal">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">Stack</span>&lt;TreeNode&gt; <span class="built_in">stack</span> = <span class="literal">new</span> <span class="built_in">Stack</span>&lt;&gt;();</span><br><span class="line">        TreeNode root0 = root;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(root0 != <span class="built_in">null</span> || !<span class="built_in">stack</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span>(root0 != <span class="built_in">null</span>) &#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(root0);</span><br><span class="line">                root0 = root0.left;</span><br><span class="line">            &#125;</span><br><span class="line">                <span class="comment">// 此时符合 !stack.isEmpty() 条件</span></span><br><span class="line">                <span class="comment">// root指针移动到回当前节点的父亲节点</span></span><br><span class="line">                root0 = <span class="built_in">stack</span>.pop();</span><br><span class="line">                <span class="comment">// 中序遍历，此时直接访问节点结果即可</span></span><br><span class="line">                result.add(root0.val);</span><br><span class="line">                <span class="comment">// 已经完成了某个节点的根、左孩子遍历，最后访问右孩子</span></span><br><span class="line">                root0 = root0.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注：</strong>额外定义了一个root0，避免操作之后整棵树找不到了的情况。面试过程中只是为了完成遍历，不定义root0问题也不大。</p>
<h2 id="144-Binary-Tree-Preorder-Traversal-二叉树的前序遍历-Mid"><a href="#144-Binary-Tree-Preorder-Traversal-二叉树的前序遍历-Mid" class="headerlink" title="144. Binary Tree Preorder Traversal (二叉树的前序遍历)(Mid)"></a><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">144. Binary Tree Preorder Traversal (二叉树的前序遍历)(Mid)</a></h2><p>Given a binary tree, return the preorder traversal of its nodes’ values.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="literal">null</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">   <span class="number">1</span></span><br><span class="line">    \</span><br><span class="line">     <span class="number">2</span></span><br><span class="line">    /</span><br><span class="line">   <span class="number">3</span></span><br><span class="line"></span><br><span class="line">Output: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p>
<hr>
<p>解：方法一，递归</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; preorder<span class="constructor">Traversal(TreeNode <span class="params">root</span>)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">if</span>(root<span class="operator"> == </span>null) return result;</span><br><span class="line">        pre<span class="constructor">Helper(<span class="params">root</span>, <span class="params">result</span>)</span>;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void pre<span class="constructor">Helper(TreeNode <span class="params">root</span>, List&lt;Integer&gt; <span class="params">result</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// terminator</span></span><br><span class="line">        <span class="keyword">if</span>(root<span class="operator"> == </span>null) return ;</span><br><span class="line">        result.add(root.<span class="keyword">val</span>);</span><br><span class="line">        pre<span class="constructor">Helper(<span class="params">root</span>.<span class="params">left</span>, <span class="params">result</span>)</span>;</span><br><span class="line">        pre<span class="constructor">Helper(<span class="params">root</span>.<span class="params">right</span>, <span class="params">result</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，非递归</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">class Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; preorderTraversal(TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// corner case</span></span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; result = <span class="literal">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">Stack</span>&lt;TreeNode&gt; <span class="built_in">stack</span> = <span class="literal">new</span> <span class="built_in">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="built_in">null</span> || !<span class="built_in">stack</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span>(root != <span class="built_in">null</span>) &#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(root);</span><br><span class="line">                <span class="comment">// 先序遍历，碰到节点就访问，再访问孩子节点</span></span><br><span class="line">                result.add(root.val);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 此时root左孩子没有节点了</span></span><br><span class="line">            <span class="comment">// 回溯访问当前root的父节点</span></span><br><span class="line">            root = <span class="built_in">stack</span>.pop();</span><br><span class="line">            <span class="comment">// 最后访问root的右孩子</span></span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注：</strong>额外定义了一个root0，避免操作之后整棵树找不到了的情况。面试过程中只是为了完成遍历，不定义root0问题也不大。</p>
<h2 id="145-Binary-Tree-Postorder-Traversal-二叉树的后序遍历-Hard"><a href="#145-Binary-Tree-Postorder-Traversal-二叉树的后序遍历-Hard" class="headerlink" title="145. Binary Tree Postorder Traversal (二叉树的后序遍历)(Hard)"></a><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">145. Binary Tree Postorder Traversal (二叉树的后序遍历)(Hard)</a></h2><p>Given a binary tree, return the postorder traversal of its nodes’ values.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="literal">null</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">   <span class="number">1</span></span><br><span class="line">    \</span><br><span class="line">     <span class="number">2</span></span><br><span class="line">    /</span><br><span class="line">   <span class="number">3</span></span><br><span class="line"></span><br><span class="line">Output: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p>
<hr>
<p>解：方法一，递归</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; postorder<span class="constructor">Traversal(TreeNode <span class="params">root</span>)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">if</span>(root<span class="operator"> == </span>null) return result;</span><br><span class="line">        post<span class="constructor">Helper(<span class="params">root</span>, <span class="params">result</span>)</span>;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void post<span class="constructor">Helper(TreeNode <span class="params">root</span>, List&lt;Integer&gt; <span class="params">result</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root<span class="operator"> == </span>null) return ;</span><br><span class="line">        post<span class="constructor">Helper(<span class="params">root</span>.<span class="params">left</span>, <span class="params">result</span>)</span>;</span><br><span class="line">        post<span class="constructor">Helper(<span class="params">root</span>.<span class="params">right</span>, <span class="params">result</span>)</span>;</span><br><span class="line">        result.add(root.<span class="keyword">val</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，利用通过LinkedList构造的List&lt;&gt;可以用addFirst()方法。因为后序遍历访问节点的顺序刚好和前序相反，所以在同样地方访问节点然后加入到结果集合的头部即可。此外这个方法因为完全模拟前序的相反流程，所以访问节点的顺序也是和遍历顺序相反，即先访问右子树，再左子树。</p>
<p>需要注意：如果要用LinkedList的addFirst()方法，在定义result的时候左边就要是LinkedList这个实现类型，而不是用List接口，用接口的话不能自动实现addFirst()方法</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">class Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; postorderTraversal(TreeNode root) &#123;</span><br><span class="line">        LinkedList&lt;<span class="built_in">Integer</span>&gt; result = <span class="literal">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="built_in">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">Stack</span>&lt;TreeNode&gt; <span class="built_in">stack</span> = <span class="literal">new</span> <span class="built_in">Stack</span>&lt;&gt;();</span><br><span class="line">        TreeNode root0 = root;</span><br><span class="line">        <span class="keyword">while</span>(root0 != <span class="built_in">null</span> || !<span class="built_in">stack</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span>(root0 != <span class="built_in">null</span>) &#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(root0);</span><br><span class="line">                result.addFirst(root0.val);</span><br><span class="line">                root0 = root0.right;</span><br><span class="line">            &#125;</span><br><span class="line">            root0 = <span class="built_in">stack</span>.pop();</span><br><span class="line">            root0 = root0.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注：</strong>额外定义了一个root0，避免操作之后整棵树找不到了的情况。面试过程中只是为了完成遍历，不定义root0问题也不大。</p>
<p>但是这个看起来很巧妙(确实也很巧妙，利用后序遍历和前序遍历相反的规律)的方法有Bug，即如果树存在比较复杂的拓扑依赖，这种方法会报出错(但是面试用这个方法应该问题不大)。</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">class Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; postorderTraversal(TreeNode root) &#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; result=<span class="literal">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="built_in">Stack</span>&lt;TreeNode&gt; <span class="built_in">stack</span>=<span class="literal">new</span> <span class="built_in">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="built_in">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">stack</span>.push(root);</span><br><span class="line">        TreeNode cur=root;</span><br><span class="line">        TreeNode pre=<span class="built_in">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">stack</span>.isEmpty())&#123;</span><br><span class="line">            cur=<span class="built_in">stack</span>.peek();</span><br><span class="line">            <span class="keyword">if</span>(cur.left==<span class="built_in">null</span>&amp;&amp;cur.right==<span class="built_in">null</span>||(pre!=<span class="built_in">null</span>&amp;&amp;(pre==cur.left||pre==cur.right)))&#123;</span><br><span class="line">                result.add(cur.val); <span class="comment">//deal with topological dependency</span></span><br><span class="line">                <span class="built_in">stack</span>.pop();</span><br><span class="line">                pre=cur;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.right!=<span class="built_in">null</span>)&#123;</span><br><span class="line">                    <span class="built_in">stack</span>.push(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur.left!=<span class="built_in">null</span>)&#123;</span><br><span class="line">                    <span class="built_in">stack</span>.push(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>经过了一段时间的学习和沉淀，我发现实际上树的后序遍历虽然理论上是<code>(pre, in, post)</code>的顺序，也就是<code>(left, right, root.val)</code>,但是实际上可以通过(root.val,right, left)这种顺序访问二叉树来得到，只是得到的结果需要每次都添加到result的First位置上。</p>
<h2 id="102-Binary-tree-level-order-traversal-二叉树的层序遍历-Mid"><a href="#102-Binary-tree-level-order-traversal-二叉树的层序遍历-Mid" class="headerlink" title="102. Binary tree level order traversal(二叉树的层序遍历)(Mid)"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">102. Binary tree level order traversal(二叉树的层序遍历)(Mid)</a></h2><p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).</p>
<p>For example:<br><code>Given binary tree [3,9,20,null,null,15,7],</code></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>return its level order traversal as:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">20</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<hr>
<p>解：这道题，在整个硅谷的面试题中，出现次数也是能够排在前三的位置，非常重要。</p>
<p>方法一，递归，DFS。层序遍历用深搜其实有一点”反人类”，但是有助于理解和面试时候的表现。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Definition for </span>a<span class="markdown"> binary tree node.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>public class TreeNode &#123;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>int val;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>TreeNode left;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>TreeNode right;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>TreeNode(int x) &#123; val = x; &#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>&#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> */</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    public <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        levelHelper(result, root ,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public <span class="keyword">void</span> levelHelper(<span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;Integer&gt;&gt; result, TreeNode root, <span class="built_in">int</span> height) &#123;</span><br><span class="line">        <span class="comment">// terminator</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// process current logic</span></span><br><span class="line">        <span class="keyword">if</span>(height &gt;= result.size()) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> LinkedList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="keyword">get</span>(height).add(root.val);</span><br><span class="line">        levelHelper(result, root.left, height + <span class="number">1</span>);</span><br><span class="line">        levelHelper(result, root.right, height + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，使用队列，使用BFS遍历的模板。</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">class Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; result = <span class="literal">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">Queue</span>&lt;TreeNode&gt; <span class="built_in">queue</span> = <span class="literal">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="built_in">queue</span>.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">queue</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 循环里面要定义三个变量</span></span><br><span class="line">            </span><br><span class="line">			<span class="comment">// 每次循环队列长度都会变化，需要每次都更新</span></span><br><span class="line">            int levelLength = <span class="built_in">queue</span>.size();</span><br><span class="line">            <span class="comment">// 需要临时保存当前层的所有元素</span></span><br><span class="line">            <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; currLevel = <span class="literal">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            for(int i = <span class="number">0</span>; i &lt; levelLength; i++) &#123;</span><br><span class="line">                TreeNode currNode = <span class="built_in">queue</span>.poll();</span><br><span class="line">                currLevel.add(currNode.val);</span><br><span class="line">                <span class="keyword">if</span>(currNode.left != <span class="built_in">null</span>) <span class="built_in">queue</span>.add(currNode.left);</span><br><span class="line">                <span class="keyword">if</span>(currNode.right != <span class="built_in">null</span>) <span class="built_in">queue</span>.add(currNode.right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(currLevel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="103-Binary-Tree-Zigzag-Level-Order-Traversal-二叉树的锯齿形层序遍历-Mid"><a href="#103-Binary-Tree-Zigzag-Level-Order-Traversal-二叉树的锯齿形层序遍历-Mid" class="headerlink" title="103. Binary Tree Zigzag Level Order Traversal(二叉树的锯齿形层序遍历)(Mid)"></a><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">103. Binary Tree Zigzag Level Order Traversal(二叉树的锯齿形层序遍历)(Mid)</a></h2><p>Given a binary tree, return the <em>zigzag level order</em> traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p>
<p>For example:<br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>return its zigzag level order traversal as:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">20</span>,<span class="number">9</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<hr>
<p>解：上一道102已经解决了层次遍历的问题，可以基于上一题使用队列实现BFS的思想。但是这里需要判断锯齿(或者称为之字型)，用变量zigzag记录当前从右向左添加还是从左向右添加元素。zigzag为false，表示从左到右。zigzag为true，表示从右到左。初始的时候为从左到右，即zigzag初始值为false。</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">class Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; result = <span class="literal">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">Queue</span>&lt;TreeNode&gt; <span class="built_in">queue</span> = <span class="literal">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="built_in">queue</span>.add(root);</span><br><span class="line">        <span class="built_in">boolean</span> zigzag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">queue</span>.isEmpty()) &#123;</span><br><span class="line">            <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; currLevel = <span class="literal">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            int currLength = <span class="built_in">queue</span>.size();</span><br><span class="line">            for(int i = <span class="number">0</span>; i &lt; currLength; i++) &#123;</span><br><span class="line">                TreeNode currNode = <span class="built_in">queue</span>.poll();</span><br><span class="line">                <span class="keyword">if</span>(zigzag) &#123;</span><br><span class="line">                    currLevel.add(<span class="number">0</span>, currNode.val);</span><br><span class="line">                &#125; <span class="keyword">else</span> currLevel.add(currNode.val);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(currNode.left != <span class="built_in">null</span>) <span class="built_in">queue</span>.add(currNode.left);</span><br><span class="line">                <span class="keyword">if</span>(currNode.right != <span class="built_in">null</span>) <span class="built_in">queue</span>.add(currNode.right);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            result.add(currLevel);</span><br><span class="line">            zigzag = !zigzag;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>linkedList的add方法，两参数的重构方法中第一个参数为index：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">	<span class="built_in">add</span>(int index, E <span class="keyword">element</span>)</span><br><span class="line">Inserts <span class="keyword">the</span> specified <span class="keyword">element</span> <span class="keyword">at</span> <span class="keyword">the</span> specified position <span class="keyword">in</span> this list.</span><br></pre></td></tr></table></figure>

<h2 id="515-Find-Largest-Value-in-Each-Tree-Row-在每个树中找最大值-Mid"><a href="#515-Find-Largest-Value-in-Each-Tree-Row-在每个树中找最大值-Mid" class="headerlink" title="515. Find Largest Value in Each Tree Row(在每个树中找最大值)(Mid)"></a><a href="https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/#/description" target="_blank" rel="noopener">515. Find Largest Value in Each Tree Row(在每个树中找最大值)(Mid)</a></h2><p>You need to find the largest value in each row of a binary tree.</p>
<p><strong>Example :</strong></p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Input</span>: </span><br><span class="line"></span><br><span class="line">          1</span><br><span class="line">         / \</span><br><span class="line">        3   2</span><br><span class="line">       / \   \  </span><br><span class="line">      5   3   9 </span><br><span class="line"></span><br><span class="line"><span class="attribute">Output</span>: [1, 3, 9]</span><br></pre></td></tr></table></figure>

<hr>
<p>解：因为需要按照层次记录最大值，所以和层次遍历题目有类似之处。</p>
<p>方法一：DFS。深搜大多利用递归，写一个递归函数，直接利用计算机帮你维护的栈即可。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; largest<span class="constructor">Values(TreeNode <span class="params">root</span>)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">if</span>(root<span class="operator"> == </span>null) return result;</span><br><span class="line">        largest<span class="constructor">Helper(<span class="params">result</span>, <span class="params">root</span>, 0)</span>;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void largest<span class="constructor">Helper(List&lt;Integer&gt; <span class="params">result</span>, TreeNode <span class="params">root</span>, <span class="params">int</span> <span class="params">height</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root<span class="operator"> == </span>null) return ;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// expand list size</span></span><br><span class="line">        <span class="keyword">if</span>(height<span class="operator"> == </span>result.size<span class="literal">()</span>) &#123;</span><br><span class="line">            result.add(root.<span class="keyword">val</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.set(height, <span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>max(result.get(height), root.<span class="keyword">val</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        largest<span class="constructor">Helper(<span class="params">result</span>, <span class="params">root</span>.<span class="params">left</span>, <span class="params">height</span> + 1)</span>;</span><br><span class="line">        largest<span class="constructor">Helper(<span class="params">result</span>, <span class="params">root</span>.<span class="params">right</span>, <span class="params">height</span> + 1)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：BFS。和树部分102题层次遍历大体结构相同。</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">class Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; largestValues(TreeNode root) &#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; result = <span class="literal">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">Queue</span>&lt;TreeNode&gt; <span class="built_in">queue</span> = <span class="literal">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>.offer(root);</span><br><span class="line">        int <span class="keyword">max</span> = <span class="built_in">Integer</span>.MIN_VALUE;</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">queue</span>.isEmpty()) &#123;</span><br><span class="line">            int levelSize = <span class="built_in">queue</span>.size();</span><br><span class="line">            for(int i = <span class="number">0</span>; i &lt; levelSize; i++) &#123;</span><br><span class="line">                TreeNode currNode = <span class="built_in">queue</span>.poll();</span><br><span class="line">                <span class="keyword">max</span> = Math.<span class="keyword">max</span>(<span class="keyword">max</span>, currNode.val);</span><br><span class="line">                <span class="keyword">if</span>(currNode.left != <span class="built_in">null</span>) <span class="built_in">queue</span>.add(currNode.left);</span><br><span class="line">                <span class="keyword">if</span>(currNode.right != <span class="built_in">null</span>) <span class="built_in">queue</span>.add(currNode.right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(<span class="keyword">max</span>);</span><br><span class="line">            <span class="keyword">max</span> = <span class="built_in">Integer</span>.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="590-N-ary-Tree-Postorder-Traversal-N叉树的后序遍历-Easy"><a href="#590-N-ary-Tree-Postorder-Traversal-N叉树的后序遍历-Easy" class="headerlink" title="590. N-ary Tree Postorder Traversal (N叉树的后序遍历)(Easy)"></a><a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/" target="_blank" rel="noopener">590. N-ary Tree Postorder Traversal (N叉树的后序遍历)(Easy)</a></h2><p>Given an n-ary tree, return the postorder traversal of its nodes’ values.</p>
<p><em>Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).</em></p>
<p><strong>Follow up:</strong></p>
<p>Recursive solution is trivial, could you do it iteratively?</p>
<p><strong>Example 1:</strong><br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/narytreeexample.png" alt=""></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: root = [<span class="number">1</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">Output: [<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong><br><img src="https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png" alt=""></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: root = [<span class="number">1</span>,<span class="literal">null</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="literal">null</span>,<span class="number">8</span>,<span class="literal">null</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">11</span>,<span class="literal">null</span>,<span class="number">12</span>,<span class="literal">null</span>,<span class="number">13</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">14</span>]</span><br><span class="line">Output: [<span class="number">2</span>,<span class="number">6</span>,<span class="number">14</span>,<span class="number">11</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">12</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">13</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li>The height of the n-ary tree is less than or equal to 1000</li>
<li>The total number of nodes is between [0, 10^4]</li>
</ul>
<hr>
<p>解：利用LinkedList的addFirst()遍历树。。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">// Definition for a <span class="keyword">Node</span>.<span class="title"></span></span><br><span class="line"><span class="title">class</span> <span class="keyword">Node</span> <span class="title">&#123;</span></span><br><span class="line"><span class="title">    public</span> int val;</span><br><span class="line">    public List<span class="tag">&lt;Node&gt;</span> children;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">Node</span><span class="title">() &#123;&#125;</span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">    public</span> <span class="keyword">Node</span><span class="title">(int</span> _val) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">Node</span><span class="title">(int</span> _val, List<span class="tag">&lt;Node&gt;</span> _children) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        children = _children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List<span class="tag">&lt;Integer&gt;</span> postorder(<span class="keyword">Node</span> <span class="title">root</span>) &#123;</span><br><span class="line">        LinkedList<span class="tag">&lt;Integer&gt;</span> result = new LinkedList<span class="tag">&lt;&gt;</span>();</span><br><span class="line">        if(root == null) return result;</span><br><span class="line">        Stack<span class="tag">&lt;Node&gt;</span> stack = new Stack<span class="tag">&lt;&gt;</span>();</span><br><span class="line">        stack.add(root);</span><br><span class="line">        </span><br><span class="line">        while(!stack.empty()) &#123;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            result.addFirst(root.val);</span><br><span class="line">            for(<span class="keyword">Node</span> <span class="title">node</span> : root.children) &#123;</span><br><span class="line">                stack.add(<span class="keyword">node</span><span class="title">);</span></span><br><span class="line"><span class="title">            &#125;</span></span><br><span class="line"><span class="title">        &#125;</span></span><br><span class="line"><span class="title">        return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="589-N-ary-Tree-Preorder-Traversal-N叉树的前序遍历-Easy"><a href="#589-N-ary-Tree-Preorder-Traversal-N叉树的前序遍历-Easy" class="headerlink" title="589. N-ary Tree Preorder Traversal (N叉树的前序遍历)(Easy)"></a><a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/" target="_blank" rel="noopener">589. N-ary Tree Preorder Traversal (N叉树的前序遍历)(Easy)</a></h2><p>Given an n-ary tree, return the preorder traversal of its nodes’ values.</p>
<p><em>Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).</em></p>
<p><strong>Follow up:</strong><br>Recursive solution is trivial, could you do it iteratively?</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/narytreeexample.png" alt=""></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: root = [<span class="number">1</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">Output: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong><br><img src="https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png" alt=""></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: root = [<span class="number">1</span>,<span class="literal">null</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="literal">null</span>,<span class="number">8</span>,<span class="literal">null</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">11</span>,<span class="literal">null</span>,<span class="number">12</span>,<span class="literal">null</span>,<span class="number">13</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">14</span>]</span><br><span class="line">Output: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">14</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">13</span>,<span class="number">10</span>]</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li>The height of the n-ary tree is less than or equal to 1000</li>
<li>The total number of nodes is between [0, 10^4]</li>
</ul>
<hr>
<p>解：使用DFS非递归模板。把子树从后往前添加到栈里面，弹出的时候刚好相反，从前往后的顺序弹出。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">// Definition for a <span class="keyword">Node</span>.<span class="title"></span></span><br><span class="line"><span class="title">class</span> <span class="keyword">Node</span> <span class="title">&#123;</span></span><br><span class="line"><span class="title">    public</span> int val;</span><br><span class="line">    public List<span class="tag">&lt;Node&gt;</span> children;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">Node</span><span class="title">() &#123;&#125;</span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">    public</span> <span class="keyword">Node</span><span class="title">(int</span> _val) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">Node</span><span class="title">(int</span> _val, List<span class="tag">&lt;Node&gt;</span> _children) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        children = _children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List<span class="tag">&lt;Integer&gt;</span> preorder(<span class="keyword">Node</span> <span class="title">root</span>) &#123;</span><br><span class="line">        List<span class="tag">&lt;Integer&gt;</span> result = new LinkedList<span class="tag">&lt;&gt;</span>();</span><br><span class="line">        if(root == null) return result;</span><br><span class="line">        </span><br><span class="line">        Stack<span class="tag">&lt;Node&gt;</span> stack = new Stack<span class="tag">&lt;&gt;</span>();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        </span><br><span class="line">        while(!stack.empty()) &#123;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            result.add(root.val);</span><br><span class="line">            for(int i = root.children.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                stack.add(root.children.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="429-N-ary-Tree-Level-Order-Traversal-N叉树的层序遍历-Mid"><a href="#429-N-ary-Tree-Level-Order-Traversal-N叉树的层序遍历-Mid" class="headerlink" title="429. N-ary Tree Level Order Traversal(N叉树的层序遍历)(Mid)"></a><a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/" target="_blank" rel="noopener">429. N-ary Tree Level Order Traversal(N叉树的层序遍历)(Mid)</a></h2><p>Given an n-ary tree, return the level order traversal of its nodes’ values.</p>
<p><em>Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).</em></p>
<p><strong>Example 1:</strong><br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/narytreeexample.png" alt=""></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: root = [<span class="number">1</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">Output: [[<span class="number">1</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>]]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong><br><img src="https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png" alt=""></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: root = [<span class="number">1</span>,<span class="literal">null</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="literal">null</span>,<span class="number">8</span>,<span class="literal">null</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">11</span>,<span class="literal">null</span>,<span class="number">12</span>,<span class="literal">null</span>,<span class="number">13</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">14</span>]</span><br><span class="line">Output: [[<span class="number">1</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>],[<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>],[<span class="number">14</span>]]</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li>The height of the n-ary tree is less than or equal to 1000</li>
<li>The total number of nodes is between [0, 10^4]</li>
</ul>
<hr>
<p>解：和层序遍历思路相同，只是需要注意N叉树的遍历在内层要多一个循环去遍历所有节点的子节点。</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public List&lt;Node&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, List&lt;Node&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">class Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; levelOrder(Node root) &#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; result = <span class="literal">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="built_in">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">Queue</span>&lt;Node&gt; <span class="built_in">queue</span> = <span class="literal">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="built_in">queue</span>.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">queue</span>.isEmpty()) &#123;</span><br><span class="line">            int currLength = <span class="built_in">queue</span>.size();</span><br><span class="line">            <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; currLevel = <span class="literal">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            for(int i = <span class="number">0</span>; i &lt; currLength; i++) &#123;</span><br><span class="line">                Node currNode = <span class="built_in">queue</span>.poll();</span><br><span class="line">                currLevel.add(currNode.val);</span><br><span class="line">                for(Node node : currNode.children) &#123;</span><br><span class="line">                    <span class="built_in">queue</span>.add(node);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(currLevel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="70-Climbing-stairsl-爬楼梯-Easy"><a href="#70-Climbing-stairsl-爬楼梯-Easy" class="headerlink" title="70. Climbing-stairsl(爬楼梯)(Easy)"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. Climbing-stairsl(爬楼梯)(Easy)</a></h2><p>You are climbing a stair case. It takes n steps to reach to the top.</p>
<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>
<p>Note: Given <em>n</em> will be a positive integer.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">Output:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">Explanation:</span> <span class="string">There</span> <span class="string">are</span> <span class="string">two</span> <span class="string">ways</span> <span class="string">to</span> <span class="string">climb</span> <span class="string">to</span> <span class="string">the</span> <span class="string">top.</span></span><br><span class="line"><span class="number">1</span><span class="string">.</span> <span class="number">1</span> <span class="string">step</span> <span class="string">+</span> <span class="number">1</span> <span class="string">step</span></span><br><span class="line"><span class="number">2</span><span class="string">.</span> <span class="number">2</span> <span class="string">steps</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">Output:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">Explanation:</span> <span class="string">There</span> <span class="string">are</span> <span class="string">three</span> <span class="string">ways</span> <span class="string">to</span> <span class="string">climb</span> <span class="string">to</span> <span class="string">the</span> <span class="string">top.</span></span><br><span class="line"><span class="number">1</span><span class="string">.</span> <span class="number">1</span> <span class="string">step</span> <span class="string">+</span> <span class="number">1</span> <span class="string">step</span> <span class="string">+</span> <span class="number">1</span> <span class="string">step</span></span><br><span class="line"><span class="number">2</span><span class="string">.</span> <span class="number">1</span> <span class="string">step</span> <span class="string">+</span> <span class="number">2</span> <span class="string">steps</span></span><br><span class="line"><span class="number">3</span><span class="string">.</span> <span class="number">2</span> <span class="string">steps</span> <span class="string">+</span> <span class="number">1</span> <span class="string">step</span></span><br></pre></td></tr></table></figure>
<hr>
<p>解：爬楼梯很经典，变型也很多。首先结论是，单纯的这道题，通过数学归纳的思路(或者说递归的思路)，不难发现其实结果就是前两个元素为1,2的斐波那契数列。(斐波那契数列为509题，因为类似这里就不记录了，链接<a href="https://leetcode-cn.com/problems/fibonacci-number/" target="_blank" rel="noopener">点击这里</a>)</p>
<p>方法一：递归，可以画出递归树发现，因为每个层级都会在上一层的数量基础上多出2倍的节点，所以时间复杂度为O(2^n)，指数级别，不可以接受。而且实际测试中在N为44的时候会出现超时。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> climbStairs(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> climbHelper(<span class="number">0</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> climbHelper(<span class="built_in">int</span> curr, <span class="built_in">int</span> target) &#123;</span><br><span class="line">        <span class="comment">// terminator</span></span><br><span class="line">        <span class="comment">// 跨过了目标阶梯，不算入方法</span></span><br><span class="line">        <span class="keyword">if</span>(curr &gt; target) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 刚好攀登到某个位置</span></span><br><span class="line">        <span class="keyword">if</span>(curr == target) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> climbHelper(curr + <span class="number">1</span>, target) + climbHelper(curr + <span class="number">2</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>方法二：基于递归，加上备忘录，进行有记忆的递归，可以把之前计算过的结果保存下来，有很好的剪枝效果。因为有记录所有的过程，所以子问题的数量就是f(1),f(2)…，为O(n),而且每个子问题解决的时间为O(n)</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> climbStairs(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="comment">// 基于暴力递归，进行有记忆的递归，把每一步的结果存储在mem数组之中，每当有函数被再次调用，就直接从memo数组返回结果，减少计算次数</span></span><br><span class="line">        <span class="built_in">int</span>[] memo = new <span class="built_in">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> climbHelper(<span class="number">0</span>,n,memo);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> climbHelper(<span class="built_in">int</span> curr, <span class="built_in">int</span> target, <span class="built_in">int</span>[] memo) &#123;</span><br><span class="line">        <span class="comment">// terminator</span></span><br><span class="line">        <span class="comment">// 跨过了目标阶梯，不算入方法</span></span><br><span class="line">        <span class="keyword">if</span>(curr &gt; target) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 刚好攀登到某个位置</span></span><br><span class="line">        <span class="keyword">if</span>(curr == target) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果当前N阶梯数量已经计算过，直接从memo返回</span></span><br><span class="line">        <span class="keyword">if</span>(memo[curr] &gt; <span class="number">0</span>) <span class="keyword">return</span> memo[curr];</span><br><span class="line">        </span><br><span class="line">        memo[curr] =  climbHelper(curr + <span class="number">1</span>, target, memo) + climbHelper(curr + <span class="number">2</span>, target, memo);</span><br><span class="line">        <span class="keyword">return</span> memo[curr];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>方法三：常规动态规划，时间复杂度为O(n)，空间复杂度也为O(n)</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> climbStairs(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// dp[i]表示爬到第i阶共有的爬法</span></span><br><span class="line">        <span class="built_in">int</span>[] dp = new <span class="built_in">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>; dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法四：基于常规动态规划的优化。在空间复杂度上可以提升到O(1)。实际上在一开始的时间复杂度的基础上都可以进行空间的优化，比如O(n)可以优化到O(1),O(m*n)可以优化到O(n)。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> climbStairs(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> f1 = <span class="number">1</span>, f2 = <span class="number">2</span>, f3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            f3 = f1 + f2;</span><br><span class="line">            f1 = f2;</span><br><span class="line">            f2 = f3;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="22-Generate-Parentheses-括号生成-Mid"><a href="#22-Generate-Parentheses-括号生成-Mid" class="headerlink" title="22. Generate Parentheses (括号生成)(Mid)"></a><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">22. Generate Parentheses (括号生成)(Mid)</a></h2><p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p>
<p>For example, given <em>n = 3</em>, a solution set is:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="string">"((()))"</span>,</span><br><span class="line">  <span class="string">"(()())"</span>,</span><br><span class="line">  <span class="string">"(())()"</span>,</span><br><span class="line">  <span class="string">"()(())"</span>,</span><br><span class="line">  <span class="string">"()()()"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<hr>
<p>解：<strong>方法一</strong>，这道题是用递归+剪枝可以轻松解决的典型题目。</p>
<p>可以想象一共有2n个位置来填补括号。然后给上括号的填补条件即可得到符合要求的括号对。</p>
<p>什么条件呢？必须明确，n为几，就一定会有几个左括号和右括号。<strong>其中左括号加入的条件，是不超过n。而添加左括号的条件是没有的，也就是随时可以加。而右括号添加有条件，就是左括号个数要大于右括号个数才能添加。</strong></p>
<p>也就是说，左括号的条件时：left &lt; n; 右括号的条件是：left &gt; right &amp;&amp; right &lt; n。当然，因为Left&lt;n了，right&lt;left,所以右括号的条件中可以不用写right &lt; n了</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 经典的剪枝问题</span></span><br><span class="line">    <span class="comment">// 方法一，递归</span></span><br><span class="line">    public List&lt;String&gt; generate<span class="constructor">Parenthesis(<span class="params">int</span> <span class="params">n</span>)</span> &#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">        <span class="constructor">_generate( 0, 0, <span class="params">n</span>, <span class="string">""</span>,<span class="params">result</span>)</span>;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void <span class="constructor">_generate(<span class="params">int</span> <span class="params">left</span>, <span class="params">int</span> <span class="params">right</span>, <span class="params">int</span> <span class="params">n</span>, String <span class="params">s</span>, List&lt;String&gt; <span class="params">result</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// terminator</span></span><br><span class="line">        <span class="keyword">if</span> (left<span class="operator"> == </span>n<span class="operator"> &amp;&amp; </span>right<span class="operator"> == </span>n) &#123;</span><br><span class="line">            result.add(s);</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// drill down</span></span><br><span class="line">        <span class="comment">//运用剪枝思想，分别针对左括号和右括号的放置条件来剪枝</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 左括号只要数量小于n，随便放</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; n)</span><br><span class="line">            <span class="constructor">_generate(<span class="params">left</span>+1, <span class="params">right</span>, <span class="params">n</span>, <span class="params">s</span> + <span class="string">"("</span>, <span class="params">result</span>)</span>;</span><br><span class="line">        <span class="comment">// 右括号数量要比左括号少，而且少于n。但是因为本身就存在left &lt; n的条件，所以写left &lt; right 即可</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt; right)</span><br><span class="line">            <span class="constructor">_generate(<span class="params">left</span>, <span class="params">right</span> + 1, <span class="params">n</span>, <span class="params">s</span> + <span class="string">")"</span>, <span class="params">result</span>)</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度上，因为每个子问题处理的时间为O(1)，一共的子问题数量是O(2n)，也就是<strong>O(n)</strong></p>
<p><img src="https://s2.ax1x.com/2020/02/11/1Tttpt.png" alt="1Tttpt.png"></p>
<p><strong>方法二：</strong>动态规划。</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;<span class="keyword">String</span>&gt; generateParenthesis(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义dp为list方便调用</span></span><br><span class="line">        List&lt;List&lt;<span class="keyword">String</span>&gt;&gt; dp = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        dp.<span class="built_in">add</span>(Collections.singletonList(<span class="string">""</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// i表示i对括号</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            List&lt;<span class="keyword">String</span>&gt; curr = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="comment">//j表示在i循环的内部循环，每次可能的括号对数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">String</span> first : dp.<span class="built_in">get</span>(j)) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">String</span> <span class="built_in">second</span> : dp.<span class="built_in">get</span>(i-j<span class="number">-1</span>)) &#123;</span><br><span class="line">                        curr.<span class="built_in">add</span>(<span class="string">"("</span> + first + <span class="string">")"</span> + <span class="built_in">second</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp.<span class="built_in">add</span>(curr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.<span class="built_in">get</span>(dp.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="226-Invert-binary-tree-反转二叉树-Mid"><a href="#226-Invert-binary-tree-反转二叉树-Mid" class="headerlink" title="226. Invert-binary-tree(反转二叉树)(Mid)"></a><a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">226. Invert-binary-tree(反转二叉树)(Mid)</a></h2><p>Invert a binary tree.</p>
<p><strong>Example:</strong></p>
<p>Input:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">     <span class="number">4</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">2</span>     <span class="number">7</span></span><br><span class="line"> / \   / \</span><br><span class="line"><span class="number">1</span>   <span class="number">3</span> <span class="number">6</span>   <span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>Output:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">     <span class="number">4</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">7</span>     <span class="number">2</span></span><br><span class="line"> / \   / \</span><br><span class="line"><span class="number">9</span>   <span class="number">6</span> <span class="number">3</span>   <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>Trivia:<br>This problem was inspired by this original tweet by Max Howell:</p>
<blockquote>
<p>Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so f*** off.</p>
</blockquote>
<hr>
<p>解：方法一，DFS，用递归实现。</p>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * <span class="keyword">public</span> <span class="keyword">class</span> TreeNode &#123;</span><br><span class="line"> *     <span class="built_in">int</span> val;</span><br><span class="line"> *     TreeNode <span class="built_in">left</span>;</span><br><span class="line"> *     TreeNode <span class="built_in">right</span>;</span><br><span class="line"> *     TreeNode(<span class="built_in">int</span> x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) return <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        TreeNode <span class="built_in">left</span> = root.<span class="built_in">left</span>, <span class="built_in">right</span> = root.<span class="built_in">right</span>;</span><br><span class="line">        root.<span class="built_in">left</span> = invertTree(<span class="built_in">right</span>);</span><br><span class="line">        root.<span class="built_in">right</span> = invertTree(<span class="built_in">left</span>);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，非递归，BFS，用队列实现。本质上是针对层次进行翻转，故可以在层次遍历的基础上把每一层的两个子树交换即可。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree <span class="keyword">node</span>.<span class="title"></span></span><br><span class="line"><span class="title"> * public</span> class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">        if(root == null) return null;</span><br><span class="line">        </span><br><span class="line">        Queue<span class="tag">&lt;TreeNode&gt;</span> queue = new LinkedList<span class="tag">&lt;&gt;</span>();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        while(!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode <span class="keyword">node</span> <span class="title">= queue</span>.poll();</span><br><span class="line">            TreeNode tempNode = <span class="keyword">node</span>.<span class="title">left</span>;</span><br><span class="line">            <span class="keyword">node</span>.<span class="title">left</span> = <span class="keyword">node</span>.<span class="title">right</span>;</span><br><span class="line">            <span class="keyword">node</span>.<span class="title">right</span> = tempNode;</span><br><span class="line">            </span><br><span class="line">            if(<span class="keyword">node</span>.<span class="title">left</span> != null) queue.add(<span class="keyword">node</span>.<span class="title">left</span>);</span><br><span class="line">            if(<span class="keyword">node</span>.<span class="title">right</span> != null) queue.add(<span class="keyword">node</span>.<span class="title">right</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="98-Validate-Binary-Search-Tree-验证二叉搜索树-Mid"><a href="#98-Validate-Binary-Search-Tree-验证二叉搜索树-Mid" class="headerlink" title="98. Validate Binary Search Tree(验证二叉搜索树)(Mid)"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree" target="_blank" rel="noopener">98. Validate Binary Search Tree(验证二叉搜索树)(Mid)</a></h2><p>Given a binary tree, determine if it is a valid binary search tree (BST).</p>
<p>Assume a BST is defined as follows:</p>
<ul>
<li>The left subtree of a node contains only nodes with keys less than the node’s key.</li>
<li>The right subtree of a node contains only nodes with keys greater than the node’s key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">    <span class="number">2</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">1</span>   <span class="number">3</span></span><br><span class="line"></span><br><span class="line">Input: [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">Output: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">    <span class="number">5</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">1</span>   <span class="number">4</span></span><br><span class="line">     / \</span><br><span class="line">    <span class="number">3</span>   <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Input</span>: [<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">3</span>,<span class="number">6</span>]</span><br><span class="line">Output: <span class="keyword">false</span></span><br><span class="line">Explanation: The root nod<span class="string">e's value is 5 but its right child'</span>s <span class="keyword">value</span> <span class="keyword">is</span> <span class="number">4.</span></span><br></pre></td></tr></table></figure>
<hr>
<p>解：<strong>验证是否为二叉搜索树</strong>是一道经常考的题目，root0.val为当前遍历的节点，inorderVal为上一个节点</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Definition for </span>a<span class="markdown"> binary tree node.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>public class TreeNode &#123;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>int val;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>TreeNode left;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>TreeNode right;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>TreeNode(int x) &#123; val = x; &#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>&#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> */</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    public boolean isValidBST(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">double</span> inorderVal = -Double.MAX_VALUE;</span><br><span class="line">        TreeNode root0 = root;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() || root0 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span>(root0 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(root0);</span><br><span class="line">                root0 = root0.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root0 = stack.pop();</span><br><span class="line">            <span class="comment">// BST中序遍历一定是递增的，不是递增的序列就一定不是BST</span></span><br><span class="line">            <span class="keyword">if</span>(root0.val &lt;= inorderVal) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            inorderVal = root0.val;</span><br><span class="line">            root0 = root0.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>，在LeetCode平台上，输入的root为空，最终返回的也是true。</p>
<ul>
<li>时间复杂度 : O(N)。每个结点访问一次。</li>
<li>空间复杂度 : O(N)。我们跟进了整棵树。</li>
</ul>
<h2 id="114-Flatten-Binary-Tree-to-Linked-List-二叉树展开为链表-Mid"><a href="#114-Flatten-Binary-Tree-to-Linked-List-二叉树展开为链表-Mid" class="headerlink" title="114. Flatten Binary Tree to Linked List(二叉树展开为链表)(Mid)"></a><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">114. Flatten Binary Tree to Linked List(二叉树展开为链表)(Mid)</a></h2><p>Given a binary tree, flatten it to a linked list in-place.</p>
<p>For example, given the following tree:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">5</span></span><br><span class="line"> / \   \</span><br><span class="line"><span class="number">3</span>   <span class="number">4</span>   <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>The flattened tree should look like:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"> \</span><br><span class="line">  <span class="number">2</span></span><br><span class="line">   \</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">4</span></span><br><span class="line">       \</span><br><span class="line">        <span class="number">5</span></span><br><span class="line">         \</span><br><span class="line">          <span class="number">6</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：本题详细题解<a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--26/" target="_blank" rel="noopener">参考这篇文章</a></p>
<p>首先需要注意，<strong>这棵树是二叉树，不是二叉搜索树</strong>，所以不要想用中序遍历得到递增的遍历结果。</p>
<p>结合题目意思，可以看到，把二叉树展开成链表，实际上就是把二叉树变成原先先序遍历的结果的链表。但是因为要in-place，所以原则上只能在原先二叉树上进行操作。</p>
<p>方法一：不考虑原地(in-place)的操作，先序遍历整棵树，把它们放到一个数组里，然后利用TreeNode依次构建新的树，时间复杂度和空间复杂度都是O(n)。当然，因为不遵从in-place，这种方法可能不行。</p>
<p>方法二：同样用先序遍历，具体流程是：</p>
<ol>
<li>将左子树插入到右子树的地方</li>
<li>将原来的右子树接到左子树的最右边节点</li>
<li>考虑新的右子树的根节点，一直重复上边的过程，直到新的右子树为null</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> void flatten(<span class="type">TreeNode</span> root) &#123;</span><br><span class="line">        <span class="keyword">while</span>(root != null) &#123;</span><br><span class="line">            <span class="comment">// 左子树为null的话直接考虑下一个节点</span></span><br><span class="line">            <span class="keyword">if</span>(root.<span class="keyword">left</span> == null) &#123;</span><br><span class="line">                root = root.<span class="keyword">right</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 找当前节点左子树最右边的节点</span></span><br><span class="line">                <span class="type">TreeNode</span> pre = root.<span class="keyword">left</span>;</span><br><span class="line">                <span class="keyword">while</span>(pre.<span class="keyword">right</span> != null) &#123;</span><br><span class="line">                    pre = pre.<span class="keyword">right</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将原来的右子树接到左子树的最右边节点</span></span><br><span class="line">                pre.<span class="keyword">right</span> = root.<span class="keyword">right</span>;</span><br><span class="line">                <span class="comment">// 将左子树插入到右子树的地方</span></span><br><span class="line">                root.<span class="keyword">right</span> = root.<span class="keyword">left</span>;</span><br><span class="line">                root.<span class="keyword">left</span> = null;</span><br><span class="line">                <span class="comment">// 考虑下一节点</span></span><br><span class="line">                root = root.<span class="keyword">right</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法三：递归</p>
<p>虽然要求In-place，但是意思不是时间复杂度必须O(1)，而是直接在原来节点上改变指向，对空间复杂度没有要求，所以可以用递归解的。</p>
<p>递归解法实际上是通过二叉树的<strong>右指针</strong>，组成一个链表。</p>
<p>按照题意最后链表的顺序是先序遍历的结果，那么我们可以就按照先序遍历，然后每遍历一个节点，就让上一个遍历的节点的右指针更新为当前节点。</p>
<p>但是这样的话有一个很绝望的问题，就是，如果直接这么做，上一个节点的右孩子就会丢失。比如题目给的样例，先序遍历顺序是<code>1,2,3,4,5,6</code>，那么如果遍历到2，把1的右指针指向2，那么1本身的右孩子(也就是5)会丢失，即没有指针指向5了。</p>
<p>解决方法就是后序遍历，然后每次让当前节点右指针指向上一个节点。比如访问5，让5的右指针指向6.遍历4，让4的右指针指向5.这样一来就没有指针丢失的问题了，因为更新当前右指针的时候，当前节点的右孩子已经访问过了。</p>
<p>可以用一个全局变量pre，每次更新当前节点的右指针为pre，左指针为null。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Definition for </span>a<span class="markdown"> binary tree node.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>public class TreeNode &#123;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>int val;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>TreeNode left;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>TreeNode right;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>TreeNode(int x) &#123; val = x; &#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>&#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> */</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    private TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    public <span class="keyword">void</span> flatten(TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// terminator</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="comment">// 先访问右孩子，这样改变右指针的时候右孩子不会丢失</span></span><br><span class="line">        flatten(root.right);</span><br><span class="line">        flatten(root.left);</span><br><span class="line">        root.right = pre; <span class="comment">// 相当于保存root的右孩子</span></span><br><span class="line">        root.left = <span class="keyword">null</span>; <span class="comment">// 左孩子指针要置空，不然会出循环</span></span><br><span class="line">        pre = root; <span class="comment">// 将pre往前移1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码虽然简洁，但是还是比较难想的。一个记忆技巧可以是，首先找到所有结点的最右孩子节点，然后每次都先访问右孩子，让pre指向root.right,然后清空左孩子节点，最后把pre往前移动即可。</p>
<h2 id="104-Maximum-depth-of-binary-tree-二叉树的最大深度-Easy"><a href="#104-Maximum-depth-of-binary-tree-二叉树的最大深度-Easy" class="headerlink" title="104. Maximum-depth-of-binary-tree(二叉树的最大深度)(Easy)"></a><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree" target="_blank" rel="noopener">104. Maximum-depth-of-binary-tree(二叉树的最大深度)(Easy)</a></h2><p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<p><strong>Note:</strong>A leaf is a node with no children.</p>
<p><strong>Example:</strong><br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>return its depth = 3.</p>
<hr>
<p>解：方法一，递归</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Definition for </span>a<span class="markdown"> binary tree node.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>public class TreeNode &#123;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>int val;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>TreeNode left;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>TreeNode right;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>TreeNode(int x) &#123; val = x; &#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>&#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> */</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    public <span class="built_in">int</span> maxDepth(TreeNode root) &#123;</span><br><span class="line">        <span class="comment">//虽然是树的遍历，但是用DFS可以不需要写递归辅助函数</span></span><br><span class="line">        <span class="comment">//不需要记录任何节点的信息，这是这道题可以用简短代码解决的主要原因</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归退出条件，到叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> leftDepthMax = maxDepth(root.left);</span><br><span class="line">        <span class="built_in">int</span> rightDepthMax = maxDepth(root.right);</span><br><span class="line">        <span class="comment">// 计算出来的max是以某个节点为根节点的数的最大深度</span></span><br><span class="line">        <span class="comment">// max = java.lang.Math.max(leftMaxDepth，rightMaxDepth) + 1;</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(leftDepthMax, rightDepthMax) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写得漂亮一些，可以用一行解决：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public <span class="built_in">int</span> max<span class="constructor">Depth(TreeNode <span class="params">root</span>)</span> &#123;</span><br><span class="line">        return root<span class="operator"> == </span>null ? <span class="number">0</span> : <span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>max(max<span class="constructor">Depth(<span class="params">root</span>.<span class="params">left</span>)</span>,max<span class="constructor">Depth(<span class="params">root</span>.<span class="params">right</span>)</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度：我们每个结点只访问一次，因此时间复杂度为 O(N)，<br>其中 N 是结点的数量。</li>
<li>空间复杂度：在最糟糕的情况下，树是完全不平衡的，例如每个结点只剩下左子结点，递归将会被调用 N 次（树的高度），因此保持调用栈的存储将是 O(N)。但在最好的情况下（树是完全平衡的），树的高度将是 log(N)。因此，在这种情况下的空间复杂度将是 O(log(N))。</li>
</ul>
<p>方法二，迭代，用BFS层次遍历的方法，遍历完之后层数就是最大深度：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == null) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        Queue&lt;TreeNode&gt; <span class="built_in">queue</span> = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="built_in">queue</span>.add(root);</span><br><span class="line">        <span class="keyword">int</span> maxDepth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">queue</span>.isEmpty()) &#123;</span><br><span class="line">            maxDepth ++;</span><br><span class="line">            <span class="keyword">int</span> currLength = <span class="built_in">queue</span>.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; currLength; i++) &#123;</span><br><span class="line">                TreeNode node = <span class="built_in">queue</span>.poll();</span><br><span class="line">                <span class="keyword">if</span>(node.left != null) <span class="built_in">queue</span>.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != null) <span class="built_in">queue</span>.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxDepth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<p><strong>注：</strong>综合下来这道题用递归解法时间和空间复杂度都更优，因为平衡二叉树的情况下栈的调用次数只有log(n)。</p>
<h2 id="111-Minimum-depth-of-binary-tree-二叉树的最小深度-Mid"><a href="#111-Minimum-depth-of-binary-tree-二叉树的最小深度-Mid" class="headerlink" title="111. Minimum-depth-of-binary-tree(二叉树的最小深度)(Mid)"></a><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree" target="_blank" rel="noopener">111. Minimum-depth-of-binary-tree(二叉树的最小深度)(Mid)</a></h2><p>Given a binary tree, find its minimum depth.</p>
<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>
<p><strong>Note:</strong> A leaf is a node with no children.</p>
<p><strong>Example:</strong><br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>return its minimum depth = 2.</p>
<hr>
<p>解：递归是最直接的方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> int minDepth(<span class="type">TreeNode</span> root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == null) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        int <span class="keyword">left</span> = minDepth(root.<span class="keyword">left</span>);</span><br><span class="line">        int <span class="keyword">right</span> = minDepth(root.<span class="keyword">right</span>);</span><br><span class="line">        <span class="comment">//1.如果左孩子和右孩子有为空的情况，直接返回 left + right + 1</span></span><br><span class="line">        <span class="comment">//2.如果都不为空，返回较小深度+1</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">left</span> == <span class="number">0</span> || <span class="keyword">right</span> == <span class="number">0</span>) ? <span class="keyword">left</span> + <span class="keyword">right</span> + <span class="number">1</span>: <span class="type">Math</span>.<span class="built_in">min</span>(<span class="keyword">left</span>,<span class="keyword">right</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：我们访问每个节点一次，时间复杂度为 O(N) ，其中 N 是节点个数。</li>
<li>空间复杂度：最坏情况下，整棵树是非平衡的，例如每个节点都只有一个孩子，递归会调用 N （树的高度）次，因此栈的空间开销是 O(N) 。但在最好情况下，树是完全平衡的，高度只有 log(N)，因此在这种情况下空间复杂度只有 O(log(N)) 。</li>
</ul>
<h2 id="297-Serialize-and-deserialize-binary-tree-二叉树的序列化与反序列化-Hard"><a href="#297-Serialize-and-deserialize-binary-tree-二叉树的序列化与反序列化-Hard" class="headerlink" title="297. Serialize-and-deserialize-binary-tree(二叉树的序列化与反序列化)(Hard)"></a><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener">297. Serialize-and-deserialize-binary-tree(二叉树的序列化与反序列化)(Hard)</a></h2><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p>
<p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>
<p><strong>示例：</strong></p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">你可以将以下二叉树：</span><br><span class="line"></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">3</span></span><br><span class="line">     / \</span><br><span class="line">    <span class="number">4</span>   <span class="number">5</span></span><br><span class="line"></span><br><span class="line">序列化为 <span class="string">"[1,2,3,null,null,4,5]"</span></span><br></pre></td></tr></table></figure>
<p><strong>提示</strong>: 这与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p>
<p><strong>说明：</strong>不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。</p>
<hr>
<p>解：可以看出来，序列化和反序列化在实际中应用非常广泛也非常的重要。如果没有序列化，数据结构无法存储到文件和内存里面，通过网络的传输效率也会很低。</p>
<p>因为需要完成序列化和反序列化两个函数，所以需要两个思路：序列化的思想是利用dfs的先序遍历得到一个完整的序列，遇到了null直接存储null即可。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化的思想：利用dfs的preorder遍历得到一个完整的序列，遇到null的地方可以直接存储null，反序列化的时候可以根据标识操作</span></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serializeHelper(root, <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">String</span> <span class="title">serializeHelper</span><span class="params">(TreeNode root, <span class="keyword">String</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == null) &#123;</span><br><span class="line">            str += <span class="string">"null,"</span>;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// preorder add node</span></span><br><span class="line">        str += root.val + <span class="string">","</span>;</span><br><span class="line">        str = serializeHelper(root.left, str);</span><br><span class="line">        str = serializeHelper(root.right, str);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 反序列化的思想：利用list结构，每次返回list的首元素，作为上一个节点的左节点和右节点，然后依次删除掉list的首元素</span></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(<span class="keyword">String</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">String</span>[] data_ = data.split(<span class="string">","</span>);</span><br><span class="line">        List&lt;<span class="keyword">String</span>&gt; <span class="built_in">list</span> = <span class="keyword">new</span> LinkedList&lt;&gt;(Arrays.asList(data_));</span><br><span class="line">        <span class="keyword">return</span> desHelper(<span class="built_in">list</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">desHelper</span><span class="params">(List&lt;<span class="keyword">String</span>&gt; <span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">list</span>.<span class="built_in">get</span>(<span class="number">0</span>).equals(<span class="string">"null"</span>)) &#123;</span><br><span class="line">            <span class="built_in">list</span>.<span class="built_in">remove</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> null;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把String元素转换成int</span></span><br><span class="line">        <span class="keyword">int</span> val = Integer.valueOf(<span class="built_in">list</span>.<span class="built_in">get</span>(<span class="number">0</span>));</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        <span class="built_in">list</span>.<span class="built_in">remove</span>(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        root.left = desHelper(<span class="built_in">list</span>);</span><br><span class="line">        root.right = desHelper(<span class="built_in">list</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec = new Codec();</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：在序列化和反序列化函数中，我们只访问每个节点一次，因此时间复杂度为 O(n)，其中 n 是节点数，即树的大小。</li>
<li>空间复杂度：在序列化和反序列化函数中，我们将整棵树保留在开头或结尾，因此，空间复杂性为 O(n)。</li>
</ul>
<h2 id="236-Lowest-common-ancestor-of-a-binary-tree-二叉树的最近公共祖先-Mid"><a href="#236-Lowest-common-ancestor-of-a-binary-tree-二叉树的最近公共祖先-Mid" class="headerlink" title="236. Lowest-common-ancestor-of-a-binary-tree(二叉树的最近公共祖先)(Mid)"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">236. Lowest-common-ancestor-of-a-binary-tree(二叉树的最近公共祖先)(Mid)</a></h2><p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>
<p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”</p>
<p>Given the following binary tree:  root = [3,5,1,6,2,0,8,null,null,7,4]</p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt=""></p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: root = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">7</span>,<span class="number">4</span>], p = <span class="number">5</span>, q = <span class="number">1</span></span><br><span class="line">Output: <span class="number">3</span></span><br><span class="line">Explanation: The LCA of nodes <span class="number">5</span> <span class="keyword">and</span> <span class="number">1</span> <span class="keyword">is</span> <span class="number">3.</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: root = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">7</span>,<span class="number">4</span>], p = <span class="number">5</span>, q = <span class="number">4</span></span><br><span class="line">Output: <span class="number">5</span></span><br><span class="line">Explanation: The LCA of nodes <span class="number">5</span> <span class="keyword">and</span> <span class="number">4</span> <span class="keyword">is</span> <span class="number">5</span>, since a node can be a descendant of itself according to the LCA definition.</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ul>
<li>All of the nodes’ values will be unique.</li>
<li>p and q are different and both values will exist in the binary tree.</li>
</ul>
<hr>
<p>解：递归代码简单而且时间空间复杂度和迭代相同。</p>
<p>递归的base case:递归过程中如果root 是null,则返回null；如果递归到了子过程，比如(5, 5, 8)，则忽略其他内容返回传入的头结点(5)，同理如果到了(5, 8, 5)，同样忽略其他节点返回5。<br>这个逻辑可以用一行代码概括：</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span><span class="built_in">(root</span> == null ||<span class="built_in"> root</span> == p ||<span class="built_in"> root</span> == q) <span class="keyword">return</span><span class="built_in"> root</span>;</span><br></pre></td></tr></table></figure>
<p>之后进行递归调用，每次drill down 根节点的左孩子和右孩子。递归过程一般有四种：</p>
<ol>
<li>递归的时候总会传入整个结构的根节点。拿题目给的树为例，如果递归到了(2, 6, 0),即p和q都不为根节点的左子树和右子树节点，则返回null。(但是编写代码过程中貌似到不了这种情况，在递归过程中已经过滤掉了)。</li>
<li>传入的p和q中没有根节点右孩子节点，比如(3, 5, 4)，此时返回左子树靠上节点：5</li>
<li>传入的p和q中没有根节点左孩子节点，比如(3, 1, 0)， 此时返回右子树靠上节点：1</li>
<li>传入的p和q分别为根节点的左孩子节点和右孩子节点，比如(3, 6, 8)，返回根节点：3</li>
</ol>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Definition for </span>a<span class="markdown"> binary tree node.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>public class TreeNode &#123;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>int val;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>TreeNode left;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>TreeNode right;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>TreeNode(int x) &#123; val = x; &#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>&#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> */</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">        <span class="comment">// terminator</span></span><br><span class="line">        <span class="comment">// base cases</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || root == p || root == q)  <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">// 一路 drill down</span></span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="comment">// 第四种情况，左孩子和右孩子都有，则返回根节点</span></span><br><span class="line">        <span class="keyword">if</span>(left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>)   <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">// 概括第二和第三种情况</span></span><br><span class="line">        <span class="keyword">return</span> left != <span class="keyword">null</span> ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(N)，N 是二叉树中的节点数，最坏情况下，我们需要访问二叉树的所有节点。</li>
<li>空间复杂度：O(N)，这是因为递归堆栈使用的最大空间位 N,斜二叉树的高度可以是 N。</li>
</ul>
<h2 id="105-Construct-binary-tree-from-preorder-and-inorder-traversal-从前序与中序遍历序列构造二叉树-Mid"><a href="#105-Construct-binary-tree-from-preorder-and-inorder-traversal-从前序与中序遍历序列构造二叉树-Mid" class="headerlink" title="105. Construct-binary-tree-from-preorder-and-inorder-traversal(从前序与中序遍历序列构造二叉树)(Mid)"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal" target="_blank" rel="noopener">105. Construct-binary-tree-from-preorder-and-inorder-traversal(从前序与中序遍历序列构造二叉树)(Mid)</a></h2><p>Given preorder and inorder traversal of a tree, construct the binary tree.</p>
<p><strong>Note:</strong><br>You may assume that duplicates do not exist in the tree.</p>
<p>For example, given</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">preorder = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">inorder = [<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure>
<p>Return the following binary tree:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure>
<hr>
<p>解：这个题解过程在大学期间的数据结构课程应当有掌握。先序遍历的顺序总是根节点的顺序。我们可以根据先序遍历过程中遍历过的点逐渐判断哪些是根节点，然后中序遍历数组中在根节点左边的就是左子树，在右边的就是这个根节点的子树。</p>
<p>首先，preorder中的第一个元素一定是树的根，这个根又将inorder序列分成了左右两棵子树。现在我们只需要将先序遍历的数组中删除根元素，然后重复这个过程处理左右两棵子树。</p>
<p>解法一，直接使用上述原理，利用递归进行。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode buildTree(<span class="built_in">int</span>[] preorder, <span class="built_in">int</span>[] inorder) &#123;</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>, <span class="number">0</span>, inorder.length - <span class="number">1</span>, preorder, inorder);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 需要标记先序开始的地方和中序的序列.不需要preend是因为可以用preorder.length-1来标识</span></span><br><span class="line">    <span class="comment">// 每次递归的子问题需要用类似size的变量构造左子树和右子树</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode helper(<span class="built_in">int</span> preStart, <span class="built_in">int</span> inStart, <span class="built_in">int</span> inEnd, <span class="built_in">int</span>[] preorder, <span class="built_in">int</span>[] inorder) &#123;</span><br><span class="line">        <span class="comment">// 当前遍历的为null的条件</span></span><br><span class="line">        <span class="keyword">if</span> (preStart &gt; preorder.length - <span class="number">1</span> || inStart &gt; inEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// root 为当前遍历的根节点</span></span><br><span class="line">        TreeNode root = new TreeNode(preorder[preStart]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//知道了根节点之后可以推出左子树和右子树有哪些序列</span></span><br><span class="line">        <span class="comment">// 下面6行代码用于找到当前的根节点在中序遍历的什么位置</span></span><br><span class="line">        <span class="built_in">int</span> inIndex = <span class="number">0</span>; <span class="comment">// Index of current root in inorder</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = inStart; i &lt;= inEnd; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == root.val) &#123;</span><br><span class="line">                inIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归构造左子树。preStart+1是下一个左子树开始的节点。</span></span><br><span class="line">        <span class="comment">// 之前循环已经找到了当前root的位置并且用inIndex记录好了，所以左子树索引就是inIndex-1</span></span><br><span class="line">        root.left = helper(preStart + <span class="number">1</span>, inStart, inIndex - <span class="number">1</span>, preorder, inorder);</span><br><span class="line">        <span class="comment">// 递归构造右子树</span></span><br><span class="line">        root.right = helper(preStart + inIndex - inStart + <span class="number">1</span>, inIndex + <span class="number">1</span>, inEnd, preorder, inorder);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解法二，因为在递归过程中每次都要遍历中序遍历的数组去寻找，所以可以利用HashMap，把inorder[]，即中序遍历数组的每一个元素的值和下标存起来，这样可以直接用当前先序的值获取中序数组的下标位置了。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public TreeNode build<span class="constructor">Tree(<span class="params">int</span>[] <span class="params">preorder</span>, <span class="params">int</span>[] <span class="params">inorder</span>)</span> &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">        </span><br><span class="line">        for(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">            map.put(inorder<span class="literal">[<span class="identifier">i</span>]</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        TreeNode root = <span class="constructor">Helper(<span class="params">preorder</span>, 0, <span class="params">preorder</span>.<span class="params">length</span> - 1, <span class="params">inorder</span>, 0, <span class="params">inorder</span>.<span class="params">length</span> - 1, <span class="params">map</span>)</span>;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public TreeNode <span class="constructor">Helper(<span class="params">int</span>[] <span class="params">preorder</span>, <span class="params">int</span> <span class="params">preStart</span>, <span class="params">int</span> <span class="params">preEnd</span>, <span class="params">int</span>[] <span class="params">inorder</span>, <span class="params">int</span> <span class="params">inStart</span>, <span class="params">int</span> <span class="params">inEnd</span>, Map&lt;Integer, Integer&gt; <span class="params">map</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(preStart &gt; preEnd<span class="operator"> || </span>inStart &gt; inEnd) return null;</span><br><span class="line">        </span><br><span class="line">        TreeNode root = <span class="keyword">new</span> <span class="constructor">TreeNode(<span class="params">preorder</span>[<span class="params">preStart</span>])</span>;</span><br><span class="line">        <span class="built_in">int</span> inRoot = map.get(root.<span class="keyword">val</span>);</span><br><span class="line">        <span class="built_in">int</span> numsLeft = inRoot - inStart;</span><br><span class="line">        </span><br><span class="line">        root.left = <span class="constructor">Helper(<span class="params">preorder</span>, <span class="params">preStart</span> + 1, <span class="params">preStart</span> + <span class="params">numsLeft</span>, <span class="params">inorder</span>, <span class="params">inStart</span>, <span class="params">inRoot</span> - 1,<span class="params">map</span>)</span>;</span><br><span class="line">        root.right = <span class="constructor">Helper(<span class="params">preorder</span>, <span class="params">preStart</span> + <span class="params">numsLeft</span> + 1, <span class="params">preEnd</span>, <span class="params">inorder</span>, <span class="params">inRoot</span> + 1, <span class="params">inEnd</span>,<span class="params">map</span>)</span>;</span><br><span class="line">        </span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用HashMap可以大大提高效率，因为哈希表平均情况下查找效率为O(1)</p>
<ul>
<li>时间复杂度:O(n)，可用主定理计算得到</li>
<li>空间复杂度:O(n),存储整棵树的开销</li>
</ul>
<h2 id="剑指offer面试题54-二叉搜索树的第k大节点"><a href="#剑指offer面试题54-二叉搜索树的第k大节点" class="headerlink" title="剑指offer面试题54.二叉搜索树的第k大节点"></a>剑指offer面试题54.二叉搜索树的第k大节点</h2><p>给定一棵二叉搜索树，请找出其中第k大的节点。</p>
<p><strong>示例1：</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: root = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">2</span>], k = <span class="number">1</span></span><br><span class="line">   <span class="number">3</span></span><br><span class="line">  / \</span><br><span class="line"> <span class="number">1</span>   <span class="number">4</span></span><br><span class="line">  \</span><br><span class="line">   <span class="number">2</span></span><br><span class="line">输出: <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><strong>示例2：</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: root = [<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">1</span>], k = <span class="number">3</span></span><br><span class="line">       <span class="number">5</span></span><br><span class="line">      / \</span><br><span class="line">     <span class="number">3</span>   <span class="number">6</span></span><br><span class="line">    / \</span><br><span class="line">   <span class="number">2</span>   <span class="number">4</span></span><br><span class="line">  /</span><br><span class="line"> <span class="number">1</span></span><br><span class="line">输出: <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>限制：</p>
<p>1 ≤ k ≤ 二叉搜索树元素个数</p>
<hr>
<p>解：二叉搜索树的中序遍历能够保证结果是从小到大的。现在如果要第k大，即要找从大到小的。我们可以改变访问树的节点的顺序：本来中序遍历是左孩子、根节点、右孩子。我们可以把左孩子和右孩子的访问顺序改变一下，这样结果就是从大到小的了，用flag做记录，到了k之后记录当前值即可。</p>
<p>中序遍历代码可以用94题的中序遍历代码模板。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Definition for </span>a<span class="markdown"> binary tree node.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>public class TreeNode &#123;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>int val;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>TreeNode left;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>TreeNode right;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>TreeNode(int x) &#123; val = x; &#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>&#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> */</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    public <span class="built_in">int</span> kthLargest(TreeNode root, <span class="built_in">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// 中序遍历即可</span></span><br><span class="line">        <span class="comment">// if(root == null) return 0;</span></span><br><span class="line">        <span class="built_in">int</span> flag = <span class="number">0</span>, result = <span class="number">0</span>;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            flag++;</span><br><span class="line">            <span class="keyword">if</span>(flag == k) &#123;</span><br><span class="line">                result = root.val;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="50-Pow-x-n-Mid"><a href="#50-Pow-x-n-Mid" class="headerlink" title="50. Pow(x ,n)(Mid)"></a><a href="https://leetcode-cn.com/problems/powx-n/" target="_blank" rel="noopener">50. Pow(x ,n)(Mid)</a></h2><p>实现 <em>pow(x, n)</em> ，即计算 x 的 n 次幂函数。<br>Implement pow(x, n), which calculates x raised to the power n (x^n).</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="number">2.00000</span><span class="string">,</span> <span class="number">10</span></span><br><span class="line"><span class="attr">Output:</span> <span class="number">1024.00000</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="number">2.10000</span><span class="string">,</span> <span class="number">3</span></span><br><span class="line"><span class="attr">Output:</span> <span class="number">9.26100</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: <span class="number">2.00000</span>, <span class="number">-2</span></span><br><span class="line">Output: <span class="number">0.25000</span></span><br><span class="line">Explanation: <span class="number">2</span>^(<span class="number">-2</span>) = <span class="number">1</span>/(<span class="number">2</span>^<span class="number">2</span>) = <span class="number">1</span>/<span class="number">4</span> = <span class="number">0.25</span></span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ul>
<li>-100.0 &lt; x &lt; 100.0</li>
<li><em>n</em> is a 32 bit signed integer, within the range [−2^31, 2^(31 − 1)]</li>
</ul>
<hr>
<p>解：面试中碰到，首先需要和面试官确定一些事情(经常需要做的)：是否允许调用库函数？更重要的是，x和n的取值范围？x和n是否可以取0，正负值之类的。</p>
<p>其实我们在小学初中就学过某个数的几次方，就是把它乘几个自己，但是在高等数学中不是这么做的，在这里就进行一下计算。</p>
<p>方法一：暴力，求Pow就直接乘出来，时间复杂度为O(n)，提一嘴就行。</p>
<p>方法二，利用回溯和二分查找。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> myPow(<span class="built_in">double</span> x, <span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="comment">// 需要注意，如果输入的x大于1，同时n非常小，那么需要四舍五入输出0</span></span><br><span class="line">        <span class="comment">// 少了这一个判断，新增的一个用例无法通过：</span></span><br><span class="line">        <span class="comment">// 2.00000</span></span><br><span class="line">        <span class="comment">//-2147483648</span></span><br><span class="line">        <span class="keyword">if</span>(n == Integer.MIN_VALUE &amp;&amp; x &gt; <span class="number">1</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 递归出口</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 针对n为负数的处理</span></span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            n = -n;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (n % <span class="number">2</span> == <span class="number">0</span>) ? myPow(x * x, n / <span class="number">2</span>) : x * myPow(x * x, n / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<p><font color=#FF0000><strong>下面八道题为利用回溯解决的几个经典问题：求子集、排列问题、组合问题。此外还加上了分割回文串问题。虽然不是数字的list了，但是也是对List&lt;List<String>&gt;的操作以及回溯法的使用。</strong></font></p>
<p>参考LeetCode国际站回答： <a href="https://leetcode.com/problems/permutations/discuss/18239/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partioning)" target="_blank" rel="noopener">点击这里</a> 这些问题可以利用相同的一套解题模板，具体思路过程是：选择-&gt;拓展-&gt;剔除。</p>
<p>还有一点，这几道题最后返回的结果都是List&lt;List&lt;&gt;&gt;()类型的，即list里面装了list，如果不熟练，可能新手写起来都会存在困惑和错误。需要注意因为List不是基本数据类型，每次添加到result中时都需要new出来新的对象才可以，这也是对操作java中的list集合对象的熟练程度的考察。</p>
<p>此外，在过程中每次都是使用result.add(new ArrayList&lt;&gt;(curList))，是因为curList在回溯过程中每次都会被改变，我们需要记录当前curList的结果而不能让后面的curList的内容改变当前curList的结果。</p>
<h2 id="77-Combinations-组合-Mid"><a href="#77-Combinations-组合-Mid" class="headerlink" title="77. Combinations(组合)(Mid)"></a><a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/" target="_blank" rel="noopener">77. Combinations(组合)(Mid)</a></h2><p>Given two integers n and k, return all possible combinations of k numbers out of 1 … <em>n</em>.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: n = <span class="number">4</span>, k = <span class="number">2</span></span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">2</span>,<span class="number">4</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">4</span>],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>


<hr>
<p>解：这道题是很典型的用分治，回溯。这个题目递归最重要的两件事：递归终止条件和递归里面的for循环做的事情。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combine(<span class="built_in">int</span> n, <span class="built_in">int</span> k) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span><span class="operator"> || </span>k &lt;= <span class="number">0</span>) return results;</span><br><span class="line">        combine<span class="constructor">Helper(<span class="params">n</span>, <span class="params">k</span>, 1, <span class="params">results</span>, <span class="params">new</span> ArrayList&lt;Integer&gt;()</span>);</span><br><span class="line">        return results;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// st_num 为当前回合从哪个数开始取值。比如一开始从1到n所有的值都可以取</span></span><br><span class="line">    <span class="comment">// curSeq为当前List的状态</span></span><br><span class="line">    public void combine<span class="constructor">Helper(<span class="params">int</span> <span class="params">n</span>, <span class="params">int</span> <span class="params">k</span>, <span class="params">int</span> <span class="params">st_num</span>, List&lt;List&lt;Integer&gt;&gt; <span class="params">results</span>, List&lt;Integer&gt; <span class="params">curSeq</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// terminator ，k位都生成了,size满足条件之后把curSeq加入到results中</span></span><br><span class="line">        <span class="keyword">if</span>(k<span class="operator"> == </span><span class="number">0</span>) results.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt; (curSeq));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            for(<span class="built_in">int</span> i = st_num; i &lt;= n; i++) &#123;</span><br><span class="line">                curSeq.add(i);</span><br><span class="line">                <span class="comment">// 每次drill down循环次数为k-1</span></span><br><span class="line">                combine<span class="constructor">Helper(<span class="params">n</span>, <span class="params">k</span>-1, <span class="params">i</span> + 1, <span class="params">results</span>, <span class="params">curSeq</span>)</span>;</span><br><span class="line">                <span class="comment">// 和数组一样，list下标从0开始</span></span><br><span class="line">                curSeq.remove(curSeq.size<span class="literal">()</span>-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="39-Combination-Sum-组合总和-Mid"><a href="#39-Combination-Sum-组合总和-Mid" class="headerlink" title="39. Combination Sum(组合总和)(Mid)"></a><a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">39. Combination Sum(组合总和)(Mid)</a></h2><p>Given a <strong>set</strong> of candidate numbers (<code>candidates</code>) (<strong>without duplicates</strong>) and a target number (<code>target</code>), find all unique combinations in <code>candidates</code> where the candidate numbers sums to <code>target</code>.</p>
<p>The <strong>same</strong> repeated number may be chosen from <code>candidates</code> unlimited number of times.</p>
<p><strong>Note:</strong></p>
<ul>
<li>All numbers (including <code>target</code>) will be positive integers.</li>
<li>The solution set must not contain duplicate combinations.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: candidates = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>], target = <span class="number">7</span>,</span><br><span class="line">A solution <span class="keyword">set</span> <span class="keyword">is</span>:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">7</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: candidates = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>], target = <span class="number">8</span>,</span><br><span class="line">A solution <span class="keyword">set</span> <span class="keyword">is</span>:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<hr>
<p>解：需要注意的是只要和为target，candidates里面的元素每一个都可以被无限次选择。</p>
<p>看起来和上一道，77组合问题，有相似之处，但是解决起来复杂比较多，因为既需要考虑和是否为target，同时candidates里面的元素可以无限次数选择，加大了难度。</p>
<p>但是可以套用解决这几道回溯(写递归)问题的一系列问题的模板。</p>
<p>首先排序，用于剪枝。不排序也可以通过，但是先排序能够提升最后的空间和时间复杂度。</p>
<p>这样只要当前值比剩余的target大了，后面都是递增的，则可以break跳出了。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combination<span class="constructor">Sum(<span class="params">int</span>[] <span class="params">candidates</span>, <span class="params">int</span> <span class="params">target</span>)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">if</span>(target<span class="operator"> == </span><span class="number">0</span><span class="operator"> || </span>candidates<span class="operator"> == </span>null<span class="operator"> || </span>candidates.length<span class="operator"> == </span><span class="number">0</span>) return result;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span>sort(candidates);</span><br><span class="line">        <span class="constructor">Helper(<span class="params">result</span>, <span class="params">candidates</span>, <span class="params">target</span>, <span class="params">new</span> ArrayList&lt;&gt;()</span>, <span class="number">0</span>);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// start为当前使用的元素在candidates中的位置。因为可以重复使用，所以下一次传入的是i而不是i+1</span></span><br><span class="line">    public void <span class="constructor">Helper(List&lt;List&lt;Integer&gt;&gt; <span class="params">result</span>, <span class="params">int</span>[] <span class="params">candidates</span>, <span class="params">int</span> <span class="params">remain</span>, List&lt;Integer&gt; <span class="params">curList</span>, <span class="params">int</span> <span class="params">start</span>)</span> &#123;</span><br><span class="line">         <span class="keyword">if</span>(remain &lt; <span class="number">0</span>) return ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(remain<span class="operator"> == </span><span class="number">0</span>) result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(curList));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 从当前的 start 到数组的最后一个数来进行判断</span></span><br><span class="line">            for(<span class="built_in">int</span> i = start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">                curList.add(candidates<span class="literal">[<span class="identifier">i</span>]</span>);</span><br><span class="line">                <span class="constructor">Helper(<span class="params">result</span>, <span class="params">candidates</span>, <span class="params">remain</span> - <span class="params">candidates</span>[<span class="params">i</span>], <span class="params">curList</span>, <span class="params">i</span>)</span>; <span class="comment">// The start is not i+1 because we can reuse same element</span></span><br><span class="line">                curList.remove(curList.size<span class="literal">()</span> - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的for循环中的三行内容为回溯常用的写法，在curList中，先curList.add()加进去，再递归处理得到结果，再从curList中移除掉。</p>
<p>回溯的过程是怎样的呢？举个例子，如果candidates为<code>[1,2,3,4,5]</code>, target为7，一开始加入的结果是[1,2,3]，然后为[1,2,3,4]的时候，此时remain &lt; 0，所以return 回到curList为[1,2,3]的时候，此时需要执行curList.remove(curList.size() - 1)，即curList又变成[1,2]，然后再放入4, curList变成[1,2,4]，再往后执行，以此类推。</p>
<p>时间复杂度：组合问题，指数级的，O(2^n)。因为最终是从所有candidates的组合中选择出符合要求的，所有的情况是2^n的，所以整体时间复杂度就是O(2^n)。</p>
<h2 id="40-Combination-Sum-II-组合总和-II-Mid"><a href="#40-Combination-Sum-II-组合总和-II-Mid" class="headerlink" title="40. Combination Sum II (组合总和 II)(Mid)"></a><a href="https://leetcode-cn.com/problems/combination-sum-ii/" target="_blank" rel="noopener">40. Combination Sum II (组合总和 II)(Mid)</a></h2><p>Given a collection of candidate numbers (<code>candidates</code>) and a target number (<code>target</code>), find all unique combinations in <code>candidates</code> where the candidate numbers sums to <code>target</code>.</p>
<p>Each number in <code>candidates</code> may only be used <strong>once</strong> in the combination.</p>
<p><strong>Note:</strong></p>
<ul>
<li>All numbers (including <code>target</code>) will be positive integers.</li>
<li>The solution set must not contain duplicate combinations.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: candidates = [<span class="number">10</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">5</span>], target = <span class="number">8</span>,</span><br><span class="line">A solution <span class="keyword">set</span> <span class="keyword">is</span>:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>, <span class="number">7</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="number">6</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">1</span>, <span class="number">6</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: candidates = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>], target = <span class="number">5</span>,</span><br><span class="line">A solution <span class="keyword">set</span> <span class="keyword">is</span>:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">5</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<hr>
<p>解：39题的变题。和39相比的区别是，给的candidates数组可能包含重复元素、结果的list中不能有重复元素。</p>
<p>在去重思路上有一点变化。首先结果中不能重复使用candidates中的元素，所以在递归中start元素要变成i+1。此外，因为candidates中可以有重复元素，所以也要避免重复使用相同元素，在for循环中加一个判断。其他相同。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combination<span class="constructor">Sum2(<span class="params">int</span>[] <span class="params">candidates</span>, <span class="params">int</span> <span class="params">target</span>)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">if</span>(target<span class="operator"> == </span><span class="number">0</span><span class="operator"> || </span>candidates<span class="operator"> == </span>null<span class="operator"> || </span>candidates.length<span class="operator"> == </span><span class="number">0</span>) return result;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span>sort(candidates);</span><br><span class="line">        <span class="constructor">Helper(<span class="params">result</span>, <span class="params">candidates</span>, <span class="params">target</span>, <span class="params">new</span> ArrayList&lt;&gt;()</span>, <span class="number">0</span>);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void <span class="constructor">Helper(List&lt;List&lt;Integer&gt;&gt; <span class="params">result</span>, <span class="params">int</span>[] <span class="params">candidates</span>, <span class="params">int</span> <span class="params">remain</span>, List&lt;Integer&gt; <span class="params">curList</span>, <span class="params">int</span> <span class="params">start</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(remain &lt; <span class="number">0</span>) return ;</span><br><span class="line">        <span class="keyword">if</span>(remain<span class="operator"> == </span><span class="number">0</span>) result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(curList));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            for(<span class="built_in">int</span> i = start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">                <span class="comment">// 很重要的去掉重复解的步骤，这一行代码就可以实现</span></span><br><span class="line">                <span class="comment">// 逻辑写成i != start也可以</span></span><br><span class="line">                <span class="keyword">if</span>(i &gt; start<span class="operator"> &amp;&amp; </span>candidates<span class="literal">[<span class="identifier">i</span>]</span><span class="operator"> == </span>candidates<span class="literal">[<span class="identifier">i</span>-<span class="number">1</span>]</span>) continue; <span class="comment">// skip duplicates</span></span><br><span class="line">                curList.add(candidates<span class="literal">[<span class="identifier">i</span>]</span>);</span><br><span class="line">                <span class="constructor">Helper(<span class="params">result</span>, <span class="params">candidates</span>, <span class="params">remain</span> - <span class="params">candidates</span>[<span class="params">i</span>], <span class="params">curList</span>, <span class="params">i</span>+1)</span>;</span><br><span class="line">                curList.remove(curList.size<span class="literal">()</span> - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：指数级的，O(2^n)，推理方法和39题相同。</p>
<h2 id="46-Permutations-全排列-Mid"><a href="#46-Permutations-全排列-Mid" class="headerlink" title="46. Permutations(全排列)(Mid)"></a><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">46. Permutations(全排列)(Mid)</a></h2><p>Given a collection of distinct integers, return all possible permutations.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<hr>
<p>解：这是一个典型的用递归解决的问题</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="built_in">public</span> List&lt;List&lt;<span class="type">Integer</span>&gt;&gt; permute(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;<span class="type">Integer</span>&gt;&gt; result = <span class="built_in">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        permuteHelper(result, <span class="built_in">new</span> ArrayList&lt;<span class="type">Integer</span>&gt;(),  nums);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> permuteHelper(List&lt;List&lt;<span class="type">Integer</span>&gt;&gt; result, List&lt;<span class="type">Integer</span>&gt; curList, <span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(curList.size() == nums.length) &#123;</span><br><span class="line">            result.<span class="keyword">add</span>(<span class="built_in">new</span> ArrayList&lt;&gt;(curList));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(curList.contains(nums[i])) <span class="keyword">continue</span>; // element already <span class="keyword">exists</span>, skip</span><br><span class="line">                curList.<span class="keyword">add</span>(nums[i]);</span><br><span class="line">                permuteHelper(result,curList,nums);</span><br><span class="line">                curList.remove(curList.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以想象，每一位都是从nums[0]开始，递归完(nums[0],nums[1],nums[2])之后，从list中remove掉nums[2]，发现会掉入if(curList.contains(nums[i]))的条件，所以会紧接着remove掉nums[1]。再之后会尝试往curList中加入nums[2],因为此时nums[0]和nums[2]都已经在list中有了，所以会在continue之后加入nums[1]，再continue一次，然后以nums[0]作为第一个元素的list的答案就结束了，后面第一个元素变成nums[1]，再进行递归。</p>
<p>之前有一个不清楚的困扰，就是为什么result.add(curList)会返回空的list，必须result.add(new ArrayList&lt;&gt;(curList))才可以返回有值的结果。后来发现应该是单纯的add能加入的只能是基本数据类型，而要加入的curList是引用类型，需要new 以curList为内容的list才能加入。也可以理解为，在递归过程中curList总会变化，所以每次新加的是为了记录当前curList的内容的值，需要new才可以。</p>
<p>这道题是非常经典的一道题，这种递归的写法对于初学者可能会比较难思考的，建议多重复几遍，参考我上面这两段文字，更利于理解。</p>
<h2 id="47-Permutations-ii-全排列-II-Mid"><a href="#47-Permutations-ii-全排列-II-Mid" class="headerlink" title="47. Permutations-ii(全排列 II)(Mid)"></a><a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">47. Permutations-ii(全排列 II)(Mid)</a></h2><p>Given a collection of numbers that might contain duplicates, return all possible unique permutations.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<hr>
<p>解：47是46的变题。输入的nums可能存在重复的元素，实际上，重复的元素也是最重要的考量因素。</p>
<p>有了重复元素之后，整个逻辑和46就已经完全不同了。如果仍然使用46的contains去在循环过程中剔除掉，那么根本凑不足排列的元素数量。所以在往curList里面添加元素的过程中的逻辑需要改变。</p>
<p>在遍历每个元素的过程中，我们也要考虑去重，同一个元素不能被多次使用。而对于这道题，相等的元素也不能被多次使用。</p>
<p>具体到实现上，因为nums[]没说排好序了，所以为了方便根据前后元素进行判重，所以相比46题需要先排序。此外，因为nums[]中存在重复元素，需要判断当前元素是否使用的情况，所以要定义一个boolean数组:used。</p>
<p><font color=#FF0000><strong>为什么用一个boolean数组可以对去重复情况有效？</strong></font>因为经过推演可以发现这样一个规律：每次重复的结果出现的情况都是：<strong>重复的元素中，前面的不取，后面的取</strong>。其他情况比如前面和后面都取、前面取后面不取、前面后面都不取，这些都不会是重复的情况。读者可以自行举例推演验证。</p>
<p>为了方便记忆，实际上，used数组成为了循环内部判断的条件，不再需要使用curList.contains()方法。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; permute<span class="constructor">Unique(<span class="params">int</span>[] <span class="params">nums</span>)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length<span class="operator"> == </span><span class="number">0</span><span class="operator"> || </span>nums<span class="operator"> == </span>null) return result;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span>sort(nums);</span><br><span class="line">        permute<span class="constructor">UniqueHelper(<span class="params">result</span>, <span class="params">nums</span>, <span class="params">new</span> ArrayList&lt;&gt;()</span>, <span class="keyword">new</span> boolean<span class="literal">[<span class="identifier">nums</span>.<span class="identifier">length</span>]</span>);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// used 每一位都记录nums的某一个数字是否用过了   </span></span><br><span class="line">    public void permute<span class="constructor">UniqueHelper(List&lt;List&lt;Integer&gt;&gt; <span class="params">result</span>, <span class="params">int</span>[] <span class="params">nums</span>, List&lt;Integer&gt; <span class="params">curList</span>, <span class="params">boolean</span>[] <span class="params">used</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(curList.size<span class="literal">()</span><span class="operator"> == </span>nums.length) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(curList));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            for(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">                <span class="comment">// 相比46题，continue的条件有点复杂</span></span><br><span class="line">                <span class="comment">// 如果第i个已经被用过了，即used[i]为true，则直接跳过本轮</span></span><br><span class="line">                <span class="comment">// 如果当前第i个没有用过，那么同时满足三个条件，本轮也跳过。分别是：</span></span><br><span class="line">                <span class="comment">// 不是第一轮了，即i &gt; 0; nums[]中当前元素为重复; 当前元素的前一个元素目前没有被用，即</span></span><br><span class="line">                <span class="comment">// 正要把第i个之前有重复的元素推到最前面的时候</span></span><br><span class="line">                <span class="keyword">if</span>(used<span class="literal">[<span class="identifier">i</span>]</span><span class="operator"> || </span>i &gt; <span class="number">0</span><span class="operator"> &amp;&amp; </span>nums<span class="literal">[<span class="identifier">i</span>]</span><span class="operator"> == </span>nums<span class="literal">[<span class="identifier">i</span>-<span class="number">1</span>]</span><span class="operator"> &amp;&amp; </span>!used<span class="literal">[<span class="identifier">i</span>-<span class="number">1</span>]</span>) continue;</span><br><span class="line">                used<span class="literal">[<span class="identifier">i</span>]</span> = <span class="literal">true</span>;</span><br><span class="line">                curList.add(nums<span class="literal">[<span class="identifier">i</span>]</span>);</span><br><span class="line">                permute<span class="constructor">UniqueHelper(<span class="params">result</span>, <span class="params">nums</span>, <span class="params">curList</span>, <span class="params">used</span>)</span>;</span><br><span class="line">                used<span class="literal">[<span class="identifier">i</span>]</span> = <span class="literal">false</span>;</span><br><span class="line">                curList.remove(curList.size<span class="literal">()</span> - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="78-Subsets-子集-Mid"><a href="#78-Subsets-子集-Mid" class="headerlink" title="78. Subsets(子集)(Mid)"></a><a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">78. Subsets(子集)(Mid)</a></h2><p>Given a set of <strong>distinct</strong> integers, <em>nums</em>, return all possible subsets (the power set).</p>
<p><strong>Note</strong>: The solution set must not contain duplicate subsets.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>],</span><br><span class="line">  [<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<hr>
<p>解：方法一：给的nums都是不同的元素，都没有排序过，返回的list总会包含[]，这几点需要注意。</p>
<p>这也是非常典型的用回溯完成的题目。和之前几个需要考虑和为target的或者每个集合里面必须有所有数字的排列来说，其实终止条件比较简单。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; subsets(<span class="built_in">int</span><span class="literal">[]</span> nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length<span class="operator"> == </span><span class="number">0</span><span class="operator"> || </span>nums<span class="operator"> == </span>null) return result;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span>sort(nums);</span><br><span class="line">        <span class="constructor">Helper(<span class="params">result</span>, <span class="params">nums</span>, <span class="params">new</span> ArrayList&lt;&gt;()</span>, <span class="number">0</span>);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void <span class="constructor">Helper(List&lt;List&lt;Integer&gt;&gt; <span class="params">result</span>, <span class="params">int</span>[] <span class="params">nums</span>, List&lt;Integer&gt; <span class="params">curList</span>, <span class="params">int</span> <span class="params">start</span>)</span> &#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(curList));</span><br><span class="line">        for(<span class="built_in">int</span> i = start; i &lt; nums.length; i++) &#123;</span><br><span class="line">            curList.add(nums<span class="literal">[<span class="identifier">i</span>]</span>);</span><br><span class="line">            <span class="constructor">Helper(<span class="params">result</span>, <span class="params">nums</span>, <span class="params">curList</span>, <span class="params">i</span> + 1)</span>;</span><br><span class="line">            curList.remove(curList.size<span class="literal">()</span> - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：考虑每一位可以选某个元素或者不选，相当于填空。</p>
<h2 id="90-Subsets-II-子集II-Mid"><a href="#90-Subsets-II-子集II-Mid" class="headerlink" title="90. Subsets II(子集II)(Mid)"></a><a href="https://leetcode.com/problems/subsets-ii/" target="_blank" rel="noopener">90. Subsets II(子集II)(Mid)</a></h2><p>Given a collection of integers that might contain duplicates, <strong>nums</strong>, return all possible subsets (the power set).</p>
<p><strong>Note</strong>: The solution set must not contain duplicate subsets.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<hr>
<p>解：与78题相比，Input可以有重复元素。具体写法上主要是for里面需要增加循环终止的条件，因为相同的元素只能使用一次，再次使用产生的结果会是重复的。具体做法也和之前一样，排好序之后，当前循环变量(i)不为start之后(条件为i &gt; start或者i!=start都可以)，只要 <code>nums[i] == nums[i-1]</code>，就continue。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; subsets<span class="constructor">WithDup(<span class="params">int</span>[] <span class="params">nums</span>)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums<span class="operator"> == </span>null<span class="operator"> || </span>nums.length<span class="operator"> == </span><span class="number">0</span>) return result;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span>sort(nums);</span><br><span class="line">        <span class="constructor">Helper(<span class="params">result</span>, <span class="params">nums</span>, <span class="params">new</span> ArrayList&lt;&gt;()</span>, <span class="number">0</span>);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void <span class="constructor">Helper(List&lt;List&lt;Integer&gt;&gt; <span class="params">result</span>, <span class="params">int</span>[] <span class="params">nums</span>, List&lt;Integer&gt; <span class="params">curList</span>, <span class="params">int</span> <span class="params">start</span>)</span> &#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(curList));</span><br><span class="line">        for(<span class="built_in">int</span> i = start; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; start<span class="operator"> &amp;&amp; </span>nums<span class="literal">[<span class="identifier">i</span>]</span><span class="operator"> == </span>nums<span class="literal">[<span class="identifier">i</span>-<span class="number">1</span>]</span>) continue;</span><br><span class="line">            curList.add(nums<span class="literal">[<span class="identifier">i</span>]</span>);</span><br><span class="line">            <span class="constructor">Helper(<span class="params">result</span>, <span class="params">nums</span>, <span class="params">curList</span>, <span class="params">i</span> + 1)</span>;</span><br><span class="line">            curList.remove(curList.size<span class="literal">()</span> - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="131-Palindrome-Partitioning-分割回文串-Mid"><a href="#131-Palindrome-Partitioning-分割回文串-Mid" class="headerlink" title="131. Palindrome Partitioning(分割回文串)(Mid)"></a><a href="https://leetcode-cn.com/problems/palindrome-partitioning/" target="_blank" rel="noopener">131. Palindrome Partitioning(分割回文串)(Mid)</a></h2><p>Given a string s, partition s such that every substring of the partition is a palindrome.</p>
<p>Return all possible palindrome partitioning of s.</p>
<p><strong>Example:</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Input</span>: <span class="string">"aab"</span></span><br><span class="line"><span class="symbol">Output</span>:</span><br><span class="line">[</span><br><span class="line">  [<span class="string">"aa"</span>,<span class="string">"b"</span>],</span><br><span class="line">  [<span class="string">"a"</span>,<span class="string">"a"</span>,<span class="string">"b"</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<hr>
<p>解：判断是否为回文串的部分可以单独定义成一个函数。一头一尾两个指针扫描，必须相等才能是回文串。利用自增自减简化写法。只有符合要求才放入curList</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;<span class="keyword">String</span>&gt;&gt; partition(<span class="keyword">String</span> s) &#123;</span><br><span class="line">        List&lt;List&lt;<span class="keyword">String</span>&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        backtrack(result, <span class="keyword">new</span> ArrayList&lt;&gt;(), s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;<span class="keyword">String</span>&gt;&gt; result, List&lt;<span class="keyword">String</span>&gt; curList, <span class="keyword">String</span> s, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == s.length())</span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(curList));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; s.length(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(isPalindrome(s, start, i)) &#123;</span><br><span class="line">                    curList.add(s.substring(start, i+<span class="number">1</span>));</span><br><span class="line">                    backtrack(result, curList, s, i+<span class="number">1</span>);</span><br><span class="line">                    curList.<span class="built_in">remove</span>(curList.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">String</span> s, <span class="keyword">int</span> <span class="built_in">begin</span>, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">begin</span> &lt; <span class="built_in">end</span>)</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(<span class="built_in">begin</span>++) != s.charAt(<span class="built_in">end</span>--)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="307-Range-Sum-Query-Mutable-区域和检索-数组可修改-Mid"><a href="#307-Range-Sum-Query-Mutable-区域和检索-数组可修改-Mid" class="headerlink" title="307.Range Sum Query-Mutable(区域和检索-数组可修改)(Mid)"></a><a href="https://leetcode-cn.com/problems/range-sum-query-mutable/" target="_blank" rel="noopener">307.Range Sum Query-Mutable(区域和检索-数组可修改)(Mid)</a></h2><p>Given an integer array <em>nums</em>, find the sum of the elements between indices <em>i</em> and <em>j (i ≤ j)</em>, inclusive.</p>
<p>The <em>update(i, val)</em> function modifies nums by updating the element at index <em>i</em> to <em>val</em>.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Given nums = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">sumRange(<span class="number">0</span>, <span class="number">2</span>) -&gt; <span class="number">9</span></span><br><span class="line">update(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">sumRange(<span class="number">0</span>, <span class="number">2</span>) -&gt; <span class="number">8</span></span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ol>
<li>The array is only modifiable by the update function.</li>
<li>You may assume the number of calls to update and sumRange function is distributed evenly.</li>
</ol>
<hr>
<p>解：简而言之，这道题简直就是为了考线段树(Segment Tree)而出的。这道题非常符合线段树的使用场景，详细可参考<a href="https://www.geeksforgeeks.org/segment-tree-set-1-sum-of-given-range/" target="_blank" rel="noopener">这篇文章</a></p>
<p>参考LeetCode国际站高票代码：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> NumArray &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> SegmentTreeNode &#123;</span><br><span class="line">        <span class="built_in">int</span> start, <span class="keyword">end</span>;</span><br><span class="line">        SegmentTreeNode left, right;</span><br><span class="line">        <span class="built_in">int</span> sum;</span><br><span class="line">        </span><br><span class="line">        <span class="constructor">SegmentTreeNode(<span class="params">int</span> <span class="params">start</span>, <span class="params">int</span> <span class="params">end</span>)</span> &#123;</span><br><span class="line">            this.start = start;</span><br><span class="line">            this.<span class="keyword">end</span> = <span class="keyword">end</span>;</span><br><span class="line">            this.left = null;</span><br><span class="line">            this.right = null;</span><br><span class="line">            this.sum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SegmentTreeNode root = null;</span><br><span class="line">    </span><br><span class="line">    public <span class="constructor">NumArray(<span class="params">int</span>[] <span class="params">nums</span>)</span> &#123;</span><br><span class="line">        root = build<span class="constructor">Tree(<span class="params">nums</span>, 0, <span class="params">nums</span>.<span class="params">length</span> - 1)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">private</span> SegmentTreeNode build<span class="constructor">Tree(<span class="params">int</span>[] <span class="params">nums</span>, <span class="params">int</span> <span class="params">start</span>, <span class="params">int</span> <span class="params">end</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; <span class="keyword">end</span>) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            SegmentTreeNode ret = <span class="keyword">new</span> <span class="constructor">SegmentTreeNode(<span class="params">start</span>, <span class="params">end</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (start<span class="operator"> == </span><span class="keyword">end</span>) &#123;</span><br><span class="line">                ret.sum = nums<span class="literal">[<span class="identifier">start</span>]</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">int</span> mid = start  + (<span class="keyword">end</span> - start)<span class="operator"> / </span><span class="number">2</span>;             </span><br><span class="line">                ret.left = build<span class="constructor">Tree(<span class="params">nums</span>, <span class="params">start</span>, <span class="params">mid</span>)</span>;</span><br><span class="line">                ret.right = build<span class="constructor">Tree(<span class="params">nums</span>, <span class="params">mid</span> + 1, <span class="params">end</span>)</span>;</span><br><span class="line">                ret.sum = ret.left.sum + ret.right.sum;</span><br><span class="line">            &#125;         </span><br><span class="line">            return ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void update(<span class="built_in">int</span> i, <span class="built_in">int</span> <span class="keyword">val</span>) &#123;</span><br><span class="line">        update(root, i, <span class="keyword">val</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     void update(SegmentTreeNode root, <span class="built_in">int</span> pos, <span class="built_in">int</span> <span class="keyword">val</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.start<span class="operator"> == </span>root.<span class="keyword">end</span>) &#123;</span><br><span class="line">           root.sum = <span class="keyword">val</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">int</span> mid = root.start + (root.<span class="keyword">end</span> - root.start)<span class="operator"> / </span><span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (pos &lt;= mid) &#123;</span><br><span class="line">                 update(root.left, pos, <span class="keyword">val</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 update(root.right, pos, <span class="keyword">val</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            root.sum = root.left.sum + root.right.sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="built_in">int</span> sum<span class="constructor">Range(<span class="params">int</span> <span class="params">i</span>, <span class="params">int</span> <span class="params">j</span>)</span> &#123;</span><br><span class="line">        return sum<span class="constructor">Range(<span class="params">root</span>, <span class="params">i</span>, <span class="params">j</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public <span class="built_in">int</span> sum<span class="constructor">Range(SegmentTreeNode <span class="params">root</span>, <span class="params">int</span> <span class="params">start</span>, <span class="params">int</span> <span class="params">end</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.<span class="keyword">end</span><span class="operator"> == </span><span class="keyword">end</span><span class="operator"> &amp;&amp; </span>root.start<span class="operator"> == </span>start) &#123;</span><br><span class="line">            return root.sum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">int</span> mid = root.start + (root.<span class="keyword">end</span> - root.start)<span class="operator"> / </span><span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">end</span> &lt;= mid) &#123;</span><br><span class="line">                return sum<span class="constructor">Range(<span class="params">root</span>.<span class="params">left</span>, <span class="params">start</span>, <span class="params">end</span>)</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (start &gt;= mid+<span class="number">1</span>) &#123;</span><br><span class="line">                return sum<span class="constructor">Range(<span class="params">root</span>.<span class="params">right</span>, <span class="params">start</span>, <span class="params">end</span>)</span>;</span><br><span class="line">            &#125;  <span class="keyword">else</span> &#123;    </span><br><span class="line">                return sum<span class="constructor">Range(<span class="params">root</span>.<span class="params">right</span>, <span class="params">mid</span>+1, <span class="params">end</span>)</span> + sum<span class="constructor">Range(<span class="params">root</span>.<span class="params">left</span>, <span class="params">start</span>, <span class="params">mid</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumArray obj = new NumArray(nums);</span></span><br><span class="line"><span class="comment"> * obj.update(i,val);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.sumRange(i,j);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithms Note</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Practice by Categories Hash Table</title>
    <url>/2020/01/13/LeetCode-Practice-by-Categories-Hash-Table/</url>
    <content><![CDATA[<blockquote>
<p>合理安排时间，等于节约时间。——培根</p>
</blockquote>
<p>LeetCode哈希表、相关题目，其解决思路和具体代码。以及有关java语言哈希表的解析。</p>
<a id="more"></a>

<h2 id="242-Valid-Anagram-有效的字母异位词-Easy"><a href="#242-Valid-Anagram-有效的字母异位词-Easy" class="headerlink" title="242. Valid Anagram(有效的字母异位词)(Easy)"></a><a href="https://leetcode-cn.com/problems/valid-anagram/" target="_blank" rel="noopener">242. Valid Anagram(有效的字母异位词)(Easy)</a></h2><p>Given two strings s and t , write a function to determine if t is an anagram of s.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">Input:</span> s = <span class="string">"anagram"</span>, t = <span class="string">"nagaram"</span></span><br><span class="line"><span class="string">Output:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">Input:</span> s = <span class="string">"rat"</span>, t = <span class="string">"car"</span></span><br><span class="line"><span class="string">Output:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong><br>You may assume the string contains only lowercase alphabets.</p>
<p><strong>Follow up:</strong><br>What if the inputs contain unicode characters? How would you adapt your solution to such case?</p>
<hr>
<p>解：这道题可以直接把传入的两个字符串转换成字符数组，按照字典序排序后比较是否相等。这种方法不需要用到哈希表，但是类库自带的快排整体速度不如哈希表(这道题实际上使用到哈希表的思想，我们自己定义一个哈希映射)的查询速度快。</p>
<p>方法一：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public boolean is<span class="constructor">Anagram(String <span class="params">s</span>, String <span class="params">t</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length<span class="literal">()</span> != t.length<span class="literal">()</span>) return <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">char</span><span class="literal">[]</span> s1 = s.<span class="keyword">to</span><span class="constructor">CharArray()</span>;</span><br><span class="line">        <span class="built_in">char</span><span class="literal">[]</span> t1 = t.<span class="keyword">to</span><span class="constructor">CharArray()</span>;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span>sort(s1);</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span>sort(t1);</span><br><span class="line">        return <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span>equals(s1,t1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：使用哈希映射思想，定义一个我们自己的哈希表，遍历s和t，每次把s中遍历到的字母的ASICC码计算并且加起来，再减去t中对应的值。遍历一遍下来，如果有一个字母的对应的出现次数不为0，则整个传入数据不为字母异位词。此方法中new了一个大小为26的数组，其中每一个元素代表一个字母的出现次数，所以最后只要有一个不为0，输入就不为字母异位词。</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isAnagram(String s, String t) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() != t.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] <span class="keyword">count</span> = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">char</span>[] s1 = s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] t1 = t.toCharArray();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s1.length; i++) &#123;</span><br><span class="line">            <span class="keyword">count</span>[s1[i] - <span class="string">'a'</span>]++;</span><br><span class="line">            <span class="keyword">count</span>[t1[i] - <span class="string">'a'</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">count</span>[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>，如果不先将s和t 进行toCharArray转换，而直接用charAt()判断位置然后进行哈希映射，整体执行效率会很慢。上面的用时可以击败90%以上，但是下面这段代码一般只能击败60%，试验了多次。</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isAnagram(String s, String t) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() != t.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] <span class="keyword">count</span> = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s.length() ;i++) &#123;</span><br><span class="line">            <span class="keyword">count</span>[s.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">            <span class="keyword">count</span>[t.charAt(i) - <span class="string">'a'</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> counter : <span class="keyword">count</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(counter != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="49-Group-Anagram-字母异位词分组-Mid"><a href="#49-Group-Anagram-字母异位词分组-Mid" class="headerlink" title="49. Group Anagram(字母异位词分组)(Mid)"></a><a href="https://leetcode-cn.com/problems/group-anagrams/" target="_blank" rel="noopener">49. Group Anagram(字母异位词分组)(Mid)</a></h2><p>Given an array of strings, group anagrams together.</p>
<p><strong>Example:</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Input</span>: [<span class="string">"eat"</span>, <span class="string">"tea"</span>, <span class="string">"tan"</span>, <span class="string">"ate"</span>, <span class="string">"nat"</span>, <span class="string">"bat"</span>],</span><br><span class="line"><span class="symbol">Output</span>:</span><br><span class="line">[</span><br><span class="line">  [<span class="string">"ate"</span>,<span class="string">"eat"</span>,<span class="string">"tea"</span>],</span><br><span class="line">  [<span class="string">"nat"</span>,<span class="string">"tan"</span>],</span><br><span class="line">  [<span class="string">"bat"</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ul>
<li>All inputs will be in lowercase.</li>
<li>The order of your output does not matter.</li>
</ul>
<hr>
<p>解：使用排序解决判断是否为异位词的部分。</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;<span class="keyword">String</span>&gt;&gt; groupAnagrams(<span class="keyword">String</span>[] strs) &#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.length == <span class="number">0</span> || strs == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;List&lt;<span class="keyword">String</span>&gt;&gt;();</span><br><span class="line">        Map&lt;<span class="keyword">String</span>, List&lt;<span class="keyword">String</span>&gt;&gt; <span class="built_in">map</span> = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">String</span> s : strs) &#123;</span><br><span class="line">            <span class="built_in">char</span>[] ca = s.toCharArray();</span><br><span class="line">            Arrays.<span class="built_in">sort</span>(ca);</span><br><span class="line">            <span class="keyword">String</span> keyStr = <span class="keyword">String</span>.valueOf(ca);</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">map</span>.containsKey(keyStr)) <span class="built_in">map</span>.put(keyStr, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            <span class="built_in">map</span>.<span class="built_in">get</span>(keyStr).<span class="built_in">add</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;List&lt;<span class="keyword">String</span>&gt;&gt; (<span class="built_in">map</span>.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="1-Two-Sum-两数之和-Easy"><a href="#1-Two-Sum-两数之和-Easy" class="headerlink" title="1. Two Sum(两数之和)(Easy)"></a><a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">1. Two Sum(两数之和)(Easy)</a></h2><p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have <strong><em>exactly</em></strong> one solution, and you may not use the same element twice.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Given nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span>,</span><br><span class="line"></span><br><span class="line">Because nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span>,</span><br><span class="line"><span class="keyword">return</span> [<span class="number">0</span>, <span class="number">1</span>].</span><br></pre></td></tr></table></figure>

<hr>
<p>解：保持数组中的每个元素与其索引相互对应的最好方式是什么？当然是基于数组的哈希表。利用哈希表先把内容存储起来，这样一来查找的过程只需要O(1)了。</p>
<p>这个map中，key是nums元素的值，value是该元素的下标。因为要找到a+b = target,所以 a = target - b，所以查找 target-a 在不在数组里面即可。</p>
<p>注意</p>
<ol>
<li>这里是把元素当做key，该元素的位置当做value。</li>
<li>虽然看起来 <code>map.put(nums[i], i)</code> 这句放在循环体里的前面和后面都可以，但是其实是不能放在前面的，否则如果某个元素的值是target的二分之一，先把它添加进map之后再比较，会直接比较到它自己。换句话说，必须先比较，再put进map。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                result[<span class="number">0</span>] = i;</span><br><span class="line">                result[<span class="number">1</span>] = map.get(target - nums[i]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 注意这里put不能放在判断前面，必须先比较再放入。否则如果某个元素是target的一半，先添加再比较的话，会比较到它自己。</span></span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithms Note</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Practice by Categories(Stack, Queue)</title>
    <url>/2020/01/08/LeetCode-Practice-by-Categories-Stack-Queue/</url>
    <content><![CDATA[<blockquote>
<p>衡量一个人真正的品德，是看他在知道没有人看见的时候做些什么 —— 孟德斯鸠</p>
</blockquote>
<p>分析讨论栈、队列、优先队列、双端队列以及相关LeetCode题目。</p>
<a id="more"></a>

<p><font color=#FF0000>java中，队列Queue是一种特殊的线性表，实例化的时候用链表(new LinkedList&lt;&gt;())、栈Stack有单独的类，实例化的时候使用Stack(new Stack&lt;&gt;())。 队列因为用LinkedList实现,一般操作size()方法。而栈可以使用empty()或者isEmpty()判空(empty()和isEmpty()没有本质区别，一般可以通用)</p>
<p>事实上，普通的栈和队列在工作中基本不会使用，而用得比较多的是双端队列。比如本文中曾经在239题中使用了java库中的双端队列，并用Array实现：<code>Deque&lt;Integer&gt; dq = new ArrayDeque&lt;&gt;();</code><br></font> </p>
<h2 id="20-Valid-Parentheses-有效的括号-Easy"><a href="#20-Valid-Parentheses-有效的括号-Easy" class="headerlink" title="20.Valid Parentheses(有效的括号)(Easy)"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">20.Valid Parentheses(有效的括号)(Easy)</a></h2><p>Given a string containing just the characters <code>&#39;(&#39;, &#39;)&#39;, &#39;{&#39;, &#39;}&#39;, &#39;[&#39;</code> and<code>&#39;]&#39;</code>, determine if the input string is valid.</p>
<p>An input string is valid if:</p>
<ol>
<li>Open brackets must be closed by the same type of brackets.</li>
<li>Open brackets must be closed in the correct order.</li>
</ol>
<p>Note that an empty string is also considered valid.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">Input:</span> <span class="string">"()"</span></span><br><span class="line"><span class="string">Output:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">Input:</span> <span class="string">"()[]&#123;&#125;"</span></span><br><span class="line"><span class="string">Output:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">Input:</span> <span class="string">"(]"</span></span><br><span class="line"><span class="string">Output:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">Input:</span> <span class="string">"([)]"</span></span><br><span class="line"><span class="string">Output:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 5:</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">Input:</span> <span class="string">"&#123;[]&#125;"</span></span><br><span class="line"><span class="string">Output:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>


<hr>
<p>解：想要符合闭合的括号的标准，用一个栈保存和左括号对应的右括号。每次碰到左括号就入栈对应的右括号，碰到右括号就判断是否和当前栈顶元素相同。</p>
<p>注意有两个判空，一个是碰到右括号，如果此时栈为空，那么不能pop()(会报错)，如果此时栈为空则不为有效括号。另一个情况是所有括号都遍历完了，此时如果栈不为空，则不是有效括号。所以在遍历完s之后需要返回stack.isEmpty()。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">String</span> s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; <span class="built_in">stack</span> = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'('</span>) &#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(<span class="string">')'</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'['</span>) &#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(<span class="string">']'</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'&#123;'</span>) &#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(<span class="string">'&#125;'</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">stack</span>.isEmpty() || <span class="built_in">stack</span>.pop() != c) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="155-Min-Stack-最小栈-Easy"><a href="#155-Min-Stack-最小栈-Easy" class="headerlink" title="155.Min Stack(最小栈)(Easy)"></a><a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">155.Min Stack(最小栈)(Easy)</a></h2><p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p>
<ul>
<li>push(x) – Push element x onto stack.</li>
<li>pop() – Removes the element on top of the stack.</li>
<li>top() – Get the top element.</li>
<li>getMin() – Retrieve the minimum element in the stack.</li>
</ul>
<p><strong>Example:</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">MinStack minStack = new MinStack()<span class="comment">;</span></span><br><span class="line">minStack.push(-<span class="number">2</span>)<span class="comment">;</span></span><br><span class="line">minStack.push(<span class="number">0</span>)<span class="comment">;</span></span><br><span class="line">minStack.push(-<span class="number">3</span>)<span class="comment">;</span></span><br><span class="line">minStack.getMin()<span class="comment">;   --&gt; Returns -3.</span></span><br><span class="line">minStack.pop()<span class="comment">;</span></span><br><span class="line">minStack.top()<span class="comment">;      --&gt; Returns 0.</span></span><br><span class="line">minStack.getMin()<span class="comment">;   --&gt; Returns -2.</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：java语言本身已经定义好了一种传统作用的Stack，这道题有什么意义呢？事实上这道题就是要实现一个可以获得最小元素的栈。</p>
<p>换个角度看，要能够在常数时间内检索到最小元素的栈，是不是有点像优先队列？——其实不一样，它还是一个先入后出的栈。它只是能让你在常规时间中探索到最小元素，而不是取的时候每次都取最小元素。它的api本身和栈一模一样，只是多了一个功能，能够探测到最小元素。</p>
<p>给出两种方法，分别用两个栈和一个栈实现。</p>
<p>解法一：用两个栈实现，一个数据栈，一个辅助栈。这种写法注意了健壮性，考虑了栈为空的情况。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据栈和辅助栈同步,后面每个操作两个栈都进行相同操作</span></span><br><span class="line">    Stack&lt;Integer&gt; data;</span><br><span class="line">    Stack&lt;Integer&gt; helper;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化两个栈</span></span><br><span class="line">        data = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        helper = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        data.push(x);</span><br><span class="line">        <span class="keyword">if</span>(helper.isEmpty() || helper.<span class="built_in">peek</span>() &gt;= x) &#123;</span><br><span class="line">            helper.push(x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            helper.push(helper.<span class="built_in">peek</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!data.isEmpty()) &#123;</span><br><span class="line">            data.pop();</span><br><span class="line">            helper.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!data.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> data.<span class="built_in">peek</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"栈中元素为空，此操作非法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!helper.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> helper.<span class="built_in">peek</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"栈中元素为空，此操作非法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>解法二：用一个栈解决。解法一开辟了一个helper栈去保存最小值，实际上我们可以用一个变量,min,去保存这个最小值。<br>这里有两个问题：</p>
<ol>
<li>min保存了当前的最小值，如果min更新了，那么如何保存之前的最小值呢？——把之前的min在新元素之前入栈，也就是说来了新的更小的元素，旧的最小的元素需要再次入栈以求保存。</li>
<li>如果当前出栈的是最小值，我们在出栈当前元素之余，还需要再出栈一次，并且把这一次出栈的值赋给min。因为最小的元素入栈前会把之前最小的元素入栈，所以这样做就把旧的最小元素保存下来了。</li>
</ol>
<p>详细题解：<a href="https://leetcode-cn.com/problems/min-stack/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-38/" target="_blank" rel="noopener">点击这里</a></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">min</span> = Integer.MAX_VALUE;</span><br><span class="line">    Stack&lt;Integer&gt; <span class="built_in">stack</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span> = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// only push the old minimum value when the current</span></span><br><span class="line">        <span class="comment">// minimum value changes after pushing the new value x</span></span><br><span class="line">        <span class="keyword">if</span>(x &lt;= <span class="built_in">min</span>) &#123;</span><br><span class="line">            <span class="built_in">stack</span>.push(<span class="built_in">min</span>);</span><br><span class="line">            <span class="built_in">min</span> = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">stack</span>.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// if pop operation could result in the changing of the current minimum value,</span></span><br><span class="line">        <span class="comment">// pop twice and change the current minimum value to the last minimum value</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">stack</span>.pop() == <span class="built_in">min</span>) <span class="built_in">min</span> = <span class="built_in">stack</span>.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>.<span class="built_in">peek</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="641-Design-Circular-Deque-设计循环双端队列-Mid"><a href="#641-Design-Circular-Deque-设计循环双端队列-Mid" class="headerlink" title="641.Design Circular Deque(设计循环双端队列)(Mid)"></a><a href="https://leetcode-cn.com/problems/design-circular-deque/" target="_blank" rel="noopener">641.Design Circular Deque(设计循环双端队列)(Mid)</a></h2><p>Design your implementation of the circular double-ended queue (deque).</p>
<p>Your implementation should support following operations:</p>
<ul>
<li><code>MyCircularDeque(k)</code>: Constructor, set the size of the deque to be k.</li>
<li><code>insertFront()</code>: Adds an item at the front of Deque. Return true if the operation is successful.</li>
<li><code>insertLast()</code>: Adds an item at the rear of Deque. Return true if the operation is successful.</li>
<li><code>deleteFront()</code>: Deletes an item from the front of Deque. Return true if the operation is successful.</li>
<li><code>deleteLast()</code>: Deletes an item from the rear of Deque. Return true if the operation is successful.</li>
<li><code>getFront()</code>: Gets the front item from the Deque. If the deque is empty, return -1.</li>
<li><code>getRear()</code>: Gets the last item from Deque. If the deque is empty, return -1.</li>
<li><code>isEmpty()</code>: Checks whether Deque is empty or not. </li>
<li><code>isFull()</code>: Checks whether Deque is full or not.</li>
</ul>
<p><strong>Example:</strong></p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">MyCircularDeque circularDeque = new MycircularDeque(<span class="number">3</span>); <span class="regexp">//</span> set the size to be <span class="number">3</span></span><br><span class="line">circularDeque.insertLast(<span class="number">1</span>);			<span class="regexp">//</span> <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">circularDeque.insertLast(<span class="number">2</span>);			<span class="regexp">//</span> <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">circularDeque.insertFront(<span class="number">3</span>);			<span class="regexp">//</span> <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">circularDeque.insertFront(<span class="number">4</span>);			<span class="regexp">//</span> <span class="keyword">return</span> <span class="keyword">false</span>, the queue is full</span><br><span class="line">circularDeque.getRear();  			<span class="regexp">//</span> <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">circularDeque.isFull();				<span class="regexp">//</span> <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">circularDeque.deleteLast();			<span class="regexp">//</span> <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">circularDeque.insertFront(<span class="number">4</span>);			<span class="regexp">//</span> <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">circularDeque.getFront();			<span class="regexp">//</span> <span class="keyword">return</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ul>
<li>All values will be in the range of [0, 1000].</li>
<li>The number of operations will be in the range of [1, 1000].</li>
<li>Please do not use the built-in Deque library.</li>
</ul>
<hr>
<p>解：使用链表完成这个API的设计。</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> MyCircularDeque &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> DoubleListNode &#123;</span><br><span class="line">        DoubleListNode pre;</span><br><span class="line">        DoubleListNode <span class="keyword">next</span>;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">public</span> DoubleListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">size</span>;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    DoubleListNode head;</span><br><span class="line">    DoubleListNode tail;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Initialize your data structure here. Set the size of the deque to be k. */</span></span><br><span class="line">    <span class="keyword">public</span> MyCircularDeque(<span class="keyword">int</span> k) &#123;</span><br><span class="line">        head = <span class="keyword">new</span> DoubleListNode(-<span class="number">1</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> DoubleListNode(-<span class="number">1</span>);</span><br><span class="line">        head.pre = tail;</span><br><span class="line">        tail.<span class="keyword">next</span> = head;</span><br><span class="line">        <span class="keyword">this</span>.k = k;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">size</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Adds an item at the front of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> insertFront(<span class="keyword">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">size</span> == k) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        DoubleListNode node = <span class="keyword">new</span> DoubleListNode(value);</span><br><span class="line">        node.<span class="keyword">next</span> = head;</span><br><span class="line">        node.pre = head.pre;</span><br><span class="line">        head.pre.<span class="keyword">next</span> = node;</span><br><span class="line">        head.pre = node;</span><br><span class="line">        <span class="keyword">size</span>++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Adds an item at the rear of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> insertLast(<span class="keyword">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">size</span> == k) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        DoubleListNode node = <span class="keyword">new</span> DoubleListNode(value);</span><br><span class="line">        node.<span class="keyword">next</span> = tail.<span class="keyword">next</span>;</span><br><span class="line">        tail.<span class="keyword">next</span>.pre = node;</span><br><span class="line">        tail.<span class="keyword">next</span> = node;</span><br><span class="line">        node.pre = tail;</span><br><span class="line">        <span class="keyword">size</span>++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Deletes an item from the front of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> deleteFront() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">size</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        head.pre.pre.<span class="keyword">next</span> = head;</span><br><span class="line">        head.pre = head.pre.pre;</span><br><span class="line">        <span class="keyword">size</span>--;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Deletes an item from the rear of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> deleteLast() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">size</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        tail.<span class="keyword">next</span>.<span class="keyword">next</span>.pre = tail;</span><br><span class="line">        tail.<span class="keyword">next</span> = tail.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">        <span class="keyword">size</span>--;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front item from the deque. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> getFront() &#123;</span><br><span class="line">        <span class="keyword">return</span> head.pre.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the last item from the deque. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> getRear() &#123;</span><br><span class="line">        <span class="keyword">return</span> tail.<span class="keyword">next</span>.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Checks whether the circular deque is empty or not. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">size</span> == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Checks whether the circular deque is full or not. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isFull() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">size</span> == k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyCircularDeque object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyCircularDeque obj = new MyCircularDeque(k);</span></span><br><span class="line"><span class="comment"> * boolean param_1 = obj.insertFront(value);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.insertLast(value);</span></span><br><span class="line"><span class="comment"> * boolean param_3 = obj.deleteFront();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.deleteLast();</span></span><br><span class="line"><span class="comment"> * int param_5 = obj.getFront();</span></span><br><span class="line"><span class="comment"> * int param_6 = obj.getRear();</span></span><br><span class="line"><span class="comment"> * boolean param_7 = obj.isEmpty();</span></span><br><span class="line"><span class="comment"> * boolean param_8 = obj.isFull();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="225-Implement-Stack-using-Queues-用队列实现栈-Easy"><a href="#225-Implement-Stack-using-Queues-用队列实现栈-Easy" class="headerlink" title="225.Implement Stack using Queues(用队列实现栈)(Easy)"></a><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/" target="_blank" rel="noopener">225.Implement Stack using Queues(用队列实现栈)(Easy)</a></h2><p>Implement the following operations of a stack using queues.</p>
<ul>
<li>push(x) – Push element x onto stack.</li>
<li>pop() – Removes the element on top of the stack.</li>
<li>top() – Get the top element.</li>
<li>empty() – Return whether the stack is empty.</li>
</ul>
<p><strong>Example:</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MyStack <span class="built_in">stack</span> = <span class="keyword">new</span> MyStack();</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>.push(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">stack</span>.push(<span class="number">2</span>);  </span><br><span class="line"><span class="built_in">stack</span>.top();   <span class="comment">// returns 2</span></span><br><span class="line"><span class="built_in">stack</span>.pop();   <span class="comment">// returns 2</span></span><br><span class="line"><span class="built_in">stack</span>.empty(); <span class="comment">// returns false</span></span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ul>
<li>You must use only standard operations of a queue – which means only <code>push to back, peek/pop from front, size</code>, and <code>is empty</code> operations are valid.</li>
<li>Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.</li>
<li>You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).</li>
</ul>
<hr>
<p>解：想要用队列实现栈，常规想法可以使用两个队列，在每次出栈操作的时候，把元素临时保存到第二个队列中，在第一个队列还剩一个元素的时候把这个元素取出，从而实现类似栈的”后入先出”操作。</p>
<p>但是存在空间复杂度更优的方法，就是使用一个队列。具体操作方法是，每次入队都把整个队列循环弹出和新增元素，使得新添加的元素总在队列的前面，由此一来这个队列实际操作与栈无异。**关键步骤就是在于入队列时候的操作：<code>queue.add(queue.remove())</code>(remove()在队列为空的时候会抛出NoSuchElementException异常，poll()会返回null，其他没有区别)</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    Queue&lt;Integer&gt; <span class="built_in">queue</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="built_in">queue</span> = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>.add(x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">queue</span>.<span class="built_in">size</span>()<span class="number">-1</span>; i++)</span><br><span class="line">            <span class="built_in">queue</span>.add(<span class="built_in">queue</span>.<span class="built_in">remove</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">queue</span>.<span class="built_in">remove</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">queue</span>.<span class="built_in">peek</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">queue</span>.<span class="built_in">size</span>() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>


<h2 id="232-Implement-Queue-using-Stacks-用栈实现队列-Easy"><a href="#232-Implement-Queue-using-Stacks-用栈实现队列-Easy" class="headerlink" title="232.Implement Queue using Stacks(用栈实现队列)(Easy)"></a><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/" target="_blank" rel="noopener">232.Implement Queue using Stacks(用栈实现队列)(Easy)</a></h2><p>Implement the following operations of a queue using stacks.</p>
<ul>
<li>push(x) – Push element x to the back of queue.</li>
<li>pop() – Removes the element from in front of queue.</li>
<li>peek() – Get the front element.</li>
<li>empty() – Return whether the queue is empty.</li>
</ul>
<p><strong>Example:</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">MyQueue <span class="built_in">queue</span> = <span class="keyword">new</span> MyQueue();</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>.push(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">queue</span>.push(<span class="number">2</span>);  </span><br><span class="line"><span class="built_in">queue</span>.<span class="built_in">peek</span>();  <span class="comment">// returns 1</span></span><br><span class="line"><span class="built_in">queue</span>.pop();   <span class="comment">// returns 1</span></span><br><span class="line"><span class="built_in">queue</span>.empty(); <span class="comment">// returns false</span></span><br></pre></td></tr></table></figure>
<p><strong>Notes:</strong></p>
<ul>
<li>You must use only standard operations of a stack – which means only <code>push to top, peek/pop from top, size, and is empty</code> operations are valid.</li>
<li>Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.</li>
<li>You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).</li>
</ul>
<hr>
<p>解：和之前用队列实现栈类似，可以用两个栈实现一个队列。但是由于栈只有一个出入口，所以不能用一个栈实现队列(队列中出队再入队可以实现倒置，栈不行).</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要两个栈才能实现队列</span></span><br><span class="line">    Stack&lt;Integer&gt; input;</span><br><span class="line">    Stack&lt;Integer&gt; output;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        input = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        output = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        input.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">peek</span>();</span><br><span class="line">        <span class="keyword">return</span> output.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(output.empty())</span><br><span class="line">            <span class="keyword">while</span>( !input.empty() )</span><br><span class="line">                output.push(input.pop());</span><br><span class="line">        <span class="keyword">return</span> output.<span class="built_in">peek</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input.empty() &amp;&amp; output.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.peek();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>


<h2 id="239-Sliding-Window-Maximum-滑动窗口最大值-Hard"><a href="#239-Sliding-Window-Maximum-滑动窗口最大值-Hard" class="headerlink" title="239.Sliding Window Maximum(滑动窗口最大值)(Hard)"></a><a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">239.Sliding Window Maximum(滑动窗口最大值)(Hard)</a></h2><p>Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: nums = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">-1</span>,<span class="number">-3</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>], <span class="keyword">and</span> k = <span class="number">3</span></span><br><span class="line">Output: [<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>] </span><br><span class="line">Explanation: </span><br><span class="line"></span><br><span class="line">Window position                Max</span><br><span class="line">---------------               -----</span><br><span class="line">[<span class="number">1</span>  <span class="number">3</span>  <span class="number">-1</span>] <span class="number">-3</span>  <span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">3</span></span><br><span class="line"> <span class="number">1</span> [<span class="number">3</span>  <span class="number">-1</span>  <span class="number">-3</span>] <span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">3</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span> [<span class="number">-1</span>  <span class="number">-3</span>  <span class="number">5</span>] <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">5</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  <span class="number">-1</span> [<span class="number">-3</span>  <span class="number">5</span>  <span class="number">3</span>] <span class="number">6</span>  <span class="number">7</span>       <span class="number">5</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  <span class="number">-1</span>  <span class="number">-3</span> [<span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>] <span class="number">7</span>       <span class="number">6</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  <span class="number">-1</span>  <span class="number">-3</span>  <span class="number">5</span> [<span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>]      <span class="number">7</span></span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong><br>You may assume k is always valid, 1 ≤ k ≤ input array’s size for non-empty array.</p>
<p><strong>Follow up:</strong><br>Could you solve it in linear time?</p>
<hr>
<p>解：<strong>所有滑动窗口的题目，想到用队列解决。</strong></p>
<p>方法一：暴力求解。枚举窗口的起点位置，因为窗口长度是k,所以枚举起点是0，终点是 length-1 。写一个二重循环，最后时间复杂度是O(n*k)。</p>
<p>方法二：这里用到单调队列(实际就是所谓的双端队列)，可以达到线性的时间复杂度。</p>
<p><font color=#FF0000>双端队列可以操作队列里面的头元素和尾元素，一些API见下图：</font><br><img src="https://s2.ax1x.com/2020/01/11/lIIZSs.png" alt="JDK8 Deque API"></p>
<p>我们通过双端队列维护的一个”单调队列”，从左到右为递减。所以每次对比元素都是peekLast()，弹出元素也是pollLast()</p>
<p>我们用双向队列可以在O(N)时间内解决这题。当我们遇到新的数时，将新的数和双向队列的末尾比较，如果末尾比新数小，则把末尾扔掉，直到该队列的末尾比新数大或者队列为空的时候才住手。这样，我们可以保证队列里的元素是从头到尾降序的，由于队列里只有窗口内的数，所以他们其实就是窗口内第一大，第二大，第三大…的数。保持队列里只有窗口内数的方法和上个解法一样，也是每来一个新的把窗口最左边的扔掉，然后把新的加进去。然而由于我们在加新数的时候，已经把很多没用的数给扔了，这样队列头部的数并不一定是窗口最左边的数。这里的技巧是，我们队列中存的是那个数在原数组中的下标，这样我们既可以直到这个数的值，也可以知道该数是不是窗口最左边的数。这里为什么时间复杂度是O(N)呢？因为每个数只可能被操作最多两次，一次是加入队列的时候，一次是因为有别的更大数在后面，所以被扔掉，或者因为出了窗口而被扔掉。(引用<a href="https://segmentfault.com/a/1190000003903509" target="_blank" rel="noopener">这篇文章</a>)</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>[] maxSlidingWindow(<span class="built_in">int</span>[] nums, <span class="built_in">int</span> k) &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(nums.length == <span class="number">0</span> || k &lt;= <span class="number">0</span>) <span class="keyword">return</span> nums;</span><br><span class="line">		<span class="built_in">int</span> len = nums.length;</span><br><span class="line">		<span class="comment">// 可以自己举个例子，推得这个result大小应该为len-k+1</span></span><br><span class="line">		<span class="built_in">int</span>[] result = new <span class="built_in">int</span>[len - k + <span class="number">1</span>];</span><br><span class="line">		<span class="comment">// store index</span></span><br><span class="line">		<span class="comment">// 注意，dq用于保存数组下标</span></span><br><span class="line">		Deque&lt;Integer&gt; dq = new ArrayDeque&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">			<span class="comment">//这里不需要循环，用一个判断就可 </span></span><br><span class="line">			<span class="comment">//因为我们最多只能在一轮中弹出一个超出范围的元素。（一轮我们只接受一个元素，所以我们最多弹出一个元素）。</span></span><br><span class="line">			<span class="comment">// dq 用于保存数组下标，这也是一个技巧</span></span><br><span class="line">			<span class="keyword">if</span>( !dq.isEmpty() &amp;&amp; dq.peekFirst() == i-k) &#123;</span><br><span class="line">				<span class="comment">// 双端队列中 poll() 相当于 pollFirst(),皮一下</span></span><br><span class="line">				dq.poll();</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 新加入的元素必须比前面的小，否则前面比它小的元素都要出队</span></span><br><span class="line">			<span class="keyword">while</span>(!dq.isEmpty() &amp;&amp; nums[i] &gt;= nums[dq.peekLast()]) &#123;</span><br><span class="line">				dq.pollLast();</span><br><span class="line">			&#125;</span><br><span class="line">			dq.offer(i);</span><br><span class="line">			<span class="comment">// dq是有序的，队列头总是最大的元素，只要下标在范围内，直接peek()即可</span></span><br><span class="line">			<span class="keyword">if</span>(i-k+<span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">				result[i-k+<span class="number">1</span>] = nums[dq.peek()];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<h2 id="621-Task-Scheduler-任务调度-Mid"><a href="#621-Task-Scheduler-任务调度-Mid" class="headerlink" title="621.Task Scheduler(任务调度)(Mid)"></a><a href="https://leetcode-cn.com/problems/task-scheduler/" target="_blank" rel="noopener">621.Task Scheduler(任务调度)(Mid)</a></h2><p>Given a char array representing tasks CPU need to do. It contains capital letters A to Z where different letters represent different tasks. Tasks could be done without original order. Each task could be done in one interval. For each interval, CPU could finish one task or just be idle.</p>
<p>However, there is a non-negative cooling interval <strong>n</strong> that means between two <strong>same tasks</strong>, there must be at least n intervals that CPU are doing different tasks or just be idle.</p>
<p>You need to return the <strong>least</strong> number of intervals the CPU will take to finish all the given tasks.</p>
<p><strong>Example:</strong></p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">Input: tasks = [<span class="string">"A"</span>,<span class="string">"A"</span>,<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"B"</span>,<span class="string">"B"</span>], n = <span class="number">2</span></span><br><span class="line">Output: <span class="number">8</span></span><br><span class="line">Explanation: A -&gt; B -&gt; idle -&gt; A -&gt; B -&gt; idle -&gt; A -&gt; B.</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ol>
<li>The number of tasks is in the range [1, 10000].</li>
<li>The integer n is in the range [0, 100].</li>
</ol>
<hr>
<p>解：</p>
<ol>
<li>因为所有任务都是大写字母，所以可以申请大小为26的数组来保存任务类型个数。</li>
<li>对数组进行排序，按照出现的次数进行排序，优先记录出现次数多的任务。根据题意，时间至少为：retCount = (count - 1) * (n + 1) + 1 =&gt;A-&gt;X-&gt;X-&gt;A-&gt;X-&gt;X-&gt;A(X为其他任务或者待命)</li>
<li>再排序下一个任务，如果下一个任务B个数和最大任务数一致，则retCount++ ==&gt; A-&gt;B-&gt;X-&gt;A-&gt;B-&gt;X-&gt;A-&gt;B</li>
<li>如果空位都插满之后还有任务，那就随便在这些间隔里面插入就可以，因为间隔长度肯定会大于n，在这种情况下就是任务的总数是最小所需时间</li>
</ol>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> leastInterval(char[] tasks, <span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="comment">// corner case</span></span><br><span class="line">        <span class="keyword">if</span>(tasks.length &lt;= <span class="number">1</span> || n &lt; <span class="number">1</span>) <span class="keyword">return</span> tasks.length;</span><br><span class="line">        <span class="comment">// 步骤1</span></span><br><span class="line">        <span class="built_in">int</span>[] counts = new <span class="built_in">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; tasks.length; i++) &#123;</span><br><span class="line">            counts[tasks[i] - <span class="string">'A'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//步骤2</span></span><br><span class="line">        Arrays.sort(counts);</span><br><span class="line">        <span class="built_in">int</span> maxCount = counts[<span class="number">25</span>];</span><br><span class="line">        <span class="built_in">int</span> retCount = (maxCount - <span class="number">1</span>) * (n + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">24</span>;</span><br><span class="line">        <span class="comment">// 步骤3</span></span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; counts[i] == maxCount) &#123;</span><br><span class="line">            retCount++;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//步骤4</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(retCount, tasks.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他参考题解：<a href="https://leetcode-cn.com/problems/task-scheduler/solution/python-xiang-jie-by-jalan/" target="_blank" rel="noopener">参考这篇文章</a></p>
<h2 id="84-Largest-Rectangle-in-Histogram-柱状图中最大的矩形-Hard"><a href="#84-Largest-Rectangle-in-Histogram-柱状图中最大的矩形-Hard" class="headerlink" title="84.Largest Rectangle in Histogram(柱状图中最大的矩形)(Hard)"></a><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">84.Largest Rectangle in Histogram(柱状图中最大的矩形)(Hard)</a></h2><p>Given <em>n</em> non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram.png" alt="eg"></p>
<p>Above is a histogram where width of each bar is 1, given height = <code>[2,1,5,6,2,3]</code>.</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram_area.png" alt="eg"></p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">Output: <span class="number">10</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：方法一：暴力法，枚举所有可能的柱子对。每次遍历的时候都基于当前的第i个柱子，向右用j扫描一遍。这样可以确保每一个都扫描扫过。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> largestRectangleArea(<span class="built_in">int</span>[] heights) &#123;</span><br><span class="line">        <span class="comment">// 方法一，暴力O(n^2)</span></span><br><span class="line">        <span class="built_in">int</span> maxArea = <span class="number">0</span>, len = heights.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 每次重新循环，minHeight都要更新</span></span><br><span class="line">            <span class="built_in">int</span> minHeight = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = i; j &lt; len; j++) &#123;</span><br><span class="line">                minHeight = Math.min(minHeight, heights[j]);</span><br><span class="line">                maxArea = Math.max(maxArea, minHeight * (j - i + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(n)</li>
</ul>
<p>方法二，时间复杂度为O(n)的方法，利用Stack进行,具体来说，是一个<strong>单调栈</strong>。</p>
<p>它是怎么做的呢？</p>
<p>遍历的过程中，因为是从左开始遍历的，所以其实如果用一个有序的栈，其实是可以用O(1)得到某根柱子的左边界的。注意这里说的是左边界，右边界仍然需要遍历，因为右边还没遍历，没法一下子知道右边界。但是这是合理的，因为如果你不继续往右边界遍历，你永远也不知道右边界在哪里。</p>
<p>这个办法是维护一个栈，这个栈的元素是从<strong>小到大（对于栈，从小到大是从栈底到栈顶是从小到大排列的）</strong>进行排列的。因为这样排列，可以有效知道它的左边界在什么地方。</p>
<p><strong>不得不说，这个算法需要后面不断反复地看</strong>，才能熟悉他它因为它的逻辑其实是比较复杂和精妙的。</p>
<p>栈的初始值为-1，也是巧妙的一点。</p>
<p>为了保证栈是从小到大的，每次入栈都进行一次判断， 必须比当前栈顶元素大，才能进栈，否则要把那个栈元素出栈。</p>
<p>进栈的时候要保留它的下标，因为后面计算的时候好计算它的宽度。</p>
<p><font color=#FF0000>栈里面任何一个元素的左边界，都是它在栈里面的下一个元素。也就是说，如果一个元素要出栈了，它的左边界就是它在栈里的下一个元素，它的右边界就是比它小的那个元素，换句话说，哪个元素触发了另一个元素要被弹出栈，触发它的那个元素，就是被弹出元素的右边界。由此一来，当前被弹出元素的左边界和右边界都有了，通过公式计算得到的就是被以被弹出元素为中心能围成的最大矩形面积。</font></p>
<p>比如一个元素3，让9,5,4三个元素都出栈了，那么3就是9,5,4这三个元素的右边界</p>
<p>如果一个元素想要加入栈，但是它比栈顶元素要大，那么它不能是前一个元素的右边界，所以要把它保存到栈里面，直到下一个入栈的元素比栈里面它的上一个元素要小，那么开始出栈操作，因为找到了边界了。</p>
<p>扫描到哪里，谁更小，谁就是整个栈操作的颠覆者。</p>
<ul>
<li>实质是求每个柱子可以向左右两边延伸的距离<ul>
<li>向左：由于栈是单调递增的，因此以当前柱子为中心向左延展时，不能超过当前栈的上一个元素(最近的比它小的元素)</li>
<li>向右：由于遇到非单调递增的元素时才开始弹出，所以当前位置的高度小于每个弹出的元素。因此，向右延展时，不能超过当前位置</li>
</ul>
</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// corner case</span></span><br><span class="line">        <span class="keyword">if</span>(heights == null || heights.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 方法二，栈,O(n)</span></span><br><span class="line">        <span class="comment">// 主要目标是求能够覆盖当前第i个柱子的最大矩形，即为第i个矩形的"专属面积"</span></span><br><span class="line">        Stack&lt;Integer&gt; <span class="built_in">stack</span> = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 栈里面存放heights数组的下标，取元素的时候为：heights[stack.pop()]</span></span><br><span class="line">        <span class="built_in">stack</span>.push(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>, len = heights.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 只有遍历的heights[i]比当前stack里面的栈顶元素大，才能跳过while循环，直接入栈</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">stack</span>.<span class="built_in">peek</span>() != <span class="number">-1</span> &amp;&amp; heights[<span class="built_in">stack</span>.<span class="built_in">peek</span>()] &gt;= heights[i])</span><br><span class="line">                <span class="comment">// 若当前遍历的heights[i]比栈顶元素小，则栈顶元素出栈，计算此时面积</span></span><br><span class="line">                <span class="comment">// 先pop()后peek()，很巧妙的写法设置</span></span><br><span class="line">                <span class="comment">// 这里多减一个1主要因为之前已经pop()了，这里要减回来</span></span><br><span class="line">                maxArea = Math.<span class="built_in">max</span>(maxArea, heights[<span class="built_in">stack</span>.pop() ] * (i - <span class="built_in">stack</span>.<span class="built_in">peek</span>() - <span class="number">1</span>));</span><br><span class="line">            <span class="built_in">stack</span>.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果遍历完了一遍最后栈不为空，则再用一重循环吧栈搞空</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">stack</span>.<span class="built_in">peek</span>() != <span class="number">-1</span>)</span><br><span class="line">            maxArea = Math.<span class="built_in">max</span>(maxArea, heights[<span class="built_in">stack</span>.pop()] * (len - <span class="built_in">stack</span>.<span class="built_in">peek</span>() - <span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，n个数字每个会被压栈弹栈各一次。</li>
<li>空间复杂度：O(n)，存放栈中元素。</li>
</ul>
<h2 id="85-Maximal-Rectangle-最大矩形-Hard"><a href="#85-Maximal-Rectangle-最大矩形-Hard" class="headerlink" title="85.Maximal Rectangle(最大矩形)(Hard)"></a><a href="https://leetcode-cn.com/problems/maximal-rectangle/" target="_blank" rel="noopener">85.Maximal Rectangle(最大矩形)(Hard)</a></h2><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing only 1’s and return its area.</p>
<p><strong>Example:</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Input</span>:</span><br><span class="line">[</span><br><span class="line">  [<span class="string">"1"</span>,<span class="string">"0"</span>,<span class="string">"1"</span>,<span class="string">"0"</span>,<span class="string">"0"</span>],</span><br><span class="line">  [<span class="string">"1"</span>,<span class="string">"0"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>],</span><br><span class="line">  [<span class="string">"1"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>],</span><br><span class="line">  [<span class="string">"1"</span>,<span class="string">"0"</span>,<span class="string">"0"</span>,<span class="string">"1"</span>,<span class="string">"0"</span>]</span><br><span class="line">]</span><br><span class="line"><span class="symbol">Output</span>: <span class="number">6</span></span><br></pre></td></tr></table></figure>
<hr>
<p>解：此题可以基于84题实现的找到矩形围成的最大面积来考虑，利用84题已经实现的函数，在遍历input的数组的时候将每一行值都记录，并且在有连续的1的时候进行累加(碰到0的话对应下标值要清空)</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == null || matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length, rows = matrix.length;</span><br><span class="line">        <span class="keyword">int</span>[] heights = <span class="keyword">new</span> <span class="keyword">int</span>[cols];</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 每次遍历之后都获取当前row的直方图，保存到heights中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    heights[j]++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    heights[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将当前直方图面积和之前最大面积进行比较，取一个最大值</span></span><br><span class="line">            maxArea = Math.<span class="built_in">max</span>(maxArea, largestRectangleArea(heights));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// corner case</span></span><br><span class="line">        <span class="keyword">if</span>(heights == null || heights.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 方法二，栈,O(n)</span></span><br><span class="line">        <span class="comment">// 主要目标是求能够覆盖当前第i个柱子的最大矩形，即为第i个矩形的"专属面积"</span></span><br><span class="line">        Stack&lt;Integer&gt; <span class="built_in">stack</span> = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 栈里面存放heights数组的下标，取元素的时候为：heights[stack.pop()]</span></span><br><span class="line">        <span class="built_in">stack</span>.push(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>, len = heights.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 只有遍历的heights[i]比当前stack里面的栈顶元素大，才能跳过while循环，直接入栈</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">stack</span>.<span class="built_in">peek</span>() != <span class="number">-1</span> &amp;&amp; heights[<span class="built_in">stack</span>.<span class="built_in">peek</span>()] &gt;= heights[i])</span><br><span class="line">                <span class="comment">// 若当前遍历的heights[i]比栈顶元素小，则栈顶元素出栈，计算此时面积</span></span><br><span class="line">                <span class="comment">// 先pop()后peek()，很巧妙的写法设置</span></span><br><span class="line">                <span class="comment">// 这里多减一个1主要因为之前已经pop()了，这里要减回来</span></span><br><span class="line">                maxArea = Math.<span class="built_in">max</span>(maxArea, heights[<span class="built_in">stack</span>.pop() ] * (i - <span class="built_in">stack</span>.<span class="built_in">peek</span>() - <span class="number">1</span>));</span><br><span class="line">            <span class="built_in">stack</span>.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果遍历完了一遍最后栈不为空，则再用一重循环吧栈搞空</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">stack</span>.<span class="built_in">peek</span>() != <span class="number">-1</span>)</span><br><span class="line">            maxArea = Math.<span class="built_in">max</span>(maxArea, heights[<span class="built_in">stack</span>.pop()] * (len - <span class="built_in">stack</span>.<span class="built_in">peek</span>() - <span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(mn)。84题实现的函数的时间复杂度为O(n)，然后主函数有两个循环，但是因为内层循环和84题的函数是并列的，所以整个时间复杂度还是O(mn)</li>
</ul>
<h2 id="42-Trapping-Rain-Water-接雨水-Hard"><a href="#42-Trapping-Rain-Water-接雨水-Hard" class="headerlink" title="42.Trapping Rain Water(接雨水)(Hard)"></a><a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">42.Trapping Rain Water(接雨水)(Hard)</a></h2><p>Given <em>n</em> non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt="42接雨水"></p>
<p>The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">Output: <span class="number">6</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：本篇题解内容取材于<a href="https://leetcode-cn.com/problems/trapping-rain-water/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-8/" target="_blank" rel="noopener">这篇文章</a></p>
<p>方法一：按列求。</p>
<p>整个题目需要遍历heights的每一个元素，即每一列的值。而对于每一列，我们只需要关注当前列、当前列左边墙最高值、当前列右边墙最高值，关注这三个值。而且由于木桶效应，我们只需要看左边和右边最高值中的较小的那个即可，这样把当前左边与右边的最小值和当前列作比较，就能得出当前列能够最多盛多少水了。</p>
<p>按照题意，会有三种情况：</p>
<ol>
<li>左边与右边两个中较矮的墙的高度大于当前列的墙的高度</li>
</ol>
<p>此时用较矮的值减去当前高度，即为当前列能盛放的高度。</p>
<ol start="2">
<li>左边与右边两个中较矮的墙的高度小于当前列的墙的高度</li>
</ol>
<p>此时当前列不能盛水。</p>
<ol start="3">
<li>左边与右边两个中较矮的墙的高度等于当前列的墙的高度</li>
</ol>
<p>此时当前列也不能盛水。</p>
<p>所以，根据这三种情况写程序。外层循环遍历每一列，然后针对当前列求出这一列两边的最高的墙，并找出较矮的一端，和当前列高度比较，用上述这三种情况作为参考的结果即可。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 方法一，按列求</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, len = <span class="built_in">height</span>.length;</span><br><span class="line">        <span class="comment">//最两端的列不用考虑，因为一定不会有水。所以下标从 1 到 length - 2</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len<span class="number">-1</span> ;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> maxLeft = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 找出左边最高</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">height</span>[j] &gt; maxLeft) &#123;</span><br><span class="line">                    maxLeft = <span class="built_in">height</span>[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> maxRight = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 找出右边最高</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">height</span>[j] &gt; maxRight) &#123;</span><br><span class="line">                    maxRight = <span class="built_in">height</span>[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找出左右两端更小的</span></span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">min</span> = Math.<span class="built_in">min</span>(maxLeft, maxRight);</span><br><span class="line">            <span class="comment">// 根据之前分析，此时只有min大于height[i]，才能盛水</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">min</span> &gt; <span class="built_in">height</span>[i])</span><br><span class="line">                sum += <span class="built_in">min</span>-<span class="built_in">height</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n^2)，遍历每一列一遍需要O(n)，然后每次找出左边和右边最高的墙，加起来又需要一个O(n)，合在一起是O(n^2)</li>
<li>空间复杂度：O(1)</li>
</ul>
<p>方法二：动态规划</p>
<p>基于方法一的优化，在方法一中，我们要求当前每一列的左边界和右边界，都必须重新遍历一遍所有高度，其实可以优化的。</p>
<p>这里用<code>maxLeft[]</code>和<code>maxRight[]</code>两个数组，<code>maxLeft[i]</code>代表<strong>第i列左边最高的墙的高度</strong>，<code>maxRight[i]</code>代表<strong>第i列右边最高的墙的高度</strong>。<font color=#FF0000>注意，这里两个数组中定义的第i列的左边和右边，不包括i本身</font></p>
<p>递推公式：<code>maxLeft[i]=Max(maxLeft[i-1], height[i-1])</code>。它左边的墙的左边的最高高度和它左边墙的高度选一个作为最大的即可。这里相当于用到了”备忘录”，让之前的每一次遍历都有意义，都被记忆了。</p>
<p>类似的：<code>maxRight[i] = Max(maxRight[i+1], height[i+1])</code>。它右边墙的最高高度和它右边墙本身的高度进行比较，取最高的。</p>
<p>由此一来，就不需要像方法一那样，在内部又加了一层for循环，不用每次都去求一次i的左边和右边的最大值了，已经用两个数组分别记录好了。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// corner case</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">height</span> == null || <span class="built_in">height</span>.length &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">height</span>.length, sum = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] maxLeft = <span class="keyword">new</span> <span class="keyword">int</span>[len], maxRight = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 道理还是和之前一样，下标为0和len-1的两个地方一定没办法盛水，可以直接跳过</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len<span class="number">-1</span>; i++) &#123;</span><br><span class="line">            maxLeft[i] = Math.<span class="built_in">max</span>(maxLeft[i<span class="number">-1</span>], <span class="built_in">height</span>[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            maxRight[i] = Math.<span class="built_in">max</span>(maxRight[i+<span class="number">1</span>], <span class="built_in">height</span>[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把结果全部放入到maxLeft和maxRight之后，用下标统一遍历，用到了</span></span><br><span class="line">        <span class="comment">// maxLeft, maxRight, height三个数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">min</span> = Math.<span class="built_in">min</span>(maxLeft[i], maxRight[i]);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">min</span> &gt; <span class="built_in">height</span>[i]) &#123;</span><br><span class="line">                sum += <span class="built_in">min</span> - <span class="built_in">height</span>[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)，保存每一列左边最高边界和右边最高边界</li>
</ul>
<p>方法三：动态规划在空间复杂度上的优化，<strong>双指针</strong>，时间复杂度为O(n)，时间复杂度为O(1)</p>
<p>动态规划中maxLeft[]和maxRight[]这两个数组中每个元素我们每次只用一次，之后不会再用，所以我们不需要用数组，用一个元素就够了。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// corner case</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">height</span> == null || <span class="built_in">height</span>.length &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 方法三，双指针</span></span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>,leftmax = <span class="number">0</span>,rightmax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="built_in">height</span>.length<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            leftmax = Math.<span class="built_in">max</span>(leftmax, <span class="built_in">height</span>[i]);</span><br><span class="line">            rightmax = Math.<span class="built_in">max</span>(rightmax, <span class="built_in">height</span>[j]);</span><br><span class="line">            <span class="keyword">if</span>(leftmax &lt; rightmax) &#123;</span><br><span class="line">                maxArea += leftmax - <span class="built_in">height</span>[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                maxArea += rightmax - <span class="built_in">height</span>[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法四：栈</p>
<p>这里用的，实际上在空间复杂度上不如方法三，但是用到栈的思路还是很巧妙的。</p>
<p>首先，这道题和括号匹配问题非常相似。我们可以每找到对应的两堵墙，就计算存储的水量，用栈保存每堵墙。</p>
<p>当遍历墙的高度的时候，如果当前高度小于栈顶的墙高度，说明这里会有积水，我们将墙的高度的下标入栈。</p>
<p>如果当前高度大于栈顶的墙的高度，说明之前的积水到这里停下，我们可以计算下有多少积水了。计算完，就把当前的墙继续入栈，作为新的积水的墙。</p>
<p>总体原则：</p>
<ol>
<li>当前高度小于等于栈顶高度，将墙的下标值入栈，后移指针。</li>
<li>当前高度大于栈顶高度，出栈，计算当前墙和当前栈顶值的差值，为可存储的水量。然后用当前墙高度再和栈的新栈顶比较，重复两个判断，一直到当前墙的高度不大于栈顶高度或者栈为空，再把当前墙入栈，指针后移。</li>
</ol>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap6</span><span class="params">(<span class="keyword">int</span>[] <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    Stack&lt;Integer&gt; <span class="built_in">stack</span> = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (current &lt; <span class="built_in">height</span>.length) &#123;</span><br><span class="line">        <span class="comment">//如果栈不空并且当前指向的高度大于栈顶高度就一直循环</span></span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">stack</span>.empty() &amp;&amp; <span class="built_in">height</span>[current] &gt; <span class="built_in">height</span>[<span class="built_in">stack</span>.<span class="built_in">peek</span>()]) &#123;</span><br><span class="line">            <span class="keyword">int</span> h = <span class="built_in">height</span>[<span class="built_in">stack</span>.<span class="built_in">peek</span>()]; <span class="comment">//取出要出栈的元素</span></span><br><span class="line">            <span class="built_in">stack</span>.pop(); <span class="comment">//出栈</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">stack</span>.empty()) &#123; <span class="comment">// 栈空就出去</span></span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> distance = current - <span class="built_in">stack</span>.<span class="built_in">peek</span>() - <span class="number">1</span>; <span class="comment">//两堵墙之前的距离。</span></span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">min</span> = Math.<span class="built_in">min</span>(<span class="built_in">height</span>[<span class="built_in">stack</span>.<span class="built_in">peek</span>()], <span class="built_in">height</span>[current]);</span><br><span class="line">            sum = sum + distance * (<span class="built_in">min</span> - h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">stack</span>.push(current); <span class="comment">//当前指向的墙入栈</span></span><br><span class="line">        current++; <span class="comment">//指针后移</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="394-Decode-String-字符串解码-Mid"><a href="#394-Decode-String-字符串解码-Mid" class="headerlink" title="394.Decode String(字符串解码)(Mid)"></a><a href="https://leetcode-cn.com/problems/decode-string/" target="_blank" rel="noopener">394.Decode String(字符串解码)(Mid)</a></h2><p>Given an encoded string, return its decoded string.</p>
<p>The encoding rule is: <code>k[encoded_string]</code>, where the <em>encoded_string</em> inside the square brackets is being repeated exactly <em>k</em> times. Note that <em>k</em> is guaranteed to be a positive integer.</p>
<p>You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.</p>
<p>Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won’t be input like <code>3a</code> or <code>2[4]</code>.</p>
<p><strong>Examples:</strong></p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">s</span> = <span class="string">"3[a]2[bc]"</span>, return <span class="string">"aaabcbc"</span>.</span><br><span class="line"><span class="attribute">s</span> = <span class="string">"3[a2[c]]"</span>, return <span class="string">"accaccacc"</span>.</span><br><span class="line"><span class="attribute">s</span> = <span class="string">"2[abc]3[cd]ef"</span>, return <span class="string">"abcabccdcdcdef"</span>.</span><br></pre></td></tr></table></figure>

<hr>
<p>解：举个例子，<code>s=&quot;3[a2[c]]&quot;</code></p>
<p>这道题最后我们用StringBuilder记录目前为止字符的长度，然后需要用到两个栈进行辅助，分别是Integer和String泛型的栈，一个(numStack)用于保存当前字符重复的遍数,另一个(strStack)用于保存当前要重复的字符,需要它的原因是，哪怕你知道了某一个字符要重复的遍数，你还需要知道它前面还有什么字符，可能它前面的需要和它一起重复。</p>
<p>拿例子来说，走到了<code>2[c]</code>的时候，tail这个StringBuilder就是”c”，numStack就是2</p>
<p>具体入栈规则：</p>
<p>String泛型栈：每当遇到左括号的时候，要把之前记录的String(在StringBuilder里面保存着)都push到strStack，当然这个StringBuilder本身不会变化</p>
<p>Integer泛型栈：碰到数字就入这个栈，用来记录某一段字符串要重复的次数。</p>
<p>直到遍历到右括号，开始出栈。首先从numStack中pop()出一个数字，</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public String decode<span class="constructor">String(String <span class="params">s</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 存储当前字符需要重复的遍数</span></span><br><span class="line">        Stack&lt;Integer&gt; numStack = <span class="keyword">new</span> Stack&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">        <span class="comment">// 记录前面没有数字的，"落单"的字母</span></span><br><span class="line">        Stack&lt;String&gt; strStack = <span class="keyword">new</span> Stack&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">        <span class="comment">// 记录迄今为止的解码结果</span></span><br><span class="line">        StringBuilder tail = <span class="keyword">new</span> <span class="constructor">StringBuilder()</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> n = s.length<span class="literal">()</span>;</span><br><span class="line">        </span><br><span class="line">        for(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">char</span> c = s.<span class="built_in">char</span><span class="constructor">At(<span class="params">i</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="module-access"><span class="module"><span class="identifier">Character</span>.</span></span>is<span class="constructor">Digit(<span class="params">c</span>)</span>) &#123; <span class="comment">// 第一种情况，当前遍历的为数字</span></span><br><span class="line">                <span class="built_in">int</span> num = c - <span class="character">'0'</span>;</span><br><span class="line">                <span class="comment">// 因为前面的数字可能有十位、百位等，所以要循环判断</span></span><br><span class="line">                <span class="keyword">while</span>(<span class="module-access"><span class="module"><span class="identifier">Character</span>.</span></span>is<span class="constructor">Digit(<span class="params">s</span>.<span class="params">charAt</span>(<span class="params">i</span> + 1)</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 每往后一位，num相当于要乘10再加上新数字</span></span><br><span class="line">                    num = num<span class="operator"> * </span><span class="number">10</span> + s.<span class="built_in">char</span><span class="constructor">At(<span class="params">i</span> + 1)</span> - <span class="character">'0'</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                numStack.push(num);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(c<span class="operator"> == </span><span class="character">'['</span>) &#123; <span class="comment">// 每当遇到左括号，就开始存encoded_string</span></span><br><span class="line">                <span class="comment">// 具体做法就是把当前tail的所有内容都push进strStack，然后重新定义一个StringBuilder记录</span></span><br><span class="line">                <span class="comment">// 被加密的内层的字符串</span></span><br><span class="line">                strStack.push(tail.<span class="keyword">to</span><span class="constructor">String()</span>);</span><br><span class="line">                <span class="comment">// 清空tail</span></span><br><span class="line">                tail = <span class="keyword">new</span> <span class="constructor">StringBuilder()</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(c<span class="operator"> == </span><span class="character">']'</span>) &#123;</span><br><span class="line">                <span class="comment">// 碰到右括号，首先把落单的，在被加密的字符的前面的字符pop出来</span></span><br><span class="line">                StringBuilder temp = <span class="keyword">new</span> <span class="constructor">StringBuilder(<span class="params">strStack</span>.<span class="params">pop</span>()</span>);</span><br><span class="line">                <span class="comment">// 记录当前被加密的内容的重复的次数，从numStack里面pop()即可</span></span><br><span class="line">                <span class="built_in">int</span> repeatedTimes = numStack.pop<span class="literal">()</span>;</span><br><span class="line">                <span class="comment">// 解码的过程，持续将tail的内容放入到temp，从而变成："非加密+加密*次数"</span></span><br><span class="line">                for(<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; repeatedTimes; j++) &#123;</span><br><span class="line">                    temp.append(tail);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 保存当前生成的temp值</span></span><br><span class="line">                tail = temp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return tail.<span class="keyword">to</span><span class="constructor">String()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithms Note</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Practice by Categories(Array,LinkedList,SkipList)</title>
    <url>/2019/12/28/LeetCode-Practice-by-Categories/</url>
    <content><![CDATA[<blockquote>
<p>天才是长期劳动的结果。 —— 牛顿</p>
</blockquote>
<p>包含大量LeetCode链表、数组相关题目及其解决思路和具体代码。</p>
<a id="more"></a>

<p>点击题目链接为中国站题目，页面附上英文题目。</p>
<p><strong>对于链表，在操作上实际是有需要注意的地方的。</strong><br><font color=#FF0000></p>
<ol>
<li>利用快慢指针(有时候需要用到三个指针)。例如，链表翻转、寻找倒数第k个元素、寻找链表中间元素、判断链表是否有环</font><font color=#FF0000></li>
<li>构建一个虚假的链表头，一般用在需要返回一个新的链表的题目中。(整合两个有序链表、整合奇数偶数链表)。如果不创建空的链表头，每次都要多一个if else判断头结点是否为空。</font>

</li>
</ol>
<h1 id="数组、链表、跳表"><a href="#数组、链表、跳表" class="headerlink" title="数组、链表、跳表"></a>数组、链表、跳表</h1><h2 id="283-Move-zeros-移动零-Easy"><a href="#283-Move-zeros-移动零-Easy" class="headerlink" title="283.Move zeros(移动零)(Easy)"></a><a href="https://leetcode-cn.com/problems/move-zeroes/?utm_source=LCUS&utm_medium=ip_redirect_q_uns&utm_campaign=transfer2china" target="_blank" rel="noopener">283.Move zeros(移动零)(Easy)</a></h2><p>Given an array <code>nums</code> , write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.</p>
<p><strong>Examples:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">12</span>]</span><br><span class="line">Output: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ol>
<li>You must do this in-place without making a copy of the array.</li>
<li>Minimize the total number of operations.</li>
</ol>
<hr>
<p>解：这道题可以使用双指针思想很简洁代码解决。用i作为指针，只要之前元素不为0，就把它移动到j的位置上去，把i位置的元素赋值为0. 但是需要注意corner case, 如果传入的数据全都是非0，那么i和j始终相等，不能给任何元素赋值为0.</p>
<p>需要注意指针j什么时候递增，<strong>只要i指的位置不为零，j就要往后移动</strong>，j用来记录从左到右，下一个非0元素的位置.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                nums[j] = nums[i];</span><br><span class="line">                <span class="keyword">if</span>(i != j) &#123;</span><br><span class="line">                    nums[i] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)，一重循环</p>
<p>空间复杂度：O(1)，按照题目要求，不能使用额外数组空间</p>
<h2 id="11-Container-With-Most-Water-盛水最多的容器-Mid"><a href="#11-Container-With-Most-Water-盛水最多的容器-Mid" class="headerlink" title="11.Container With Most Water(盛水最多的容器)(Mid)"></a><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">11.Container With Most Water(盛水最多的容器)(Mid)</a></h2><p>Given n non-negative integers <em>a1, a2, …, an</em> , where each represents a point at coordinate <em>(i, ai)</em>. <em>n</em> vertical lines are drawn such that the two endpoints of line <em>i</em> is at <em>(i, ai)</em> and <em>(i, 0)</em>. Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>
<p><strong>Note</strong>: You may not slant the container and n is at least 2.</p>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg" alt=""></p>
<p>The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.</p>
<p><strong>Example</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">7</span>]</span><br><span class="line">Output: <span class="number">49</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：<strong>方法一</strong>，枚举。记录左边bar x, 右边 bar y，遍历每一个x和y的组合，计算(x-y)*height_diff，但是时间复杂度太高了，O(n^2)，显然不是最优解法。</p>
<p>但是这里可以回顾一下遍历数组的固定写法，形成机械记忆，一定要熟悉。</p>
<p>正常遍历一维数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.length; i++) &#123;</span><br></pre></td></tr></table></figure>

<p>遍历二维数组，实现 i 和 j 两个下标对数组的遍历，而且 i 和 j 不会重复</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; height.length; j++) &#123;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一段二维数组的遍历应当形成肌肉式记忆。 整个遍历过程中，j 总是比 i 大，最后j到了最后一个元素，i还在前面。当然，这种暴力的方式很慢，开销很大。</p>
<p><strong>方法二</strong>，从左边和右边开始往中间收敛（或者理解是左右往中间夹逼）。<strong>因为肯定是外面的棒子组成的面积更大。如果内部的棒子高度也不如外面，那么组成的面积肯定比外面小</strong>，这里可以看做是一个tricky的点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//循环初始条件巧妙，很简洁</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = height.length-<span class="number">1</span>; i &lt; j;) &#123;</span><br><span class="line">            <span class="comment">// 这句话真的很巧妙，也侧面利用了类似i++和++i的语法内容，把下标的挪动放在了比较选择更低的那一端，会更舒服</span></span><br><span class="line">            <span class="keyword">int</span> minHeight = (height[i] &lt; height[j]) ? height[i++] : height[j--];</span><br><span class="line">            <span class="comment">//这里加一是一因为经过上面选择最小内容之后的操作，两个点之间的宽度减小了1，这里加回来</span></span><br><span class="line">            <span class="keyword">int</span> area = (j-i+<span class="number">1</span>) * minHeight;</span><br><span class="line">            max = Math.max(area,max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>i 和 j 是左下标和右下标，哪个棒子更矮，就挪动哪个。</p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<h2 id="1-Two-Sum-两数之和-Easy"><a href="#1-Two-Sum-两数之和-Easy" class="headerlink" title="1. Two Sum(两数之和)(Easy)"></a><a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">1. Two Sum(两数之和)(Easy)</a></h2><p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have <strong><em>exactly</em></strong> one solution, and you may not use the same element twice.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Given nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span>,</span><br><span class="line"></span><br><span class="line">Because nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span>,</span><br><span class="line"><span class="keyword">return</span> [<span class="number">0</span>, <span class="number">1</span>].</span><br></pre></td></tr></table></figure>

<hr>
<p>解：<font color=#FF0000>这里给出两个解法，第一个无脑双指针遍历，第二个基于哈希表，是正解。</font></p>
<p><strong>方法一</strong>，两重循环，枚举下标，如果下标对应的内容相加可以达成target，那么完成。但是这种方法时间复杂度较大，O(n^2)</p>
<p>直接可以利用之前讲过的双指针遍历的方法。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>[] twoSum(<span class="built_in">int</span>[] nums, <span class="built_in">int</span> target) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span>[] result = new <span class="built_in">int</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.length<span class="number">-1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = i+<span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    result[<span class="number">0</span>] = i;</span><br><span class="line">                    result[<span class="number">1</span>] = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码可以通过，但是性能怎么样？——某次LeetCode的统计结果是，击败8%用户。<font color=#FF0000>所以如果你面试只想到了这个方法，刷刷写完了，没后续了，还很得意，那对不起，你的面试肯定过不了。除非其他候选者连这个方法都没想到。</font></p>
<p><strong>方法二</strong>,保持数组中的每个元素与其索引相互对应的最好方式是什么？当然是基于数组的哈希表。利用哈希表先把内容存储起来，这样一来查找的过程只需要O(1)了。</p>
<p>这个map中，key是nums元素的值，value是该元素的下标。因为要找到a+b = target,所以 a = target - b，所以查找 target-a 在不在数组里面即可。</p>
<p>注意</p>
<ol>
<li>这里是把元素当做key，该元素的位置当做value。</li>
<li>虽然看起来 <code>map.put(nums[i], i)</code> 这句放在循环体里的前面和后面都可以，但是其实是不能放在前面的，否则如果某个元素的值是target的二分之一，先把它添加进map之后再比较，会直接比较到它自己。换句话说，必须先比较，再put进map。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                result[<span class="number">0</span>] = i;</span><br><span class="line">                result[<span class="number">1</span>] = map.get(target - nums[i]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 注意这里put不能放在判断前面，必须先比较再放入。否则如果某个元素是target的一半，先添加再比较的话，会比较到它自己。</span></span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="15-3Sum-三数之和-Mid"><a href="#15-3Sum-三数之和-Mid" class="headerlink" title="15. 3Sum(三数之和)(Mid)"></a><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">15. 3Sum(三数之和)(Mid)</a></h2><p>Given an array <code>nums</code> of <em>n</em> integers, are there elements <em>a, b, c</em> in <code>nums</code> such that <em>a + b + c</em> = 0? Find all unique triplets in the array which gives the sum of zero.</p>
<p><strong>Note:</strong><br>The solution set must not contain duplicate triplets.(答案不能包含重复三元组)</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Given <span class="built_in">array</span> nums = [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-4</span>],</span><br><span class="line"></span><br><span class="line">A solution <span class="keyword">set</span> <span class="keyword">is</span>:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">2</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<hr>
<p>解：这道三数之和其实是第一题两数之和的升级版本。</p>
<p>方法一：暴力求解，和第一题非常相似，但是时间复杂度为O(n^3)，非常高。</p>
<p>方法二，用类似第一题的哈希表，时间复杂度可以降到O(n^2)</p>
<p>方法三，用左右下标夹逼的方法。其实很难直接想到，比较tricky。</p>
<p>方法三的解法详解：<a href="https://leetcode-cn.com/problems/3sum/solution/hua-jie-suan-fa-15-san-shu-zhi-he-by-guanpengchn/" target="_blank" rel="noopener">点击这里</a></p>
<p>需要注意题目输入的nums中可能有重复的元素；最后返回的答案不能有重复的三元组。</p>
<p>步骤：</p>
<ol>
<li>排序（排好序之后非常利于判重）</li>
<li>循环，因为有3个指针，循环length-2即可</li>
<li>设置判断条件，初始化指针位置</li>
<li>遍历找符合条件的3个数，一路上都要注意判重</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);<span class="comment">// 默认有小到大排序，先排序</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">		<span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="comment">// 有三个指针，循环 nums.length-2 次就够了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len-<span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> || (i &gt; <span class="number">0</span> &amp;&amp; nums[i] != nums[i-<span class="number">1</span>])) &#123; <span class="comment">//第二个条件是去重</span></span><br><span class="line">                <span class="keyword">int</span> lo = i+<span class="number">1</span>, hi = len-<span class="number">1</span>, sum = <span class="number">0</span>-nums[i];</span><br><span class="line">                <span class="keyword">while</span>(lo &lt; hi) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[lo] + nums[hi] == sum) &#123;</span><br><span class="line">                        <span class="comment">// asList是Arrays的工具类，能把数组转化成List，但是注意只能转换包装类，不能转换基本数据类型</span></span><br><span class="line">                    <span class="comment">// 此外asList不支持add和remove方法。</span></span><br><span class="line">                    <span class="comment">// 把所有数组里的内容丢到asList的参数里面来直接把几个数变成list，看得出技巧熟练</span></span><br><span class="line">                        res.add(Arrays.asList(nums[i], nums[lo],nums[hi]));</span><br><span class="line">                        <span class="keyword">while</span>(lo &lt; hi &amp;&amp; nums[lo] == nums[lo+<span class="number">1</span>]) lo++;</span><br><span class="line">                        <span class="keyword">while</span>(lo &lt; hi &amp;&amp; nums[hi] == nums[hi-<span class="number">1</span>]) hi--;</span><br><span class="line">                        lo++;hi--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[lo] + nums[hi] &lt; sum) lo++; <span class="comment">// lo++ 把和变大</span></span><br><span class="line">                    <span class="keyword">else</span> hi--; <span class="comment">// hi-- 把和变小</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="206-Reverse-LinkedList-反转链表-Easy"><a href="#206-Reverse-LinkedList-反转链表-Easy" class="headerlink" title="206. Reverse LinkedList(反转链表)(Easy)"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">206. Reverse LinkedList(反转链表)(Easy)</a></h2><p>Reverse a singly linked list.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL</span><br><span class="line">Output: <span class="number">5</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br></pre></td></tr></table></figure>

<p><strong>Follow up:</strong></p>
<p>A linked list can be reversed either iteratively or recursively. Could you implement both?</p>
<hr>
<p>解：就按照题目，给出迭代(iteratively)和递归(recursively)两种方法的解法。</p>
<p><strong>方法一：栈</strong></p>
<p>这个方法是参考Kevin大神的思路，因为要反转整个链表，所以最直接的想法就是依次遍历整个链表之后把每一个节点都放到栈里，然后再反过来取出来。但是这样的做法会使得空间复杂度很高，这点可以在方法二的迭代中得到优化。</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode reverseList(ListNode head) &#123;</span><br><span class="line">        Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.<span class="keyword">push</span>(head);</span><br><span class="line">            head = head.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode dummyNode = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        head = dummyNode;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 注意这里需要用current接住pop出来的节点，否则</span></span><br><span class="line">            <span class="comment">// pop()之后就没了</span></span><br><span class="line">            ListNode current = stack.<span class="keyword">pop</span>();</span><br><span class="line">            head.<span class="keyword">next</span> = <span class="keyword">new</span> ListNode(current.val);</span><br><span class="line">            head = head.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyNode.<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>方法二：迭代</strong></p>
<p>可以直接利用head，也只需要新定义两个ListNode</p>
<p>具体相等操作的过程可以记成修改指针指向的四步走。</p>
<p>总的来说，head总是在newHeader的next的位置，nextTemp总是在head的next的位置。</p>
<p>反转的四步：</p>
<ol>
<li>用nextTemp记录保存head.next</li>
<li>将head.next往前指，即指向newHeader</li>
<li>将newHeader往前移动一个位置指到head</li>
<li>把head往前一个位置，让其与nextTemp位置相同。但是因为下一次循环nextTemp又会在head.next的位置，所以不影响后面的反转。</li>
</ol>
<p>当跳出循环的时候，head为null，newHeader为反转后的链表的头结点，返回newHeader即可，不像方法一那样从0重新构建一个链表然后返回dummyNode.next。</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode reverseList(ListNode head) &#123;</span><br><span class="line">        ListNode <span class="keyword">new</span><span class="type">Header</span> = <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 最后返回的时候head为null，返回newHeader即可</span></span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 第一步，记录head的next，避免head.next丢失</span></span><br><span class="line">            ListNode nextTemp = head.next;</span><br><span class="line">            <span class="comment">// 第二部，翻转操作，把原先的head.next指向前面</span></span><br><span class="line">            head.next = <span class="keyword">new</span><span class="type">Header</span>;</span><br><span class="line">            <span class="comment">// newHeader指向旧的head的位置</span></span><br><span class="line">            <span class="keyword">new</span><span class="type">Header</span> = head;</span><br><span class="line">            <span class="comment">// head往后移动</span></span><br><span class="line">            head = nextTemp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span><span class="type">Header</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法三：递归</strong></p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode <span class="keyword">next</span>;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode reverseList(ListNode<span class="built_in"> head</span>) &#123;</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">if</span><span class="built_in">(head</span> == null ||<span class="built_in"> head</span>.<span class="keyword">next</span> == null) <span class="keyword">return</span><span class="built_in"> head</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode newHeader = reverseList<span class="built_in">(head</span>.<span class="keyword">next</span>);</span><br><span class="line">       <span class="built_in"> head</span>.<span class="keyword">next</span>.<span class="keyword">next</span> =<span class="built_in"> head</span>;</span><br><span class="line">       <span class="built_in"> head</span>.<span class="keyword">next</span> = null;</span><br><span class="line">        <span class="keyword">return</span> newHeader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对递归方法值得注意的是，因为newHeader没有被动过，所以在一开始递归结束的时候，就返回的是反转之后的链表的新的head，也就是这个newHeader，所以最后的结果就是每一层的递归返回的都是一开始递归返回的newHeader，问题就迎刃而解了。</p>
<h2 id="92-Reverse-LinkedList-II-反转链表II-Mid"><a href="#92-Reverse-LinkedList-II-反转链表II-Mid" class="headerlink" title="92. Reverse LinkedList II(反转链表II)(Mid)"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">92. Reverse LinkedList II(反转链表II)(Mid)</a></h2><p>Reverse a linked list from position <em>m</em> to <em>n</em>. Do it in one-pass.</p>
<p>Note: 1 ≤ <em>m ≤ n</em> ≤ length of list.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL, m = <span class="number">2</span>, n = <span class="number">4</span></span><br><span class="line">Output: <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span>-&gt;NULL</span><br></pre></td></tr></table></figure>

<hr>
<p>解：和数组不同，这里的反转下标从1开始。需要初始化一个dummy节点代表0号节点，然后开始遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create a dummy node to mark the head of this list</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>); </span><br><span class="line">        dummy.next = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// make a pointer pre as a marker for the node before reversing</span></span><br><span class="line">        ListNode pre = dummy; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m-<span class="number">1</span>; i++) pre = pre.next;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// a pointer to the beginning of a sub-list that will be reversed</span></span><br><span class="line">        ListNode start = pre.next; </span><br><span class="line">        <span class="comment">// a pointer to a node that will be reversed</span></span><br><span class="line">        ListNode then = start.next; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1 - 2 -3 - 4 - 5 ; m=2; n =4 ---&gt; pre = 1, start = 2, then = 3</span></span><br><span class="line">    <span class="comment">// dummy-&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n-m; i++) &#123;</span><br><span class="line">        start.next = then.next;</span><br><span class="line">        then.next = pre.next;</span><br><span class="line">        pre.next = then;</span><br><span class="line">        then = start.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// first reversing : dummy-&gt;1 - 3 - 2 - 4 - 5; pre = 1, start = 2, then = 4</span></span><br><span class="line">    <span class="comment">// second reversing: dummy-&gt;1 - 4 - 3 - 2 - 5; pre = 1, start = 2, then = 5 (finish)</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="141-Linked-List-Cycle-环形链表-Easy"><a href="#141-Linked-List-Cycle-环形链表-Easy" class="headerlink" title="141. Linked List Cycle(环形链表)(Easy)"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">141. Linked List Cycle(环形链表)(Easy)</a></h2><p>Given a linked list, determine if it has a cycle in it.</p>
<p>To represent a cycle in the given linked list, we use an integer <code>pos</code> which represents the position (0-indexed) in the linked list where tail connects to. If <code>pos</code> is <code>-1</code>, then there is no cycle in the linked list.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: head = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">-4</span>], pos = <span class="number">1</span></span><br><span class="line">Output: <span class="literal">true</span></span><br><span class="line">Explanation: There <span class="keyword">is</span> a cycle <span class="keyword">in</span> the linked list, </span><br><span class="line">where tail connects to the second node.</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt=""></p>
<p><strong>Example 2:</strong></p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">Input:<span class="built_in"> head</span> = [<span class="number">1</span>,<span class="number">2</span>], pos = <span class="number">0</span></span><br><span class="line">Output:<span class="built_in"> true</span></span><br><span class="line">Explanation: There <span class="literal">is</span> a cycle <span class="keyword">in</span> the linked list, <span class="keyword">where</span><span class="built_in"> tail</span> connects <span class="keyword">to</span> the first <span class="type">node</span>.</span><br></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" alt=""></p>
<p><strong>Example 3:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="string">head</span> <span class="string">=</span> <span class="string">[1],</span> <span class="string">pos</span> <span class="string">=</span> <span class="number">-1</span></span><br><span class="line"><span class="attr">Output:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">Explanation:</span> <span class="string">There</span> <span class="string">is</span> <span class="literal">no</span> <span class="string">cycle</span> <span class="string">in</span> <span class="string">the</span> <span class="string">linked</span> <span class="string">list.</span></span><br></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png" alt=""></p>
<p><strong>Follow up:</strong></p>
<p>Can you solve it using O(1) (i.e. constant) memory?</p>
<hr>
<p>解：题目中虽然说会用pos明显标出成环的链表情况，而且貌似人用眼睛可以非常直接地发现，pos只要不是-1就一定有环，但是传入的参数没有pos,不能直接使用它。</p>
<p>判断链表成环可以有思维上的巧妙性，主要是快慢指针的使用。</p>
<p>解法一，用哈希表，但是不符合进阶要求，时间复杂度和空间复杂度都是O(n)</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Definition for singly-linked list.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>class ListNode &#123;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>int val;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>ListNode next;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>ListNode(int x) &#123;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *         </span>val = x;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *         </span>next = null;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>&#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>&#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> */</span></span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    public boolean hasCycle(ListNode head) &#123;</span><br><span class="line">        <span class="built_in">Set</span>&lt;ListNode&gt; <span class="keyword">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">set</span>.contains(head)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">set</span>.add(head);</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，如果没有了解，很难想到的双指针法（其实之前很多题目已经用到了双指针，比如283题移动零、11题盛水容器、15题三数之和等。三数之和甚至用到了三指针。）</p>
<p>时间复杂度为O(n)，但是符合空间复杂度为O(1)的要求因为它是在原有的链表上进行操作。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>Definition for singly-linked list.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>class ListNode &#123;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>int val;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>ListNode next;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>ListNode(int x) &#123;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *         </span>val = x;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *         </span>next = null;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *     </span>&#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>&#125;</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> */</span></span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    public boolean hasCycle(ListNode head) &#123;</span><br><span class="line">        <span class="comment">// 一开始考虑边界条件，head或head.next可能为空，那么slow或fast就有一个</span></span><br><span class="line">        <span class="comment">// 会是空指针异常了。这个边界条件考虑得很重要</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head.next;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast) &#123;</span><br><span class="line">            <span class="comment">// 只要链表有环，fast和fast.next一定不会为null，会一直走下去</span></span><br><span class="line">            <span class="comment">// 不可能跳出false</span></span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="142-Linked-List-Cycle-II-环形链表II-Mid"><a href="#142-Linked-List-Cycle-II-环形链表II-Mid" class="headerlink" title="142. Linked List Cycle II(环形链表II)(Mid)"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">142. Linked List Cycle II(环形链表II)(Mid)</a></h2><p>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.</p>
<p>To represent a cycle in the given linked list, we use an integer <code>pos</code> which represents the position (0-indexed) in the linked list where tail connects to. If <code>pos</code> is <code>-1</code>, then there is no cycle in the linked list.</p>
<p><strong>Note</strong>: Do not modify the linked list.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">Input:<span class="built_in"> head</span> = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,-<span class="number">4</span>], pos = <span class="number">1</span></span><br><span class="line">Output:<span class="built_in"> tail</span> connects <span class="keyword">to</span> <span class="type">node</span> index <span class="number">1</span></span><br><span class="line">Explanation: There <span class="literal">is</span> a cycle <span class="keyword">in</span> the linked list, <span class="keyword">where</span><span class="built_in"> tail</span> connects <span class="keyword">to</span> the second <span class="type">node</span>.</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt=""></p>
<p><strong>Example 2:</strong></p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">Input:<span class="built_in"> head</span> = [<span class="number">1</span>,<span class="number">2</span>], pos = <span class="number">0</span></span><br><span class="line">Output:<span class="built_in"> tail</span> connects <span class="keyword">to</span> <span class="type">node</span> index <span class="number">0</span></span><br><span class="line">Explanation: There <span class="literal">is</span> a cycle <span class="keyword">in</span> the linked list, <span class="keyword">where</span><span class="built_in"> tail</span> connects <span class="keyword">to</span> the first <span class="type">node</span>.</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" alt=""></p>
<p><strong>Example 3:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="string">head</span> <span class="string">=</span> <span class="string">[1],</span> <span class="string">pos</span> <span class="string">=</span> <span class="number">-1</span></span><br><span class="line"><span class="attr">Output:</span> <span class="literal">no</span> <span class="string">cycle</span></span><br><span class="line"><span class="attr">Explanation:</span> <span class="string">There</span> <span class="string">is</span> <span class="literal">no</span> <span class="string">cycle</span> <span class="string">in</span> <span class="string">the</span> <span class="string">linked</span> <span class="string">list.</span></span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png" alt=""></p>
<p><strong>Follow-up:</strong><br>Can you solve it without using extra space?</p>
<hr>
<p>解：还是两个方法，快慢指针是环形链表相关的常用方法。</p>
<p>方法一，哈希表。虽然不符合进阶要求，但是可以解决。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        Set&lt;ListNode&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        ListNode node = head;</span><br><span class="line">        <span class="keyword">while</span>( node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(visited.contains(node)) &#123;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">            visited.add(node);</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这个方法在空间上开辟了新的空间给哈希表。</p>
<p>方法二，快慢指针，空间复杂度为O(1)</p>
<p>把判断是否有交点单独写成方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二，快慢指针，也叫 Floyd 算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">getIntersect</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// A fast pointer will either loop around a cycle and meet the slow</span></span><br><span class="line">        <span class="comment">// pointer or reach the `null` at the end of a non-cyclic list.</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// If there is a cycle, the fast/slow pointers will intersect at some</span></span><br><span class="line">        <span class="comment">// node. Otherwise, there is no cycle, so we cannot find an entrance to a cycle.</span></span><br><span class="line">        ListNode intersect = getIntersect(head);</span><br><span class="line">        <span class="keyword">if</span> (intersect == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// To find the entrance to the cycle, we have two pointers traverse at</span></span><br><span class="line">        <span class="comment">// the same speed -- one from the front of the list, and the other from</span></span><br><span class="line">        <span class="comment">// the point of intersection.</span></span><br><span class="line">        ListNode ptr1 = head;</span><br><span class="line">        ListNode ptr2 = intersect;</span><br><span class="line">        <span class="keyword">while</span> (ptr1 != ptr2) &#123;</span><br><span class="line">            ptr1 = ptr1.next;</span><br><span class="line">            ptr2 = ptr2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ptr1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="24-Swap-Nodes-in-Pairs-两两交换链表中的节点-Mid"><a href="#24-Swap-Nodes-in-Pairs-两两交换链表中的节点-Mid" class="headerlink" title="24. Swap Nodes in Pairs(两两交换链表中的节点)(Mid)"></a><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">24. Swap Nodes in Pairs(两两交换链表中的节点)(Mid)</a></h2><p>Given a linked list, swap every two adjacent nodes and return its head.</p>
<p>You may <strong>not</strong> modify the values in the list’s nodes, only nodes itself may be changed.</p>
<p><strong>Example:</strong><br><code>Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</code></p>
<hr>
<p>解：<br>方法一，递归，开销较大。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// terminator</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// process current logic</span></span><br><span class="line">        ListNode node = head.next;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// drill down</span></span><br><span class="line">        head.next = swapPairs(node.next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// reverse current state</span></span><br><span class="line">        node.next = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，非递归：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode pre = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode temp = pre;</span><br><span class="line">        pre.next = head;</span><br><span class="line">        <span class="keyword">while</span>(temp.next != <span class="keyword">null</span> &amp;&amp; temp.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode start = temp.next;</span><br><span class="line">            ListNode end = temp.next.next;</span><br><span class="line">            temp.next = end;</span><br><span class="line">            start.next = end.next;</span><br><span class="line">            end.next = start;</span><br><span class="line">            temp = start;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比于递归，非递归的写法实际对链表指针的操作更明显，需要注意在改变指针的过程中需要利用临时指针temp.next和temp.next.next分别定义start和end的位置。将start和end指向的节点反转之后将temp位置改变再重新定义start和end的位置从而重新操作。</p>
<p>具体过程可以如下图所示：</p>
<p><img src="https://s2.ax1x.com/2020/01/04/ldDjSA.jpg" alt="ldDjSA.jpg"></p>
<h2 id="25-Reverse-Nodes-in-k-Group-k个一组翻转链表-Hard"><a href="#25-Reverse-Nodes-in-k-Group-k个一组翻转链表-Hard" class="headerlink" title="25. Reverse Nodes in k-Group(k个一组翻转链表)(Hard)"></a><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">25. Reverse Nodes in k-Group(k个一组翻转链表)(Hard)</a></h2><p>Given a linked list, reverse the nodes of a linked list <em>k</em> at a time and return its modified list.</p>
<p><em>k</em> is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of <em>k</em> then left-out nodes in the end should remain as it is.</p>
<p><strong>Example:</strong></p>
<p>Given this linked list:  <code>1-&gt;2-&gt;3-&gt;4-&gt;5</code></p>
<p>For k = 2, you should return: <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code></p>
<p>For k = 3, you should return: <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code></p>
<p><strong>Note:</strong></p>
<ul>
<li><p>Only constant extra memory is allowed.</p>
</li>
<li><p>You may not alter the values in the list’s nodes, only nodes itself may be changed.</p>
</li>
</ul>
<hr>
<p>解：提供递归和非递归两种解法。</p>
<p>方法一，递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span> &amp;&amp; count != k) &#123; <span class="comment">// To find the k+1 node</span></span><br><span class="line">            curr = curr.next;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(count == k) &#123;</span><br><span class="line">            curr = reverseKGroup(curr, k); <span class="comment">// reverse list with k+1 node as head</span></span><br><span class="line">            <span class="comment">// head - head-pointer to direct part</span></span><br><span class="line">            <span class="comment">// curr - head-pointer to reversed part</span></span><br><span class="line">            <span class="keyword">while</span>(count-- &gt; <span class="number">0</span>) &#123; <span class="comment">// reverse the k-group</span></span><br><span class="line">                ListNode tmp = head.next; <span class="comment">//tmp - next head in direct part</span></span><br><span class="line">                head.next = curr; <span class="comment">// preappending "direct" head to the reversed list</span></span><br><span class="line">                curr = head; <span class="comment">//move head of reversed part to a new node</span></span><br><span class="line">                head = tmp; <span class="comment">// move ""direct" head to the next node in direct part</span></span><br><span class="line">            &#125;</span><br><span class="line">            head = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归写法在找到k组节点之后的反转操作和单纯的链表翻转的节点指针的改变操作相同，即把第206题翻转链表非递归写法提取了出来。</p>
<p>方法二，非递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        </span><br><span class="line">        ListNode pre = dummy;</span><br><span class="line">        ListNode end = dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(end.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k &amp;&amp; end != <span class="keyword">null</span>; i++) &#123;</span><br><span class="line">                end = end.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(end == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode start = pre.next;</span><br><span class="line">            ListNode next = end.next;</span><br><span class="line">            end.next = <span class="keyword">null</span>;</span><br><span class="line">            pre.next = reverse(start);</span><br><span class="line">            start.next = next;</span><br><span class="line">            pre = start;</span><br><span class="line">            end = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode next = curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细题解：<br><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/solution/tu-jie-kge-yi-zu-fan-zhuan-lian-biao-by-user7208t/" target="_blank" rel="noopener">点击这里</a></p>
<h2 id="26-Remove-Duplicates-from-Sorted-Array-删除排序数组中的重复项-Easy"><a href="#26-Remove-Duplicates-from-Sorted-Array-删除排序数组中的重复项-Easy" class="headerlink" title="26. Remove Duplicates from Sorted Array(删除排序数组中的重复项)(Easy)"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">26. Remove Duplicates from Sorted Array(删除排序数组中的重复项)(Easy)</a></h2><p>Given a sorted array <em>nums</em>, remove the duplicates in-place(原地操作) such that each element appear only <em>once</em> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array in-place</strong> with O(1) extra memory.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">Given nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line"></span><br><span class="line">Your <span class="keyword">function</span> <span class="title">should</span> <span class="keyword">return</span> <span class="type">length</span> = <span class="number">2</span>, <span class="keyword">with</span> the first two elements <span class="keyword">of</span> nums being <span class="number">1</span> <span class="keyword">and</span> <span class="number">2</span> respectively.</span><br><span class="line"></span><br><span class="line">It doesn<span class="symbol">'t</span> matter what you leave beyond the returned length.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">Given nums = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line"></span><br><span class="line">Your function should return length = <span class="number">5</span>, with the first five elements of nums being modified to <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, and <span class="number">4</span> respectively.</span><br><span class="line"></span><br><span class="line">It doesn't matter what values are set beyond the returned length.</span><br></pre></td></tr></table></figure>

<p><strong>Clarfication:</strong><br>Confused why the returned value is an integer but your answer is an array?</p>
<p>Note that the input array is passed in by <strong>reference</strong>, which means modification to the input array will be known to the caller as well.</p>
<p>Internally you can think of this:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// nums is passed in by reference. (i.e., without making a copy)</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">len</span> = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// any modification to nums in your function would be known by the caller.</span></span><br><span class="line"><span class="comment">// using the length returned by your function, it prints the first len elements.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">len</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">print</span>(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>解：</p>
<p>方法一，快慢指针：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 删除重复项之后的数组下标为after_numsLength</span></span><br><span class="line">        <span class="keyword">int</span> after_numslength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// i在前，after_numslength在后，nums[after_numslength]为去重之后的数组</span></span><br><span class="line">            <span class="keyword">if</span>(nums[after_numslength] != nums[i]) &#123;</span><br><span class="line">                after_numslength++;</span><br><span class="line">                nums[after_numslength] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回长度，为下标最大值+1</span></span><br><span class="line">        <span class="keyword">return</span> after_numslength+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，i表示删除元素后数组元素的个数，注意因为i是元素个数，所以判断元素是否重复的时候比较的是”n != nums[i-1]”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> || nums[i-<span class="number">1</span>] != n) &#123;</span><br><span class="line">                nums[i++] = n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="189-Rotate-Array-旋转数组-Easy"><a href="#189-Rotate-Array-旋转数组-Easy" class="headerlink" title="189. Rotate Array(旋转数组)(Easy)"></a><a href="https://leetcode-cn.com/problems/rotate-array/" target="_blank" rel="noopener">189. Rotate Array(旋转数组)(Easy)</a></h2><p>Given an array, rotate the array to the right by <em>k</em> steps, where <em>k</em> is non-negative.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>] <span class="keyword">and</span> k = <span class="number">3</span></span><br><span class="line">Output: [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">Explanation:</span><br><span class="line">rotate <span class="number">1</span> steps to the right: [<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">rotate <span class="number">2</span> steps to the right: [<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">rotate <span class="number">3</span> steps to the right: [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">-1</span>,<span class="number">-100</span>,<span class="number">3</span>,<span class="number">99</span>] <span class="keyword">and</span> k = <span class="number">2</span></span><br><span class="line">Output: [<span class="number">3</span>,<span class="number">99</span>,<span class="number">-1</span>,<span class="number">-100</span>]</span><br><span class="line">Explanation: </span><br><span class="line">rotate <span class="number">1</span> steps to the right: [<span class="number">99</span>,<span class="number">-1</span>,<span class="number">-100</span>,<span class="number">3</span>]</span><br><span class="line">rotate <span class="number">2</span> steps to the right: [<span class="number">3</span>,<span class="number">99</span>,<span class="number">-1</span>,<span class="number">-100</span>]</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ul>
<li><p>Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.</p>
</li>
<li><p>Could you do it in-place with O(1) extra space?</p>
</li>
</ul>
<hr>
<p>解：给出三种解法。</p>
<p>方法一，双重循环，比较暴力。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> rotate(<span class="built_in">int</span>[] nums, <span class="built_in">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// 按照轮次来做，每一轮操作一个数字</span></span><br><span class="line">        <span class="built_in">int</span> len = nums.length;</span><br><span class="line">        <span class="comment">// 如果k太大，甚至比nums还大，那么移动过程会经过了一轮。这里k表示最后要位移的位数</span></span><br><span class="line">        k %= len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="comment">//temp 保存最后一个元素的值</span></span><br><span class="line">            <span class="built_in">int</span> temp = nums[len - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = len<span class="number">-1</span>; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">                nums[j] = nums[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            nums[<span class="number">0</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(kn)</p>
<p>空间复杂度：O(1)</p>
<p>方法二</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> rotate(<span class="built_in">int</span>[] nums, <span class="built_in">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">int</span> nums_length = nums.length;</span><br><span class="line">        k %= nums_length;</span><br><span class="line">        <span class="comment">// 第一次交换完毕后，前 k 位数字位置正确，后 n-k 位数字中最后 k 位数字顺序错误，继续交换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> start = <span class="number">0</span>; start &lt; nums.length &amp;&amp; k != <span class="number">0</span>; nums_length -= k, start += k, k %= nums_length) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">                swap(nums, start + i, nums.length - k + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> <span class="built_in">void</span> swap(<span class="built_in">int</span> [] nums, <span class="built_in">int</span> i, <span class="built_in">int</span> j)&#123;</span><br><span class="line">            <span class="built_in">int</span> temp = nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度:O(n)<br>空间复杂度：O(1)</p>
<p>方法三，翻转，最巧妙。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> rotate(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span> len = nums.length;</span><br><span class="line">        // 如果k太大，甚至比nums还大，那么移动过程会经过一轮，在这里k表示最后要位移的位数。</span><br><span class="line">        k %= len;</span><br><span class="line">        reverse(nums,<span class="number">0</span>,len<span class="number">-1</span>);</span><br><span class="line">        reverse(nums,<span class="number">0</span>,k<span class="number">-1</span>);</span><br><span class="line">        reverse(nums,k,len<span class="number">-1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private <span class="type">void</span> reverse(<span class="type">int</span>[] nums, <span class="type">int</span> <span class="keyword">start</span>, <span class="type">int</span> <span class="keyword">end</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">start</span> &lt; <span class="keyword">end</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="keyword">temp</span> = nums[<span class="keyword">start</span>];</span><br><span class="line">            nums[<span class="keyword">start</span>++] = nums[<span class="keyword">end</span>];</span><br><span class="line">            nums[<span class="keyword">end</span><span class="comment">--] = temp;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>arr = [1,2,3,4,5] –右移两位–&gt; [4,5,1,2,3]<br>假设 n = arr.length，k = 右移位数，可得：  </p>
<pre><code>[1,2,3,4,5] --翻转索引为[0,n-1]之间的元素--&gt; [5,4,3,2,1] 
            --翻转索引为[0,k-1]之间的元素--&gt; [4,5,3,2,1] 
            --翻转索引为[k,n-1]之间的元素--&gt; [4,5,1,2,3]</code></pre><p>注意上面这个区间貌似左和右都是闭合的</p>
<p>旋转数组其实就是把数组分成了两部分，解题关键就是在保证原有顺序的情况下<br>把后面一部分移到前面去。数组整体翻转满足了第二个要素，但是打乱了数组的<br>原有顺序，所以此时再次对两部分进行翻转，让他们恢复到原有顺序（翻转之后<br>再翻转，就恢复成原有顺序了）。没有什么太复杂的思想，但是这种很巧妙的思想或许是神来之笔。</p>
<h2 id="21-Merge-Two-Sorted-Lists-合并两个有序链表-Easy"><a href="#21-Merge-Two-Sorted-Lists-合并两个有序链表-Easy" class="headerlink" title="21. Merge Two Sorted Lists(合并两个有序链表)(Easy)"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">21. Merge Two Sorted Lists(合并两个有序链表)(Easy)</a></h2><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>, <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span></span><br><span class="line">Output: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：<br>方法一，非递归，操作指针。</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        <span class="comment">// 创建合并后链表的虚拟头结点</span></span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode curr = dummyHead;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 若链表不为空，开始合并,实际操作是插入节点</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt; l2.val) &#123;</span><br><span class="line">                curr.<span class="keyword">next</span> = l1;</span><br><span class="line">                l1 = l1.<span class="keyword">next</span>;</span><br><span class="line">                curr = curr.<span class="keyword">next</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr.<span class="keyword">next</span> = l2;</span><br><span class="line">                l2 = l2.<span class="keyword">next</span>;</span><br><span class="line">                curr = curr.<span class="keyword">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 若l1或者l2有一个为空，则直接返回另一条链表</span></span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            curr.<span class="keyword">next</span> = l2;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curr.<span class="keyword">next</span> = l1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummyHead.<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，递归</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        <span class="comment">// 使用recursion，代码虽然简洁，但是可能导致Stack OverFlow</span></span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="literal">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">if</span>(l1.<span class="keyword">val</span> &lt; l2.<span class="keyword">val</span>) &#123;</span><br><span class="line">            l1.next = mergeTwoLists(l1.next,l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            l2.next = mergeTwoLists(l1,l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="88-Merge-Sorted-Array-合并两个有序数组-Easy"><a href="#88-Merge-Sorted-Array-合并两个有序数组-Easy" class="headerlink" title="88. Merge Sorted Array(合并两个有序数组)(Easy)"></a><a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">88. Merge Sorted Array(合并两个有序数组)(Easy)</a></h2><p>Given two sorted integer arrays <em>nums1</em> and <em>nums2</em>, merge <em>nums2</em> into <em>nums1</em> as one sorted array.</p>
<p><strong>Note:</strong></p>
<ul>
<li><p>The number of elements initialized in <em>nums1</em> and <em>nums2</em> are m and n respectively.</p>
</li>
<li><p>You may assume that <em>nums1</em> has enough space (size that is greater or equal to <em>m + n</em>) to hold additional elements from <em>nums2</em>.</p>
</li>
</ul>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], m = <span class="number">3</span></span><br><span class="line">nums2 = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>],       n = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">Output: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure>

<hr>
<p>解：<br>方法一，调用自带函数，但是面试中肯定不允许使用，可以提一嘴</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 方法一，使用java的arraycopy进行nums1和nums2的合并，合并之后再排序即可</span></span><br><span class="line">        System.arraycopy(nums2,<span class="number">0</span>,nums1,m,n);</span><br><span class="line">        <span class="comment">// 使用工具类Arrays的排序方法</span></span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，使用从后往前的指针，一共三个指针，分别在在nums1元素的最后位置、nums1长度的最后位置和nums2的最后位置。每次进行比较，直到nums1或nums2被遍历完为止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 更加酷，不需要开辟额外空间，直接在nums1的末尾开始，用三个指针从后往前</span></span><br><span class="line">        <span class="comment">// two pointers for nums1 and nums2</span></span><br><span class="line">        <span class="keyword">int</span> p1 = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> p2 = n - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// set pointer for nums1</span></span><br><span class="line">        <span class="keyword">int</span> p = m + n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// while there are still elements to compare</span></span><br><span class="line">        <span class="keyword">while</span>((p1 &gt;= <span class="number">0</span>) &amp;&amp; (p2 &gt;= <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">// compare two elements from nums1 and nums2 and add the largest</span></span><br><span class="line">            <span class="comment">// one in nums1</span></span><br><span class="line">            nums1[p--] = (nums1[p1] &lt; nums2[p2]) ? nums2[p2--] : nums1[p1--];</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="comment">// add missing elements from nums2</span></span><br><span class="line">            <span class="comment">// 如果先触发了p1 &lt; 0的条件，nums2不再能copy了，需要手动arraycopy过去</span></span><br><span class="line">            System.arraycopy(nums2, <span class="number">0</span>, nums1, <span class="number">0</span>, p2 + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="66-Plus-One-加一-Easy"><a href="#66-Plus-One-加一-Easy" class="headerlink" title="66. Plus One(加一)(Easy)"></a><a href="https://leetcode-cn.com/problems/plus-one/" target="_blank" rel="noopener">66. Plus One(加一)(Easy)</a></h2><p>Given a <strong>non-empty</strong> array of digits representing a non-negative integer, plus one to the integer.</p>
<p>The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.</p>
<p>You may assume the integer does not contain any leading zero, except the number 0 itself.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">Output: [1,2,4]</span><br><span class="line">Explanation: The<span class="built_in"> array </span>represents the integer 123.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">Output: [<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">Explanation: The <span class="built_in">array</span> represents the <span class="built_in">int</span>eger <span class="number">4321.</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>[] plusOne(<span class="built_in">int</span>[] digits) &#123;</span><br><span class="line">        <span class="built_in">int</span> len = digits.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            digits[i]++;</span><br><span class="line">            digits[i] %= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(digits[i] != <span class="number">0</span>) <span class="keyword">return</span> digits;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若digits起初所有元素都为9，则需要新开辟一位</span></span><br><span class="line">        digits = new <span class="built_in">int</span>[len + <span class="number">1</span>];</span><br><span class="line">        digits[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="83-Remove-Duplicates-from-Sorted-List-删除排序链表中的重复元素-Easy"><a href="#83-Remove-Duplicates-from-Sorted-List-删除排序链表中的重复元素-Easy" class="headerlink" title="83. Remove Duplicates from Sorted List(删除排序链表中的重复元素)(Easy)"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">83. Remove Duplicates from Sorted List(删除排序链表中的重复元素)(Easy)</a></h2><p>Given a sorted linked list, delete all duplicates such that each element appear only once.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span></span><br><span class="line">Output: <span class="number">1</span>-&gt;<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">3</span></span><br><span class="line">Output: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：比较简单，只是考察操作链表节点指针的能力。因为传入的链表已经排序，我们只需要比较当前节点和它之后节点的值是否相等即可，如果相等，让当前节点指针跳过下一个节点，指向下一个节点的next即可。</p>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> singly-linked list.</span><br><span class="line"> * <span class="keyword">public</span> <span class="keyword">class</span> ListNode &#123;</span><br><span class="line"> *     <span class="built_in">int</span> val;</span><br><span class="line"> *     ListNode <span class="keyword">next</span>;</span><br><span class="line"> *     ListNode(<span class="built_in">int</span> x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode deleteDuplicates(ListNode head) &#123;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="literal">null</span> &amp;&amp; curr.<span class="keyword">next</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(curr.val == curr.<span class="keyword">next</span>.val) &#123;</span><br><span class="line">                curr.<span class="keyword">next</span> = curr.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr = curr.<span class="keyword">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<h2 id="82-Remove-Duplicates-from-Sorted-List-II-删除排序链表中的重复元素-II-Mid"><a href="#82-Remove-Duplicates-from-Sorted-List-II-删除排序链表中的重复元素-II-Mid" class="headerlink" title="82. Remove Duplicates from Sorted List II(删除排序链表中的重复元素 II)(Mid)"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/submissions/" target="_blank" rel="noopener">82. Remove Duplicates from Sorted List II(删除排序链表中的重复元素 II)(Mid)</a></h2><p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span></span><br><span class="line">Output: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span></span><br><span class="line">Output: <span class="number">2</span>-&gt;<span class="number">3</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：</p>
<p>方法一，非递归。</p>
<p>重复的元素直接彻底跳过而不是去重，难度上升变成中等。方法中定义虚拟节点FakeNode(用于处理开头节点就是重复节点的情况，最后一定要返回FakeNode.next)、pre节点(用于直接跳过重复的所有元素)、cur(判断当前节点是否为重复元素的节点)</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode deleteDuplicates(ListNode head) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> ) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode FakeNode = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        FakeNode.<span class="keyword">next</span> = head;</span><br><span class="line">        ListNode pre = FakeNode;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span> ) &#123;</span><br><span class="line">            <span class="comment">// cur 标记是否当前节点为重复节点，用pre进行过滤，链起来一个新链表</span></span><br><span class="line">            <span class="comment">// cur为重复元素的最后一个结点</span></span><br><span class="line">            <span class="comment">// 不能把cur.next != null 放入大循环条件，否则可能报空指针</span></span><br><span class="line">            <span class="keyword">while</span>(cur.<span class="keyword">next</span> != <span class="keyword">null</span> &amp;&amp; cur.val == cur.<span class="keyword">next</span>.val) &#123;</span><br><span class="line">                cur = cur.<span class="keyword">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若pre的下一个节点就是cur，说明cur当前元素不是重复的，不需要跳过</span></span><br><span class="line">            <span class="comment">// 反之，根据题意需要跳过cur指向的找到的重复的最后一个结点</span></span><br><span class="line">            <span class="keyword">if</span>(pre.<span class="keyword">next</span> == cur) &#123;</span><br><span class="line">                pre = pre.<span class="keyword">next</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre.<span class="keyword">next</span> = cur.<span class="keyword">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 相比83题简单地去重，这里需要判断cur重复之后还要删除重复元素，使用pre指针</span></span><br><span class="line">            <span class="comment">// 所以不是简单地在判断元素重复之后直接进入下一元素，而是经过一个循环和一个判断之后才可以</span></span><br><span class="line">            cur = cur.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> FakeNode.<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，递归。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> ) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(head.next != <span class="keyword">null</span> &amp;&amp; head.val == head.next.val) &#123;</span><br><span class="line">            <span class="keyword">while</span>(head.next != <span class="keyword">null</span> &amp;&amp; head.val == head.next.val) &#123;</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> deleteDuplicates(head.next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head.next = deleteDuplicates(head.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="203-Remove-Linked-List-Elements-移除链表元素-Easy"><a href="#203-Remove-Linked-List-Elements-移除链表元素-Easy" class="headerlink" title="203. Remove Linked List Elements(移除链表元素)(Easy)"></a><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/" target="_blank" rel="noopener">203. Remove Linked List Elements(移除链表元素)(Easy)</a></h2><p>Remove all elements from a linked list of integers that have value <strong><em>val</em></strong>.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input:  <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">6</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span>, val = <span class="number">6</span></span><br><span class="line">Output: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：<br>方法一，递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode next = removeElements(head.next, val);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(head.val == val) <span class="keyword">return</span> next;</span><br><span class="line">        </span><br><span class="line">        head.next = next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二，非递归，迭代，定义虚拟节点</p>
<p>需要注意，如果第一个元素的值是val,无法返回头结点。所以自然想到需要dummyuNode(或者叫做FakeNode)。当遇到含有val的值的时候，比如2-&gt;6-&gt;3，val是6，此时需要赋值：2.next=2.next.next，和83题的操作同样很类似。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode fakeNode = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        fakeNode.next = head;</span><br><span class="line">        ListNode curr = fakeNode;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span> &amp;&amp; curr.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(curr.next.val == val) &#123;</span><br><span class="line">                curr.next = curr.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fakeNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法三，非递归，不使用虚拟节点，单纯删除节点，只是头结点值为val的时候需要单独考虑。(删除节点操作很简单,很类似83题，只是83题是和 x.next 去比较val是否相同，而这道题比较当前节点的 val 是否和传入的val相同)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span> &amp;&amp; head.val == val) &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果没有这个判断，curr.next在corner edge情况下很可能会报空指针</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span> &amp;&amp; curr.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(curr.next.val == val) &#123;</span><br><span class="line">                curr.next = curr.next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr = curr.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="237-Delete-Node-in-a-Linked-List-删除链表中的节点-Easy"><a href="#237-Delete-Node-in-a-Linked-List-删除链表中的节点-Easy" class="headerlink" title="237. Delete Node in a Linked List(删除链表中的节点)(Easy)"></a><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/" target="_blank" rel="noopener">237. Delete Node in a Linked List(删除链表中的节点)(Easy)</a></h2><p>Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.</p>
<p>Given linked list – head = [4,5,1,9], which looks like following:</p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/28/237_example.png" alt=""></p>
<p><strong>Example 1:</strong></p>
<p>Input: head = [4,5,1,9], node = 5<br>Output: [4,1,9]<br>Explanation: You are given the second node with value 5, the linked list should become 4 -&gt; 1 -&gt; 9 after calling your function.</p>
<p><strong>Example 2:</strong></p>
<p>Input: head = [4,5,1,9], node = 1<br>Output: [4,5,9]<br>Explanation: You are given the third node with value 1, the linked list should become 4 -&gt; 5 -&gt; 9 after calling your function.</p>
<p><strong>Note:</strong></p>
<ul>
<li>The linked list will have at least two elements.</li>
<li>All of the nodes’ values will be unique.</li>
<li>The given node will not be the tail and it will always be a valid node of the linked list.</li>
<li>Do not return anything from your function.</li>
</ul>
<hr>
<p>解：<br>注意，这道题只是考如何删除某个指定的节点，考的就是在无法知道这个节点前面指针的时候该如何操作。感觉和脑筋急转弯差不多。</p>
<p>因为我们不能操作这个节点前面的节点的next指针，所以要删除当前这个节点，就只能把下一个节点的值赋给当前这个节点，然后让当前节点跳过下一个节点。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public void deleteNode(ListNode <span class="keyword">node</span><span class="title">) &#123;</span></span><br><span class="line"><span class="title">        node</span>.val = <span class="keyword">node</span>.<span class="title">next</span>.val;</span><br><span class="line">        <span class="keyword">node</span>.<span class="title">next</span> = <span class="keyword">node</span>.<span class="title">next</span>.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="61-Rotate-List-旋转链表-Mid"><a href="#61-Rotate-List-旋转链表-Mid" class="headerlink" title="61. Rotate List(旋转链表)(Mid)"></a><a href="https://leetcode-cn.com/problems/rotate-list/" target="_blank" rel="noopener">61. Rotate List(旋转链表)(Mid)</a></h2><p>Given a linked list, rotate the list to the right by <em>k</em> places, where <em>k</em> is non-negative.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL, k = <span class="number">2</span></span><br><span class="line">Output: <span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;NULL</span><br><span class="line">Explanation:</span><br><span class="line">rotate <span class="number">1</span> steps to the right: <span class="number">5</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;NULL</span><br><span class="line">rotate <span class="number">2</span> steps to the right: <span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;NULL</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: <span class="number">0</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;NULL, k = <span class="number">4</span></span><br><span class="line">Output: <span class="number">2</span>-&gt;<span class="number">0</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br><span class="line">Explanation:</span><br><span class="line">rotate <span class="number">1</span> steps to the right: <span class="number">2</span>-&gt;<span class="number">0</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br><span class="line">rotate <span class="number">2</span> steps to the right: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">0</span>-&gt;NULL</span><br><span class="line">rotate <span class="number">3</span> steps to the right: <span class="number">0</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;NULL</span><br><span class="line">rotate <span class="number">4</span> steps to the right: <span class="number">2</span>-&gt;<span class="number">0</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br></pre></td></tr></table></figure>

<hr>
<p>解：这道题用双指针来解决，即快慢指针。</p>
<p>需要返回一个新的链表，就要考虑到定义一个虚拟头结点，这样可以省去每次都判断链表头是否为空。</p>
<p>用慢指针来标记反转之后的最后一个节点的位置。但是因为反转的k值可能大于之前的总长度，所以可以先用快指针遍历一遍链表得到总长度(顺便利于最后的rotation操作)，然后再移动slow指针过k个位置，最后再反转即可。</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode rotateRight(ListNode head, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// corner case</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.<span class="keyword">next</span> == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        ListNode fakeNode = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        fakeNode.<span class="keyword">next</span> = head;</span><br><span class="line">        ListNode fast = fakeNode, slow = fakeNode;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i;<span class="comment">//i用来存储链表长度,用来给k求余，这个和数组旋转差不多,k太大要求余</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; fast.<span class="keyword">next</span> != <span class="keyword">null</span>; i++) <span class="comment">// Get the total length</span></span><br><span class="line">            fast = fast.<span class="keyword">next</span>;<span class="comment">//此时fast已经在链表尾部了</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 需要注意最后移动完之后，slow的位置是在第 i-i%k 的位置的，相当于尾节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i - k % i; j++)<span class="comment">//让slow移动到第 i-k%i 个位置</span></span><br><span class="line">            slow = slow.<span class="keyword">next</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 最后进行反转,把fast指向原来的头结点</span></span><br><span class="line">        fast.<span class="keyword">next</span> = fakeNode.<span class="keyword">next</span>;</span><br><span class="line">        fakeNode.<span class="keyword">next</span> = slow.<span class="keyword">next</span>;</span><br><span class="line">        slow.<span class="keyword">next</span> = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> fakeNode.<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-Add-Two-Numbers-两数相加-Mid"><a href="#2-Add-Two-Numbers-两数相加-Mid" class="headerlink" title="2. Add Two Numbers(两数相加)(Mid)"></a><a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">2. Add Two Numbers(两数相加)(Mid)</a></h2><p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<p><strong>Example:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="string">(2</span> <span class="string">-&gt;</span> <span class="number">4</span> <span class="string">-&gt;</span> <span class="number">3</span><span class="string">)</span> <span class="string">+</span> <span class="string">(5</span> <span class="string">-&gt;</span> <span class="number">6</span> <span class="string">-&gt;</span> <span class="number">4</span><span class="string">)</span></span><br><span class="line"><span class="attr">Output:</span> <span class="number">7</span> <span class="string">-&gt;</span> <span class="number">0</span> <span class="string">-&gt;</span> <span class="number">8</span></span><br><span class="line"><span class="attr">Explanation:</span> <span class="number">342</span> <span class="string">+</span> <span class="number">465</span> <span class="string">=</span> <span class="number">807</span><span class="string">.</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：其实这道题看上去比较别扭，实际上可以理解，因为相当于链表的头指针从个位开始指，然后往后依次加起来</p>
<p>因为最后要返回一个新的链表，所以好的方法还是创建一个fakeNode。然后用sum表示当前求和结果，carry表示进位。</p>
<p>比较重要的两个公式是求加之后的位数值(sum%10)和加之后的进位的值(sum/10)。每次只要有加计算，就让current.next指向新创建的节点</p>
<p>需要考虑三个部分：</p>
<ol>
<li>两个链表都有数位的部分，也就是从个位，十位开始l1和l2都有数，此时求和(sum)的方法是<code>l1.val+l2.val+carry</code></li>
<li>l1或者l2有一个为null了，另一个不为null，此时用不为null的节点的值加上carry为新的sum</li>
<li>l1和l2都遍历完了，最后只需要看carry是不是0，如果不是0，意味着最后要开辟一个新节点，也就是返回的求和之后的链表长度为<code>l1的长度+l2的长度+1</code></li>
</ol>
<figure class="highlight q"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     <span class="type">int</span> val;</span><br><span class="line"> *     ListNode <span class="built_in">next</span>;</span><br><span class="line"> *     ListNode(<span class="type">int</span> x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        <span class="comment">// corner case</span></span><br><span class="line">        if(l1 == <span class="built_in">null</span>) return l2;</span><br><span class="line">        if(l2 == <span class="built_in">null</span>) return l1;</span><br><span class="line">        </span><br><span class="line">        ListNode fakeNode = new ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode current = fakeNode;</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>; <span class="comment">// carry表示进位</span></span><br><span class="line">        <span class="comment">// 第一段，l1和l2共有的部分</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="built_in">null</span> &amp;&amp; l2 != <span class="built_in">null</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="built_in">sum</span> = l1.val + l2.val + carry;</span><br><span class="line">            <span class="type">int</span> val = <span class="built_in">sum</span> % <span class="number">10</span>;</span><br><span class="line">            carry = <span class="built_in">sum</span> / <span class="number">10</span>;</span><br><span class="line">            current.<span class="built_in">next</span> = new ListNode(val);</span><br><span class="line">            current = current.<span class="built_in">next</span>;</span><br><span class="line">            l1 = l1.<span class="built_in">next</span>;</span><br><span class="line">            l2 = l2.<span class="built_in">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="built_in">null</span>) &#123; <span class="comment">// 此时l1 is not null, but l2 is null</span></span><br><span class="line">            <span class="type">int</span> <span class="built_in">sum</span> = l1.val + carry;</span><br><span class="line">            <span class="type">int</span> val = <span class="built_in">sum</span> % <span class="number">10</span>;</span><br><span class="line">            carry = <span class="built_in">sum</span> / <span class="number">10</span>;</span><br><span class="line">            current.<span class="built_in">next</span> = new ListNode(val);</span><br><span class="line">            current = current.<span class="built_in">next</span>;</span><br><span class="line">            l1 = l1.<span class="built_in">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l2 != <span class="built_in">null</span>) &#123; <span class="comment">// 此时l2 is not null, but l1 is null</span></span><br><span class="line">            <span class="type">int</span> <span class="built_in">sum</span> = l2.val + carry;</span><br><span class="line">            <span class="type">int</span> val = <span class="built_in">sum</span> % <span class="number">10</span>;</span><br><span class="line">            carry = <span class="built_in">sum</span> / <span class="number">10</span>;</span><br><span class="line">            current.<span class="built_in">next</span> = new ListNode(val);</span><br><span class="line">            current = current.<span class="built_in">next</span>;</span><br><span class="line">            l2 = l2.<span class="built_in">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//此时遍历完了所有l1和l2的节点，只看最后需不需要新进一位</span></span><br><span class="line">        <span class="comment">// 进位完之后新链表长度是l1和l2长度和 +1</span></span><br><span class="line">        if(carry != <span class="number">0</span>) current.<span class="built_in">next</span> = new ListNode(carry);</span><br><span class="line">        </span><br><span class="line">        return fakeNode.<span class="built_in">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实可以简化代码，虽然不如上面的好理解，但是公式是完全相同的(就是<code>sum%10</code>和<code>sum/10</code>)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">待填</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithms Note</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Object Oriented Programming(OOP)</title>
    <url>/2019/12/25/Object-oriented-OOP/</url>
    <content><![CDATA[<p><img src="https://s2.ax1x.com/2019/12/30/lKcqcd.md.jpg" alt=""></p>
<blockquote>
<p>在乎的是，自己以及他所在乎的人，能不能够秉持着自己的心意与信念，在人生中大部分时间里都能自在、快乐</p>
</blockquote>
<a id="more"></a>

<p>本文参考<a href="https://blog.csdn.net/baidu_33714003/article/details/52290627" target="_blank" rel="noopener">https://blog.csdn.net/baidu_33714003/article/details/52290627</a></p>
<h1 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h1><ol>
<li><strong>出发点不同</strong>。面向对象强调把问题直接映射到对象以及对象之间的接口上；而面向过程强调的则是过程的抽象化和模块化，它是以过程为中心构造或者处理客观世界问题的。</li>
<li><strong>层次逻辑关系不同</strong>。面向对象尽量会用计算机逻辑来模拟客观世界的物理存在，用类的层次结构展现类之间的继承和发展；而面向过程的处理问题的基本单位是能够清晰准确表达过程的模块，而且用模块之间的关系和内容表述计算机处理问题的过程。</li>
<li><strong>数据处理方式与控制程序方式不同</strong>。面向对象方法是”事件驱动”的，通过事件来激活和运行程序，而且它会把对应的代码封装成一个整体，原则上其他类不能直接修改其数据；面向过程则通过直接调用程序来处理数据，处理完后显示结果，在控制的方式上是按照涉及调用或者返回程序，不能导航，各模块之间存在控制与被控制，调用与被调用的关系。</li>
<li><strong>分析设计与编码转换方式不同</strong>。面向对象是无缝连接，从分析到设计再到编码是采用一致性的模型表示的；面向对象是有缝链接，它强调分析、设计以及编码之间按照规则的转换，过程中使用的模型是不一样的。</li>
</ol>
<h1 id="面向对象有哪些特征"><a href="#面向对象有哪些特征" class="headerlink" title="面向对象有哪些特征"></a>面向对象有哪些特征</h1><p>应当记住这段话：<strong>封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而多态则是为了实现另一个目的——接口重用！多态的作用，就是为了类在继承和派生的时候，保证使用“家谱”中任一类的实例的某一属性时的正确调用。</strong></p>
<p>主要包括：抽象、继承、封装和多态</p>
<ol>
<li><strong>抽象</strong>。抽象包括两个方面，一是<strong>过程抽象</strong>，二是<strong>数据抽象</strong>；忽略一个主体中与当前目标无关的方面和细节，以便更充分地注意与当前目标有关的方面。</li>
<li><strong>封装</strong>。可以说是最好理解的了，把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。</li>
<li><strong>继承</strong>。通过继承，子类可以使用父类中的一些成员变量和方法，从而能够提高代码的复用性，提高开发效率。</li>
<li><strong>多态</strong>。多态也是实现代码重用的重要机制，简单来说，就是实现接口的重用。它能够实现父类和一个或者多个它的子对象<strong>相等</strong>，但是有不同的表现形式。专业点说，就是<strong>允许将子类类型的指针赋值给父类类型的指针</strong>。</li>
</ol>
<h2 id="详解继承"><a href="#详解继承" class="headerlink" title="详解继承"></a>详解继承</h2><p>继承可以让子类使用父类中的一些成员变量和方法，从而能够提高代码复用性，提高开发效率。</p>
<p>继承的特点：在继承关系中，父类更通用，子类更具体。父类具有更一般的特征和行为，而子类除了具有父类的特征和行为，还具有一些自己特殊的特征和行为。</p>
<p>Java语言中，有关继承的术语主要是，被继承类叫做的父类或者基类(superclass)，继承父类的类叫做派生类或子类(subclass)。</p>
<p>在继承关系中，父类和子类需要满足”is-a”的关系，”子类是父类”。</p>
<h3 id="继承的特性"><a href="#继承的特性" class="headerlink" title="继承的特性"></a>继承的特性</h3><ol>
<li>Java语言不支持多重继承，也就是说一个子类至多只能有一个父类，但是可以通过实现多个接口来达到多重继承的目的，这一点上可以理解继承和多态有了overlap</li>
<li><strong>子类只能继承父类的非私有(public 和 protected)成员变量和方法</strong>。<font color=#FF0000>注意这一点经常容易出题，注意是”子类能继承父类的非私有方法和状态”</font></li>
<li>当子类中的成员变量与父类中的成员变量同名时，子类中的成员变量会覆盖父类的成员变量，而不会继承。可以理解为”就近原则”</li>
<li>当子类中的方法与父类中的方法有相同的函数签名(相同的方法名，相同的参数个数与类型)时，子类将会覆盖父类的方法，而不会继承。</li>
</ol>
<h3 id="为什么要继承？什么时候应该避免继承？"><a href="#为什么要继承？什么时候应该避免继承？" class="headerlink" title="为什么要继承？什么时候应该避免继承？"></a>为什么要继承？什么时候应该避免继承？</h3><p>继承可以有效实现代码复用，避免重复代码的出现。</p>
<p>当两个类具有相同的特征(属性)和行为(方法)时，可以将相同的部分抽取出来放到一个类中作为父类，其他两个类继承这个父类。</p>
<p>继承实现了面向对象的原则：write once, only once(编写一次，且只编写一次)</p>
<p>实际上，能用组合(下面<code>继承与组合的区别</code>部分有介绍什么是组合)的话就尽量别用继承，除非两个类之间确定是”is-a”的关系。<font color=#FF0000>具体使用，应当遵循以下两点原则</font>：</p>
<ol>
<li>除非两个类之间是”is-a”的关系，否则不要轻易使用继承。不要单纯为了实现代码重用而使用继承，因为过多的继承会破坏代码的可维护性，因为当父类被修改时，会影响所有继承了它的子类，从而增加程序的维护难度与成本。</li>
<li>不要仅仅为了实现多态而使用继承，如果类之间没有”is-a”的关系，可以通过实现接口与组合的方式来达到相同的目的。设计模式中的策略模式可以很好地说明这一点，采用接口与组合的方式比采用继承的方式具有更好的可扩展性。</li>
</ol>
<h4 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4><p>由于Java只支持单继承，如果想要同时继承两个类或多个类，无法用继承实现，只能选择实现多个接口。</p>
<p>同时，Java语言中，如果继承使用太多，也会让一个class里面的内容变得臃肿不堪。<font color=#FF0000>所以，在Java语言中，能使用组合就尽量不要用继承。</font></p>
<h3 id="如何实现继承"><a href="#如何实现继承" class="headerlink" title="如何实现继承"></a>如何实现继承</h3><p>在Java中，用extends(扩展)关键字实现，使用格式为：</p>
<p><code>class 子类名 extends 父类名</code></p>
<p>在父类中只定义一些通用的属性和方法，之后子类继承父类之后自动获取父类的属性和方法。当然子类可以定义特定的属性和方法，或子类重新定义父亲的属性、重写父亲的方法，这样可以获得与父类不同的功能。</p>
<p>如果想在子类中使用父类的构造方法，可以通过super()关键字调用父类方法，但是要注意调用父类的构造方法语句(super语句)必须是构造方法中的第一条语句，因为创建对象时西安仓就爱你父类对象，再创建子类对象。如果没有显示调用父类的构造方法，将自动调用父类的无参构造方法。</p>
<h3 id="一切类的老大-祖先-Object"><a href="#一切类的老大-祖先-Object" class="headerlink" title="一切类的老大(祖先)Object"></a>一切类的老大(祖先)Object</h3><p>所有类都直接或者间接地继承了java.lang.Object类，Object类中定义了所有的java对象都具有的相同行为，是所有类的祖先。</p>
<p>一个类如果没有使用extends关键字，那么这个类直接继承自Object类。</p>
<h3 id="继承与组合的区别"><a href="#继承与组合的区别" class="headerlink" title="继承与组合的区别"></a>继承与组合的区别</h3><p>继承和组合是面向对象的两种代码复用的方式。<strong>组合是指在新类里面创建原有类的对象，从而重复利用已有类的功能</strong>，而<strong>继承则允许设计人员根据其他类的实现来定义一个新类的实现。</strong></p>
<p>继承和组合都允许在新的类中定义子对象，但是组合是显示的，继承是隐式的。</p>
<p>组合与继承存在着对应关系：组合中的整体类和继承中的子类对应，组合中的局部类和继承中的父类对应。</p>
<p>正如之前所说了，在继承中父类和子类需要满足”is-a”的关系，即要满足”子类是父类”；而组合则是两个类之间有”<br>has-a”的关系，即”组合类有父类”</p>
<p>比如现在有三个类：Car(汽车)、Vehicle(交通工具)、Tire(轮胎)，那么正确的关系应该是：Car继承Vehicle(汽车是交通工具)、Car组合Tire(汽车拥有多个轮胎)，具体实现方法如下代码：</p>
<p>继承：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">extends</span> <span class="title">Vehicle</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组合：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tire</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">extends</span> <span class="title">Vehicle</span></span>&#123;</span><br><span class="line">	<span class="type">Tire</span> tire = <span class="keyword">new</span> <span class="type">Tire</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承和组合在实际使用中的选择，可以参考上面<code>什么时候应该避免使用继承？</code>模块。</p>
<h2 id="详解多态"><a href="#详解多态" class="headerlink" title="详解多态"></a>详解多态</h2><p>多态是实现代码重用的重要机制，主要表现在同一个操作在作用在不同对象的时候，有不同的语义(或者说操作内容不同)，从而会产生不同的结果。</p>
<h3 id="使用多态的好处"><a href="#使用多态的好处" class="headerlink" title="使用多态的好处"></a>使用多态的好处</h3><p>可以增强程序的可扩展性以及可维护性，也可以使得代码更加简洁。</p>
<h3 id="实现多态机制的方法"><a href="#实现多态机制的方法" class="headerlink" title="实现多态机制的方法"></a>实现多态机制的方法</h3><p>实现多态机制主要有两种方法：方法重载(overload)和方法覆盖(override)(也叫作方法重写)</p>
<h3 id="方法重载-overload"><a href="#方法重载-overload" class="headerlink" title="方法重载(overload)"></a>方法重载(overload)</h3><p>具体实现：</p>
<p>方法的重载(overload)：重载是发生在<strong>类内部</strong>，实质是不同的方法，也可以用不同的方法名进行替换，但是采用同一方法名能间接体现方法之间的内在相似性。</p>
<p>使用方法重载的目的：</p>
<ol>
<li>节省方法名</li>
<li>体现这些方法之间的内在联系</li>
</ol>
<p>举例：</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class KeyValue &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">HashMap</span>&lt;<span class="keyword">String</span> , <span class="keyword">Object</span>&gt; kvs = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> KeyValue put(<span class="keyword">String</span> <span class="built_in">key</span> , <span class="built_in">int</span> value) &#123;</span><br><span class="line">        kvs.put(<span class="built_in">key</span> , value);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> KeyValue put(<span class="keyword">String</span> <span class="built_in">key</span> , <span class="keyword">long</span> value) &#123;</span><br><span class="line">        kvs.put(<span class="built_in">key</span> , value);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> KeyValue put(<span class="keyword">String</span> <span class="built_in">key</span> , <span class="keyword">String</span> value)&#123;</span><br><span class="line">    	kvs.put(<span class="built_in">key</span> , value);</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为这些有着相同方法名的方法参数不同，所以在<strong>编译时</strong>就可以确定到底用哪个方法，<font color=#FF0000>它是一种编译时多态</font>。</p>
<h3 id="方法覆盖-重写-override"><a href="#方法覆盖-重写-override" class="headerlink" title="方法覆盖/重写(override)"></a>方法覆盖/重写(override)</h3><p>方法覆盖发生在继承里，子类根据需要，重写继承的方法。</p>
<p>目的：用父类的方法名重写了一个新的方法。</p>
<p>需要覆盖的方法要和父类方法具有完全相同的方法名，返回值，参数列表（个数、类型、顺序）</p>
<p>举例：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">String</span> name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">String</span> <span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">	Base()&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">printFuc</span><span class="params">(<span class="keyword">int</span> data,<span class="keyword">char</span> cr,<span class="keyword">String</span> strings)</span></span>&#123;</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"父类"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现多态的子类为SubBase</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">SubBase</span> <span class="symbol">extends</span> <span class="symbol">Base</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span> printFuc(<span class="built_in">int</span> data,char cr,String <span class="built_in">string</span>s)&#123;</span><br><span class="line">		<span class="built_in">int</span> a=<span class="number">3</span>;</span><br><span class="line">		<span class="built_in">int</span> b=<span class="number">3</span>;</span><br><span class="line">		<span class="keyword">class</span> <span class="symbol">inner</span>&#123;</span><br><span class="line">			<span class="keyword">public</span> <span class="built_in">int</span> add(<span class="built_in">int</span> a, <span class="built_in">int</span> b)&#123;</span><br><span class="line">				<span class="keyword">return</span> a + b;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		inner nomean = new inner();</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"重写父类"</span>);</span><br><span class="line">		<span class="keyword">return</span> nomean.add(a , b);		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有在<strong>运行时</strong>才能确定调用哪个方法，因此<font color=#FF0000>通过方法覆盖实现的多态也被称为运行时多态</font>。</p>
<h2 id="继承与多态的区别"><a href="#继承与多态的区别" class="headerlink" title="继承与多态的区别"></a>继承与多态的区别</h2><p>继承，子类继承父类中所以的属性和方法，但是对于private的属相和方法，由于这个是父类的隐私，所以子类虽然是继承了，但是没有可以访问这些属性和方法的引用，所以相当于没有继承到。很多时候，可以理解为，没有继承。</p>
<p>多态：就是父类引用可以持有子类对象。这时候只能调用父类中的方法，而子类中特有方法是无法访问的，因为这个时候（编译时）你把他看作父类对象的原因，但是到了运行的时候，编译器就会发现这个父类引用中原来是一个子类的对像，所以如果父类和子类中有相同的方法时，调用的会是子类中的方法，而不是父类的。</p>
<p>可以这么说：编译时看父类，运行时看子类。</p>
]]></content>
  </entry>
  <entry>
    <title>Design Pattern</title>
    <url>/2019/12/25/Design-Pattern/</url>
    <content><![CDATA[<blockquote>
<p>看待事物都可以按照这个顺序：发现问题、分析问题、理顺逻辑、寻求证据、解决问题</p>
</blockquote>
<p>设计模式相关内容介绍，尤其着重Java的单例模拟，看完必有收获。</p>
<a id="more"></a>

<h1 id="常见的设计模式有哪些？"><a href="#常见的设计模式有哪些？" class="headerlink" title="常见的设计模式有哪些？"></a>常见的设计模式有哪些？</h1><p>设计模式分为 3 大类型共 23 种：</p>
<ol>
<li><p>创建型：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p>
</li>
<li><p>结构型：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p>
</li>
<li><p>行为型：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p>
</li>
</ol>
<p>最常见的设计模式有：单例模式、工厂模式、代理模式、构造者模式、责任链模式、适配器模式、观察者模式等。</p>
<h1 id="如何用java写一个单例模式？"><a href="#如何用java写一个单例模式？" class="headerlink" title="如何用java写一个单例模式？"></a>如何用java写一个单例模式？</h1><p>只能生成一个实例的类是实现了Singleton(单例)模式的类。由于设计模式在面向对象编程中起到了举足轻重的作用，所以在面试中很多公司都会问。而在常用的设计模式中，Singleton是唯一一个能够用短短几十行代码完整实现的设计模式，<font color=#FF0000>所以写一个Singleton是一个很常见的面试题</font>。</p>
<p>单例模式虽然看起来简单，但是如果往深了挖，又可以考察出候选者对于并发、类加载、序列化等知识点的掌握。</p>
<h2 id="什么是单例模式？"><a href="#什么是单例模式？" class="headerlink" title="什么是单例模式？"></a>什么是单例模式？</h2><p>如上面所说，只能生成一个实例的类是实现了Singleton(单例模式)的类，也就是一个单例模式的类只有一个实例，并且提供一个全局可以访问的入口(比如getInstance()方法)。比如《火影忍者》中漩涡鸣人特别喜欢用的影分身之术，实际上，每一个影分身都只对应着一个真身。</p>
<p>为什么要有只有一个实例的这种类？我们为什么需要它？</p>
<p><strong>理由一：</strong>为了节省内存、节省计算。很多情况下，我们只需要一个实例，如果出现了更多实例，反而是浪费。</p>
<p>举例：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">ExpensiveResource</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ExpensiveResource() &#123;</span><br><span class="line">        field1 = <span class="comment">// 查询数据库</span></span><br><span class="line">        field2 = <span class="comment">// 对查到的数据做大量计算</span></span><br><span class="line">        field3 = <span class="comment">// 加密、压缩等耗时操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类在构造的时候，需要查询数据库，对查到的数据做大量的计算，然后还要进行加密、压缩等非常耗时的操作。所以在第一次构造这个类的时候，我们就要花费很多时间来初始化这个对象。</p>
<p>假设数据库在一段时间不变，那么我们其实只需要使用这一个实例完成任务即可。如果每次都重新生成新的实例，浪费资源，十分没有必要。</p>
<p><strong>理由二：</strong>为了保证结果的正确。比如我们需要一个全局计数器用来统计人数。如果有多个实例，反而会造成混乱。</p>
<p><strong>理由三：</strong>方便管理。很多工具类，我们只需要一个实例，通过一个统一的入口，获取这个单例。太多实例不但没有帮助，只会让人眼花缭乱。</p>
<h2 id="单例模式使用场景？"><a href="#单例模式使用场景？" class="headerlink" title="单例模式使用场景？"></a>单例模式使用场景？</h2><ol>
<li><p><strong>无状态的工具类：日志工具、字符串工具等</strong>。——日志工具，不论在哪里使用，我们只需要它帮我们记录日志信息，除此功能之外并不需要在它的实例对象上存储任何状态，所以我们只需要一个实例对象就可以了。</p>
</li>
<li><p><strong>全局信息类：全局计数、环境变量</strong>。——比如我们要记录某个网站的访问次数，而且不希望有的访问记录被记录在对象A上，而有的被记录在对象B上。此时我们就可以让这个类为单例，在需要计数的时候拿出来用就可以了。</p>
</li>
</ol>
<p><font color=#FF0000>单例模式常见写法，这里列举五种：饿汉式、懒汉式、双重检查式、静态内部类式、枚举式</font></p>
<h2 id="单例模式的实现"><a href="#单例模式的实现" class="headerlink" title="单例模式的实现"></a>单例模式的实现</h2><p>下面按照写法的难易程度逐层递进：<br>相对简单的<strong>饿汉式：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 饿汉式写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类的第一行，用static修饰实例，并且把构造函数用private修饰。</p>
<p><font color=#FF0000>注：static关键字本身很重要的一个用途就是实现单例模式。</font>单例模式特点是只能有一个实例，为了实现这一功能，必须隐藏类的构造函数，即把构造函数声明为private，并提供一个创建对象的方法。由于构造对象被声明为private，所以外界无法直接创建这个对象，只能通过该类提供的方法来获取类的对象，要达到这样的目的只能把创建对象的方法声明为static.</p>
<p><strong>饿汉式优点：</strong>这种写法比较简单，在类装载的时候就完成了实例化，避免了线程同步的问题。</p>
<p><strong>饿汉式缺点：</strong>类装载的时候就完成了实例化，没有达到懒加载的效果，这点是最大缺陷。所以如果自始至终都没使用过这个实例，就可能会造成内存的浪费。</p>
<p>饿汉式写法的变种：<strong>静态代码块</strong>形式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 饿汉式另一种写法，静态代码块</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法和最开始的饿汉式的方式类似，只是把类实例化的过程放在了静态代码块中。同样，在类装载的过程中会执行静态代码块中的代码，完成实例的初始化，所以静态代码块的优缺点和饿汉式是一样的。<em>静态代码块写法就是饿汉式的写法。</em></p>
<p>接下来看第二种<strong>懒汉式</strong>。</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线程不安全的懒汉式写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是需要注意，上面这个懒汉式写法只能用于单线程。因为如果一个线程进入了 <code>if(singleton == null)</code> 判断语句块，还没来得及往下执行，另一个线程也通过了这个判断语句，此时会多次创建实例。所以这里需要注意，在多线程环境下，不能用上面这种懒汉式写法，它是错误的。</p>
<p>当然，懒汉式写法可以进行升级，让其成为线程安全的懒汉式写法。升级之后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线程安全的懒汉式写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加上了synchronized关键字，为了解决刚才的线程安全问题。<strong>缺点是效率太低了</strong>，每个线程在想获得类的实例的时候，执行getInstance的时候都要进行同步，虽然保证了多个线程不能同时访问，但是这在大多数情况下是没有必要的。</p>
<p>为了解决这个问题，衍生出了<strong>双重检查模式</strong>。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双重检查模式写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点在getInstance方法，我们进行了两次 <code>if(singleton == null)</code> 的判断，这样可以保证线程安全了。可以想象，在第一次初始化了singleton对象之后，再次调用代码块的时候，第一个if判断就可以让执行跳过整个代码块，返回之前已经初始化过的singleton,避免破坏单例。</p>
<p>这种写法的优势是，不仅保证了线程安全，而且延迟加载，效率也更高。</p>
<p>这里会有一个面试经常会问到的问题：”为什么要有两个if判断呢？去掉第二个if，可以么？(或者说，为什么要double-check?去掉第二个check行不行呢？)”</p>
<p>结论是，不行。为什么不行？我们来考虑这样的情景：</p>
<p>有两个线程同时调用getInstance()方法，由于singleton是空的，所以两个线程都可以通过第一重if判断。然后由于锁机制的存在，会有一个线程进入到第二个判断语句，而另一个线程会在外等候。过了一小段时间，第一个线程完成了对singleton的创建操作，它会退出synchronized的保护区域。此时第二个线程会进入到运行区域。此时如果没有第二个if判断，那么第二个线程也会创建一个实例，这就破坏了单例，这肯定是不行的。</p>
<p>当然，第一个check也是不能去掉的。如果去掉了第一个check,那么所有线程都会串行执行，效率低下。所以，<strong>两个check都是需要保留的</strong>。</p>
<p>此外，在双重检查模式中，我们给singleton加了 <code>volatile</code> 关键字。为什么要增加volatile呢？</p>
<p>原因在于， <code>singleton = new Singleton();</code> 这句话不是一个原子操作。事实上，在JVM中，这句话至少做了<strong>3件事</strong>：</p>
<ol>
<li>给singleton分配内存空间</li>
<li>调用Singleton的构造函数等来初始化singleton</li>
<li>将singleton对象指向分配的内存空间(执行完这步，singleton就不是Null了)</li>
</ol>
<p>但是这里需要注意1、2、3步骤的顺序。因为存在着重排序的优化。也就是说，<strong>第二步和第三步这两者的顺序是不能保证的</strong>。</p>
<p>最终的执行顺序可能是1-2-3，也可能是1-3-2。如果是1-3-2，那么如果第一个线程正在创建的时候，另一个线程也进来了，那么在进行第一重判断的时候会直接跳过整个代码块，直接返回singleton对象。而此时因为singleton还没有被初始化，所以会有空指针报错。哪怕最后线程1最后的初始化了，但是只是姗姗来迟，程序已经报错了。</p>
<p>用图解详细分析一下：<br><img src="https://s2.ax1x.com/2020/01/10/lfTzJs.png" alt="lfTzJs.png"></p>
<p>总结用volatile的原因：<strong>它可以防止上面重排序的发生，可以避免拿到未完成初始化的对象。</strong></p>
<p>下面来看静态内部类的写法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态内部类写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span> &#123;</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法和饿汉式所采用的机制类似，都才用了类装载的机制：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以此保证我们初始化实例时只有一个线程，而且是JVM帮助我们保证了线程安全性。</p>
<p>但是，饿汉式有一个特点，就是只要Singleton这个类被加载了，就会实例化单例对象。而静态内部类方式在Singleton类被装载的时候，并不会立刻实例化，而是在需要实例的时候，也就是调用getInstance()方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SingletonInstance.singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>的时候，才会去完成对singleton实例的实例化。</p>
<p><strong>静态内部类写法优点：</strong></p>
<ol>
<li>代码简洁，和双重检查的单例模式对比，静态内部类的单例实现代码更加简洁，清晰明了。</li>
<li>延迟初始化，调用getInstance()才会初始化Singleton对象。</li>
<li>线程安全。JVM在执行类的初始化阶段，会获得一个可以同步多个线程对同一个类的初始化锁。</li>
</ol>
<p>在介绍枚举写法之前，做一个小总结：</p>
<p><strong>静态内部类的写法与双重检查模式的优点是一样的，都避免了线程不安全的问题，并且延迟加载，效率高。</strong></p>
<p>可以看出，静态内部类和双重检查都是不错的写法。但是这两种方法都有一个缺陷：<strong>不能防止被反序列化。</strong></p>
<p>最后，枚举类的写法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 枚举类写法实现单例模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whatereverMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举类是在JDK1.5之后新增的方法。它不仅可以避免多线程同步的问题，而且还能防止反序列化和反射(这两种方法可以创建新的对象)破坏单例模式。</p>
<p>上面讲了五种方式，但是可以说，实现单例模式最好的方式，是利用枚举。这个观点其实是Josh Bloch的。他曾经在Effective Java中写道：”使用枚举实现单例的方法，虽然还没有被广泛采用，但是单元素的枚举类型应成为了实现Singleton的最佳方法。”</p>
<p>他如此推崇枚举，主要还是因为枚举写法的优点：</p>
<ol>
<li>代码简洁。枚举的写法不需要我们去考虑懒加载或者线程安全等问题。同时，代码短小精悍，比其他任何写法都更加简洁。</li>
<li>线程安全有保障。通过反编译枚举类，我们可以发现枚举种的各个枚举项，都是通过static代码块来定义和初始化的。他们会在类被加载的时候完成初始化。而java类的加载由JVM保证线程安全。所以，创建一个Enum类型的枚举是线程安全的。</li>
<li>最重要的优点：<strong>防止破坏单例</strong>。java专门对枚举的序列化做了单独的规定。在<strong>序列化</strong>的时候，仅仅会将枚举对象的name属性输出到结果中。而在反序列化时，会通过 <code>java.lang.Enum</code> 的valueOf方法来根据名字查找对象，而不会新建一个新的对象。这就防止了反序列化导致的单例破坏问题的出现。而针对<strong>反射</strong>，枚举类同样有防御措施。反射在通过newInstance创建对象时，会检查这个类是否是枚举类。如果是，会抛出： <code>IllegalArgumentException(&quot;Cannot reflecatively create enum objects&quot;)</code> 这个异常，反射创建对象会失败。可以说，java针对枚举做的工作是非常全面的，枚举，是java亲生的。</li>
</ol>
<p>可以看出，枚举这种方式可以防止反序列化和反射破坏单例，在这一点上与其他方式相比，优势巨大。安全问题不容小觑，一旦通过反序列化或者反射生成了多个实例，那么单例模式就彻底没用了。</p>
<p>总结：<br><img src="https://s2.ax1x.com/2020/01/10/lhCFII.png" alt="lhCFII.png"></p>
<p>需要注意，如果使用了线程不安全的写法，在并发的情况下可能产生多个实例，那么不仅会影响性能，更可能造成数据错误等严重的后果。</p>
<p>回答面试问题过程中，可以先从饿汉式、懒汉式说起，一步一步地分析每一种的优缺点，并且对写法进行演进。重点需要关注，<strong>双重检查模式为什么需要两次检查？为什么要是用volatile关键字？</strong>最后再说枚举类写法的优点和其背后的原理。</p>
<p>此外，在工作中，如果遇到了<strong>全局信息类、无状态工具类</strong>等场景，推荐使用枚举的写法实现单例模式。</p>
<h1 id="备注-static、volatile"><a href="#备注-static、volatile" class="headerlink" title="备注(static、volatile)"></a>备注(static、volatile)</h1><h2 id="static关键字用法"><a href="#static关键字用法" class="headerlink" title="static关键字用法"></a>static关键字用法</h2><p>static关键字在Java中主要有四种定义的类型：成员变量、成员方法、代码块和内部类</p>
<h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>Java语言没有全局变量的概念，但是可以通过static达到全局变量的效果。</p>
<p>不同于普通的实例变量(new出来对象之后才定义的对象)，用static修饰的变量为静态变量，<strong>只要静态变量所在的类被加载，这个静态变量就会被分配空间，后面每次只要使用这个变量，就是唯一的</strong>。</p>
<p>静态变量只有一个，被类拥有，所有对象都共享这个静态变量，而实例对象是与具体对象相关的。需要注意的是，与C++语言不同的是，在Java语言中，不能在方法中定义static变量。</p>
<h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p>static方法是类的方法，不需要创建对象就可以被调用，而非static方法是对象的方法，只有对象被创建出来后才可以被使用。</p>
<p>static方法中不能使用this和super关键字，不能调用非static方法，只能访问所属类的静态成员变量和成员方法，因为当static方法被调用时，这个类的对象可能还没被创建，即使已经被创建了，也无法确定调用哪个对象的方法。同理，static方法也不能访问非static类型的变量。</p>
<h3 id="static代码块"><a href="#static代码块" class="headerlink" title="static代码块"></a>static代码块</h3><p>static代码块，即静态代码块，在类中是独立于成员变量和成员函数的代码块的。注意它不会被定义在任何一个方法体内，JVM在加载类时会执行static代码块，如果有多个static代码块，JVM会按顺序执行。static代码块经常被用于初始化静态变量，而且只会被加载一次。</p>
<h3 id="static内部类"><a href="#static内部类" class="headerlink" title="static内部类"></a>static内部类</h3><p>static内部类指被声明为static的内部类，他可以不依赖于外部实例对象而被实例化，而通常的内部类需要在外部类实例化后才能实例化。静态内部类不能与外部类有相同的名字，不能访问外部类的普通成员变量，只能访问外部类中的静态成员和静态方法(包括私有类型)。</p>
<h2 id="static和final组合"><a href="#static和final组合" class="headerlink" title="static和final组合"></a>static和final组合</h2><p>被final修饰的变量，都是指不能被修改的。</p>
<p>在Java中，static关键字经常和final结合使用，用来修饰成员变量和成员方法，修饰之后的变量类似C/C++中的全局变量。</p>
<ul>
<li>对于变量，若使用static final修饰，则表示一旦赋值，就不可以修改，并且通过类名可以访问。</li>
<li>对于方法，若使用static final修饰，则表示该方法不可覆盖并且可以通过类名直接访问。</li>
</ul>
<p><font color=#FF0000>在Java中，不能在成员函数内部定义static变量</font></p>
<h2 id="volatile有什么用"><a href="#volatile有什么用" class="headerlink" title="volatile有什么用"></a>volatile有什么用</h2><p>用Java语言编写的程序中，有时为了提高程序的运行效率，编译器会自动对其进行优化，把经常访问的变量缓存起来，程序在读取这个变量时有可能会直接从缓存(例如寄存器)中来读取这个值，而不会去内存中读取。这样做的一个好处是提高了程序的运行效率，但当遇到多线程编程时，某个变量的值可能因为其他线程的使用而改变了，但是因为该值的缓存的值不会改变，所以会造成程序读取的值和其实际的值不一致。</p>
<p>举个可以解决问题的例子，在本次线程内，当读取一个变量时，为了提高读取速度，优先把变量存入到缓存中，之后再取变量的值时，直接从缓存中读。当变量值改变的时候，需要把新的值复制到该缓存中，以便保持一致。</p>
<p><code>volatile</code>是一个类型修饰符(type specifier)，当初设计它的用途就是用来修饰被不同线程访问和修改的变量，被<code>volatile</code>修饰之后，<strong>系统默认每次使用它的时候都是从内存中提取，而不会利用缓存</strong>。在使用了volatile修饰之后，所有线程看到的同一变量的值都是相同的。</p>
<p>一个代码例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Boolean flag;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(flag) &#123;</span><br><span class="line">            ; <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码可以停止线程，也是最常用的一种方法。如果变量flag没有被volatile修饰，那么当这个线程的run方法在判断flag值的时候，使用的有可能是缓存中的值，此时就不能即时地获取其他线程对flag所做的操作，因此会导致线程不能及时地停止。</p>
<p><strong>需要注意</strong>，volatile不能保证操作原子性，所以volatile不能代替synchronized，此外volatile会阻止编译器对代码的优化，降低执行效率，所以一般来说能不用就不用volatile.</p>
<h1 id="常用的设计模式与使用场景"><a href="#常用的设计模式与使用场景" class="headerlink" title="常用的设计模式与使用场景"></a>常用的设计模式与使用场景</h1><p>例如，在回答 “你知道哪几种设计模式” 这个问题时，不但能说出几种设计模式，以及适合哪类场景，而且还能指出哪些著名的框架在处理什么问题时使用了哪种设计模式，或者自己在处理某个项目的什么场景时，使用了哪种设计模式，取得了什么效果，这样肯定会给面试官留下非常好的印象。</p>
<h2 id="1-工厂模式：Spring如何创建Bean"><a href="#1-工厂模式：Spring如何创建Bean" class="headerlink" title="1.工厂模式：Spring如何创建Bean"></a>1.工厂模式：Spring如何创建Bean</h2><p>工厂模式是创建不同类型实例时常用的方式，例如 Spring 中的各种 Bean 是有不同 Bean 工厂类进行创建的。</p>
<h2 id="2-代理模式：Motan服务的动态代理"><a href="#2-代理模式：Motan服务的动态代理" class="headerlink" title="2.代理模式：Motan服务的动态代理"></a>2.代理模式：Motan服务的动态代理</h2><p>代理模式，主要用在不适合或者不能直接引用另一个对象的场景，可以通过代理模式对被代理对象的访问行为进行控制。Java 的代理模式分为静态代理和动态代理。静态代理指在编译时就已经创建好了代理类，例如在源代码中编写的类；动态代理指在 JVM 运行过程中动态创建的代理类，使用动态代理的方法有 JDK 动态代理、CGLIB、Javassist 等。面试时遇到这个问题可以举个动态代理的例子，比如在 Motan RPC 中，是使用 JDK 的动态代理，通过反射把远程请求进行封装，使服务看上去就像在使用本地的方法。</p>
<h2 id="3-责任链模式：Netty消息处理的方式"><a href="#3-责任链模式：Netty消息处理的方式" class="headerlink" title="3.责任链模式：Netty消息处理的方式"></a>3.责任链模式：Netty消息处理的方式</h2><p>责任链模式有点像工厂的流水线，链上每一个节点完成对对象的某一种处理，例如 Netty 框架在处理消息时使用的 Pipeline 就是一种责任链模式。</p>
<h2 id="4-适配器模式：SLF4J如何支持Log4J"><a href="#4-适配器模式：SLF4J如何支持Log4J" class="headerlink" title="4.适配器模式：SLF4J如何支持Log4J"></a>4.适配器模式：SLF4J如何支持Log4J</h2><p>适配器模式，类似于我们常见的转接头，把两种不匹配的对象来进行适配，也可以起到对两个不同的对象进行解藕的作用。例如我们常用的日志处理框架 SLF4J，如果我们使用了 SLF4J 就可以跟 Log4j 或者 Logback 等具体的日志实现框架进行解藕。通过不同适配器将 SLF4J 与 Log4j 等实现框架进行适配，完成日志功能的使用。</p>
<h2 id="5-观察者模式：GRPC是如何支持流式请求的"><a href="#5-观察者模式：GRPC是如何支持流式请求的" class="headerlink" title="5.观察者模式：GRPC是如何支持流式请求的"></a>5.观察者模式：GRPC是如何支持流式请求的</h2><p>观察者模式也被称作发布订阅模式，适用于一个对象的某个行为需要触发一系列事件的场景，例如 gRPC 中的 Stream 流式请求的处理就是通过观察者模式实现的。</p>
<h2 id="6-构造者模式：PB序列化中的Builder"><a href="#6-构造者模式：PB序列化中的Builder" class="headerlink" title="6.构造者模式：PB序列化中的Builder"></a>6.构造者模式：PB序列化中的Builder</h2><p>构造者模式，适用于一个对象有很多复杂的属性，需要根据不同情况创建不同的具体对象，例如创建一个 PB 对象时使用的 builder 方式。</p>
]]></content>
      <categories>
        <category>Study Note</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
        <tag>Foundation</tag>
      </tags>
  </entry>
</search>
