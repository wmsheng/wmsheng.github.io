<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/siyecao.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/siyecao.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","padding":18,"offset":12,"onmobile":false,"b2t":true,"scrollpercent":true},
    copycode: {"enable":true,"show_result":true,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="衡量一个人真正的品德，是看他在知道没有人看见的时候做些什么 —— 孟德斯鸠  分析讨论栈、队列、优先队列、双端队列以及相关LeetCode题目。">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode Practice by Categories(Stack, Queue)">
<meta property="og:url" content="http://yoursite.com/2020/01/08/LeetCode-Practice-by-Categories-Stack-Queue/index.html">
<meta property="og:site_name" content="Hi, This is Bennett">
<meta property="og:description" content="衡量一个人真正的品德，是看他在知道没有人看见的时候做些什么 —— 孟德斯鸠  分析讨论栈、队列、优先队列、双端队列以及相关LeetCode题目。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s2.ax1x.com/2020/01/11/lIIZSs.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram_area.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png">
<meta property="article:published_time" content="2020-01-08T13:18:16.000Z">
<meta property="article:modified_time" content="2020-03-11T00:42:31.146Z">
<meta property="article:author" content="Wang Mingsheng">
<meta property="article:tag" content="LeetCode">
<meta property="article:tag" content="Algorithms">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.ax1x.com/2020/01/11/lIIZSs.png">

<link rel="canonical" href="http://yoursite.com/2020/01/08/LeetCode-Practice-by-Categories-Stack-Queue/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>LeetCode Practice by Categories(Stack, Queue) | Hi, This is Bennett</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hi, This is Bennett</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags<span class="badge">33</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories<span class="badge">4</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives<span class="badge">37</span></a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/08/LeetCode-Practice-by-Categories-Stack-Queue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/faceimage.jpg">
      <meta itemprop="name" content="Wang Mingsheng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hi, This is Bennett">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          LeetCode Practice by Categories(Stack, Queue)
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-08 21:18:16" itemprop="dateCreated datePublished" datetime="2020-01-08T21:18:16+08:00">2020-01-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-11 08:42:31" itemprop="dateModified" datetime="2020-03-11T08:42:31+08:00">2020-03-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithms-Note/" itemprop="url" rel="index">
                    <span itemprop="name">Algorithms Note</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              
              <span>25k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>衡量一个人真正的品德，是看他在知道没有人看见的时候做些什么 —— 孟德斯鸠</p>
</blockquote>
<p>分析讨论栈、队列、优先队列、双端队列以及相关LeetCode题目。</p>
<a id="more"></a>

<p><font color=#FF0000>java中，队列Queue是一种特殊的线性表，实例化的时候用链表(new LinkedList&lt;&gt;())、栈Stack有单独的类，实例化的时候使用Stack(new Stack&lt;&gt;())。 队列因为用LinkedList实现,一般操作size()方法。而栈可以使用empty()或者isEmpty()判空(empty()和isEmpty()没有本质区别，一般可以通用)</p>
<p>事实上，普通的栈和队列在工作中基本不会使用，而用得比较多的是双端队列。比如本文中曾经在239题中使用了java库中的双端队列，并用Array实现：<code>Deque&lt;Integer&gt; dq = new ArrayDeque&lt;&gt;();</code><br></font> </p>
<h2 id="20-Valid-Parentheses-有效的括号-Easy"><a href="#20-Valid-Parentheses-有效的括号-Easy" class="headerlink" title="20.Valid Parentheses(有效的括号)(Easy)"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">20.Valid Parentheses(有效的括号)(Easy)</a></h2><p>Given a string containing just the characters <code>&#39;(&#39;, &#39;)&#39;, &#39;{&#39;, &#39;}&#39;, &#39;[&#39;</code> and<code>&#39;]&#39;</code>, determine if the input string is valid.</p>
<p>An input string is valid if:</p>
<ol>
<li>Open brackets must be closed by the same type of brackets.</li>
<li>Open brackets must be closed in the correct order.</li>
</ol>
<p>Note that an empty string is also considered valid.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Input:</span> <span class="string">"()"</span></span><br><span class="line"><span class="string">Output:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Input:</span> <span class="string">"()[]&#123;&#125;"</span></span><br><span class="line"><span class="string">Output:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Input:</span> <span class="string">"(]"</span></span><br><span class="line"><span class="string">Output:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 4:</strong></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Input:</span> <span class="string">"([)]"</span></span><br><span class="line"><span class="string">Output:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 5:</strong></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Input:</span> <span class="string">"&#123;[]&#125;"</span></span><br><span class="line"><span class="string">Output:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>


<hr>
<p>解：想要符合闭合的括号的标准，用一个栈保存和左括号对应的右括号。每次碰到左括号就入栈对应的右括号，碰到右括号就判断是否和当前栈顶元素相同。</p>
<p>注意有两个判空，一个是碰到右括号，如果此时栈为空，那么不能pop()(会报错)，如果此时栈为空则不为有效括号。另一个情况是所有括号都遍历完了，此时如果栈不为空，则不是有效括号。所以在遍历完s之后需要返回stack.isEmpty()。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">String</span> s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; <span class="built_in">stack</span> = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'('</span>) &#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(<span class="string">')'</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'['</span>) &#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(<span class="string">']'</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'&#123;'</span>) &#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(<span class="string">'&#125;'</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">stack</span>.isEmpty() || <span class="built_in">stack</span>.pop() != c) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="155-Min-Stack-最小栈-Easy"><a href="#155-Min-Stack-最小栈-Easy" class="headerlink" title="155.Min Stack(最小栈)(Easy)"></a><a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">155.Min Stack(最小栈)(Easy)</a></h2><p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p>
<ul>
<li>push(x) – Push element x onto stack.</li>
<li>pop() – Removes the element on top of the stack.</li>
<li>top() – Get the top element.</li>
<li>getMin() – Retrieve the minimum element in the stack.</li>
</ul>
<p><strong>Example:</strong></p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MinStack minStack = new MinStack()<span class="comment">;</span></span><br><span class="line">minStack.push(-<span class="number">2</span>)<span class="comment">;</span></span><br><span class="line">minStack.push(<span class="number">0</span>)<span class="comment">;</span></span><br><span class="line">minStack.push(-<span class="number">3</span>)<span class="comment">;</span></span><br><span class="line">minStack.getMin()<span class="comment">;   --&gt; Returns -3.</span></span><br><span class="line">minStack.pop()<span class="comment">;</span></span><br><span class="line">minStack.top()<span class="comment">;      --&gt; Returns 0.</span></span><br><span class="line">minStack.getMin()<span class="comment">;   --&gt; Returns -2.</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：java语言本身已经定义好了一种传统作用的Stack，这道题有什么意义呢？事实上这道题就是要实现一个可以获得最小元素的栈。</p>
<p>换个角度看，要能够在常数时间内检索到最小元素的栈，是不是有点像优先队列？——其实不一样，它还是一个先入后出的栈。它只是能让你在常规时间中探索到最小元素，而不是取的时候每次都取最小元素。它的api本身和栈一模一样，只是多了一个功能，能够探测到最小元素。</p>
<p>给出两种方法，分别用两个栈和一个栈实现。</p>
<p>解法一：用两个栈实现，一个数据栈，一个辅助栈。这种写法注意了健壮性，考虑了栈为空的情况。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据栈和辅助栈同步,后面每个操作两个栈都进行相同操作</span></span><br><span class="line">    Stack&lt;Integer&gt; data;</span><br><span class="line">    Stack&lt;Integer&gt; helper;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化两个栈</span></span><br><span class="line">        data = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        helper = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        data.push(x);</span><br><span class="line">        <span class="keyword">if</span>(helper.isEmpty() || helper.<span class="built_in">peek</span>() &gt;= x) &#123;</span><br><span class="line">            helper.push(x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            helper.push(helper.<span class="built_in">peek</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!data.isEmpty()) &#123;</span><br><span class="line">            data.pop();</span><br><span class="line">            helper.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!data.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> data.<span class="built_in">peek</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"栈中元素为空，此操作非法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!helper.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> helper.<span class="built_in">peek</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"栈中元素为空，此操作非法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>解法二：用一个栈解决。解法一开辟了一个helper栈去保存最小值，实际上我们可以用一个变量,min,去保存这个最小值。<br>这里有两个问题：</p>
<ol>
<li>min保存了当前的最小值，如果min更新了，那么如何保存之前的最小值呢？——把之前的min在新元素之前入栈，也就是说来了新的更小的元素，旧的最小的元素需要再次入栈以求保存。</li>
<li>如果当前出栈的是最小值，我们在出栈当前元素之余，还需要再出栈一次，并且把这一次出栈的值赋给min。因为最小的元素入栈前会把之前最小的元素入栈，所以这样做就把旧的最小元素保存下来了。</li>
</ol>
<p>详细题解：<a href="https://leetcode-cn.com/problems/min-stack/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-38/" target="_blank" rel="noopener">点击这里</a></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">min</span> = Integer.MAX_VALUE;</span><br><span class="line">    Stack&lt;Integer&gt; <span class="built_in">stack</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span> = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// only push the old minimum value when the current</span></span><br><span class="line">        <span class="comment">// minimum value changes after pushing the new value x</span></span><br><span class="line">        <span class="keyword">if</span>(x &lt;= <span class="built_in">min</span>) &#123;</span><br><span class="line">            <span class="built_in">stack</span>.push(<span class="built_in">min</span>);</span><br><span class="line">            <span class="built_in">min</span> = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">stack</span>.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// if pop operation could result in the changing of the current minimum value,</span></span><br><span class="line">        <span class="comment">// pop twice and change the current minimum value to the last minimum value</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">stack</span>.pop() == <span class="built_in">min</span>) <span class="built_in">min</span> = <span class="built_in">stack</span>.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>.<span class="built_in">peek</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="641-Design-Circular-Deque-设计循环双端队列-Mid"><a href="#641-Design-Circular-Deque-设计循环双端队列-Mid" class="headerlink" title="641.Design Circular Deque(设计循环双端队列)(Mid)"></a><a href="https://leetcode-cn.com/problems/design-circular-deque/" target="_blank" rel="noopener">641.Design Circular Deque(设计循环双端队列)(Mid)</a></h2><p>Design your implementation of the circular double-ended queue (deque).</p>
<p>Your implementation should support following operations:</p>
<ul>
<li><code>MyCircularDeque(k)</code>: Constructor, set the size of the deque to be k.</li>
<li><code>insertFront()</code>: Adds an item at the front of Deque. Return true if the operation is successful.</li>
<li><code>insertLast()</code>: Adds an item at the rear of Deque. Return true if the operation is successful.</li>
<li><code>deleteFront()</code>: Deletes an item from the front of Deque. Return true if the operation is successful.</li>
<li><code>deleteLast()</code>: Deletes an item from the rear of Deque. Return true if the operation is successful.</li>
<li><code>getFront()</code>: Gets the front item from the Deque. If the deque is empty, return -1.</li>
<li><code>getRear()</code>: Gets the last item from Deque. If the deque is empty, return -1.</li>
<li><code>isEmpty()</code>: Checks whether Deque is empty or not. </li>
<li><code>isFull()</code>: Checks whether Deque is full or not.</li>
</ul>
<p><strong>Example:</strong></p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MyCircularDeque circularDeque = new MycircularDeque(<span class="number">3</span>); <span class="regexp">//</span> set the size to be <span class="number">3</span></span><br><span class="line">circularDeque.insertLast(<span class="number">1</span>);			<span class="regexp">//</span> <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">circularDeque.insertLast(<span class="number">2</span>);			<span class="regexp">//</span> <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">circularDeque.insertFront(<span class="number">3</span>);			<span class="regexp">//</span> <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">circularDeque.insertFront(<span class="number">4</span>);			<span class="regexp">//</span> <span class="keyword">return</span> <span class="keyword">false</span>, the queue is full</span><br><span class="line">circularDeque.getRear();  			<span class="regexp">//</span> <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">circularDeque.isFull();				<span class="regexp">//</span> <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">circularDeque.deleteLast();			<span class="regexp">//</span> <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">circularDeque.insertFront(<span class="number">4</span>);			<span class="regexp">//</span> <span class="keyword">return</span> <span class="keyword">true</span></span><br><span class="line">circularDeque.getFront();			<span class="regexp">//</span> <span class="keyword">return</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ul>
<li>All values will be in the range of [0, 1000].</li>
<li>The number of operations will be in the range of [1, 1000].</li>
<li>Please do not use the built-in Deque library.</li>
</ul>
<hr>
<p>解：使用链表完成这个API的设计。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> MyCircularDeque &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> DoubleListNode &#123;</span><br><span class="line">        DoubleListNode pre;</span><br><span class="line">        DoubleListNode <span class="keyword">next</span>;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">public</span> DoubleListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">size</span>;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    DoubleListNode head;</span><br><span class="line">    DoubleListNode tail;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Initialize your data structure here. Set the size of the deque to be k. */</span></span><br><span class="line">    <span class="keyword">public</span> MyCircularDeque(<span class="keyword">int</span> k) &#123;</span><br><span class="line">        head = <span class="keyword">new</span> DoubleListNode(-<span class="number">1</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> DoubleListNode(-<span class="number">1</span>);</span><br><span class="line">        head.pre = tail;</span><br><span class="line">        tail.<span class="keyword">next</span> = head;</span><br><span class="line">        <span class="keyword">this</span>.k = k;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">size</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Adds an item at the front of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> insertFront(<span class="keyword">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">size</span> == k) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        DoubleListNode node = <span class="keyword">new</span> DoubleListNode(value);</span><br><span class="line">        node.<span class="keyword">next</span> = head;</span><br><span class="line">        node.pre = head.pre;</span><br><span class="line">        head.pre.<span class="keyword">next</span> = node;</span><br><span class="line">        head.pre = node;</span><br><span class="line">        <span class="keyword">size</span>++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Adds an item at the rear of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> insertLast(<span class="keyword">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">size</span> == k) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        DoubleListNode node = <span class="keyword">new</span> DoubleListNode(value);</span><br><span class="line">        node.<span class="keyword">next</span> = tail.<span class="keyword">next</span>;</span><br><span class="line">        tail.<span class="keyword">next</span>.pre = node;</span><br><span class="line">        tail.<span class="keyword">next</span> = node;</span><br><span class="line">        node.pre = tail;</span><br><span class="line">        <span class="keyword">size</span>++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Deletes an item from the front of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> deleteFront() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">size</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        head.pre.pre.<span class="keyword">next</span> = head;</span><br><span class="line">        head.pre = head.pre.pre;</span><br><span class="line">        <span class="keyword">size</span>--;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Deletes an item from the rear of Deque. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> deleteLast() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">size</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        tail.<span class="keyword">next</span>.<span class="keyword">next</span>.pre = tail;</span><br><span class="line">        tail.<span class="keyword">next</span> = tail.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">        <span class="keyword">size</span>--;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front item from the deque. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> getFront() &#123;</span><br><span class="line">        <span class="keyword">return</span> head.pre.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the last item from the deque. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> getRear() &#123;</span><br><span class="line">        <span class="keyword">return</span> tail.<span class="keyword">next</span>.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Checks whether the circular deque is empty or not. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">size</span> == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Checks whether the circular deque is full or not. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isFull() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">size</span> == k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyCircularDeque object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyCircularDeque obj = new MyCircularDeque(k);</span></span><br><span class="line"><span class="comment"> * boolean param_1 = obj.insertFront(value);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.insertLast(value);</span></span><br><span class="line"><span class="comment"> * boolean param_3 = obj.deleteFront();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.deleteLast();</span></span><br><span class="line"><span class="comment"> * int param_5 = obj.getFront();</span></span><br><span class="line"><span class="comment"> * int param_6 = obj.getRear();</span></span><br><span class="line"><span class="comment"> * boolean param_7 = obj.isEmpty();</span></span><br><span class="line"><span class="comment"> * boolean param_8 = obj.isFull();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="225-Implement-Stack-using-Queues-用队列实现栈-Easy"><a href="#225-Implement-Stack-using-Queues-用队列实现栈-Easy" class="headerlink" title="225.Implement Stack using Queues(用队列实现栈)(Easy)"></a><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/" target="_blank" rel="noopener">225.Implement Stack using Queues(用队列实现栈)(Easy)</a></h2><p>Implement the following operations of a stack using queues.</p>
<ul>
<li>push(x) – Push element x onto stack.</li>
<li>pop() – Removes the element on top of the stack.</li>
<li>top() – Get the top element.</li>
<li>empty() – Return whether the stack is empty.</li>
</ul>
<p><strong>Example:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyStack <span class="built_in">stack</span> = <span class="keyword">new</span> MyStack();</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>.push(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">stack</span>.push(<span class="number">2</span>);  </span><br><span class="line"><span class="built_in">stack</span>.top();   <span class="comment">// returns 2</span></span><br><span class="line"><span class="built_in">stack</span>.pop();   <span class="comment">// returns 2</span></span><br><span class="line"><span class="built_in">stack</span>.empty(); <span class="comment">// returns false</span></span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ul>
<li>You must use only standard operations of a queue – which means only <code>push to back, peek/pop from front, size</code>, and <code>is empty</code> operations are valid.</li>
<li>Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.</li>
<li>You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).</li>
</ul>
<hr>
<p>解：想要用队列实现栈，常规想法可以使用两个队列，在每次出栈操作的时候，把元素临时保存到第二个队列中，在第一个队列还剩一个元素的时候把这个元素取出，从而实现类似栈的”后入先出”操作。</p>
<p>但是存在空间复杂度更优的方法，就是使用一个队列。具体操作方法是，每次入队都把整个队列循环弹出和新增元素，使得新添加的元素总在队列的前面，由此一来这个队列实际操作与栈无异。**关键步骤就是在于入队列时候的操作：<code>queue.add(queue.remove())</code>(remove()在队列为空的时候会抛出NoSuchElementException异常，poll()会返回null，其他没有区别)</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    Queue&lt;Integer&gt; <span class="built_in">queue</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="built_in">queue</span> = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>.add(x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">queue</span>.<span class="built_in">size</span>()<span class="number">-1</span>; i++)</span><br><span class="line">            <span class="built_in">queue</span>.add(<span class="built_in">queue</span>.<span class="built_in">remove</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">queue</span>.<span class="built_in">remove</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">queue</span>.<span class="built_in">peek</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">queue</span>.<span class="built_in">size</span>() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>


<h2 id="232-Implement-Queue-using-Stacks-用栈实现队列-Easy"><a href="#232-Implement-Queue-using-Stacks-用栈实现队列-Easy" class="headerlink" title="232.Implement Queue using Stacks(用栈实现队列)(Easy)"></a><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/" target="_blank" rel="noopener">232.Implement Queue using Stacks(用栈实现队列)(Easy)</a></h2><p>Implement the following operations of a queue using stacks.</p>
<ul>
<li>push(x) – Push element x to the back of queue.</li>
<li>pop() – Removes the element from in front of queue.</li>
<li>peek() – Get the front element.</li>
<li>empty() – Return whether the queue is empty.</li>
</ul>
<p><strong>Example:</strong></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyQueue <span class="built_in">queue</span> = <span class="keyword">new</span> MyQueue();</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>.push(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">queue</span>.push(<span class="number">2</span>);  </span><br><span class="line"><span class="built_in">queue</span>.<span class="built_in">peek</span>();  <span class="comment">// returns 1</span></span><br><span class="line"><span class="built_in">queue</span>.pop();   <span class="comment">// returns 1</span></span><br><span class="line"><span class="built_in">queue</span>.empty(); <span class="comment">// returns false</span></span><br></pre></td></tr></table></figure>
<p><strong>Notes:</strong></p>
<ul>
<li>You must use only standard operations of a stack – which means only <code>push to top, peek/pop from top, size, and is empty</code> operations are valid.</li>
<li>Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.</li>
<li>You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).</li>
</ul>
<hr>
<p>解：和之前用队列实现栈类似，可以用两个栈实现一个队列。但是由于栈只有一个出入口，所以不能用一个栈实现队列(队列中出队再入队可以实现倒置，栈不行).</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要两个栈才能实现队列</span></span><br><span class="line">    Stack&lt;Integer&gt; input;</span><br><span class="line">    Stack&lt;Integer&gt; output;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        input = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        output = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        input.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">peek</span>();</span><br><span class="line">        <span class="keyword">return</span> output.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(output.empty())</span><br><span class="line">            <span class="keyword">while</span>( !input.empty() )</span><br><span class="line">                output.push(input.pop());</span><br><span class="line">        <span class="keyword">return</span> output.<span class="built_in">peek</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input.empty() &amp;&amp; output.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.peek();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>


<h2 id="239-Sliding-Window-Maximum-滑动窗口最大值-Hard"><a href="#239-Sliding-Window-Maximum-滑动窗口最大值-Hard" class="headerlink" title="239.Sliding Window Maximum(滑动窗口最大值)(Hard)"></a><a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">239.Sliding Window Maximum(滑动窗口最大值)(Hard)</a></h2><p>Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">-1</span>,<span class="number">-3</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>], <span class="keyword">and</span> k = <span class="number">3</span></span><br><span class="line">Output: [<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>] </span><br><span class="line">Explanation: </span><br><span class="line"></span><br><span class="line">Window position                Max</span><br><span class="line">---------------               -----</span><br><span class="line">[<span class="number">1</span>  <span class="number">3</span>  <span class="number">-1</span>] <span class="number">-3</span>  <span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">3</span></span><br><span class="line"> <span class="number">1</span> [<span class="number">3</span>  <span class="number">-1</span>  <span class="number">-3</span>] <span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">3</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span> [<span class="number">-1</span>  <span class="number">-3</span>  <span class="number">5</span>] <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">5</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  <span class="number">-1</span> [<span class="number">-3</span>  <span class="number">5</span>  <span class="number">3</span>] <span class="number">6</span>  <span class="number">7</span>       <span class="number">5</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  <span class="number">-1</span>  <span class="number">-3</span> [<span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>] <span class="number">7</span>       <span class="number">6</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  <span class="number">-1</span>  <span class="number">-3</span>  <span class="number">5</span> [<span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>]      <span class="number">7</span></span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong><br>You may assume k is always valid, 1 ≤ k ≤ input array’s size for non-empty array.</p>
<p><strong>Follow up:</strong><br>Could you solve it in linear time?</p>
<hr>
<p>解：<strong>所有滑动窗口的题目，想到用队列解决。</strong></p>
<p>方法一：暴力求解。枚举窗口的起点位置，因为窗口长度是k,所以枚举起点是0，终点是 length-1 。写一个二重循环，最后时间复杂度是O(n*k)。</p>
<p>方法二：这里用到单调队列(实际就是所谓的双端队列)，可以达到线性的时间复杂度。</p>
<p><font color=#FF0000>双端队列可以操作队列里面的头元素和尾元素，一些API见下图：</font><br><img src="https://s2.ax1x.com/2020/01/11/lIIZSs.png" alt="JDK8 Deque API"></p>
<p>我们通过双端队列维护的一个”单调队列”，从左到右为递减。所以每次对比元素都是peekLast()，弹出元素也是pollLast()</p>
<p>我们用双向队列可以在O(N)时间内解决这题。当我们遇到新的数时，将新的数和双向队列的末尾比较，如果末尾比新数小，则把末尾扔掉，直到该队列的末尾比新数大或者队列为空的时候才住手。这样，我们可以保证队列里的元素是从头到尾降序的，由于队列里只有窗口内的数，所以他们其实就是窗口内第一大，第二大，第三大…的数。保持队列里只有窗口内数的方法和上个解法一样，也是每来一个新的把窗口最左边的扔掉，然后把新的加进去。然而由于我们在加新数的时候，已经把很多没用的数给扔了，这样队列头部的数并不一定是窗口最左边的数。这里的技巧是，我们队列中存的是那个数在原数组中的下标，这样我们既可以直到这个数的值，也可以知道该数是不是窗口最左边的数。这里为什么时间复杂度是O(N)呢？因为每个数只可能被操作最多两次，一次是加入队列的时候，一次是因为有别的更大数在后面，所以被扔掉，或者因为出了窗口而被扔掉。(引用<a href="https://segmentfault.com/a/1190000003903509" target="_blank" rel="noopener">这篇文章</a>)</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>[] maxSlidingWindow(<span class="built_in">int</span>[] nums, <span class="built_in">int</span> k) &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(nums.length == <span class="number">0</span> || k &lt;= <span class="number">0</span>) <span class="keyword">return</span> nums;</span><br><span class="line">		<span class="built_in">int</span> len = nums.length;</span><br><span class="line">		<span class="comment">// 可以自己举个例子，推得这个result大小应该为len-k+1</span></span><br><span class="line">		<span class="built_in">int</span>[] result = new <span class="built_in">int</span>[len - k + <span class="number">1</span>];</span><br><span class="line">		<span class="comment">// store index</span></span><br><span class="line">		<span class="comment">// 注意，dq用于保存数组下标</span></span><br><span class="line">		Deque&lt;Integer&gt; dq = new ArrayDeque&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">			<span class="comment">//这里不需要循环，用一个判断就可 </span></span><br><span class="line">			<span class="comment">//因为我们最多只能在一轮中弹出一个超出范围的元素。（一轮我们只接受一个元素，所以我们最多弹出一个元素）。</span></span><br><span class="line">			<span class="comment">// dq 用于保存数组下标，这也是一个技巧</span></span><br><span class="line">			<span class="keyword">if</span>( !dq.isEmpty() &amp;&amp; dq.peekFirst() == i-k) &#123;</span><br><span class="line">				<span class="comment">// 双端队列中 poll() 相当于 pollFirst(),皮一下</span></span><br><span class="line">				dq.poll();</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 新加入的元素必须比前面的小，否则前面比它小的元素都要出队</span></span><br><span class="line">			<span class="keyword">while</span>(!dq.isEmpty() &amp;&amp; nums[i] &gt;= nums[dq.peekLast()]) &#123;</span><br><span class="line">				dq.pollLast();</span><br><span class="line">			&#125;</span><br><span class="line">			dq.offer(i);</span><br><span class="line">			<span class="comment">// dq是有序的，队列头总是最大的元素，只要下标在范围内，直接peek()即可</span></span><br><span class="line">			<span class="keyword">if</span>(i-k+<span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">				result[i-k+<span class="number">1</span>] = nums[dq.peek()];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<h2 id="621-Task-Scheduler-任务调度-Mid"><a href="#621-Task-Scheduler-任务调度-Mid" class="headerlink" title="621.Task Scheduler(任务调度)(Mid)"></a><a href="https://leetcode-cn.com/problems/task-scheduler/" target="_blank" rel="noopener">621.Task Scheduler(任务调度)(Mid)</a></h2><p>Given a char array representing tasks CPU need to do. It contains capital letters A to Z where different letters represent different tasks. Tasks could be done without original order. Each task could be done in one interval. For each interval, CPU could finish one task or just be idle.</p>
<p>However, there is a non-negative cooling interval <strong>n</strong> that means between two <strong>same tasks</strong>, there must be at least n intervals that CPU are doing different tasks or just be idle.</p>
<p>You need to return the <strong>least</strong> number of intervals the CPU will take to finish all the given tasks.</p>
<p><strong>Example:</strong></p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: tasks = [<span class="string">"A"</span>,<span class="string">"A"</span>,<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"B"</span>,<span class="string">"B"</span>], n = <span class="number">2</span></span><br><span class="line">Output: <span class="number">8</span></span><br><span class="line">Explanation: A -&gt; B -&gt; idle -&gt; A -&gt; B -&gt; idle -&gt; A -&gt; B.</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ol>
<li>The number of tasks is in the range [1, 10000].</li>
<li>The integer n is in the range [0, 100].</li>
</ol>
<hr>
<p>解：</p>
<ol>
<li>因为所有任务都是大写字母，所以可以申请大小为26的数组来保存任务类型个数。</li>
<li>对数组进行排序，按照出现的次数进行排序，优先记录出现次数多的任务。根据题意，时间至少为：retCount = (count - 1) * (n + 1) + 1 =&gt;A-&gt;X-&gt;X-&gt;A-&gt;X-&gt;X-&gt;A(X为其他任务或者待命)</li>
<li>再排序下一个任务，如果下一个任务B个数和最大任务数一致，则retCount++ ==&gt; A-&gt;B-&gt;X-&gt;A-&gt;B-&gt;X-&gt;A-&gt;B</li>
<li>如果空位都插满之后还有任务，那就随便在这些间隔里面插入就可以，因为间隔长度肯定会大于n，在这种情况下就是任务的总数是最小所需时间</li>
</ol>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> leastInterval(char[] tasks, <span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="comment">// corner case</span></span><br><span class="line">        <span class="keyword">if</span>(tasks.length &lt;= <span class="number">1</span> || n &lt; <span class="number">1</span>) <span class="keyword">return</span> tasks.length;</span><br><span class="line">        <span class="comment">// 步骤1</span></span><br><span class="line">        <span class="built_in">int</span>[] counts = new <span class="built_in">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; tasks.length; i++) &#123;</span><br><span class="line">            counts[tasks[i] - <span class="string">'A'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//步骤2</span></span><br><span class="line">        Arrays.sort(counts);</span><br><span class="line">        <span class="built_in">int</span> maxCount = counts[<span class="number">25</span>];</span><br><span class="line">        <span class="built_in">int</span> retCount = (maxCount - <span class="number">1</span>) * (n + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">24</span>;</span><br><span class="line">        <span class="comment">// 步骤3</span></span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; counts[i] == maxCount) &#123;</span><br><span class="line">            retCount++;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//步骤4</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(retCount, tasks.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他参考题解：<a href="https://leetcode-cn.com/problems/task-scheduler/solution/python-xiang-jie-by-jalan/" target="_blank" rel="noopener">参考这篇文章</a></p>
<h2 id="84-Largest-Rectangle-in-Histogram-柱状图中最大的矩形-Hard"><a href="#84-Largest-Rectangle-in-Histogram-柱状图中最大的矩形-Hard" class="headerlink" title="84.Largest Rectangle in Histogram(柱状图中最大的矩形)(Hard)"></a><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">84.Largest Rectangle in Histogram(柱状图中最大的矩形)(Hard)</a></h2><p>Given <em>n</em> non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram.png" alt="eg"></p>
<p>Above is a histogram where width of each bar is 1, given height = <code>[2,1,5,6,2,3]</code>.</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram_area.png" alt="eg"></p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">Output: <span class="number">10</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：方法一：暴力法，枚举所有可能的柱子对。每次遍历的时候都基于当前的第i个柱子，向右用j扫描一遍。这样可以确保每一个都扫描扫过。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> largestRectangleArea(<span class="built_in">int</span>[] heights) &#123;</span><br><span class="line">        <span class="comment">// 方法一，暴力O(n^2)</span></span><br><span class="line">        <span class="built_in">int</span> maxArea = <span class="number">0</span>, len = heights.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 每次重新循环，minHeight都要更新</span></span><br><span class="line">            <span class="built_in">int</span> minHeight = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = i; j &lt; len; j++) &#123;</span><br><span class="line">                minHeight = Math.min(minHeight, heights[j]);</span><br><span class="line">                maxArea = Math.max(maxArea, minHeight * (j - i + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(n)</li>
</ul>
<p>方法二，时间复杂度为O(n)的方法，利用Stack进行,具体来说，是一个<strong>单调栈</strong>。</p>
<p>它是怎么做的呢？</p>
<p>遍历的过程中，因为是从左开始遍历的，所以其实如果用一个有序的栈，其实是可以用O(1)得到某根柱子的左边界的。注意这里说的是左边界，右边界仍然需要遍历，因为右边还没遍历，没法一下子知道右边界。但是这是合理的，因为如果你不继续往右边界遍历，你永远也不知道右边界在哪里。</p>
<p>这个办法是维护一个栈，这个栈的元素是从<strong>小到大（对于栈，从小到大是从栈底到栈顶是从小到大排列的）</strong>进行排列的。因为这样排列，可以有效知道它的左边界在什么地方。</p>
<p><strong>不得不说，这个算法需要后面不断反复地看</strong>，才能熟悉他它因为它的逻辑其实是比较复杂和精妙的。</p>
<p>栈的初始值为-1，也是巧妙的一点。</p>
<p>为了保证栈是从小到大的，每次入栈都进行一次判断， 必须比当前栈顶元素大，才能进栈，否则要把那个栈元素出栈。</p>
<p>进栈的时候要保留它的下标，因为后面计算的时候好计算它的宽度。</p>
<p><font color=#FF0000>栈里面任何一个元素的左边界，都是它在栈里面的下一个元素。也就是说，如果一个元素要出栈了，它的左边界就是它在栈里的下一个元素，它的右边界就是比它小的那个元素，换句话说，哪个元素触发了另一个元素要被弹出栈，触发它的那个元素，就是被弹出元素的右边界。由此一来，当前被弹出元素的左边界和右边界都有了，通过公式计算得到的就是被以被弹出元素为中心能围成的最大矩形面积。</font></p>
<p>比如一个元素3，让9,5,4三个元素都出栈了，那么3就是9,5,4这三个元素的右边界</p>
<p>如果一个元素想要加入栈，但是它比栈顶元素要大，那么它不能是前一个元素的右边界，所以要把它保存到栈里面，直到下一个入栈的元素比栈里面它的上一个元素要小，那么开始出栈操作，因为找到了边界了。</p>
<p>扫描到哪里，谁更小，谁就是整个栈操作的颠覆者。</p>
<ul>
<li>实质是求每个柱子可以向左右两边延伸的距离<ul>
<li>向左：由于栈是单调递增的，因此以当前柱子为中心向左延展时，不能超过当前栈的上一个元素(最近的比它小的元素)</li>
<li>向右：由于遇到非单调递增的元素时才开始弹出，所以当前位置的高度小于每个弹出的元素。因此，向右延展时，不能超过当前位置</li>
</ul>
</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// corner case</span></span><br><span class="line">        <span class="keyword">if</span>(heights == null || heights.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 方法二，栈,O(n)</span></span><br><span class="line">        <span class="comment">// 主要目标是求能够覆盖当前第i个柱子的最大矩形，即为第i个矩形的"专属面积"</span></span><br><span class="line">        Stack&lt;Integer&gt; <span class="built_in">stack</span> = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 栈里面存放heights数组的下标，取元素的时候为：heights[stack.pop()]</span></span><br><span class="line">        <span class="built_in">stack</span>.push(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>, len = heights.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 只有遍历的heights[i]比当前stack里面的栈顶元素大，才能跳过while循环，直接入栈</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">stack</span>.<span class="built_in">peek</span>() != <span class="number">-1</span> &amp;&amp; heights[<span class="built_in">stack</span>.<span class="built_in">peek</span>()] &gt;= heights[i])</span><br><span class="line">                <span class="comment">// 若当前遍历的heights[i]比栈顶元素小，则栈顶元素出栈，计算此时面积</span></span><br><span class="line">                <span class="comment">// 先pop()后peek()，很巧妙的写法设置</span></span><br><span class="line">                <span class="comment">// 这里多减一个1主要因为之前已经pop()了，这里要减回来</span></span><br><span class="line">                maxArea = Math.<span class="built_in">max</span>(maxArea, heights[<span class="built_in">stack</span>.pop() ] * (i - <span class="built_in">stack</span>.<span class="built_in">peek</span>() - <span class="number">1</span>));</span><br><span class="line">            <span class="built_in">stack</span>.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果遍历完了一遍最后栈不为空，则再用一重循环吧栈搞空</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">stack</span>.<span class="built_in">peek</span>() != <span class="number">-1</span>)</span><br><span class="line">            maxArea = Math.<span class="built_in">max</span>(maxArea, heights[<span class="built_in">stack</span>.pop()] * (len - <span class="built_in">stack</span>.<span class="built_in">peek</span>() - <span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，n个数字每个会被压栈弹栈各一次。</li>
<li>空间复杂度：O(n)，存放栈中元素。</li>
</ul>
<h2 id="85-Maximal-Rectangle-最大矩形-Hard"><a href="#85-Maximal-Rectangle-最大矩形-Hard" class="headerlink" title="85.Maximal Rectangle(最大矩形)(Hard)"></a><a href="https://leetcode-cn.com/problems/maximal-rectangle/" target="_blank" rel="noopener">85.Maximal Rectangle(最大矩形)(Hard)</a></h2><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing only 1’s and return its area.</p>
<p><strong>Example:</strong></p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input</span>:</span><br><span class="line">[</span><br><span class="line">  [<span class="string">"1"</span>,<span class="string">"0"</span>,<span class="string">"1"</span>,<span class="string">"0"</span>,<span class="string">"0"</span>],</span><br><span class="line">  [<span class="string">"1"</span>,<span class="string">"0"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>],</span><br><span class="line">  [<span class="string">"1"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>],</span><br><span class="line">  [<span class="string">"1"</span>,<span class="string">"0"</span>,<span class="string">"0"</span>,<span class="string">"1"</span>,<span class="string">"0"</span>]</span><br><span class="line">]</span><br><span class="line"><span class="symbol">Output</span>: <span class="number">6</span></span><br></pre></td></tr></table></figure>
<hr>
<p>解：此题可以基于84题实现的找到矩形围成的最大面积来考虑，利用84题已经实现的函数，在遍历input的数组的时候将每一行值都记录，并且在有连续的1的时候进行累加(碰到0的话对应下标值要清空)</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == null || matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length, rows = matrix.length;</span><br><span class="line">        <span class="keyword">int</span>[] heights = <span class="keyword">new</span> <span class="keyword">int</span>[cols];</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 每次遍历之后都获取当前row的直方图，保存到heights中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    heights[j]++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    heights[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将当前直方图面积和之前最大面积进行比较，取一个最大值</span></span><br><span class="line">            maxArea = Math.<span class="built_in">max</span>(maxArea, largestRectangleArea(heights));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// corner case</span></span><br><span class="line">        <span class="keyword">if</span>(heights == null || heights.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 方法二，栈,O(n)</span></span><br><span class="line">        <span class="comment">// 主要目标是求能够覆盖当前第i个柱子的最大矩形，即为第i个矩形的"专属面积"</span></span><br><span class="line">        Stack&lt;Integer&gt; <span class="built_in">stack</span> = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 栈里面存放heights数组的下标，取元素的时候为：heights[stack.pop()]</span></span><br><span class="line">        <span class="built_in">stack</span>.push(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>, len = heights.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 只有遍历的heights[i]比当前stack里面的栈顶元素大，才能跳过while循环，直接入栈</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">stack</span>.<span class="built_in">peek</span>() != <span class="number">-1</span> &amp;&amp; heights[<span class="built_in">stack</span>.<span class="built_in">peek</span>()] &gt;= heights[i])</span><br><span class="line">                <span class="comment">// 若当前遍历的heights[i]比栈顶元素小，则栈顶元素出栈，计算此时面积</span></span><br><span class="line">                <span class="comment">// 先pop()后peek()，很巧妙的写法设置</span></span><br><span class="line">                <span class="comment">// 这里多减一个1主要因为之前已经pop()了，这里要减回来</span></span><br><span class="line">                maxArea = Math.<span class="built_in">max</span>(maxArea, heights[<span class="built_in">stack</span>.pop() ] * (i - <span class="built_in">stack</span>.<span class="built_in">peek</span>() - <span class="number">1</span>));</span><br><span class="line">            <span class="built_in">stack</span>.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果遍历完了一遍最后栈不为空，则再用一重循环吧栈搞空</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">stack</span>.<span class="built_in">peek</span>() != <span class="number">-1</span>)</span><br><span class="line">            maxArea = Math.<span class="built_in">max</span>(maxArea, heights[<span class="built_in">stack</span>.pop()] * (len - <span class="built_in">stack</span>.<span class="built_in">peek</span>() - <span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(mn)。84题实现的函数的时间复杂度为O(n)，然后主函数有两个循环，但是因为内层循环和84题的函数是并列的，所以整个时间复杂度还是O(mn)</li>
</ul>
<h2 id="42-Trapping-Rain-Water-接雨水-Hard"><a href="#42-Trapping-Rain-Water-接雨水-Hard" class="headerlink" title="42.Trapping Rain Water(接雨水)(Hard)"></a><a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">42.Trapping Rain Water(接雨水)(Hard)</a></h2><p>Given <em>n</em> non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt="42接雨水"></p>
<p>The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">Output: <span class="number">6</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：本篇题解内容取材于<a href="https://leetcode-cn.com/problems/trapping-rain-water/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-8/" target="_blank" rel="noopener">这篇文章</a></p>
<p>方法一：按列求。</p>
<p>整个题目需要遍历heights的每一个元素，即每一列的值。而对于每一列，我们只需要关注当前列、当前列左边墙最高值、当前列右边墙最高值，关注这三个值。而且由于木桶效应，我们只需要看左边和右边最高值中的较小的那个即可，这样把当前左边与右边的最小值和当前列作比较，就能得出当前列能够最多盛多少水了。</p>
<p>按照题意，会有三种情况：</p>
<ol>
<li>左边与右边两个中较矮的墙的高度大于当前列的墙的高度</li>
</ol>
<p>此时用较矮的值减去当前高度，即为当前列能盛放的高度。</p>
<ol start="2">
<li>左边与右边两个中较矮的墙的高度小于当前列的墙的高度</li>
</ol>
<p>此时当前列不能盛水。</p>
<ol start="3">
<li>左边与右边两个中较矮的墙的高度等于当前列的墙的高度</li>
</ol>
<p>此时当前列也不能盛水。</p>
<p>所以，根据这三种情况写程序。外层循环遍历每一列，然后针对当前列求出这一列两边的最高的墙，并找出较矮的一端，和当前列高度比较，用上述这三种情况作为参考的结果即可。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 方法一，按列求</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, len = <span class="built_in">height</span>.length;</span><br><span class="line">        <span class="comment">//最两端的列不用考虑，因为一定不会有水。所以下标从 1 到 length - 2</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len<span class="number">-1</span> ;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> maxLeft = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 找出左边最高</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">height</span>[j] &gt; maxLeft) &#123;</span><br><span class="line">                    maxLeft = <span class="built_in">height</span>[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> maxRight = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 找出右边最高</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">height</span>[j] &gt; maxRight) &#123;</span><br><span class="line">                    maxRight = <span class="built_in">height</span>[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找出左右两端更小的</span></span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">min</span> = Math.<span class="built_in">min</span>(maxLeft, maxRight);</span><br><span class="line">            <span class="comment">// 根据之前分析，此时只有min大于height[i]，才能盛水</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">min</span> &gt; <span class="built_in">height</span>[i])</span><br><span class="line">                sum += <span class="built_in">min</span>-<span class="built_in">height</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n^2)，遍历每一列一遍需要O(n)，然后每次找出左边和右边最高的墙，加起来又需要一个O(n)，合在一起是O(n^2)</li>
<li>空间复杂度：O(1)</li>
</ul>
<p>方法二：动态规划</p>
<p>基于方法一的优化，在方法一中，我们要求当前每一列的左边界和右边界，都必须重新遍历一遍所有高度，其实可以优化的。</p>
<p>这里用<code>maxLeft[]</code>和<code>maxRight[]</code>两个数组，<code>maxLeft[i]</code>代表<strong>第i列左边最高的墙的高度</strong>，<code>maxRight[i]</code>代表<strong>第i列右边最高的墙的高度</strong>。<font color=#FF0000>注意，这里两个数组中定义的第i列的左边和右边，不包括i本身</font></p>
<p>递推公式：<code>maxLeft[i]=Max(maxLeft[i-1], height[i-1])</code>。它左边的墙的左边的最高高度和它左边墙的高度选一个作为最大的即可。这里相当于用到了”备忘录”，让之前的每一次遍历都有意义，都被记忆了。</p>
<p>类似的：<code>maxRight[i] = Max(maxRight[i+1], height[i+1])</code>。它右边墙的最高高度和它右边墙本身的高度进行比较，取最高的。</p>
<p>由此一来，就不需要像方法一那样，在内部又加了一层for循环，不用每次都去求一次i的左边和右边的最大值了，已经用两个数组分别记录好了。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// corner case</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">height</span> == null || <span class="built_in">height</span>.length &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">height</span>.length, sum = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] maxLeft = <span class="keyword">new</span> <span class="keyword">int</span>[len], maxRight = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 道理还是和之前一样，下标为0和len-1的两个地方一定没办法盛水，可以直接跳过</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len<span class="number">-1</span>; i++) &#123;</span><br><span class="line">            maxLeft[i] = Math.<span class="built_in">max</span>(maxLeft[i<span class="number">-1</span>], <span class="built_in">height</span>[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            maxRight[i] = Math.<span class="built_in">max</span>(maxRight[i+<span class="number">1</span>], <span class="built_in">height</span>[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把结果全部放入到maxLeft和maxRight之后，用下标统一遍历，用到了</span></span><br><span class="line">        <span class="comment">// maxLeft, maxRight, height三个数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">min</span> = Math.<span class="built_in">min</span>(maxLeft[i], maxRight[i]);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">min</span> &gt; <span class="built_in">height</span>[i]) &#123;</span><br><span class="line">                sum += <span class="built_in">min</span> - <span class="built_in">height</span>[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)，保存每一列左边最高边界和右边最高边界</li>
</ul>
<p>方法三：动态规划在空间复杂度上的优化，<strong>双指针</strong>，时间复杂度为O(n)，时间复杂度为O(1)</p>
<p>动态规划中maxLeft[]和maxRight[]这两个数组中每个元素我们每次只用一次，之后不会再用，所以我们不需要用数组，用一个元素就够了。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// corner case</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">height</span> == null || <span class="built_in">height</span>.length &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 方法三，双指针</span></span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>,leftmax = <span class="number">0</span>,rightmax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="built_in">height</span>.length<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            leftmax = Math.<span class="built_in">max</span>(leftmax, <span class="built_in">height</span>[i]);</span><br><span class="line">            rightmax = Math.<span class="built_in">max</span>(rightmax, <span class="built_in">height</span>[j]);</span><br><span class="line">            <span class="keyword">if</span>(leftmax &lt; rightmax) &#123;</span><br><span class="line">                maxArea += leftmax - <span class="built_in">height</span>[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                maxArea += rightmax - <span class="built_in">height</span>[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法四：栈</p>
<p>这里用的，实际上在空间复杂度上不如方法三，但是用到栈的思路还是很巧妙的。</p>
<p>首先，这道题和括号匹配问题非常相似。我们可以每找到对应的两堵墙，就计算存储的水量，用栈保存每堵墙。</p>
<p>当遍历墙的高度的时候，如果当前高度小于栈顶的墙高度，说明这里会有积水，我们将墙的高度的下标入栈。</p>
<p>如果当前高度大于栈顶的墙的高度，说明之前的积水到这里停下，我们可以计算下有多少积水了。计算完，就把当前的墙继续入栈，作为新的积水的墙。</p>
<p>总体原则：</p>
<ol>
<li>当前高度小于等于栈顶高度，将墙的下标值入栈，后移指针。</li>
<li>当前高度大于栈顶高度，出栈，计算当前墙和当前栈顶值的差值，为可存储的水量。然后用当前墙高度再和栈的新栈顶比较，重复两个判断，一直到当前墙的高度不大于栈顶高度或者栈为空，再把当前墙入栈，指针后移。</li>
</ol>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap6</span><span class="params">(<span class="keyword">int</span>[] <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    Stack&lt;Integer&gt; <span class="built_in">stack</span> = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (current &lt; <span class="built_in">height</span>.length) &#123;</span><br><span class="line">        <span class="comment">//如果栈不空并且当前指向的高度大于栈顶高度就一直循环</span></span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">stack</span>.empty() &amp;&amp; <span class="built_in">height</span>[current] &gt; <span class="built_in">height</span>[<span class="built_in">stack</span>.<span class="built_in">peek</span>()]) &#123;</span><br><span class="line">            <span class="keyword">int</span> h = <span class="built_in">height</span>[<span class="built_in">stack</span>.<span class="built_in">peek</span>()]; <span class="comment">//取出要出栈的元素</span></span><br><span class="line">            <span class="built_in">stack</span>.pop(); <span class="comment">//出栈</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">stack</span>.empty()) &#123; <span class="comment">// 栈空就出去</span></span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> distance = current - <span class="built_in">stack</span>.<span class="built_in">peek</span>() - <span class="number">1</span>; <span class="comment">//两堵墙之前的距离。</span></span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">min</span> = Math.<span class="built_in">min</span>(<span class="built_in">height</span>[<span class="built_in">stack</span>.<span class="built_in">peek</span>()], <span class="built_in">height</span>[current]);</span><br><span class="line">            sum = sum + distance * (<span class="built_in">min</span> - h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">stack</span>.push(current); <span class="comment">//当前指向的墙入栈</span></span><br><span class="line">        current++; <span class="comment">//指针后移</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="394-Decode-String-字符串解码-Mid"><a href="#394-Decode-String-字符串解码-Mid" class="headerlink" title="394.Decode String(字符串解码)(Mid)"></a><a href="https://leetcode-cn.com/problems/decode-string/" target="_blank" rel="noopener">394.Decode String(字符串解码)(Mid)</a></h2><p>Given an encoded string, return its decoded string.</p>
<p>The encoding rule is: <code>k[encoded_string]</code>, where the <em>encoded_string</em> inside the square brackets is being repeated exactly <em>k</em> times. Note that <em>k</em> is guaranteed to be a positive integer.</p>
<p>You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.</p>
<p>Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won’t be input like <code>3a</code> or <code>2[4]</code>.</p>
<p><strong>Examples:</strong></p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">s</span> = <span class="string">"3[a]2[bc]"</span>, return <span class="string">"aaabcbc"</span>.</span><br><span class="line"><span class="attribute">s</span> = <span class="string">"3[a2[c]]"</span>, return <span class="string">"accaccacc"</span>.</span><br><span class="line"><span class="attribute">s</span> = <span class="string">"2[abc]3[cd]ef"</span>, return <span class="string">"abcabccdcdcdef"</span>.</span><br></pre></td></tr></table></figure>

<hr>
<p>解：举个例子，<code>s=&quot;3[a2[c]]&quot;</code></p>
<p>这道题最后我们用StringBuilder记录目前为止字符的长度，然后需要用到两个栈进行辅助，分别是Integer和String泛型的栈，一个(numStack)用于保存当前字符重复的遍数,另一个(strStack)用于保存当前要重复的字符,需要它的原因是，哪怕你知道了某一个字符要重复的遍数，你还需要知道它前面还有什么字符，可能它前面的需要和它一起重复。</p>
<p>拿例子来说，走到了<code>2[c]</code>的时候，tail这个StringBuilder就是”c”，numStack就是2</p>
<p>具体入栈规则：</p>
<p>String泛型栈：每当遇到左括号的时候，要把之前记录的String(在StringBuilder里面保存着)都push到strStack，当然这个StringBuilder本身不会变化</p>
<p>Integer泛型栈：碰到数字就入这个栈，用来记录某一段字符串要重复的次数。</p>
<p>直到遍历到右括号，开始出栈。首先从numStack中pop()出一个数字，</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    public String decode<span class="constructor">String(String <span class="params">s</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 存储当前字符需要重复的遍数</span></span><br><span class="line">        Stack&lt;Integer&gt; numStack = <span class="keyword">new</span> Stack&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">        <span class="comment">// 记录前面没有数字的，"落单"的字母</span></span><br><span class="line">        Stack&lt;String&gt; strStack = <span class="keyword">new</span> Stack&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">        <span class="comment">// 记录迄今为止的解码结果</span></span><br><span class="line">        StringBuilder tail = <span class="keyword">new</span> <span class="constructor">StringBuilder()</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> n = s.length<span class="literal">()</span>;</span><br><span class="line">        </span><br><span class="line">        for(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">char</span> c = s.<span class="built_in">char</span><span class="constructor">At(<span class="params">i</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="module-access"><span class="module"><span class="identifier">Character</span>.</span></span>is<span class="constructor">Digit(<span class="params">c</span>)</span>) &#123; <span class="comment">// 第一种情况，当前遍历的为数字</span></span><br><span class="line">                <span class="built_in">int</span> num = c - <span class="character">'0'</span>;</span><br><span class="line">                <span class="comment">// 因为前面的数字可能有十位、百位等，所以要循环判断</span></span><br><span class="line">                <span class="keyword">while</span>(<span class="module-access"><span class="module"><span class="identifier">Character</span>.</span></span>is<span class="constructor">Digit(<span class="params">s</span>.<span class="params">charAt</span>(<span class="params">i</span> + 1)</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 每往后一位，num相当于要乘10再加上新数字</span></span><br><span class="line">                    num = num<span class="operator"> * </span><span class="number">10</span> + s.<span class="built_in">char</span><span class="constructor">At(<span class="params">i</span> + 1)</span> - <span class="character">'0'</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                numStack.push(num);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(c<span class="operator"> == </span><span class="character">'['</span>) &#123; <span class="comment">// 每当遇到左括号，就开始存encoded_string</span></span><br><span class="line">                <span class="comment">// 具体做法就是把当前tail的所有内容都push进strStack，然后重新定义一个StringBuilder记录</span></span><br><span class="line">                <span class="comment">// 被加密的内层的字符串</span></span><br><span class="line">                strStack.push(tail.<span class="keyword">to</span><span class="constructor">String()</span>);</span><br><span class="line">                <span class="comment">// 清空tail</span></span><br><span class="line">                tail = <span class="keyword">new</span> <span class="constructor">StringBuilder()</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(c<span class="operator"> == </span><span class="character">']'</span>) &#123;</span><br><span class="line">                <span class="comment">// 碰到右括号，首先把落单的，在被加密的字符的前面的字符pop出来</span></span><br><span class="line">                StringBuilder temp = <span class="keyword">new</span> <span class="constructor">StringBuilder(<span class="params">strStack</span>.<span class="params">pop</span>()</span>);</span><br><span class="line">                <span class="comment">// 记录当前被加密的内容的重复的次数，从numStack里面pop()即可</span></span><br><span class="line">                <span class="built_in">int</span> repeatedTimes = numStack.pop<span class="literal">()</span>;</span><br><span class="line">                <span class="comment">// 解码的过程，持续将tail的内容放入到temp，从而变成："非加密+加密*次数"</span></span><br><span class="line">                for(<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; repeatedTimes; j++) &#123;</span><br><span class="line">                    temp.append(tail);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 保存当前生成的temp值</span></span><br><span class="line">                tail = temp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return tail.<span class="keyword">to</span><span class="constructor">String()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>


    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/LeetCode/" rel="tag"><i class="fa fa-tag"></i># LeetCode</a>
              <a href="/tags/Algorithms/" rel="tag"><i class="fa fa-tag"></i># Algorithms</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/12/28/LeetCode-Practice-by-Categories/" rel="prev" title="LeetCode Practice by Categories(Array,LinkedList,SkipList)">
      <i class="fa fa-chevron-left"></i> LeetCode Practice by Categories(Array,LinkedList,SkipList)
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/01/13/LeetCode-Practice-by-Categories-Hash-Table/" rel="next" title="LeetCode Practice by Categories Hash Table">
      LeetCode Practice by Categories Hash Table <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC80ODAxMC8yNDUwNw=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#20-Valid-Parentheses-有效的括号-Easy"><span class="nav-text">20.Valid Parentheses(有效的括号)(Easy)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#155-Min-Stack-最小栈-Easy"><span class="nav-text">155.Min Stack(最小栈)(Easy)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#641-Design-Circular-Deque-设计循环双端队列-Mid"><span class="nav-text">641.Design Circular Deque(设计循环双端队列)(Mid)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#225-Implement-Stack-using-Queues-用队列实现栈-Easy"><span class="nav-text">225.Implement Stack using Queues(用队列实现栈)(Easy)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#232-Implement-Queue-using-Stacks-用栈实现队列-Easy"><span class="nav-text">232.Implement Queue using Stacks(用栈实现队列)(Easy)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#239-Sliding-Window-Maximum-滑动窗口最大值-Hard"><span class="nav-text">239.Sliding Window Maximum(滑动窗口最大值)(Hard)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#621-Task-Scheduler-任务调度-Mid"><span class="nav-text">621.Task Scheduler(任务调度)(Mid)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#84-Largest-Rectangle-in-Histogram-柱状图中最大的矩形-Hard"><span class="nav-text">84.Largest Rectangle in Histogram(柱状图中最大的矩形)(Hard)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#85-Maximal-Rectangle-最大矩形-Hard"><span class="nav-text">85.Maximal Rectangle(最大矩形)(Hard)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#42-Trapping-Rain-Water-接雨水-Hard"><span class="nav-text">42.Trapping Rain Water(接雨水)(Hard)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#394-Decode-String-字符串解码-Mid"><span class="nav-text">394.Decode String(字符串解码)(Mid)</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Wang Mingsheng"
      src="/images/faceimage.jpg">
  <p class="site-author-name" itemprop="name">Wang Mingsheng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">37</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wmsheng" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wmsheng" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:wangmingshenghku@163.com" title="E-Mail → mailto:wangmingshenghku@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://music.163.com/#/my/m/music/playlist?id=372605964" title="Music → https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;my&#x2F;m&#x2F;music&#x2F;playlist?id&#x3D;372605964" rel="noopener" target="_blank"><i class="fa fa-fw fa-youtube"></i>Music</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>


    </div>
    
    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=3314336&auto=1&height=66">
    </iframe>

  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wang Mingsheng</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">469k</span>
</div>


<div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_uv">
    本站访客数:<span id="busuanzi_value_site_uv"></span>
  </span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_pv">
    本站访问量<span id="busuanzi_value_site_pv"></span>
  </span>
</div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共252.5k字</span>
</div>

        
<div class="busuanzi-count">
  <script pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.getAttribute('pjax') !== null) {
      element.setAttribute('pjax', '');
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

    </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/clicklove.js"></script>
