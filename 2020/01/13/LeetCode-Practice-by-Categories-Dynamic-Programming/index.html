<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/siyecao.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/siyecao.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","padding":18,"offset":12,"onmobile":false,"b2t":true,"scrollpercent":true},
    copycode: {"enable":true,"show_result":true,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="每个人都是自己命运的主宰——斯蒂尔斯  LeetCode大量动态规划相关题目，其解决思路和具体代码。">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode Dynamic Programming">
<meta property="og:url" content="http://yoursite.com/2020/01/13/LeetCode-Practice-by-Categories-Dynamic-Programming/index.html">
<meta property="og:site_name" content="Hi, This is Bennett">
<meta property="og:description" content="每个人都是自己命运的主宰——斯蒂尔斯  LeetCode大量动态规划相关题目，其解决思路和具体代码。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s2.ax1x.com/2020/02/21/3uunUK.png">
<meta property="og:image" content="https://i.loli.net/2020/04/15/eDzSvToHIdGrtA5.png">
<meta property="article:published_time" content="2020-01-13T04:47:08.000Z">
<meta property="article:modified_time" content="2020-04-20T05:21:51.710Z">
<meta property="article:author" content="Wang Mingsheng">
<meta property="article:tag" content="LeetCode">
<meta property="article:tag" content="Algorithms">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.ax1x.com/2020/02/21/3uunUK.png">

<link rel="canonical" href="http://yoursite.com/2020/01/13/LeetCode-Practice-by-Categories-Dynamic-Programming/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>LeetCode Dynamic Programming | Hi, This is Bennett</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hi, This is Bennett</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags<span class="badge">38</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories<span class="badge">5</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives<span class="badge">41</span></a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/13/LeetCode-Practice-by-Categories-Dynamic-Programming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/faceimage.jpg">
      <meta itemprop="name" content="Wang Mingsheng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hi, This is Bennett">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          LeetCode Dynamic Programming
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-13 12:47:08" itemprop="dateCreated datePublished" datetime="2020-01-13T12:47:08+08:00">2020-01-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-20 13:21:51" itemprop="dateModified" datetime="2020-04-20T13:21:51+08:00">2020-04-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithms-Note/" itemprop="url" rel="index">
                    <span itemprop="name">Algorithms Note</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              
              <span>14k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>每个人都是自己命运的主宰——斯蒂尔斯</p>
</blockquote>
<p>LeetCode大量动态规划相关题目，其解决思路和具体代码。</p>
<a id="more"></a>

<p>动态规划不是空中楼阁。</p>
<p>dynamic programming最常用的场景就是当你的结果存在大量重复的过程的时候，可以用DP利用你在过程中得到的结果。</p>
<h2 id="70-Climbing-stairsl-爬楼梯-Easy"><a href="#70-Climbing-stairsl-爬楼梯-Easy" class="headerlink" title="70. Climbing-stairsl(爬楼梯)(Easy)"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. Climbing-stairsl(爬楼梯)(Easy)</a></h2><p>You are climbing a stair case. It takes n steps to reach to the top.</p>
<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>
<p>Note: Given <em>n</em> will be a positive integer.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">Output:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">Explanation:</span> <span class="string">There</span> <span class="string">are</span> <span class="string">two</span> <span class="string">ways</span> <span class="string">to</span> <span class="string">climb</span> <span class="string">to</span> <span class="string">the</span> <span class="string">top.</span></span><br><span class="line"><span class="number">1</span><span class="string">.</span> <span class="number">1</span> <span class="string">step</span> <span class="string">+</span> <span class="number">1</span> <span class="string">step</span></span><br><span class="line"><span class="number">2</span><span class="string">.</span> <span class="number">2</span> <span class="string">steps</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">Output:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">Explanation:</span> <span class="string">There</span> <span class="string">are</span> <span class="string">three</span> <span class="string">ways</span> <span class="string">to</span> <span class="string">climb</span> <span class="string">to</span> <span class="string">the</span> <span class="string">top.</span></span><br><span class="line"><span class="number">1</span><span class="string">.</span> <span class="number">1</span> <span class="string">step</span> <span class="string">+</span> <span class="number">1</span> <span class="string">step</span> <span class="string">+</span> <span class="number">1</span> <span class="string">step</span></span><br><span class="line"><span class="number">2</span><span class="string">.</span> <span class="number">1</span> <span class="string">step</span> <span class="string">+</span> <span class="number">2</span> <span class="string">steps</span></span><br><span class="line"><span class="number">3</span><span class="string">.</span> <span class="number">2</span> <span class="string">steps</span> <span class="string">+</span> <span class="number">1</span> <span class="string">step</span></span><br></pre></td></tr></table></figure>
<hr>
<p>解：爬楼梯很经典，变型也很多。首先结论是，单纯的这道题，通过数学归纳的思路(或者说递归的思路)，不难发现其实结果就是前两个元素为1,2的斐波那契数列。(斐波那契数列为509题，因为类似这里就不记录了，链接<a href="https://leetcode-cn.com/problems/fibonacci-number/" target="_blank" rel="noopener">点击这里</a>)</p>
<p>方法一：递归，可以画出递归树发现，因为每个层级都会在上一层的数量基础上多出2倍的节点，所以时间复杂度为O(2^n)，指数级别，不可以接受。而且实际测试中在N为44的时候会出现超时。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> climbStairs(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> climbHelper(<span class="number">0</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> climbHelper(<span class="built_in">int</span> curr, <span class="built_in">int</span> target) &#123;</span><br><span class="line">        <span class="comment">// terminator</span></span><br><span class="line">        <span class="comment">// 跨过了目标阶梯，不算入方法</span></span><br><span class="line">        <span class="keyword">if</span>(curr &gt; target) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 刚好攀登到某个位置</span></span><br><span class="line">        <span class="keyword">if</span>(curr == target) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> climbHelper(curr + <span class="number">1</span>, target) + climbHelper(curr + <span class="number">2</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>方法二：基于递归，加上备忘录，进行有记忆的递归，可以把之前计算过的结果保存下来，有很好的剪枝效果。因为有记录所有的过程，所以子问题的数量就是f(1),f(2)…，为O(n),而且每个子问题解决的时间为O(n)</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> climbStairs(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="comment">// 基于暴力递归，进行有记忆的递归，把每一步的结果存储在mem数组之中，每当有函数被再次调用，就直接从memo数组返回结果，减少计算次数</span></span><br><span class="line">        <span class="built_in">int</span>[] memo = new <span class="built_in">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> climbHelper(<span class="number">0</span>,n,memo);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> climbHelper(<span class="built_in">int</span> curr, <span class="built_in">int</span> target, <span class="built_in">int</span>[] memo) &#123;</span><br><span class="line">        <span class="comment">// terminator</span></span><br><span class="line">        <span class="comment">// 跨过了目标阶梯，不算入方法</span></span><br><span class="line">        <span class="keyword">if</span>(curr &gt; target) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 刚好攀登到某个位置</span></span><br><span class="line">        <span class="keyword">if</span>(curr == target) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果当前N阶梯数量已经计算过，直接从memo返回</span></span><br><span class="line">        <span class="keyword">if</span>(memo[curr] &gt; <span class="number">0</span>) <span class="keyword">return</span> memo[curr];</span><br><span class="line">        </span><br><span class="line">        memo[curr] =  climbHelper(curr + <span class="number">1</span>, target, memo) + climbHelper(curr + <span class="number">2</span>, target, memo);</span><br><span class="line">        <span class="keyword">return</span> memo[curr];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>方法三：常规动态规划，时间复杂度为O(n)，空间复杂度也为O(n)</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> climbStairs(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// dp[i]表示爬到第i阶共有的爬法</span></span><br><span class="line">        <span class="built_in">int</span>[] dp = new <span class="built_in">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>; dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法四：基于常规动态规划的优化。在空间复杂度上可以提升到O(1)。实际上在一开始的时间复杂度的基础上都可以进行空间的优化，比如O(n)可以优化到O(1),O(m*n)可以优化到O(n)。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> climbStairs(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> f1 = <span class="number">1</span>, f2 = <span class="number">2</span>, f3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            f3 = f1 + f2;</span><br><span class="line">            f1 = f2;</span><br><span class="line">            f2 = f3;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="322-Coin-Change-零钱兑换-Mid"><a href="#322-Coin-Change-零钱兑换-Mid" class="headerlink" title="322. Coin Change(零钱兑换)(Mid)"></a><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">322. Coin Change(零钱兑换)(Mid)</a></h2><p>You are given coins of different denominations and a total amount of money <em>amount</em>. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return <code>-1</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="string">coins</span> <span class="string">=</span> <span class="string">[1,</span> <span class="number">2</span><span class="string">,</span> <span class="number">5</span><span class="string">],</span> <span class="string">amount</span> <span class="string">=</span> <span class="number">11</span></span><br><span class="line"><span class="attr">Output:</span> <span class="number">3</span> </span><br><span class="line"><span class="attr">Explanation:</span> <span class="number">11</span> <span class="string">=</span> <span class="number">5</span> <span class="string">+</span> <span class="number">5</span> <span class="string">+</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="string">coins</span> <span class="string">=</span> <span class="string">[2],</span> <span class="string">amount</span> <span class="string">=</span> <span class="number">3</span></span><br><span class="line"><span class="attr">Output:</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>


<p><strong>Note:</strong></p>
<p>You may assume that you have an infinite number of each kind of coin.</p>
<hr>
<p>解：这道题其实和之前的爬楼梯问题是异曲同工之处，可以看成每次可以走coins数组里面的步伐，最后要到达amount的高度，有多少种走法。当然这里有点变化，就是比如112和121，在爬楼梯问题是不同方法，而在这里coin change则是相同的，一种方法。但是写DP方程的话差不多了。</p>
<p>方法一：暴力法，用递归的方式。</p>
<p><img src="https://s2.ax1x.com/2020/02/21/3uunUK.png" alt="3uunUK.png"></p>
<p>题目变成：在状态树中找到叶子节点为0的，并且层数最小的。<br>可以用树的广度优先遍历，直到碰到数值为0的节点，当前层数就是最小硬币数，就是我们的答案。</p>
<p>但是这个方法会存在指数级别的时间复杂度。</p>
<p>方法二：DP</p>
<p>a. subproblems</p>
<p>b. DP array：f(n) = min{f(n-k), for k in [1,2,5]} + 1, 遍历可以选择的面值的数组，直到n被减到0为止，然后取得到的硬币数的最小值。加一是因为一开始的n-k没有被算入，后面补上。</p>
<p>c. DP方程</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// amount + 1 是无法到达的，以此判断最后是否不能到达amount</span></span><br><span class="line">        <span class="keyword">int</span> max = amount+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// dp数组的下标是当前金额，里面的值是需要的硬币的个数，初始化是不可达的max</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line">        <span class="comment">// 初始化dp,初始化考虑只有面值为1的硬币，需要max个</span></span><br><span class="line">        Arrays.fill(dp,max);</span><br><span class="line">        <span class="comment">// 当拿到的amount是0的时候，需要0个硬币，类似爬楼梯，初始化就在0级台阶</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 外层，遍历所有下标的元素，也就是当前凑到的面值数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">            <span class="comment">// 每次都从coins里面取元素出来，比如coins是[1,2,5]，每次在要凑下标</span></span><br><span class="line">            <span class="comment">// 值的时候，都会把1,2,5取出来进行值的拼凑</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; coins.length; j++) &#123;</span><br><span class="line">                <span class="comment">// 如果当前coins里面取出来的值比下标小，才能用。否则比如你下标是3，</span></span><br><span class="line">                <span class="comment">// 即当前要凑到3的值，但当前conis里面硬币值是10，那肯定不用这个</span></span><br><span class="line">                <span class="keyword">if</span>(coins[j] &lt;= i) &#123;</span><br><span class="line">                    <span class="comment">// 用DP方程进行递推</span></span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[i-coins[j]] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果最后一个没有被修改，则没办法组成这个金额。否则返回最后amount下标的值</span></span><br><span class="line">        <span class="keyword">return</span> dp[amount] == max ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态规划一般脱离递归，直接由循环迭代完成计算。</p>
<p>动态规划问题最难的就是写出状态转移方程。</p>
<p>时间复杂度：O(m*n)</p>
<h2 id="343-Integer-Break-整数拆分-Mid"><a href="#343-Integer-Break-整数拆分-Mid" class="headerlink" title="343. Integer Break(整数拆分)(Mid)"></a><a href="https://leetcode-cn.com/problems/integer-break/" target="_blank" rel="noopener">343. Integer Break(整数拆分)(Mid)</a></h2><p>Given a positive integer n, break it into the sum of <strong>at least</strong> two positive integers and maximize the product of those integers. Return the maximum product you can get.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">Output:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">Explanation:</span> <span class="number">2</span> <span class="string">=</span> <span class="number">1</span> <span class="string">+</span> <span class="number">1</span><span class="string">,</span> <span class="number">1</span> <span class="string">×</span> <span class="number">1</span> <span class="string">=</span> <span class="number">1</span><span class="string">.</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">Output:</span> <span class="number">36</span></span><br><span class="line"><span class="attr">Explanation:</span> <span class="number">10</span> <span class="string">=</span> <span class="number">3</span> <span class="string">+</span> <span class="number">3</span> <span class="string">+</span> <span class="number">4</span><span class="string">,</span> <span class="number">3</span> <span class="string">×</span> <span class="number">3</span> <span class="string">×</span> <span class="number">4</span> <span class="string">=</span> <span class="number">36</span><span class="string">.</span></span><br></pre></td></tr></table></figure>

<p><strong>Note</strong>:You may assume that <em>n</em> is not less than 2 and not larger than 58</p>
<p><strong>注</strong>：这道题和剑指offer上第14，剪绳子，题目不同，但是考察内容非常类似。链接可以<a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/" target="_blank" rel="noopener">点击这里</a></p>
<hr>
<p>解：这道题可以用纯数学思路和动态规划两种方法解决</p>
<p>方法一：纯数学，其实就是通过分析之后用贪心法。可以用数学归纳法证明，目标是拆分成多个3的乘积，并且能拆分成2*2就不拆分成 1 * 3。</p>
<p>详细内容可以参考<a href="https://leetcode-cn.com/problems/integer-break/solution/343-zheng-shu-chai-fen-tan-xin-by-jyd/" target="_blank" rel="noopener">这篇题解</a></p>
<p>简而言之，要尽可能把数字拆分成3或者3的倍数。但是按照题目要求，至少要剪一次，至少要两段，所以边界条件值(n小于等于3的时候)可以考虑返回n-1.</p>
<p>因为拆分成2比拆分成3乘积更小，所以3优先级大于2,2大于1</p>
<p>然后要求出n除以3的整数部分a和余数部分b(即<code>n=3*a+b</code>)，要分成三种情况：</p>
<ol>
<li>当b=0时，直接返回3^a;</li>
<li>当b=1时，要将一个1+3转换成2+2，因为2*2 &gt; 1 * 3，因此返回 3^(a-1) * 4;</li>
<li>当b=2时，返回3^n*2即可</li>
</ol>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">3</span>) <span class="keyword">return</span> n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> a = n / <span class="number">3</span>, b = n % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>,a);</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">1</span>) <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>, a-<span class="number">1</span>) * <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>,a) * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度为O(1)，仅有求整、取余、次方计算操作</li>
<li>空间复杂度：O(1)，只需要变量a和b和常数大小的额外空间</li>
</ul>
<h2 id="221-Maximal-Square-最大正方形-Mid"><a href="#221-Maximal-Square-最大正方形-Mid" class="headerlink" title="221.  Maximal Square(最大正方形)(Mid)"></a><a href="https://leetcode-cn.com/problems/maximal-square/" target="_blank" rel="noopener">221.  Maximal Square(最大正方形)(Mid)</a></h2><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area.</p>
<p><strong>Example:</strong></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: </span><br><span class="line"></span><br><span class="line">1 0 1 0 0</span><br><span class="line">1 0 1 1 1</span><br><span class="line">1 1 1 1 1</span><br><span class="line">1 0 0 1 0</span><br><span class="line"></span><br><span class="line"><span class="attribute">Output</span>: 4</span><br></pre></td></tr></table></figure>

<hr>
<p>解：别误读了题意，输入只是二维matrix，要找Square而已！</p>
<p>这道题看上去和”Stack-Queue”系列的84、85题好像很类似，但是做法和思路完全不同，而且也比那两道题更简单……主要的原因是正方形比矩形性质好用太多，直接用动态规划的思想即可。</p>
<p>发现规律：申请一个dp[][][]二维数组，通过找规律和观察，可以发现，如果某个位置的值为1，那么这个位置上的值取决于它的<font color=#FF0000>上面、左上角、左边</font>三个值的最小值加1.</p>
<p>然后每次都检查当前存储的值是否可以替换掉之前的maxSquare值即可。</p>
<p>因为最后求的是area，所以直接返回<code>maxSquare*maxSquare</code>即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 注意rows和cols的值，别弄反了</span></span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length, cols = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// 最大边长</span></span><br><span class="line">        <span class="keyword">int</span> maxSquare = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 申请dp数组，大小比行和列都多1，这样可以防止处理的时候越界</span></span><br><span class="line">        <span class="comment">// 申请的时候多申请1，这道题可以不用考虑边界情况，直接把</span></span><br><span class="line">        <span class="comment">// 原本的数组重新"填"到dp数组里，值是当前能组成的最大Square</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[rows + <span class="number">1</span>][cols + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i - <span class="number">1</span>][j - <span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    <span class="comment">// 取当前左、上、左上三个方向的最小值，再加1</span></span><br><span class="line">                    <span class="comment">// Math.min函数一次最多只能有两个参数，要注意</span></span><br><span class="line">                    dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>],Math.min(dp[i][j - <span class="number">1</span>],dp[i - <span class="number">1</span>][j])) + <span class="number">1</span>;</span><br><span class="line">                    maxSquare = Math.max(maxSquare, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSquare * maxSquare;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="303-Range-Sum-Query-Immutable-区域和检索-数组不可变-Easy"><a href="#303-Range-Sum-Query-Immutable-区域和检索-数组不可变-Easy" class="headerlink" title="303.Range Sum Query-Immutable(区域和检索-数组不可变)(Easy)"></a><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/" target="_blank" rel="noopener">303.Range Sum Query-Immutable(区域和检索-数组不可变)(Easy)</a></h2><p>Given an integer array <em>nums</em>, find the sum of the elements between indices i and j (<em>i</em> ≤ <em>j</em>), inclusive.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [<span class="number">-2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">-5</span>, <span class="number">2</span>, <span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">sumRange(<span class="number">0</span>, <span class="number">2</span>) -&gt; <span class="number">1</span></span><br><span class="line">sumRange(<span class="number">2</span>, <span class="number">5</span>) -&gt; <span class="number">-1</span></span><br><span class="line">sumRange(<span class="number">0</span>, <span class="number">5</span>) -&gt; <span class="number">-3</span></span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ol>
<li>You may assume that the array does not change.</li>
<li>There are many calls to sumRange function.</li>
</ol>
<hr>
<p>解：动态规划的思路解决，预先将所有的相加可能的结果计算出来并存储起来，然后调用它来找到即可。注意下标问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sums[];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        sums = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        sums[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length; i++) &#123;</span><br><span class="line">            sums[i+<span class="number">1</span>]  = sums[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sums[j+<span class="number">1</span>] - sums[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumArray obj = new NumArray(nums);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.sumRange(i,j);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>注意，先把所有计算结果保存起来，每次访问的话只需要O(1)，否则每次访问再计算，会导致时间复杂度太高。</p>
<h2 id="53-Maximum-Subarray-最大子序和"><a href="#53-Maximum-Subarray-最大子序和" class="headerlink" title="53.Maximum Subarray(最大子序和)"></a>53.<a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">Maximum Subarray(最大子序和)</a></h2><p>Given an integer array <code>nums</code>, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>],</span><br><span class="line">Output: <span class="number">6</span></span><br><span class="line">Explanation: [<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>] has the largest sum = <span class="number">6.</span></span><br></pre></td></tr></table></figure>

<p><strong>Follow up:</strong></p>
<p>If you have figured out the O(<em>n</em>) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p>
<hr>
<p>解：动态规划，定义数组dp[n.length]，其中dp[i]表示当前第i个元素可以得到的最大和，递推公式关键在于dp[i]为nums[i]与dp[i-1]+nums[i]之间的最大值，因为每次两种选择，直接加入nums[i]，或者从之前dp[i]和都小于0，需要重新从nums[i]开始算起。而在过程中需要记录当前能得到的最大的子序和max，最后返回max即可。</p>
<p>为什么要有一个max记录最大值？状态都放在dp[i]不就行了？——不可以，答案很可能是子序和，所以要有一个单独的变量保存结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="comment">// dp[i]表示第i位置到上一个计算起点的最大子序和的值</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span> result = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 比较巧妙，如果dp[i-1]&lt;0，那么肯定丢弃dp[i-1]能让dp[i]更大</span></span><br><span class="line">            <span class="comment">// 反之同理，如果dp[i-1] &gt; 0，那么加上dp[i-1]能让dp[i]更大</span></span><br><span class="line">            dp[i] = nums[i] + (dp[i-<span class="number">1</span>] &gt; <span class="number">0</span> ? dp[i-<span class="number">1</span>] : <span class="number">0</span>);</span><br><span class="line">            result = Math.max(dp[i], result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>300.<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">Longest Increasing Subsequence(最长上升子序列)</a></p>
<p>Given an unsorted array of integers, find the length of longest increasing subsequence.</p>
<p><strong>Example:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">10</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">101</span>,<span class="number">18</span>]</span><br><span class="line">Output: <span class="number">4</span> </span><br><span class="line">Explanation: The longest increasing subsequence <span class="keyword">is</span> [<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">101</span>], therefore the length <span class="keyword">is</span> <span class="number">4.</span></span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ul>
<li>There may be more than one LIS combination, it is only necessary for you to return the length.</li>
<li>Your algorithm should run in O(n^ 2) complexity.</li>
</ul>
<p><strong>Follow up:</strong> Could you improve it to O(<em>n</em> log <em>n</em>) time complexity?</p>
<hr>
<p>解：这道题非常重要，如果面试中出现了，现场想基本是想不到的。</p>
<p>方法一：暴力，时间是指数级别O(2^n)，因为要以每个数为中心，然后右边只要碰到比它大的就要继续往后探索。比如当前为2，碰到5要继续让5往后分叉，到7,7还要继续往后，等等。</p>
<p><strong>方法二</strong>：动态规划，记录dp[i]的结果，自底向上思考，定义dp[i]为以当前第i位数字为结尾能够组成的LIS，则最后返回的结果是<code>max(k=1,2...n)dp[k]</code>。</p>
<p>一开始我们把dp数组所有元素填上1，因为每个元素一定能用自己组成一个结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        Arrays.fill(dp,<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i ;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    <span class="comment">//dp[i]每次的选择有两个：用dp[j]或者不用。</span></span><br><span class="line">                    <span class="comment">//如果用dp[j]里面的值，则在dp[j]基础上加1</span></span><br><span class="line">                    <span class="comment">//如果不用，说明用nums[i]组成的子序列更长，直接用dp[i]即可</span></span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//每次以i为轴，记录每轮最大的结果，保存到result中</span></span><br><span class="line">                result = Math.max(result,dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)</p>
<p>空间复杂度：O(n)</p>
<p>但是实际上，单纯用动态规划的时间复杂度太高了，面试的时候面试官不会满意的。</p>
<p><strong>方法三</strong>：最优解，用binary search，二分查找来解决，时间复杂度可以到O(NlogN)</p>
<p>之前用dp的时候是自底向上的思路，那么如果我们正向来思考呢？</p>
<p>我们从左往右遍历，自己构建出来这个目标结果数组。每遍历到一个数，我们就判断这个数应该在我们最长上升子序列的哪个部分，然后更新这个部分。每次构造的数字实际上只能有三种情况：<strong>放到结果数组的第一位、插入到第中间、放到最后</strong>——只有放在最后，长度才+1。而如果放在中间，则只有新来的数比之前中间的小，才能让整体上升序列更长。</p>
<p>所以总结来说，可以观察到，<strong>如果出现新的最大值，整个数组长度会+1，如果遇到新的最大值比当前最大值小，那么就会更新dp的最大值因为后面出现的最大值一定可以被加到之前的连续上升subsequence当中，因为最后一个元素能更小的话这个边界肯定是最优的</strong>。所以这样我们最后得到的dp数据可能不对，但是长度肯定没错。</p>
<p><strong>具体解法</strong>：</p>
<p>首先我们可以用Java的Arrays类中的binarySearch()方法进行二分搜索。该方法返回要搜索元素的索引值。</p>
<p>介绍一下binarySearch()方法：</p>
<p><code>binarySearch(Object[] a,int fromIndex, int toIndex, Object key)</code></p>
<p>a:要搜索的数组</p>
<p>fromIndex：指定范围的开始处索引(包含)</p>
<p>toIndex：指定范围的结束处索引(不包含)</p>
<p>key：要搜索的值</p>
<p>Note:Arrays.binarySearch() method returns index of the search key, if it is contained in the array, else it returns (-(insertion point) - 1). The insertion point is the point at which the key would be inserted into the array; the index of the first element greater than the key, or a.length if all elements in the array are less than the specified key.</p>
<p>如果要搜索的元素key在指定的范围内，则返回搜索值的索引；否则返回<strong>-1</strong>或<strong>“-“(插入点)</strong>，所谓插入点的值就是第一个比关键字大的元素在数组中的位置索引，<font color=#FF0000>而且这个位置索引从1开始</font>，或者如果整个数组所有元素都比这个key小，那么返回的是-(a.length+1)。返回-1的情况是一开始查找的数组中也没有元素(即数组长度为0)的边界情况。</p>
<p><a href="https://www.cnblogs.com/qingergege/p/5658292.html" target="_blank" rel="noopener">有关binarySearch()的介绍可以参考这篇文章</a></p>
<p><a href="https://www.youtube.com/watch?v=nNPy623huVU" target="_blank" rel="noopener">这道题解法讲解可以参考这个视频</a></p>
<p>注意这个函数是被重载的，在这里只介绍这种参数形式。</p>
<p>用binarySearch()优化之后的dp方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;            </span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="comment">//范围是0~len，每次查找的元素是x</span></span><br><span class="line">            <span class="keyword">int</span> index = Arrays.binarySearch(dp, <span class="number">0</span>, len, num);</span><br><span class="line">            <span class="keyword">if</span>(index &lt; <span class="number">0</span>) &#123; <span class="comment">//没有重复元素。之后会直接返回插入点，若没找到，</span></span><br><span class="line">                <span class="comment">//插入点是从1开始最后又加上负号的值，所以i要先加1再取负才是新元素应该在</span></span><br><span class="line">                <span class="comment">//dp数组中的具体位置</span></span><br><span class="line">                index = -(index + <span class="number">1</span>);<span class="comment">//一开始插入的时候，实际坐标其实是-(-1+1)=0</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找到插入点后将元素x插入递增数组dp对应位置</span></span><br><span class="line">            dp[index] = num;</span><br><span class="line">            <span class="keyword">if</span>(index == len) <span class="comment">//若插入的位置在最后，len++，这也是唯一会让len增加的情况</span></span><br><span class="line">                len++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(NlogN)</li>
<li>空间复杂度：O(n)</li>
</ul>
<p>但是如果面试中面试官不允许使用Arrays.binarySearch，则可以我们自己手写一个二分查找的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] tails = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>, right = len;</span><br><span class="line">            <span class="comment">//手写二分查找算法，找到插入的位置left</span></span><br><span class="line">            <span class="keyword">while</span>(left != right) &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(tails[mid] &lt; num)</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            tails[left] = num;</span><br><span class="line">            <span class="keyword">if</span>(left == len) </span><br><span class="line">                len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指offer-62-圆圈中最后剩下的数字-Easy"><a href="#剑指offer-62-圆圈中最后剩下的数字-Easy" class="headerlink" title="剑指offer 62.圆圈中最后剩下的数字(Easy)"></a><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/" target="_blank" rel="noopener">剑指offer 62.圆圈中最后剩下的数字(Easy)</a></h2><p>0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p>
<p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p>
<p><strong>示例 1</strong>：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n = <span class="number">5</span>, m = <span class="number">3</span></span><br><span class="line">输出: <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n = <span class="number">10</span>, m = <span class="number">17</span></span><br><span class="line">输出: <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>限制</strong>：</p>
<ul>
<li><code>1 &lt;= n &lt;= 10^5</code></li>
<li><code>1 &lt;= m &lt;= 10^6</code></li>
</ul>
<hr>
<p>解：<strong>方法一</strong>：用双向链表(或者用单向链表模拟双向链表)来删除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// idx为每次删除元素的位置</span></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// n为环中剩余的元素数量而不是下标，所以n最后要为1</span></span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// idx为当前要删除的元素的下标</span></span><br><span class="line">            idx = (idx + m - <span class="number">1</span>) % n;</span><br><span class="line">            list.remove(idx);</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：因为看到ArrayList中的源码，删除操作需要遍历一遍链表，所以整个时间复杂度趋近于O(mn)或O(n^2)</li>
<li>空间复杂度：O(n)</li>
</ul>
<p><strong>方法二</strong>：这是非常经典的约瑟夫环问题，考虑最后剩余的1个圆环的位置，发现有规律！直接用数学方法解决，通过每轮删除元素的下标的值，如果从0开始倒着推，可以找到如下规律：</p>
<p>第一轮是 [0, 1, 2, 3, 4] ，所以是 [0, 1, 2, 3, 4] 这个数组的多个复制。这一轮 2 删除了。</p>
<p>第二轮开始时，从 3 开始，所以是 [3, 4, 0, 1] 这个数组的多个复制。这一轮 0 删除了。</p>
<p>第三轮开始时，从 1 开始，所以是 [1, 3, 4] 这个数组的多个复制。这一轮 4 删除了。</p>
<p>第四轮开始时，还是从 1 开始，所以是 [1, 3] 这个数组的多个复制。这一轮 1 删除了。</p>
<p>最后剩下的数字是 3。</p>
<p>图中的绿色的线指的是新的一轮的开头是怎么指定的，每次都是固定地向前移位 mm 个位置。</p>
<p>然后我们从最后剩下的 3 倒着看，我们可以反向推出这个数字在之前每个轮次的位置。</p>
<p>最后剩下的 3 的下标是 0。</p>
<p>第四轮反推，补上 m 个位置，然后模上当时的数组大小 2，位置是(0 + 3) % 2 = 1。</p>
<p>第三轮反推，补上 m 个位置，然后模上当时的数组大小 3，位置是(1 + 3) % 3 = 1。</p>
<p>第二轮反推，补上 m 个位置，然后模上当时的数组大小 4，位置是(1 + 3) % 4 = 0。</p>
<p>第一轮反推，补上 m 个位置，然后模上当时的数组大小 5，位置是(0 + 3) % 5 = 3。</p>
<p>所以最终剩下的数字的下标就是3。因为数组是从0开始的，所以最终的答案就是3。</p>
<p>总结一下反推的过程，就是 (当前index + m) % 上一轮剩余数字的个数。</p>
<p>所以公式为：<code>最终被删元素下标 = (当前index + m) % 上一轮剩余数字的个数</code></p>
<p><img src="https://i.loli.net/2020/04/15/eDzSvToHIdGrtA5.png" alt="约瑟夫环递推公式.png"></p>
<p>用代码来写就比较容易了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">1</span> || m &lt; <span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//最后一轮剩两个人，从2开始反推</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            result = (result + m) % i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<p>无理论是时间复杂度还是空间复杂度都优于用环形链表模拟圆环的经典解法(后者时间复杂度O(mn)、空间复杂度O(n))。有关约瑟夫环递推公式推理可以参考LeetCode题解，重点是自底向上地反推。</p>
<h2 id="剑指offer-63-LC121-股票的最大利润-Mid"><a href="#剑指offer-63-LC121-股票的最大利润-Mid" class="headerlink" title="剑指offer 63/LC121.股票的最大利润(Mid)"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">剑指offer 63/LC121.股票的最大利润(Mid)</a></h2><p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p>
<p>If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
<p>Note that you cannot sell a stock before you buy one.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">Output: <span class="number">5</span></span><br><span class="line">Explanation: Buy on day <span class="number">2</span> (price = <span class="number">1</span>) <span class="keyword">and</span> sell on day <span class="number">5</span> (price = <span class="number">6</span>), profit = <span class="number">6</span><span class="number">-1</span> = <span class="number">5.</span></span><br><span class="line">             Not <span class="number">7</span><span class="number">-1</span> = <span class="number">6</span>, as selling price needs to be larger than buying price.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">Output: <span class="number">0</span></span><br><span class="line">Explanation: In <span class="keyword">this</span> <span class="keyword">case</span>, no transaction <span class="keyword">is</span> done, i.e. max profit = <span class="number">0.</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：这道题可以牵扯出买卖股票的一系列问题(121,122,123,188,309,714)，这里暂时只介绍121这道最基础的情况。</p>
<p>由于不用考虑交易的次数和交易冷冻时期，所以这道题场景比较简单，只需要定义一个二维数组即可，大小为dp [len] [2]，其中第二位只可能有两种情况，0或1,0代表当前没有股友股票，1代表当前持有股票。</p>
<p>需要注意考虑边界情况，即第一天如果没有股票，则收益为0；如果有股票，则可以看做是新买入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = prices.length;</span><br><span class="line">        <span class="comment">//dp[][]表示第i天是否持有股票时候的利润</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//第1天不持有股票，利润是0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//第1天就持有股票，必须买入，故此时利润是-prices[0]</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">//第i天买入股票或卖出股票</span></span><br><span class="line">            <span class="comment">//0代表不持有，有两种：</span></span><br><span class="line">            <span class="comment">//第i天不买入也不卖出，或者卖出。</span></span><br><span class="line">            <span class="comment">//前者利润和i-1天不持有股票一样</span></span><br><span class="line">            <span class="comment">//后者利润是i-1天持有股票的利润加上股票的价值</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i]);</span><br><span class="line">            <span class="comment">//1为第i天持有股票时候的利润，也是两种情况：</span></span><br><span class="line">            <span class="comment">//一个是第i-1天拥有股票，那么这一天的收益和前一天拥有股票时收益相同</span></span><br><span class="line">            <span class="comment">//一个是第i-1天没有股票，则要新买入，收益是"-股票价格"</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(-prices[i], dp[i-<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最大利润的情况一定是最后一天不持有股票的时候的盈利值</span></span><br><span class="line">        <span class="keyword">return</span> dp[len-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>


    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/LeetCode/" rel="tag"><i class="fa fa-tag"></i># LeetCode</a>
              <a href="/tags/Algorithms/" rel="tag"><i class="fa fa-tag"></i># Algorithms</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/01/13/LeetCode-Practice-by-Categories-Search/" rel="prev" title="LeetCode Search">
      <i class="fa fa-chevron-left"></i> LeetCode Search
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/01/13/LeetCode-Practice-by-Categories-Bitwise-Operation/" rel="next" title="LeetCode Bitwise Operation">
      LeetCode Bitwise Operation <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC80ODAxMC8yNDUwNw=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#70-Climbing-stairsl-爬楼梯-Easy"><span class="nav-text">70. Climbing-stairsl(爬楼梯)(Easy)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#322-Coin-Change-零钱兑换-Mid"><span class="nav-text">322. Coin Change(零钱兑换)(Mid)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#343-Integer-Break-整数拆分-Mid"><span class="nav-text">343. Integer Break(整数拆分)(Mid)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#221-Maximal-Square-最大正方形-Mid"><span class="nav-text">221.  Maximal Square(最大正方形)(Mid)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#303-Range-Sum-Query-Immutable-区域和检索-数组不可变-Easy"><span class="nav-text">303.Range Sum Query-Immutable(区域和检索-数组不可变)(Easy)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#53-Maximum-Subarray-最大子序和"><span class="nav-text">53.Maximum Subarray(最大子序和)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指offer-62-圆圈中最后剩下的数字-Easy"><span class="nav-text">剑指offer 62.圆圈中最后剩下的数字(Easy)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指offer-63-LC121-股票的最大利润-Mid"><span class="nav-text">剑指offer 63&#x2F;LC121.股票的最大利润(Mid)</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Wang Mingsheng"
      src="/images/faceimage.jpg">
  <p class="site-author-name" itemprop="name">Wang Mingsheng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wmsheng" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wmsheng" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:wangmingshenghku@163.com" title="E-Mail → mailto:wangmingshenghku@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://music.163.com/#/my/m/music/playlist?id=372605964" title="Music → https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;my&#x2F;m&#x2F;music&#x2F;playlist?id&#x3D;372605964" rel="noopener" target="_blank"><i class="fa fa-fw fa-youtube"></i>Music</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>


    </div>
    
    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=3314336&auto=1&height=66">
    </iframe>

  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wang Mingsheng</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">655k</span>
</div>


<div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_uv">
    本站访客数:<span id="busuanzi_value_site_uv"></span>
  </span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_pv">
    本站访问量<span id="busuanzi_value_site_pv"></span>
  </span>
</div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共336.9k字</span>
</div>

        
<div class="busuanzi-count">
  <script pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.getAttribute('pjax') !== null) {
      element.setAttribute('pjax', '');
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

    </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/clicklove.js"></script>
