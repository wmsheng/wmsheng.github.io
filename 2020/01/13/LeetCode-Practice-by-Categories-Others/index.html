<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/siyecao.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/siyecao.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","padding":18,"offset":12,"onmobile":false,"b2t":true,"scrollpercent":true},
    copycode: {"enable":true,"show_result":true,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="时间像海绵里的水，只要你愿意挤，总还是有的。——鲁迅  LeetCode其他题目其解决思路和具体代码。">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode Practice by Categories Others">
<meta property="og:url" content="http://yoursite.com/2020/01/13/LeetCode-Practice-by-Categories-Others/index.html">
<meta property="og:site_name" content="Hi, This is Bennett">
<meta property="og:description" content="时间像海绵里的水，只要你愿意挤，总还是有的。——鲁迅  LeetCode其他题目其解决思路和具体代码。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://pic.leetcode-cn.com/815038bb44b7f15f1f32f31d40e75c250cec3c5c42b95175ec012c00a0243833-146-1.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/48292c190e50537087ea8c60ed44062675d55a73d1a59035d26e277a36b7b8e2-146-2.png">
<meta property="article:published_time" content="2020-01-13T04:51:23.000Z">
<meta property="article:modified_time" content="2020-03-23T15:19:51.164Z">
<meta property="article:author" content="Wang Mingsheng">
<meta property="article:tag" content="LeetCode">
<meta property="article:tag" content="Algorithms">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic.leetcode-cn.com/815038bb44b7f15f1f32f31d40e75c250cec3c5c42b95175ec012c00a0243833-146-1.png">

<link rel="canonical" href="http://yoursite.com/2020/01/13/LeetCode-Practice-by-Categories-Others/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>LeetCode Practice by Categories Others | Hi, This is Bennett</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hi, This is Bennett</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags<span class="badge">30</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories<span class="badge">4</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives<span class="badge">36</span></a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/13/LeetCode-Practice-by-Categories-Others/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/faceimage.jpg">
      <meta itemprop="name" content="Wang Mingsheng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hi, This is Bennett">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          LeetCode Practice by Categories Others
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-13 12:51:23" itemprop="dateCreated datePublished" datetime="2020-01-13T12:51:23+08:00">2020-01-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-23 23:19:51" itemprop="dateModified" datetime="2020-03-23T23:19:51+08:00">2020-03-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithms-Note/" itemprop="url" rel="index">
                    <span itemprop="name">Algorithms Note</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              
              <span>15k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>时间像海绵里的水，只要你愿意挤，总还是有的。——鲁迅</p>
</blockquote>
<p>LeetCode其他题目其解决思路和具体代码。</p>
<a id="more"></a>

<h2 id="169-Majority-Element-多数元素-Easy"><a href="#169-Majority-Element-多数元素-Easy" class="headerlink" title="169. Majority Element(多数元素)(Easy)"></a><a href="https://leetcode-cn.com/problems/majority-element/description/" target="_blank" rel="noopener">169. Majority Element(多数元素)(Easy)</a></h2><p>Given an array of size n, find the majority element. The majority element is the element that appears more than <code>⌊ n/2 ⌋</code> times.</p>
<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">Output: <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">Output: <span class="number">2</span></span><br></pre></td></tr></table></figure>
<hr>
<p>解：题目名字是”多数元素”，实际上，就是众数。</p>
<p>思路一：如果你头脑足够灵活，数学感觉足够好，那么实际上抓住一个点就可以：题目问的多数元素，其实不算真正的众数。这里的多数元素出现的次数必须大于 <code>n/2</code> ，所以，如果一个数组中一定有众数，那么这个数组排好序之后，下标为 <code>nums.length/2</code> 的那个元素，就是众数。利用排序，排好序之后返回下标为 <code>nums.length/2</code>的元素，就是这道题需要的结果。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> majorityElement(<span class="built_in">int</span>[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为用到了系统自带的排序方法，所以这种方法的时间复杂度是O(NlogN)。</p>
<p>方法二：开两个变量，result为最后返回的结果，count用于统计，因为按照题目定义，众数出现次数一定大于 n/2 ，所以count只要回到了0，说明当前result不可能是最后的众数。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> majorityElement(<span class="built_in">int</span>[] nums) &#123;</span><br><span class="line">        <span class="built_in">int</span> result = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">0</span>) </span><br><span class="line">                result = num;</span><br><span class="line">            <span class="keyword">if</span>(result != num) </span><br><span class="line">                count --;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                count ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h2 id="7-Reverse-Integer-整数反转-Mid"><a href="#7-Reverse-Integer-整数反转-Mid" class="headerlink" title="7. Reverse Integer(整数反转)(Mid)"></a><a href="https://leetcode-cn.com/problems/reverse-integer/" target="_blank" rel="noopener">7. Reverse Integer(整数反转)(Mid)</a></h2><p>Given a 32-bit signed integer, reverse digits of an integer.</p>
<p><strong>Example 1</strong>:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="number">123</span></span><br><span class="line"><span class="attr">Output:</span> <span class="number">321</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2</strong>:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="number">-123</span></span><br><span class="line"><span class="attr">Output:</span> <span class="number">-321</span></span><br></pre></td></tr></table></figure>
<p><strong>Example 3</strong>:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="number">120</span></span><br><span class="line"><span class="attr">Output:</span> <span class="number">21</span></span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong><br>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31,  2^31 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p>
<hr>
<p>解：x最大可以取2^31-1，但是当x取最大值的时候，再reverse之后的数字大小会超出原本Integer能够保存的最大2^31-1的范围了，会报错移除。所以我们需要考虑到如何解决这个溢出的问题。</p>
<p>需要注意：1，翻转后的数字是否会溢出、2，有关负数的处理</p>
<ol>
<li><p>如果不发生溢出，每次的当前结果可以得到是<code>x0*10+y=x1</code>，x1为计算之后得到的新的值。此时我们可以转换一下，解出来x的值：<code>x=(x1-y)/10</code>，可以想到，如果整个计算结果不发生溢出，这个式子是成立的。但是如果计算结果发生了溢出(比如到了2^31-1)，那么这个式子会不成立，我们可以通过这个方式检查当前数字反转之后是否会溢出。</p>
</li>
<li><p>比如传入的是-123，那么<code>-123/10=-12</code>，而且<code>-123%10=-3</code>，然后<code>result*10+x%10</code>这个公式实际上也是负数之间的计算，所以对于负数，不用单独考虑，就用一样的公式计算即可。</p>
</li>
</ol>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> reverse(<span class="built_in">int</span> x) &#123;</span><br><span class="line">        <span class="built_in">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 用一个公式的正和反是否相等来判断当前数字是否溢出</span></span><br><span class="line">            <span class="comment">// result表示以前的数字，乘10再加上新来的数字即为翻转后的数newReverse</span></span><br><span class="line">            <span class="built_in">int</span> newReverse = result * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>((newReverse - x % <span class="number">10</span>) / <span class="number">10</span> != result) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 溢出则返回0</span></span><br><span class="line">            result = newReverse;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-Palindrome-Number-回文数-Mid"><a href="#9-Palindrome-Number-回文数-Mid" class="headerlink" title="9. Palindrome Number(回文数)(Mid)"></a><a href="https://leetcode-cn.com/problems/palindrome-number/" target="_blank" rel="noopener">9. Palindrome Number(回文数)(Mid)</a></h2><p>Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="number">121</span></span><br><span class="line"><span class="attr">Output:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">-121</span></span><br><span class="line">Output: <span class="literal">false</span></span><br><span class="line">Explanation: From left <span class="built_in">to</span> <span class="literal">right</span>, <span class="keyword">it</span> reads <span class="number">-121.</span> From <span class="literal">right</span> <span class="built_in">to</span> left, <span class="keyword">it</span> becomes <span class="number">121</span>-. Therefore <span class="keyword">it</span> is <span class="keyword">not</span> <span class="keyword">a</span> palindrome.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">Output:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">Explanation:</span> <span class="string">Reads</span> <span class="number">01</span> <span class="string">from</span> <span class="string">right</span> <span class="string">to</span> <span class="string">left.</span> <span class="string">Therefore</span> <span class="string">it</span> <span class="string">is</span> <span class="string">not</span> <span class="string">a</span> <span class="string">palindrome.</span></span><br></pre></td></tr></table></figure>

<p><strong>Follow up:</strong></p>
<p>Coud you solve it without converting the integer to a string?</p>
<hr>
<p>解：为了避免溢出问题(如果给的数字本身不是回文，翻转之后有可能大于int.MAX,造成溢出)，直接比较反转的int数的一半即可。</p>
<p>首先要处理临界情况，所有的负数都不可能是回文(这就可以过滤到很多啦！)。</p>
<p>后面的操作就是取出来数字了，取个位可以用对10取余，取十位可以用除以10之后再对10取余。</p>
<p>判断是否到了原始数字的一半，可以让原始数字除以10，再让反转后的数字乘上10。此时如果原始数字小于反转后的数字，就意味着我们已经处理了一半位数的数字了。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span>ean isPalindrome(<span class="built_in">int</span> x) &#123;</span><br><span class="line">        <span class="comment">// 处理特殊情况</span></span><br><span class="line">        <span class="comment">// 所有负数都一定不是回文数</span></span><br><span class="line">        <span class="comment">// 如果某一个数字最后一位是0，那么如果它是回文数，</span></span><br><span class="line">        <span class="comment">// 那么开头也一定要是0，只有0符合</span></span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> revertedNumber  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( x &gt; revertedNumber ) &#123;</span><br><span class="line">            revertedNumber  = revertedNumber  * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x = x/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。</span></span><br><span class="line">        <span class="comment">// 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，</span></span><br><span class="line">        <span class="comment">// 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。</span></span><br><span class="line">        <span class="keyword">return</span> (x == revertedNumber  || x == revertedNumber /<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(log10(N))，因为每次迭代，我们会将输入除以10，因此时间复杂度为O(log10(N))</li>
<li>空间复杂度：O(1)</li>
</ul>
<h2 id="1109-Corporate-Flight-Bookings-航班预订统计-Mid"><a href="#1109-Corporate-Flight-Bookings-航班预订统计-Mid" class="headerlink" title="1109. Corporate Flight Bookings(航班预订统计)(Mid)"></a><a href="https://leetcode-cn.com/problems/corporate-flight-bookings/" target="_blank" rel="noopener">1109. Corporate Flight Bookings(航班预订统计)(Mid)</a></h2><p>There are <code>n</code> flights, and they are labeled from <code>1</code> to <code>n</code>.</p>
<p>We have a list of flight bookings.  The <code>i</code>-th booking <code>bookings[i] = [i, j, k]</code> means that we booked <code>k</code> seats from flights labeled <code>i</code> to <code>j</code> inclusive.</p>
<p>Return an array <code>answer</code> of length <code>n</code>, representing the number of seats booked on each flight in order of their label.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: bookings = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">20</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">25</span>]], n = <span class="number">5</span></span><br><span class="line">Output: [<span class="number">10</span>,<span class="number">55</span>,<span class="number">45</span>,<span class="number">25</span>,<span class="number">25</span>]</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= bookings.length &lt;= 20000</code></li>
<li><code>1 &lt;= bookings[i][0] &lt;= bookings[i][1] &lt;= n &lt;= 20000</code></li>
<li><code>1 &lt;= bookings[i][2] &lt;= 10000</code></li>
</ul>
<hr>
<p>解：这道题利用很经典的”上下车”的思路，可以把<code>booking[i]=[i, j, k]</code>理解成在<code>i</code>站上车<code>k</code>人，这些人乘坐到了第<code>j</code>站，然后在<code>j+1</code>站下车，我们要返回的是按照顺序的每一站上车的人数。</p>
<p>根据上面的思路，定义一个<code>counter[]</code>数组来记录每站人数的变化，<strong><code>counter[i]</code>表示第i+1站</strong>。遍历<code>bookings[],bookings[i]=[i,j,k]</code>表示在i站增加<code>k</code>人,即<code>counter[i-1] += k</code>，在<code>j+1</code>站减少<code>k</code>人，即<code>counter[j] -= k</code></p>
<p>最后遍历counter[]数组，得到每站的总人数：每站的总人数为前一站人数加上当前人数变化：counter[i] += counter[i-1]</p>
<p>重点：第i站上车、第j+1站下车。一开始counter只用于记录某一站人数的变化，后面counter用于保存每一站总共的人数。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>[] corpFlightBookings(<span class="built_in">int</span>[][] bookings, <span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="comment">// 需要注意：counter记录的是人数变化量</span></span><br><span class="line">        <span class="built_in">int</span>[] counter = new <span class="built_in">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span>[] booking : bookings) &#123;</span><br><span class="line">            <span class="comment">// counter[i]表示第i-1站上车，上车人数是booking[2]</span></span><br><span class="line">            counter[booking[<span class="number">0</span>] - <span class="number">1</span>] += booking[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(booking[<span class="number">1</span>] &lt; n) &#123; <span class="comment">// 如果在最后一站或者最后一站之前下车，就要减去</span></span><br><span class="line">                counter[booking[<span class="number">1</span>]] -= booking[<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 统计最后每一站的人数的结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            counter[i] += counter[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n),n是航班的数量</li>
<li>空间复杂度：O(n)</li>
</ul>
<h2 id="135-Candy-分发糖果-Hard"><a href="#135-Candy-分发糖果-Hard" class="headerlink" title="135. Candy(分发糖果)(Hard)"></a><a href="https://leetcode-cn.com/problems/candy/" target="_blank" rel="noopener">135. Candy(分发糖果)(Hard)</a></h2><p>There are <em>N</em> children standing in a line. Each child is assigned a rating value.</p>
<p>You are giving candies to these children subjected to the following requirements:</p>
<ul>
<li>Each child must have at least one candy.</li>
<li>Children with a higher rating get more candies than their neighbors.</li>
</ul>
<p>What is the minimum candies you must give?</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>]</span><br><span class="line">Output: <span class="number">5</span></span><br><span class="line">Explanation: You can allocate to the first, second <span class="keyword">and</span> third child with <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span> candies respectively.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">Output: <span class="number">4</span></span><br><span class="line">Explanation: You can allocate <span class="built_in">to</span> <span class="keyword">the</span> <span class="keyword">first</span>, <span class="keyword">second</span> <span class="keyword">and</span> <span class="keyword">third</span> child <span class="keyword">with</span> <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span> candies respectively.</span><br><span class="line">             The <span class="keyword">third</span> child gets <span class="number">1</span> candy because <span class="keyword">it</span> satisfies <span class="keyword">the</span> above <span class="literal">two</span> conditions.</span><br></pre></td></tr></table></figure>

<hr>
<p>解：需要注意题目说的是，评分高的children分到的candy是比他的<strong>neighbors</strong>多，而不是比其他所有评分比他低的小孩多</p>
<p>一个比较巧妙的方法是，可以从左往右和从右往左两次遍历，改变当前结果数组candy需要遵循这个公式：<code>candy[i] = Math.max(candy[i],candy[i+1]+1)</code></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> candy(<span class="built_in">int</span>[] ratings) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ratings == <span class="literal">null</span> || ratings.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> len = ratings.length;</span><br><span class="line">        <span class="comment">// 最后的结果数组</span></span><br><span class="line">        <span class="built_in">int</span>[] result = new <span class="built_in">int</span>[len];</span><br><span class="line">        <span class="comment">// 初始化每个小孩至少有一个糖果</span></span><br><span class="line">        Arrays.fill(result, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 然后开始遍历，一次从前往后，一次从后往前</span></span><br><span class="line">        <span class="comment">// 两次遍历的过程中第一个都不用管，因为在下一次遍历中会遍历到的</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从左往右,从第2个小孩开始直到最后一个</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前小孩评分比他右边的小孩高，他分到的糖果数</span></span><br><span class="line">            <span class="comment">// 就比他右边的小孩多1个</span></span><br><span class="line">            <span class="keyword">if</span>(ratings[i] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                result[i] = result[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从右往左，从倒数第二个小孩开始直到第一个</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 如果当前小孩评分比他左边小孩低，他左边小孩分到的</span></span><br><span class="line">            <span class="comment">// 糖果数是其本身存储的值和当前右边小孩糖果数+1的最大值</span></span><br><span class="line">            <span class="keyword">if</span>(ratings[i] &gt; ratings[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                result[i] = Math.max(result[i], result[i + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> temp : result) sum += temp;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指offer-面试题03-数组中重复的数字-Easy"><a href="#剑指offer-面试题03-数组中重复的数字-Easy" class="headerlink" title="剑指offer 面试题03 数组中重复的数字(Easy)"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/" target="_blank" rel="noopener">剑指offer 面试题03 数组中重复的数字(Easy)</a></h2><p>找出数组中重复的数字。</p>
<p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>]</span><br><span class="line">输出：<span class="number">2</span> 或 <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong></p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">2 </span>&lt;= n &lt;= <span class="number">100000</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：这道题没有说额外空间的限制，所以可以和面试官讨论一下再决定用哪种方法。</p>
<p>方法一：哈希表，利用哈希Set放入重复元素的时候会返回false(添加失败)来做，每次返回false的时候就将函数返回这个值即可。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    public <span class="built_in">int</span> findRepeatNumber(<span class="built_in">int</span>[] nums) &#123;</span><br><span class="line">        <span class="built_in">Set</span>&lt;Integer&gt; <span class="keyword">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> <span class="built_in">num</span> : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="keyword">set</span>.add(<span class="built_in">num</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">num</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<p>方法二：抓住题目条件，所有数字范围都在0~n-1之内。如果没有重复数字，那么对每一个数排序之后其值都等于下标值。</p>
<p>利用这一点做哈希，遍历整个数组，如果当前数字不等于其下标，就将其和其下标位置的元素交换。在交换过程中，某个重复的数字迟早会有冲突，此时返回即可。</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findRepeatNumber(int[] nums) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(int <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; nums.<span class="built_in">length</span>; <span class="built_in">i</span>++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">i</span> != nums[<span class="built_in">i</span>]) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[<span class="built_in">i</span>] == nums[nums[<span class="built_in">i</span>]]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> nums[<span class="built_in">i</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                int temp = nums[<span class="built_in">i</span>];</span><br><span class="line">                nums[<span class="built_in">i</span>] = nums[temp];</span><br><span class="line">                nums[temp] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)，空间复杂度得到了优化</li>
</ul>
<h2 id="146-LRU-Cache-LRU缓存机制-Mid"><a href="#146-LRU-Cache-LRU缓存机制-Mid" class="headerlink" title="146. LRU Cache(LRU缓存机制)(Mid)"></a><a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">146. LRU Cache(LRU缓存机制)(Mid)</a></h2><p>Design and implement a data structure for <strong>Least Recently Used (LRU)</strong> cache. It should support the following operations: <code>get</code> and <code>put</code>.</p>
<p><code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br><code>put(key, value)</code> - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</p>
<p>The cache is initialized with a <strong>positive</strong> capacity.</p>
<p><strong>Follow up:</strong></p>
<p>Could you do both operations in <strong>O(1)</strong> time complexity?</p>
<p><strong>Example:</strong></p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LRUCache <span class="keyword">cache</span> = new LRUCache( <span class="number">2</span> <span class="comment">/* capacity */</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">cache</span>.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">cache</span>.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">cache</span>.get(<span class="number">1</span>);       // <span class="keyword">returns</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">cache</span>.put(<span class="number">3</span>, <span class="number">3</span>);    // evicts key <span class="number">2</span></span><br><span class="line"><span class="keyword">cache</span>.get(<span class="number">2</span>);       // <span class="keyword">returns</span> <span class="number">-1</span> (<span class="keyword">not</span> <span class="built_in">found</span>)</span><br><span class="line"><span class="keyword">cache</span>.put(<span class="number">4</span>, <span class="number">4</span>);    // evicts key <span class="number">1</span></span><br><span class="line"><span class="keyword">cache</span>.get(<span class="number">1</span>);       // <span class="keyword">returns</span> <span class="number">-1</span> (<span class="keyword">not</span> <span class="built_in">found</span>)</span><br><span class="line"><span class="keyword">cache</span>.get(<span class="number">3</span>);       // <span class="keyword">returns</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">cache</span>.get(<span class="number">4</span>);       // <span class="keyword">returns</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<hr>
<p>注：因为这道题在写之后会有很大的改动，所以可以记住题目原本的代码其实很短，如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span>(<span class="params"><span class="keyword">int</span> capacity</span>)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span>(<span class="params"><span class="keyword">int</span> key</span>)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span>(<span class="params"><span class="keyword">int</span> key, <span class="keyword">int</span> <span class="keyword">value</span></span>)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>解：LRU cache是页面置换算法。具体使用场景：在进程运行过程中，若其所要访问的页面不在内存而需把它们调入内存，但内存已无空闲空间时，为了保证该进程能正常运行，系统必须从内存中调出一页程序或数据送磁盘的对换区中。但应将哪个页面调出，须根据一定的算法来确定。通常，把选择换出页面的算法称为页面置换算法(Page-Replacement Algorithms)。</p>
<p>LRU是Least Recently Used的缩写，即最近最少使用，是一种常用的页面置换算法，选择最近最久未使用的页面予以淘汰。该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 t，当须淘汰一个页面时，选择现有页面中其 t 值最大的，即最近最少使用的页面予以淘汰。</p>
<p>本质上，这个替换算法和现在的推荐系统有异曲同工之妙。</p>
<p>推荐算法就是根据之前元素被使用的频次和被使用的时间，来预测新来的元素为某一个老元素的概率是多少。</p>
<p>现代计算机中，替换算法越来越使用人工智能来做了，而不是简单基于逻辑式的公式。</p>
<p>LRU cache源自于用得非常多的缓存的思想。它有两个比较重要的策略：大小和替换策略。除了LRU(Least Recently Used)，还有一种可以和它相似的，只是替换策略不同的缓存机制：LFU(Least Frequently Used)，具体区别可以从名字中看出。</p>
<p>按照题目的要求，我们自己完成的LRU cache应当保证<strong>查询</strong>与<strong>修改</strong>的时间复杂度都为O(1)。</p>
<p>如果最朴素的，全部自己实现，那么就是哈希表加双向链表。这样就训练一下双向链表怎么写。</p>
<p>所有双向链表或者单向链表的题目，没有巧，就是多练，即可。</p>
<p>在现实工作中，其实不太可能去手写一个链表、map、set或者排序，都是有现成的库。</p>
<p>有些公司可能比较刻板，需要多练一些基本功。</p>
<p>官方题解中，给出了两种解法，<a href="https://leetcode-cn.com/problems/lru-cache/solution/lru-huan-cun-ji-zhi-by-leetcode/" target="_blank" rel="noopener">详情可以点击这里</a></p>
<p>方法一：使用<strong>有序字典</strong>这个数据结构，它综合了哈希表和链表。对于java，系统使用了LinkedHashMap这个类实现；对于Python，系统使用了OrderedDict实现字典序。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">LRUCache</span> <span class="symbol">extends</span> <span class="symbol">LinkedHashMap</span>&lt;<span class="symbol">Integer, <span class="symbol">Integer</span></span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> capacity;</span><br><span class="line">    <span class="keyword">public</span> LRUCache(<span class="built_in">int</span> capacity) &#123;</span><br><span class="line">        <span class="keyword">super</span>(capacity, <span class="number">0.75</span>F, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> <span class="keyword">get</span>(<span class="built_in">int</span> key) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getOrDefault(key, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> put(<span class="built_in">int</span> key, <span class="built_in">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">super</span>.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">bool</span>ean removeEldestEntry(Map.Entry&lt;Integer, Integer&gt; eldest) &#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; capacity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p><strong>拓展:</strong>linkedhashmap和hashmap有什么区别？<br>HashMap就只是一个哈希表，键值对对应，最多允许一条记录的键值为Null，而且HashMap不支持线程同步，即任一时刻如果多个线程同时写HashMap，可能导致数据的不一致性。如果需要同步，对于HashMap，可以用Collections的synchronizedMap方法使HashMap拥有同步的能力。</p>
<p>LinkedHashMap也是一个HashMap，<strong>但是它内部维持了一个双向链表</strong>，可以保持顺序。</p>
<p>总之，LinkedHashMap的内部实现原理，就是一个双向的LinkedList+HashMap,所以名字是：LinkedHashMap。</p>
<p>方法二：不用LinkedHashMap，自己手写双向链表+哈希表</p>
<p>利用哈希表，辅以双向链表记录键值对的信息，所以可以在O(1)时间内完成put和get操作，同时也支持O(1)删除第一个添加的节点。</p>
<p><img src="https://pic.leetcode-cn.com/815038bb44b7f15f1f32f31d40e75c250cec3c5c42b95175ec012c00a0243833-146-1.png" alt="双向链表+哈希"></p>
<p>一个需要注意的是，在双向链表实现中，这里使用一个<em>伪头部</em>和<em>伪尾部</em>标记界限，这样在更新的时候就不需要检查是否是 <code>null</code> 节点。</p>
<p><img src="https://pic.leetcode-cn.com/48292c190e50537087ea8c60ed44062675d55a73d1a59035d26e277a36b7b8e2-146-2.png" alt="伪头结点和伪尾节点"></p>
<p>至于到代码，我们需要自己定义一个双向链表的节点以及它的各种操作方法。这里定义了增加、删除、移动到头部、pop出Tail。实际上要写的只有addNode和removeNode，这两个写好了，其他两个方法只要调用它们就好。需要注意这里增加的位置是指定在head之后、删除的位置是在tail前一个。</p>
<p>然后需要定义缓存空间cache，完成它的三个函数：初始化、get()、put()。</p>
<p>这过程中我们需要两个变量：key和value，其中key就是保存某个秘钥。而value则是这个秘钥的值。(分页置换算法相关知识)</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">class LRUCache &#123;</span><br><span class="line">    </span><br><span class="line">    class DLinkedNode &#123;</span><br><span class="line">        int key, value;</span><br><span class="line">        DLinkedNode prev;</span><br><span class="line">        DLinkedNode next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void addNode(DLinkedNode <span class="keyword">node</span><span class="title">) &#123;</span></span><br><span class="line"><span class="title">        // always</span> add new <span class="keyword">node</span> <span class="title">right</span> after head</span><br><span class="line">        <span class="keyword">node</span>.<span class="title">next</span> = head.next;</span><br><span class="line">        <span class="keyword">node</span>.<span class="title">prev</span> = head;</span><br><span class="line">        </span><br><span class="line">        head.next.prev = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">        head</span>.next = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">    &#125;</span></span><br><span class="line"><span class="title">    </span></span><br><span class="line"><span class="title">    private</span> void removeNode(DLinkedNode <span class="keyword">node</span><span class="title">) &#123;</span></span><br><span class="line"><span class="title">        // remove</span> an existing <span class="keyword">node</span> <span class="title">from</span> the double LinkedList</span><br><span class="line">        DLinkedNode next = <span class="keyword">node</span>.<span class="title">next</span>;</span><br><span class="line">        DLinkedNode prev = <span class="keyword">node</span>.<span class="title">prev</span>;</span><br><span class="line">        </span><br><span class="line">        next.prev = prev;</span><br><span class="line">        prev.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void moveToHead(DLinkedNode <span class="keyword">node</span><span class="title">) &#123;</span></span><br><span class="line"><span class="title">        // move</span> certain <span class="keyword">node</span> <span class="title">to</span> the head</span><br><span class="line">        removeNode(<span class="keyword">node</span><span class="title">);</span></span><br><span class="line"><span class="title">        addNode</span>(<span class="keyword">node</span><span class="title">);</span></span><br><span class="line"><span class="title">    &#125;</span></span><br><span class="line"><span class="title">    </span></span><br><span class="line"><span class="title">    private</span> DLinkedNode popTail() &#123;</span><br><span class="line">        // pop the current tail</span><br><span class="line">        DLinkedNode target = tail.prev;</span><br><span class="line">        removeNode(target);</span><br><span class="line">        return target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    private HashMap<span class="tag">&lt;Integer, DLinkedNode&gt;</span> cache = new HashMap<span class="tag">&lt;&gt;</span>();</span><br><span class="line">    private int size;</span><br><span class="line">    private int capacity;</span><br><span class="line">    private DLinkedNode head, tail;</span><br><span class="line">    </span><br><span class="line">    public LRUCache(int capacity) &#123;</span><br><span class="line">        this.size = <span class="number">0</span>;</span><br><span class="line">        this.capacity = capacity;</span><br><span class="line">        </span><br><span class="line">        // 默认调用无参构造函数</span><br><span class="line">        head = new DLinkedNode();</span><br><span class="line">        </span><br><span class="line">        tail = new DLinkedNode();</span><br><span class="line">        </span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int get(int key) &#123;</span><br><span class="line">        </span><br><span class="line">        DLinkedNode <span class="keyword">node</span> <span class="title">= cache</span>.get(key);</span><br><span class="line">        </span><br><span class="line">        if(<span class="keyword">node</span> <span class="title">== null</span>) return -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        // 成功取到，因为本身是Least Recently Used，所以最近使用的放到头部</span><br><span class="line">        moveToHead(<span class="keyword">node</span><span class="title">);</span></span><br><span class="line"><span class="title">        </span></span><br><span class="line"><span class="title">        return</span> <span class="keyword">node</span>.<span class="title">value</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void put(int key, int value) &#123;</span><br><span class="line">        DLinkedNode <span class="keyword">node</span> <span class="title">= cache</span>.get(key);</span><br><span class="line">        </span><br><span class="line">        if(<span class="keyword">node</span> <span class="title">== null</span>) &#123;</span><br><span class="line">            DLinkedNode newNode = new DLinkedNode();</span><br><span class="line">            newNode.key = key;</span><br><span class="line">            newNode.value = value;</span><br><span class="line">            </span><br><span class="line">            cache.put(key, newNode);</span><br><span class="line">            addNode(newNode);</span><br><span class="line">            </span><br><span class="line">            ++size;</span><br><span class="line">            </span><br><span class="line">            // 如果存不下了，要pop</span><br><span class="line">            if(size &gt; capacity) &#123;</span><br><span class="line">                // pop the tail</span><br><span class="line">                DLinkedNode tail = popTail();</span><br><span class="line">                cache.remove(tail.key);</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // update the value</span><br><span class="line">            <span class="keyword">node</span>.<span class="title">value</span> = value;</span><br><span class="line">            moveToHead(<span class="keyword">node</span><span class="title">);</span></span><br><span class="line"><span class="title">        &#125;</span></span><br><span class="line"><span class="title">    &#125;</span></span><br><span class="line"><span class="title">&#125;</span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">/**</span></span><br><span class="line"><span class="title"> * Your</span> LRUCache object will be instantiated <span class="keyword">and</span> called as such:</span><br><span class="line"> * LRUCache obj = new LRUCache(capacity);</span><br><span class="line"> * int param_1 = obj.get(key);</span><br><span class="line"> * obj.put(key,value);</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：对于<code>put</code>和<code>get</code>都是O(1)</li>
<li>空间复杂度：O(capacity),因为哈希表和双向链表最多存储<code>capacity + 1</code>个元素</li>
</ul>
<h2 id="寻找K数"><a href="#寻找K数" class="headerlink" title="寻找K数"></a>寻找K数</h2><p>K数是指一个数组中，它前面的数都比它小，它后面的数都比它大。找出一个数组中所有的K数</p>
<hr>
<p>解：题目描述很简单，但是实际考虑起来需要注意，首先K数在一个数组里面很可能不止1个，然后数组的第一个的左边和数组最后一个的右边，该怎么处理？</p>
<p>把数组最左边设置为负无穷(Integer.MIN_VALUE),最右边设置成正无穷(Integer.MAX_VALUE),新开一个大小为原来大小+2的数组，把最左边和最右边处理完之后，依次遍历每个元素，然后以每个元素为轴，分别比较其左边和右边的每一个元素，满足左边都比它小同时右边都比它大的，这个数就是K树。</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; findK(int[] array) &#123;</span><br><span class="line">    int len = array.length;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="type">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 为了存放正无穷和负无穷的数组</span></span><br><span class="line">    int[] <span class="keyword">new</span><span class="type">Array</span> = <span class="keyword">new</span> <span class="type">int</span>[len + <span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 初始化newArray,赋值array进去，同时设置0和len-1位置</span></span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span><span class="type">Array</span>[i] = array[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">new</span><span class="type">Array</span>[<span class="number">0</span>] = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">new</span><span class="type">Array</span>[len+<span class="number">1</span>] = Integer.MAX_VALUE;</span><br><span class="line">    <span class="comment">// 标记当前 i 数是否是K数，只要不满足要求就设置为false</span></span><br><span class="line">    boolean flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">        <span class="comment">// 第一次判断，i左边的所有数是否都比它小</span></span><br><span class="line">        <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt;= i<span class="number">-1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">new</span><span class="type">Array</span>[j] &gt;= <span class="keyword">new</span><span class="type">Array</span>[i]) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第二次判断，i右边的所有数是否都比它大</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">for</span>(int j = i+<span class="number">1</span>; j &lt;= len+<span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">new</span><span class="type">Array</span>[j] &lt;= <span class="keyword">new</span><span class="type">Array</span>[i]) &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 两次判断都成功，则i就是K数</span></span><br><span class="line">        <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span><span class="type">Array</span>[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指offer21-调整数组顺序使奇数位于偶数前面-Easy"><a href="#剑指offer21-调整数组顺序使奇数位于偶数前面-Easy" class="headerlink" title="剑指offer21.调整数组顺序使奇数位于偶数前面(Easy)"></a><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/" target="_blank" rel="noopener">剑指offer21.调整数组顺序使奇数位于偶数前面(Easy)</a></h2><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p>
<p><strong>示例：</strong></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>] </span><br><span class="line">注：[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>] 也是正确的答案之一。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= nums.length &lt;= 50000</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10000</code></li>
</ol>
<hr>
<p>解：方法一：可以用两个指针，一头一尾，头指针先不断遍历找到偶数，然后尾指针不断遍历找到奇数，然后将两者交换即可。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>[] exchange(<span class="built_in">int</span>[] nums) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> left = <span class="number">0</span>, right = nums.length<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 先找到左边的偶数</span></span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; (nums[left] &amp; <span class="number">1</span>) != <span class="number">0</span> ) left++;</span><br><span class="line">            <span class="comment">// 再找到右边的奇数</span></span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; (nums[right] &amp; <span class="number">1</span>) == <span class="number">0</span> ) right--;</span><br><span class="line">            <span class="comment">// 找到之后直接将两者交换。这样比写四个if-else去遍历所有情况更快</span></span><br><span class="line">            swap(nums, left, right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> swap(<span class="built_in">int</span>[] arr, <span class="built_in">int</span> i, <span class="built_in">int</span> j) &#123;</span><br><span class="line">        <span class="built_in">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(N),N为数组nums长度，过程下来left和right两个指针遍历整个数组。</li>
<li>空间复杂度：O(1)，额外开销只有两个指针</li>
</ul>
<p>但是如果对于工程要求比较高，面试官可能更希望我们能够写出如下可以扩展的写法。怎么扩展？</p>
<p>我们可以把代码拆解成两部分，一部分判断数字应该在数组前半部分还是后半部分的标准；二是拆分数组的操作。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>[] exchange(<span class="built_in">int</span>[] nums) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> left = <span class="number">0</span>, right = nums.length<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 先找到左边的偶数</span></span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; !isEven(nums[left]) ) left++;</span><br><span class="line">            <span class="comment">// 再找到右边的奇数</span></span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; isEven(nums[right]) ) right--;</span><br><span class="line">            <span class="comment">// 找到之后直接将两者交换。这样比写四个if-else去遍历所有情况更快</span></span><br><span class="line">            swap(nums, left, right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> swap(<span class="built_in">int</span>[] arr, <span class="built_in">int</span> i, <span class="built_in">int</span> j) &#123;</span><br><span class="line">        <span class="built_in">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span>ean isEven(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">return</span> (n&amp;<span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：也是用两个指针，但是一快一慢。快的在前，找到奇数就和慢指针指向的元素交换。</p>
<p>操作流程：</p>
<ul>
<li>定义快慢双指针 fastfast 和 lowlow ，fastfast 在前， lowlow 在后 .</li>
<li>fastfast 的作用是向前搜索奇数位置，lowlow 的作用是指向下一个奇数应当存放的位置</li>
<li>fastfast 向前移动，当它搜索到奇数时，将它和 nums[low]nums[low] 交换，此时 lowlow 向前移动一个位置 .</li>
<li>重复上述操作，直到 fastfast 指向数组末尾 .</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>[] exchange(<span class="built_in">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="built_in">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.length) &#123;</span><br><span class="line">            <span class="keyword">if</span>((nums[fast] &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                swap(nums, slow, fast);</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> swap(<span class="built_in">int</span>[] arr, <span class="built_in">int</span> i, <span class="built_in">int</span> j) &#123;</span><br><span class="line">        <span class="built_in">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>


    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/LeetCode/" rel="tag"><i class="fa fa-tag"></i># LeetCode</a>
              <a href="/tags/Algorithms/" rel="tag"><i class="fa fa-tag"></i># Algorithms</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/01/13/LeetCode-Practice-by-Categories-String-Algorithm/" rel="prev" title="LeetCode Practice by Categories String Algorithm">
      <i class="fa fa-chevron-left"></i> LeetCode Practice by Categories String Algorithm
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/02/12/Analysis-of-LeetCode-High-Frequency-Problems-I/" rel="next" title="Analysis of LeetCode High Frequency Problems I">
      Analysis of LeetCode High Frequency Problems I <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC80ODAxMC8yNDUwNw=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#169-Majority-Element-多数元素-Easy"><span class="nav-text">169. Majority Element(多数元素)(Easy)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-Reverse-Integer-整数反转-Mid"><span class="nav-text">7. Reverse Integer(整数反转)(Mid)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-Palindrome-Number-回文数-Mid"><span class="nav-text">9. Palindrome Number(回文数)(Mid)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1109-Corporate-Flight-Bookings-航班预订统计-Mid"><span class="nav-text">1109. Corporate Flight Bookings(航班预订统计)(Mid)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#135-Candy-分发糖果-Hard"><span class="nav-text">135. Candy(分发糖果)(Hard)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指offer-面试题03-数组中重复的数字-Easy"><span class="nav-text">剑指offer 面试题03 数组中重复的数字(Easy)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#146-LRU-Cache-LRU缓存机制-Mid"><span class="nav-text">146. LRU Cache(LRU缓存机制)(Mid)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#寻找K数"><span class="nav-text">寻找K数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指offer21-调整数组顺序使奇数位于偶数前面-Easy"><span class="nav-text">剑指offer21.调整数组顺序使奇数位于偶数前面(Easy)</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Wang Mingsheng"
      src="/images/faceimage.jpg">
  <p class="site-author-name" itemprop="name">Wang Mingsheng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">36</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wmsheng" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wmsheng" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:wangmingshenghku@163.com" title="E-Mail → mailto:wangmingshenghku@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://music.163.com/#/my/m/music/playlist?id=372605964" title="Music → https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;my&#x2F;m&#x2F;music&#x2F;playlist?id&#x3D;372605964" rel="noopener" target="_blank"><i class="fa fa-fw fa-youtube"></i>Music</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>


    </div>
    
    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=3314336&auto=1&height=66">
    </iframe>

  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wang Mingsheng</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">413k</span>
</div>


<div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_uv">
    本站访客数:<span id="busuanzi_value_site_uv"></span>
  </span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_pv">
    本站访问量<span id="busuanzi_value_site_pv"></span>
  </span>
</div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共217.3k字</span>
</div>

        
<div class="busuanzi-count">
  <script pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.getAttribute('pjax') !== null) {
      element.setAttribute('pjax', '');
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

    </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/clicklove.js"></script>
