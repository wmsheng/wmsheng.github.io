<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/siyecao.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/siyecao.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","padding":18,"offset":12,"onmobile":false,"b2t":true,"scrollpercent":true},
    copycode: {"enable":true,"show_result":true,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="轻财足以聚人，律己足以服人，量宽足以得人，身先足以率人。——陈继儒  LeetCode搜索相关题目，其解决思路和具体代码。内容也包括二分查找。">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode Practice by Categories Search">
<meta property="og:url" content="http://yoursite.com/2020/01/13/LeetCode-Practice-by-Categories-Search/index.html">
<meta property="og:site_name" content="Hi, This is Bennett">
<meta property="og:description" content="轻财足以聚人，律己足以服人，量宽足以得人，身先足以率人。——陈继儒  LeetCode搜索相关题目，其解决思路和具体代码。内容也包括二分查找。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://pic.leetcode-cn.com/a78a34cc8145ef5b51b59b1482238c6fa940ecfb67bf424cb839d197d4c72eba-153-3.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2019/02/16/oranges.png">
<meta property="article:published_time" content="2020-01-13T04:46:07.000Z">
<meta property="article:modified_time" content="2020-04-16T23:44:09.293Z">
<meta property="article:author" content="Wang Mingsheng">
<meta property="article:tag" content="LeetCode">
<meta property="article:tag" content="Algorithms">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic.leetcode-cn.com/a78a34cc8145ef5b51b59b1482238c6fa940ecfb67bf424cb839d197d4c72eba-153-3.png">

<link rel="canonical" href="http://yoursite.com/2020/01/13/LeetCode-Practice-by-Categories-Search/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>LeetCode Practice by Categories Search | Hi, This is Bennett</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hi, This is Bennett</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags<span class="badge">33</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories<span class="badge">4</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives<span class="badge">37</span></a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/13/LeetCode-Practice-by-Categories-Search/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/faceimage.jpg">
      <meta itemprop="name" content="Wang Mingsheng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hi, This is Bennett">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          LeetCode Practice by Categories Search
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-13 12:46:07" itemprop="dateCreated datePublished" datetime="2020-01-13T12:46:07+08:00">2020-01-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-17 07:44:09" itemprop="dateModified" datetime="2020-04-17T07:44:09+08:00">2020-04-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithms-Note/" itemprop="url" rel="index">
                    <span itemprop="name">Algorithms Note</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              
              <span>17k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>轻财足以聚人，律己足以服人，量宽足以得人，身先足以率人。——陈继儒</p>
</blockquote>
<p>LeetCode搜索相关题目，其解决思路和具体代码。内容也包括二分查找。</p>
<a id="more"></a>

<p>在树的章节中已经包括了很多有关DFS和BFS的题目，比如，非常经典和重要的，树的层次遍历(102)和树的一些遍历。之前重复的在这里先不再写了。</p>
<h2 id="74-Search-a-2D-Matrix-搜索二维矩阵-Mid"><a href="#74-Search-a-2D-Matrix-搜索二维矩阵-Mid" class="headerlink" title="74. Search a 2D Matrix(搜索二维矩阵)(Mid)"></a><a href="https://leetcode-cn.com/problems/search-a-2d-matrix/" target="_blank" rel="noopener">74. Search a 2D Matrix(搜索二维矩阵)(Mid)</a></h2><p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p>
<ul>
<li>Integers in each row are sorted from left to right.</li>
<li>The first integer of each row is greater than the last integer of the previous row.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">matrix = [</span><br><span class="line">  [<span class="number">1</span>,   <span class="number">3</span>,  <span class="number">5</span>,  <span class="number">7</span>],</span><br><span class="line">  [<span class="number">10</span>, <span class="number">11</span>, <span class="number">16</span>, <span class="number">20</span>],</span><br><span class="line">  [<span class="number">23</span>, <span class="number">30</span>, <span class="number">34</span>, <span class="number">50</span>]</span><br><span class="line">]</span><br><span class="line">target = <span class="number">3</span></span><br><span class="line">Output: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">matrix = [</span><br><span class="line">  [<span class="number">1</span>,   <span class="number">3</span>,  <span class="number">5</span>,  <span class="number">7</span>],</span><br><span class="line">  [<span class="number">10</span>, <span class="number">11</span>, <span class="number">16</span>, <span class="number">20</span>],</span><br><span class="line">  [<span class="number">23</span>, <span class="number">30</span>, <span class="number">34</span>, <span class="number">50</span>]</span><br><span class="line">]</span><br><span class="line">target = <span class="number">13</span></span><br><span class="line">Output: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：这道题和下一道题几乎是兄弟模样，但是比240更简单，主要因为properties的第二条——他在保证了每一行为递增的之外，还保证下一行的第一个元素一定大于上一行的最后一个。</p>
<p>经典的二分查找的思想，把整个二维数组当成是一个排好序的数组对待即可。</p>
<p>需要注意的一个很有用的公式：</p>
<ul>
<li>把m*n的二维矩阵转换成一个数组：matrix[x][y] =&gt; array[x * n + y]</li>
<li>把一个array转换成m*n的二维矩阵：array[x] =&gt; matrix[x/n][x%n]</li>
</ul>
<p>抓住了上面这个转换机制，就抓住了关键</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// corner case</span></span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// start为开始的位置，end为当前终止的位置</span></span><br><span class="line">        <span class="comment">// rows为行数，cols为列数</span></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, rows = matrix.length, cols = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> end = rows * cols - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start &lt;= end) &#123;</span><br><span class="line">            <span class="comment">// 找到当前中间位置的元素mid</span></span><br><span class="line">            <span class="keyword">int</span> mid = (end + start) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 最关键的是用start和end与二维矩阵matrix之间的转换公式</span></span><br><span class="line">            <span class="comment">// 二维矩阵转换中最重要的是列数，这个和定义二维数组的时候，可以没有</span></span><br><span class="line">            <span class="comment">// 行数，但是必须声明列数的道理是一样的</span></span><br><span class="line">            <span class="keyword">if</span>(matrix[mid / cols][mid % cols] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果当前mid比target小，那么target一定在mid右边，就要把start右移</span></span><br><span class="line">            <span class="comment">// vice versa</span></span><br><span class="line">            <span class="keyword">if</span>(matrix[mid / cols][mid % cols] &lt; target) &#123;</span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：标准的二分查找，时间复杂度为O(log(m*n))</li>
<li>空间复杂度：O(1)</li>
</ul>
<h2 id="240-Search-a-2D-Matrix-II-搜索二维矩阵-Mid"><a href="#240-Search-a-2D-Matrix-II-搜索二维矩阵-Mid" class="headerlink" title="240. Search a 2D Matrix II(搜索二维矩阵)(Mid)"></a><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/" target="_blank" rel="noopener">240. Search a 2D Matrix II(搜索二维矩阵)(Mid)</a></h2><p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p>
<ul>
<li>Integers in each row are sorted in ascending from left to right.</li>
<li>Integers in each column are sorted in ascending from top to bottom.</li>
</ul>
<p><strong>Example:</strong></p>
<p>Consider the following matrix:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,   <span class="number">4</span>,  <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>],</span><br><span class="line">  [<span class="number">2</span>,   <span class="number">5</span>,  <span class="number">8</span>, <span class="number">12</span>, <span class="number">19</span>],</span><br><span class="line">  [<span class="number">3</span>,   <span class="number">6</span>,  <span class="number">9</span>, <span class="number">16</span>, <span class="number">22</span>],</span><br><span class="line">  [<span class="number">10</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">17</span>, <span class="number">24</span>],</span><br><span class="line">  [<span class="number">18</span>, <span class="number">21</span>, <span class="number">23</span>, <span class="number">26</span>, <span class="number">30</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>Given target = <code>5</code>, return <code>true</code>.</p>
<p>Given target = <code>20</code>, return <code>false</code>.</p>
<hr>
<p>解：和74的区别是，此题输入的数组下一行的首元素和上一行相比不是递增的，而是在行和列这两个方向上是递增的，这样一来解题思路和上一题就完全不同了。上一题因为存储方式和二维矩阵与数组的转换方式有吻合之处所以可以用二分法，这里也可以，但是没有上一题那么容易解了。</p>
<p>但是不难发现，因为在行和列这两个方向是递增的，所以右上角成为了突破口。右上角的元素如果大于target，那么再次查找target的时候可以排除之前的一列；如果右上角元素小于target，那么再次查找的时候可以排除之前元素的这一行。</p>
<p>写法一：从右上角开始突破。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// corner case</span></span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 从右上角开始</span></span><br><span class="line">        <span class="comment">// start our pointer fron top-right</span></span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>, col = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(col &gt;= <span class="number">0</span> &amp;&amp; row &lt;= matrix.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[row][col] == target) &#123; <span class="comment">// found it</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(matrix[row][col] &lt; target) &#123;</span><br><span class="line">                row++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                col--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理，其实从左下角开始也可以，可以把左下角当做搜索的突破口，若当前元素小于target，那么下次从当前元素的右边开始，剔除掉当前元素在的列；如果当前元素大于target,下次从当前元素上一个开始，剔除掉当前元素在的行。</p>
<p>写法二：从左下角开始突破</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// corner case</span></span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 从左下角开始</span></span><br><span class="line">        <span class="comment">// start our pointer fron bottom-left</span></span><br><span class="line">        <span class="keyword">int</span> col = <span class="number">0</span>, row = matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(row &gt;= <span class="number">0</span> &amp;&amp; col &lt;= matrix[<span class="number">0</span>].length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[row][col] == target) <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// found it</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(matrix[row][col] &lt; target) &#123;</span><br><span class="line">                col++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                row--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(m + n)。时间复杂度分析的关键是注意到在每次迭代（我们不返回 true）时，行或列都会精确地递减/递增一次。由于行只能减少 mm 次，而列只能增加 nn 次，因此在导致 while 循环终止之前，循环不能运行超过 n+mn+m 次。因为所有其他的工作都是常数，所以总的时间复杂度在矩阵维数之和中是线性的。</p>
</li>
<li><p>空间复杂度：O(1)。因为这种方法都只需要处理几个指针，所以内存占用是恒定的。</p>
</li>
</ul>
<h2 id="127-Word-Ladder-单词接龙-Mid"><a href="#127-Word-Ladder-单词接龙-Mid" class="headerlink" title="127. Word Ladder(单词接龙)(Mid)"></a><a href="https://leetcode-cn.com/problems/word-ladder/" target="_blank" rel="noopener">127. Word Ladder(单词接龙)(Mid)</a></h2><p>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary’s word list, find the length of shortest transformation sequence from <em>beginWord</em> to <em>endWord</em>, such that:</p>
<ol>
<li>Only one letter can be changed at a time.</li>
<li>Each transformed word must exist in the word list. Note that <em>beginWord</em> is not a <em>transformed</em> word.</li>
</ol>
<p><strong>Note:</strong></p>
<ul>
<li>Return 0 if there is no such transformation sequence.</li>
<li>All words have the same length.</li>
<li>All words contain only lowercase alphabetic characters.</li>
<li>You may assume no duplicates in the word list.</li>
<li>You may assume beginWord and endWord are non-empty and are not the same.</li>
</ul>
<p><strong>Example 1:</strong></p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">beginWord = <span class="string">"hit"</span>,</span><br><span class="line">endWord = <span class="string">"cog"</span>,</span><br><span class="line">wordList = [<span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span>,<span class="string">"cog"</span>]</span><br><span class="line"></span><br><span class="line">Output: <span class="number">5</span></span><br><span class="line"></span><br><span class="line">Explanation: As one shortest transformation <span class="keyword">is</span> <span class="string">"hit"</span><span class="function"> -&gt;</span> <span class="string">"hot"</span><span class="function"> -&gt;</span> <span class="string">"dot"</span><span class="function"> -&gt;</span> <span class="string">"dog"</span><span class="function"> -&gt;</span> <span class="string">"cog"</span>,</span><br><span class="line"><span class="keyword">return</span> its length <span class="number">5.</span></span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">Input:</span></span><br><span class="line">beginWord = <span class="string">"hit"</span></span><br><span class="line">endWord = <span class="string">"cog"</span></span><br><span class="line">wordList = [<span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span>]</span><br><span class="line"></span><br><span class="line"><span class="section">Output: 0</span></span><br><span class="line"></span><br><span class="line"><span class="section">Explanation: The endWord "cog" is not in wordList, therefore no possible transformation.</span></span><br></pre></td></tr></table></figure>
<hr>
<p>解：<strong>这道题是面试中经常会出现的问题</strong>。一般思路，可以使用初级搜索，即单向BFS。但是这里着重介绍使用双向BFS的方法，从beginWord和endWord中更小的那个开始扩散。为什么这样扩散比单向扩散效率更高？</p>
<p>因为同时从beginWord和endWord开始，然后每次从更短的一段开始继续搜索，那么因为是更小的Set，所以辐射的内容会更少，如果需要剪枝或者回溯，代价也可以更小。</p>
<p>比如，打仗的时候一方总会派出侦察兵，这些侦察兵往往身上负重很轻，因为这样他们才可以移动迅速，累赘小。而如果他们被抓了，需要被放弃，那么少量的武器，也能成为更小的损失和代价。</p>
<p>实际上，双向BFS是属于<strong>高级搜索</strong>的范畴的。对于初级搜索(BFS和DFS)，一般来说优化的思路有两个：<strong>一是让搜索过程去掉重复以及尽早剪枝</strong>，<strong>二是</strong>让它在搜索方向上加强。</p>
<p>事实上，双向BFS在高级搜索中用得比较多，而且代码并不难。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!wordList.contains(endWord)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 用Set代替Queue进行BFS, 是为了更方便查询单词是否在wordList中</span></span><br><span class="line">        <span class="comment">// 如果不用哈希，直接的list查询时间复杂度为O(n),使用Set之后时间复杂度为O(1)</span></span><br><span class="line">        Set&lt;String&gt; wordListSet = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// beginSet是从beginWord开始扩散的，endSet是从endWord开始扩散的</span></span><br><span class="line">        Set&lt;String&gt; beginSet = <span class="keyword">new</span> HashSet&lt;&gt;(), endSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里和单向BFS中一开始往queue中加入元素的操作类似,加入初始元素</span></span><br><span class="line">        <span class="comment">// 可以看出，beginSet和endSet本质没有先后顺序,先扩散小的可以更快收敛</span></span><br><span class="line">        beginSet.add(beginWord);</span><br><span class="line">        endSet.add(endWord);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 转换次数，这是细节，由于beingWord != endWord, 所以至少一步</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// visited 表示这个BFS节点是否已经被访问过了</span></span><br><span class="line">        Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// BFS start here</span></span><br><span class="line">        <span class="keyword">while</span>( !beginSet.isEmpty() ) &#123;</span><br><span class="line">            <span class="comment">// 扩散的时候优先选择小的Set</span></span><br><span class="line">            <span class="comment">// 如果beginSet更小，就扩散它</span></span><br><span class="line">            <span class="comment">// 否则如果beginSet更大，交换这两个Set,还是小的Set开始扩散</span></span><br><span class="line">            <span class="comment">// 核心：控制当前循环从哪个方向进行bfs；让begin指向size更小的集合，这样不会一直从一个方向BFS</span></span><br><span class="line">            <span class="keyword">if</span>(beginSet.size() &gt; endSet.size()) &#123;</span><br><span class="line">                Set&lt;String&gt; set = beginSet;</span><br><span class="line">                beginSet = endSet;</span><br><span class="line">                endSet = set;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// neighbor 这个set表示每一次要扩散的set的内容</span></span><br><span class="line">            Set&lt;String&gt; neighbor = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            <span class="comment">// 模板中这里会开始控制次数的for循环，但这里的HashSet和模板的queue是一样的含义,只是更方便查找</span></span><br><span class="line">            <span class="keyword">for</span>(String word : beginSet) &#123;</span><br><span class="line">                <span class="comment">// 对每一个单词，变化它的字符位</span></span><br><span class="line">                <span class="keyword">char</span>[] chs = word.toCharArray();</span><br><span class="line">                <span class="comment">// 用字母表遍历当前chs的每一个字母</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">char</span> c = <span class="string">'a'</span>; c &lt;= <span class="string">'z'</span>; c++) &#123;</span><br><span class="line">                        <span class="comment">// 保存chs的当前位置的字母</span></span><br><span class="line">                        <span class="keyword">char</span> old = chs[i];</span><br><span class="line">                        <span class="comment">// 然后替换成当前遍历到的字母表的字母</span></span><br><span class="line">                        chs[i] = c;</span><br><span class="line">                        <span class="comment">// 转换回String，从而使用endSet中的contains方法</span></span><br><span class="line">                        <span class="comment">// 否则不能对char[]使用contains方法</span></span><br><span class="line">                        String target = String.valueOf(chs);</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 因为endSet是从endWord那边扩散过来的，如果我们替换过程中产生的target也在</span></span><br><span class="line">                        <span class="comment">// 这个Set里，说明从begin扩散过来的Set和从end扩散过来的set，在这里相交了</span></span><br><span class="line">                        <span class="comment">// 这个相交的word就是target</span></span><br><span class="line">                        <span class="keyword">if</span>(endSet.contains(target)) &#123;</span><br><span class="line">                            <span class="keyword">return</span> len + <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 如果当时没找到target，则继续扩散其他的target,且把target追加到下一次</span></span><br><span class="line">                        <span class="comment">// 要扩散的set里面去，这里的neighbor set就是后面要扩散的set</span></span><br><span class="line">                        <span class="keyword">if</span>(!visited.contains(target) &amp;&amp; wordListSet.contains(target)) &#123;</span><br><span class="line">                            neighbor.add(target);</span><br><span class="line">                            <span class="comment">// 标记target 为 visited, 表示访问过了</span></span><br><span class="line">                            visited.add(target);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 把单词本身还原</span></span><br><span class="line">                        chs[i] = old;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理完beign中的元素之后，让begin指向begin中的元素的邻居</span></span><br><span class="line">            beginSet = neighbor;</span><br><span class="line">            <span class="comment">// 路径长度++</span></span><br><span class="line">            len ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有转换的路径</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="126-单词接龙-II-Hard"><a href="#126-单词接龙-II-Hard" class="headerlink" title="126. (单词接龙 II)(Hard)"></a><a href="https://leetcode-cn.com/problems/word-ladder-ii/" target="_blank" rel="noopener">126. (单词接龙 II)(Hard)</a></h2><h2 id="433-Minimum-Genetic-Mutation-最小基因变化-Mid"><a href="#433-Minimum-Genetic-Mutation-最小基因变化-Mid" class="headerlink" title="433. Minimum Genetic Mutation(最小基因变化)(Mid)"></a><a href="https://leetcode-cn.com/problems/minimum-genetic-mutation/" target="_blank" rel="noopener">433. Minimum Genetic Mutation(最小基因变化)(Mid)</a></h2><p>A gene string can be represented by an 8-character long string, with choices from <code>&quot;A&quot;, &quot;C&quot;, &quot;G&quot;, &quot;T&quot;</code>.</p>
<p>Suppose we need to investigate about a mutation (mutation from “start” to “end”), where ONE mutation is defined as ONE single character changed in the gene string.</p>
<p>For example, <code>&quot;AACCGGTT&quot; -&gt; &quot;AACCGGTA&quot;</code> is 1 mutation.</p>
<p>Also, there is a given gene “bank”, which records all the valid gene mutations. A gene must be in the bank to make it a valid gene string.</p>
<p>Now, given 3 things - start, end, bank, your task is to determine what is the minimum number of mutations needed to mutate from “start” to “end”. If there is no such a mutation, return -1.</p>
<p><strong>Note:</strong></p>
<ol>
<li>Starting point is assumed to be valid, so it might not be included in the bank.</li>
<li>If multiple mutations are needed, all mutations during in the sequence must be valid.</li>
<li>You may assume start and end string is not the same.</li>
</ol>
<p><strong>Exmaple 1:</strong></p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">start:</span> <span class="string">"AACCGGTT"</span></span><br><span class="line"><span class="symbol">end:</span>   <span class="string">"AACCGGTA"</span></span><br><span class="line"><span class="symbol">bank:</span> [<span class="string">"AACCGGTA"</span>]</span><br><span class="line"></span><br><span class="line"><span class="symbol">return:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">start:</span> <span class="string">"AACCGGTT"</span></span><br><span class="line"><span class="symbol">end:</span>   <span class="string">"AAACGGTA"</span></span><br><span class="line"><span class="symbol">bank:</span> [<span class="string">"AACCGGTA"</span>, <span class="string">"AACCGCTA"</span>, <span class="string">"AAACGGTA"</span>]</span><br><span class="line"></span><br><span class="line"><span class="symbol">return:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">start:</span> <span class="string">"AAAAACCC"</span></span><br><span class="line"><span class="symbol">end:</span>   <span class="string">"AACCCCCC"</span></span><br><span class="line"><span class="symbol">bank:</span> [<span class="string">"AAAACCCC"</span>, <span class="string">"AAACCCCC"</span>, <span class="string">"AACCCCCC"</span>]</span><br><span class="line"></span><br><span class="line"><span class="symbol">return:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：这道题实际和单词接龙属于一种类型的题目，都是通过BFS解决状态图搜索问题。</p>
<h2 id="200-Number-of-Islands-岛屿数量-Mid"><a href="#200-Number-of-Islands-岛屿数量-Mid" class="headerlink" title="200. Number of Islands(岛屿数量)(Mid)"></a><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">200. Number of Islands(岛屿数量)(Mid)</a></h2><p>Given a 2d grid map of <code>&#39;1&#39;</code>s (land) and <code>&#39;0&#39;</code>s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Input:</span></span><br><span class="line"><span class="number">11110</span></span><br><span class="line"><span class="number">11010</span></span><br><span class="line"><span class="number">11000</span></span><br><span class="line"><span class="number">00000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Output:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Input:</span></span><br><span class="line"><span class="number">11000</span></span><br><span class="line"><span class="number">11000</span></span><br><span class="line"><span class="number">00100</span></span><br><span class="line"><span class="number">00011</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Output:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：参考油管上Kevin大神的代码，思路非常清晰。</p>
<p>这道题在面试中经常会考到，主要思想是利用dfs，每碰到一个”1”，都将其周围的所有”1”击沉掉，也就是全部重新设置为0，然后总的岛屿数量加1，这样持续下去可以每次将一块岛击沉。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// error checking</span></span><br><span class="line">        <span class="keyword">if</span>(grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">int</span> numIslands = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    numIslands += dfs(grid, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numIslands;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 沉岛法,将i和j相邻的所有为1的点全部置为0</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// terminator，分别对应上下左右四个方向的超比边界情况</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= grid.length || j &lt; <span class="number">0</span> || j &gt;= grid[i].length || grid[i][j] == <span class="string">'0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//sink</span></span><br><span class="line">        grid[i][j] = <span class="string">'0'</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// down</span></span><br><span class="line">        dfs(grid, i+<span class="number">1</span>, j);</span><br><span class="line">        <span class="comment">// right</span></span><br><span class="line">        dfs(grid, i, j+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// up</span></span><br><span class="line">        dfs(grid, i-<span class="number">1</span>, j);</span><br><span class="line">        <span class="comment">// left</span></span><br><span class="line">        dfs(grid, i, j-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="153-Find-Minimum-in-Rotated-Sorted-Array-寻找旋转排序数组中的最小值-Mid"><a href="#153-Find-Minimum-in-Rotated-Sorted-Array-寻找旋转排序数组中的最小值-Mid" class="headerlink" title="153. Find Minimum in Rotated Sorted Array(寻找旋转排序数组中的最小值)(Mid)"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">153. Find Minimum in Rotated Sorted Array(寻找旋转排序数组中的最小值)(Mid)</a></h2><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e.,  <code>[0,1,2,4,5,6,7]</code> might become  <code>[4,5,6,7,0,1,2]</code>).</p>
<p>Find the minimum element.</p>
<p>You may assume no duplicate exists in the array.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>] </span><br><span class="line">Output: <span class="number">1</span></span><br></pre></td></tr></table></figure>


<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">Output: <span class="number">0</span></span><br></pre></td></tr></table></figure>

<hr>
<p>解：用二分搜索解决，在二分搜索的过程中，我们每次找到区间的中点，然后根据某些条件去决定去区间的左边还是右边继续搜索。</p>
<p>重点是数组已经被旋转过了，所以简单的二分搜索不可行。</p>
<p>通过分析可以发现，旋转之后的数组两头总会存在头部元素比尾部元素大的情况，直到到了之前旋转的元素才会变化，我们可以把这个地方成为变化点：</p>
<p><img src="https://pic.leetcode-cn.com/a78a34cc8145ef5b51b59b1482238c6fa940ecfb67bf424cb839d197d4c72eba-153-3.png" alt="变化点"></p>
<p>有关”变化点”的特点：</p>
<blockquote>
<p>所有变化点左侧元素 &gt; 数组第一个元素<br>所有变化点右侧元素 &lt; 数组第一个元素</p>
</blockquote>
<p>可以说这个是我们定义的新的”二分查找”</p>
<p>具体算法流程：</p>
<ol>
<li>找到数组中间元素mid</li>
<li>如果<code>中间元素 &gt; 数组第一个元素</code>，我们需要在<code>mid</code>右边搜索变化点</li>
<li>如果<code>中间元素 &lt; 数组第一个元素</code>，我们需要在<code>mid</code>左边搜索变化点</li>
<li>当我们找到变化点时停止搜索，当以下条件满足任意一个即可：</li>
</ol>
<ul>
<li><p>nums[mid] &gt; nums[mid + 1]，因此 mid+1 是最小值。</p>
</li>
<li><p>nums[mid - 1] &gt; nums[mid]，因此 mid 是最小值。</p>
</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> findMin(<span class="built_in">int</span>[] nums) &#123;</span><br><span class="line">        <span class="built_in">int</span> len = nums.length;</span><br><span class="line">        <span class="comment">// corner case</span></span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> left = <span class="number">0</span>, right = len<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[left] &lt; nums[right]) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// binary search</span></span><br><span class="line">        <span class="keyword">while</span>(right &gt;= left) &#123;</span><br><span class="line">            <span class="built_in">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[mid + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[mid - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[mid];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[<span class="number">0</span>]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把代码简化一点：</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> findMin(<span class="built_in">int</span>[] nums) &#123;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">len</span> = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">len</span> == <span class="number">0</span> || nums == <span class="literal">null</span>) &#123;</span><br><span class="line">            return <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = <span class="built_in">len</span> - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>) &#123;</span><br><span class="line">            <span class="built_in">int</span> <span class="built_in">mid</span> = (<span class="built_in">left</span> + <span class="built_in">right</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">mid</span> &gt; <span class="number">0</span> &amp;&amp; nums[<span class="built_in">mid</span>] &lt; nums[<span class="built_in">mid</span> - <span class="number">1</span>]) &#123;</span><br><span class="line">                return nums[<span class="built_in">mid</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[<span class="built_in">left</span>] &lt;= nums[<span class="built_in">mid</span>] &amp;&amp; nums[<span class="built_in">mid</span>] &gt; nums[<span class="built_in">right</span>]) &#123;</span><br><span class="line">                <span class="built_in">left</span> = <span class="built_in">mid</span> + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">right</span> = <span class="built_in">mid</span> - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return nums[<span class="built_in">left</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(logN)，和二分搜索一样</li>
<li>空间复杂度：O(1)</li>
</ul>
<h2 id="154-Find-Minimum-in-Rotated-Sorted-Array-寻找旋转排序数组中的最小值-II-Hard"><a href="#154-Find-Minimum-in-Rotated-Sorted-Array-寻找旋转排序数组中的最小值-II-Hard" class="headerlink" title="154. Find Minimum in Rotated Sorted Array(寻找旋转排序数组中的最小值 II)(Hard)"></a><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">154. Find Minimum in Rotated Sorted Array(寻找旋转排序数组中的最小值 II)(Hard)</a></h2><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e.,  <code>[0,1,2,4,5,6,7]</code> might become  <code>[4,5,6,7,0,1,2]</code>).</p>
<p>Find the minimum element.</p>
<p>The array may contain duplicates.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">Output: <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">Output: <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>Note:</p>
<ul>
<li>This is a follow up problem to Find Minimum in Rotated Sorted Array.</li>
<li>Would allow duplicates affect the run-time complexity? How and why?</li>
</ul>
<hr>
<p>写在前面：这可以算是代码最简单的Hard题之一。</p>
<p>这道题是上一题153的延伸题目，而且和剑指offer面试题11相同。(重点在于考虑可能会有重复元素)</p>
<p>解：注意这里只能用mid位置的值去和nums[right]去比较，不能用mid位置的值和nums[left]比较，因为做比较的目的是判断 mm 在哪个排序数组中。但在 <code>numbers[m] &gt; numbers[i]</code>情况下，无法判断 m 在哪个排序数组中。本质是因为 j 初始值肯定在右排序数组中； i 初始值无法确定在哪个排序数组中。</p>
<p>举例：当 i = 0, j = 4, m = 2 时，有 numbers[m] &gt; numbers[i] ，以下两示例得出不同结果。<br>numbers = [1, 2, 3, 4 ,5] 旋转点 x = 0 ： m 在右排序数组（此示例只有右排序数组）；<br>numbers = [3, 4, 5, 1 ,2]旋转点 x=3 ： m 在左排序数组。</p>
<p>所以循环比较nums[mid]和nums[right]</p>
<ol>
<li>当 <code>numbers[m] &gt; numbers[j]</code>时： m 一定在 左排序数组中，即旋转点 x 一定在 <code>[m + 1, j]</code> 闭区间内，因此执行 <code>i = m + 1</code>；</li>
<li>当 <code>numbers[m] &lt; numbers[j]</code> 时： m 一定在 右排序数组 中，即旋转点 xx 一定在<code>[i, m]</code> 闭区间内，因此执行 <code>j = m</code>；</li>
<li>当 <code>numbers[m] == numbers[j]</code> 时： 无法判断 m 在哪个排序数组中，即无法判断旋转点 x 在 <code>[i, m]</code> 还是 <code>[m + 1, j]</code> 区间中。解决方案： 执行 <code>j = j - 1</code>缩小判断范围</li>
</ol>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> findMin(<span class="built_in">int</span>[] nums) &#123;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">len</span> = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">len</span> == <span class="number">0</span> || nums == <span class="literal">null</span>) return <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = <span class="built_in">len</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">left</span> &lt; <span class="built_in">right</span>) &#123;</span><br><span class="line">            <span class="built_in">int</span> <span class="built_in">mid</span> = (<span class="built_in">left</span> + <span class="built_in">right</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[<span class="built_in">mid</span>] &gt; nums[<span class="built_in">right</span>]) &#123;</span><br><span class="line">                <span class="built_in">left</span> = <span class="built_in">mid</span> + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[<span class="built_in">mid</span>] &lt; nums[<span class="built_in">right</span>])&#123;</span><br><span class="line">                <span class="built_in">right</span> = <span class="built_in">mid</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">right</span>--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nums[<span class="built_in">left</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(logN),但是在特例下(比如所有元素都相等的情况)，会退化到O(N)</li>
<li>空间复杂度：O(1),left,right,mid指针都是常数大小的空间</li>
</ul>
<h2 id="79-Word-Search-单词搜索-Mid"><a href="#79-Word-Search-单词搜索-Mid" class="headerlink" title="79. Word Search (单词搜索)(Mid)"></a><a href="https://leetcode-cn.com/problems/word-search/" target="_blank" rel="noopener">79. Word Search (单词搜索)(Mid)</a></h2><p>Given a 2D board and a word, find if the word exists in the grid.</p>
<p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>
<p><strong>Example:</strong></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">board =</span><br><span class="line">[</span><br><span class="line">  [<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'E'</span>],</span><br><span class="line">  [<span class="string">'S'</span>,<span class="string">'F'</span>,<span class="string">'C'</span>,<span class="string">'S'</span>],</span><br><span class="line">  [<span class="string">'A'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Given <span class="keyword">word</span> = <span class="string">"ABCCED"</span>, <span class="keyword">return</span> <span class="literal">true</span>.</span><br><span class="line">Given <span class="keyword">word</span> = <span class="string">"SEE"</span>, <span class="keyword">return</span> <span class="literal">true</span>.</span><br><span class="line">Given <span class="keyword">word</span> = <span class="string">"ABCB"</span>, <span class="keyword">return</span> <span class="literal">false</span>.</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>board</code> and <code>word</code> consists only of lowercase and uppercase English letters.</li>
<li><code>1 &lt;= board.length &lt;= 200</code></li>
<li><code>1 &lt;= board[i].length &lt;= 200</code></li>
<li><code>1 &lt;= word.length &lt;= 10^3</code></li>
</ul>
<hr>
<p>解：这道题用递归或者叫回溯来解决。每次只要当前字符和word的第一个字母相同，就开始使用函数dfs进行DFS搜索，每次搜索的方向是上、下、左、右四个，只有找到了才返回true</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">String</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">word</span>.length() == <span class="number">0</span> || <span class="keyword">word</span> == null) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="keyword">word</span>.charAt(<span class="number">0</span>) &amp;&amp; dfs(board,i,j,<span class="number">0</span>,<span class="keyword">word</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board,<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> count, <span class="keyword">String</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="keyword">word</span>.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理边界条件，分别是:go above the board(处在边界上面，下同)(i &lt; 0)、go below the board(i &gt;= board.length)</span></span><br><span class="line">        <span class="comment">// go left the board(j &lt; 0)、go right the board (j &gt;= board[i].length)、</span></span><br><span class="line">        <span class="comment">// 或者就是当前字母不匹配word的单词：board[i][j] != word.charAt(count)</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= board.length || j &lt; <span class="number">0</span> || j &gt;= board[i].length || board[i][j] != <span class="keyword">word</span>.charAt(count)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span> temp = board[i][j]; <span class="comment">// 记录当前i,j位置的字符</span></span><br><span class="line">        board[i][j] = <span class="string">' '</span>; <span class="comment">// 访问过的地方置空，防止重复访问</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span> found = dfs(board,i+<span class="number">1</span>,j,count+<span class="number">1</span>,<span class="keyword">word</span>)</span><br><span class="line">            || dfs(board,i<span class="number">-1</span>,j,count+<span class="number">1</span>,<span class="keyword">word</span>)</span><br><span class="line">            || dfs(board,i,j+<span class="number">1</span>,count+<span class="number">1</span>,<span class="keyword">word</span>)</span><br><span class="line">            || dfs(board,i,j<span class="number">-1</span>,count+<span class="number">1</span>,<span class="keyword">word</span>);</span><br><span class="line">        <span class="comment">// 因为之前每次查找的时候都清空了当前位置元素，所以再找的时候要把值赋回去。因为你不能确保第一次就找到，可能一个字母</span></span><br><span class="line">        <span class="comment">// 要在四个方向都各自查找一次才行，如果之前被置空了而且不管了，那么再找的时候其为空，那就无论如何也不可能找到了，就出错了</span></span><br><span class="line">        board[i][j] = temp;</span><br><span class="line">        <span class="keyword">return</span> found;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：如果整个board元素数量是N,那时间复杂度就是O(N)</li>
<li>空间复杂度：因为调用了递归，可能坏的情况是要每一个元素都建立一个变量，所以空间复杂度应该是O(n)</li>
</ul>
<h2 id="剑指offer面试题13-机器人的运动范围-Mid"><a href="#剑指offer面试题13-机器人的运动范围-Mid" class="headerlink" title="剑指offer面试题13.机器人的运动范围(Mid)"></a><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/" target="_blank" rel="noopener">剑指offer面试题13.机器人的运动范围(Mid)</a></h2><p>地上有一个m行n列的方格，从坐标 <code>[0,0]</code> 到坐标 <code>[m-1,n-1]</code> 。一个机器人从坐标 <code>[0, 0]</code> 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>
<p><strong>示例1：</strong></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = <span class="number">2</span>, n = <span class="number">3</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>示例2：</strong></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = <span class="number">3</span>, n = <span class="number">1</span>, k = <span class="number">0</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n,m &lt;= 100</code></li>
<li><code>0 &lt;= k &lt;= 20</code></li>
</ul>
<hr>
<p>解：这道题和上面的79单词搜索比较类似，都可以用DFS，或者叫回溯的思想。</p>
<p>DFS通过递归，先朝着一个防线搜索到底，再回溯至上一个节点，沿另一个方向搜索，以此类推。在访问过程中可以用到剪枝：遇到数位和超出目标值(k)、或者某位已经访问过，则立即返回，可以称之为<code>可行性剪枝</code></p>
<p>具体做法：</p>
<ul>
<li><strong>递归参数</strong>：可以把m,n,k定义到类外面成为类变量而不是方法变量来减少需要传入的参数值；要传入当前在矩阵中的索引i和j、记录某节点是否被访问过的visited</li>
<li><strong>终止条件</strong>：1.行或者列索引越界(和79机器人、200岛屿相同)、2.数位和si和sj的和超出目标值k、3.当前元素已经访问过</li>
<li><strong>递归工作</strong>：<ul>
<li>标记当前单元格为已访问，即将(i,j)存入Set <code>visited</code>中，代表此单元格已被访问过。</li>
<li>搜索下一个单元格：计算当前元素的<strong>下、右</strong>两个方向元素的数位和，并开启下层递归。</li>
</ul>
</li>
<li>回溯返回值：返回 <code>1 + 右方搜索的可达解总数 + 下方搜索的可达解总数</code>，代表从本单元格递归搜索的可达解总数。</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int</span> m,n,k;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> movingCount(<span class="built_in">int</span> m, <span class="built_in">int</span> n, <span class="built_in">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">this</span>.m = m;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">        <span class="keyword">this</span>.k = k;</span><br><span class="line">        <span class="comment">// visited记录当前位置是否被访问过</span></span><br><span class="line">        <span class="built_in">bool</span>ean[][] visited = new <span class="built_in">bool</span>ean[m][n];</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, visited);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> dfs(<span class="built_in">int</span> i, <span class="built_in">int</span> j, <span class="built_in">bool</span>ean[][] visited) &#123;</span><br><span class="line">        <span class="comment">// terminator</span></span><br><span class="line">        <span class="keyword">if</span>(add(i,j) &gt; k || i &lt; <span class="number">0</span> || i &gt;= m || j &lt; <span class="number">0</span> || j &gt;= n || visited[i][j]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当前位置满足条件而且没被访问过，所以进行访问。</span></span><br><span class="line">        <span class="comment">// 访问之后将visited置true</span></span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> result = <span class="number">0</span>;</span><br><span class="line">        result = <span class="number">1</span> + dfs(i + <span class="number">1</span>,j ,visited) + dfs(i ,j + <span class="number">1</span> ,visited);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> add(<span class="built_in">int</span> i, <span class="built_in">int</span> j) &#123;</span><br><span class="line">        <span class="built_in">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i != <span class="number">0</span>) &#123;</span><br><span class="line">            result += i%<span class="number">10</span>;</span><br><span class="line">            i /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j != <span class="number">0</span>) &#123;</span><br><span class="line">            result += j%<span class="number">10</span>;</span><br><span class="line">            j /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="17-Letter-Combinations-of-a-Phone-Number-电话号码的字母组合-Mid"><a href="#17-Letter-Combinations-of-a-Phone-Number-电话号码的字母组合-Mid" class="headerlink" title="17. Letter Combinations of a Phone Number(电话号码的字母组合)(Mid)"></a><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">17. Letter Combinations of a Phone Number(电话号码的字母组合)(Mid)</a></h2><p>Given a string containing digits from <code>2-9</code> inclusive, return all possible letter combinations that the number could represent.</p>
<p>A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png" alt=""></p>
<p><strong>Example:</strong></p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> <span class="string">"23"</span></span><br><span class="line"><span class="symbol">Output:</span> [<span class="string">"ad"</span>, <span class="string">"ae"</span>, <span class="string">"af"</span>, <span class="string">"bd"</span>, <span class="string">"be"</span>, <span class="string">"bf"</span>, <span class="string">"cd"</span>, <span class="string">"ce"</span>, <span class="string">"cf"</span>].</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong><br>Although the above answer is in lexicographical order(字典序), your answer could be in any order you want.</p>
<hr>
<p>解：这道题是比较经典的搜索问题。深搜和广搜都可以。</p>
<p>方法一：</p>
<h2 id="994-Rotting-Oranges-腐烂的橘子-Mid"><a href="#994-Rotting-Oranges-腐烂的橘子-Mid" class="headerlink" title="994. Rotting Oranges (腐烂的橘子)(Mid)"></a><a href="https://leetcode-cn.com/problems/rotting-oranges/" target="_blank" rel="noopener">994. Rotting Oranges (腐烂的橘子)(Mid)</a></h2><p>In a given grid, each cell can have one of three values:</p>
<ul>
<li>the value <code>0</code> representing an empty cell;</li>
<li>the value <code>1</code> representing a fresh orange;</li>
<li>the value <code>2</code> representing a rotten orange.</li>
</ul>
<p>Every minute, any fresh orange that is adjacent (4-directionally) to a rotten orange becomes rotten.</p>
<p>Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return <code>-1</code> instead.</p>
<p><strong>Example 1:</strong></p>
<p><strong><img src="https://assets.leetcode.com/uploads/2019/02/16/oranges.png" alt="img"></strong></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">Output: <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">Output: <span class="number">-1</span></span><br><span class="line">Explanation:  The orange <span class="keyword">in</span> the bottom left corner (row <span class="number">2</span>, column <span class="number">0</span>) <span class="keyword">is</span> never rotten, because rotting only happens <span class="number">4</span>-directionally.</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="string">[[0,2]]</span></span><br><span class="line"><span class="attr">Output:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">Explanation:</span>  <span class="string">Since</span> <span class="string">there</span> <span class="string">are</span> <span class="string">already</span> <span class="literal">no</span> <span class="string">fresh</span> <span class="string">oranges</span> <span class="string">at</span> <span class="string">minute</span> <span class="number">0</span><span class="string">,</span> <span class="string">the</span> <span class="string">answer</span> <span class="string">is</span> <span class="string">just</span> <span class="number">0</span><span class="string">.</span></span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ol>
<li><code>1 &lt;= grid.length &lt;= 10</code></li>
<li><code>1 &lt;= grid[0].length &lt;= 10</code></li>
<li><code>grid[i][j]</code> is only <code>0</code>, <code>1</code>, or <code>2</code>.</li>
</ol>

    </div>


    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/LeetCode/" rel="tag"><i class="fa fa-tag"></i># LeetCode</a>
              <a href="/tags/Algorithms/" rel="tag"><i class="fa fa-tag"></i># Algorithms</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/01/13/LeetCode-Practice-by-Categories-Tree/" rel="prev" title="LeetCode Practice by Categories Tree+Recursion">
      <i class="fa fa-chevron-left"></i> LeetCode Practice by Categories Tree+Recursion
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/01/13/LeetCode-Practice-by-Categories-Dynamic-Programming/" rel="next" title="LeetCode Practice by Categories Dynamic Programming">
      LeetCode Practice by Categories Dynamic Programming <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC80ODAxMC8yNDUwNw=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#74-Search-a-2D-Matrix-搜索二维矩阵-Mid"><span class="nav-text">74. Search a 2D Matrix(搜索二维矩阵)(Mid)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#240-Search-a-2D-Matrix-II-搜索二维矩阵-Mid"><span class="nav-text">240. Search a 2D Matrix II(搜索二维矩阵)(Mid)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#127-Word-Ladder-单词接龙-Mid"><span class="nav-text">127. Word Ladder(单词接龙)(Mid)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#126-单词接龙-II-Hard"><span class="nav-text">126. (单词接龙 II)(Hard)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#433-Minimum-Genetic-Mutation-最小基因变化-Mid"><span class="nav-text">433. Minimum Genetic Mutation(最小基因变化)(Mid)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#200-Number-of-Islands-岛屿数量-Mid"><span class="nav-text">200. Number of Islands(岛屿数量)(Mid)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#153-Find-Minimum-in-Rotated-Sorted-Array-寻找旋转排序数组中的最小值-Mid"><span class="nav-text">153. Find Minimum in Rotated Sorted Array(寻找旋转排序数组中的最小值)(Mid)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#154-Find-Minimum-in-Rotated-Sorted-Array-寻找旋转排序数组中的最小值-II-Hard"><span class="nav-text">154. Find Minimum in Rotated Sorted Array(寻找旋转排序数组中的最小值 II)(Hard)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#79-Word-Search-单词搜索-Mid"><span class="nav-text">79. Word Search (单词搜索)(Mid)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剑指offer面试题13-机器人的运动范围-Mid"><span class="nav-text">剑指offer面试题13.机器人的运动范围(Mid)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-Letter-Combinations-of-a-Phone-Number-电话号码的字母组合-Mid"><span class="nav-text">17. Letter Combinations of a Phone Number(电话号码的字母组合)(Mid)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#994-Rotting-Oranges-腐烂的橘子-Mid"><span class="nav-text">994. Rotting Oranges (腐烂的橘子)(Mid)</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Wang Mingsheng"
      src="/images/faceimage.jpg">
  <p class="site-author-name" itemprop="name">Wang Mingsheng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">37</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wmsheng" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wmsheng" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:wangmingshenghku@163.com" title="E-Mail → mailto:wangmingshenghku@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://music.163.com/#/my/m/music/playlist?id=372605964" title="Music → https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;my&#x2F;m&#x2F;music&#x2F;playlist?id&#x3D;372605964" rel="noopener" target="_blank"><i class="fa fa-fw fa-youtube"></i>Music</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>


    </div>
    
    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=3314336&auto=1&height=66">
    </iframe>

  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wang Mingsheng</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">495k</span>
</div>


<div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_uv">
    本站访客数:<span id="busuanzi_value_site_uv"></span>
  </span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_pv">
    本站访问量<span id="busuanzi_value_site_pv"></span>
  </span>
</div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共265.6k字</span>
</div>

        
<div class="busuanzi-count">
  <script pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.getAttribute('pjax') !== null) {
      element.setAttribute('pjax', '');
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

    </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/clicklove.js"></script>
