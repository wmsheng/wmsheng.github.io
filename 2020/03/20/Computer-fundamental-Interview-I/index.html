<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/siyecao.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/siyecao.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","padding":18,"offset":12,"onmobile":false,"b2t":true,"scrollpercent":true},
    copycode: {"enable":true,"show_result":true,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="知识犹如人体的血液一样宝贵。——高士其">
<meta property="og:type" content="article">
<meta property="og:title" content="Computer fundamental Intergrated Interview-I">
<meta property="og:url" content="http://yoursite.com/2020/03/20/Computer-fundamental-Interview-I/index.html">
<meta property="og:site_name" content="Hi, This is Bennett">
<meta property="og:description" content="知识犹如人体的血液一样宝贵。——高士其">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2020/03/18/G9r3NBHycJA5Cts.png">
<meta property="og:image" content="https://i.loli.net/2020/03/18/Wspjk3vbEQzdScf.png">
<meta property="og:image" content="https://i.loli.net/2020/03/18/uoacZHrNE1MUzmF.png">
<meta property="og:image" content="https://i.loli.net/2020/03/18/sCcTNa9eULfPwpI.png">
<meta property="og:image" content="https://i.loli.net/2020/03/18/p96xDFSVn3YXCUj.png">
<meta property="og:image" content="https://i.loli.net/2020/03/18/tZbqOCITSged1z8.png">
<meta property="og:image" content="https://i.loli.net/2020/03/18/xDHKZlhciMgfdNG.png">
<meta property="og:image" content="https://i.loli.net/2020/03/18/nUXIerAGEjt1Fbo.png">
<meta property="og:image" content="https://s2.ax1x.com/2020/02/28/30Hs3D.png">
<meta property="og:image" content="https://i.loli.net/2020/03/19/5B9UPNkcjZohXAv.png">
<meta property="og:image" content="https://i.loli.net/2020/03/19/7DTeEOArayKsWFn.png">
<meta property="og:image" content="https://i.loli.net/2020/03/19/9tAPyYbSXFT5qJj.png">
<meta property="og:image" content="https://i.loli.net/2020/03/19/JsDdO4mzlA1BijR.png">
<meta property="og:image" content="https://i.loli.net/2020/03/19/Ixpo25YevyRhL3M.png">
<meta property="og:image" content="https://i.loli.net/2020/03/19/AdSc4CEVvQkrDIa.png">
<meta property="og:image" content="https://i.loli.net/2020/03/19/qgGjK9ilPIpLAZo.png">
<meta property="og:image" content="https://i.loli.net/2020/03/20/MsaHLzIjCUAVh9O.png">
<meta property="og:image" content="https://i.loli.net/2020/03/12/Lja9iFcHx2hubp8.jpg">
<meta property="og:image" content="https://i.loli.net/2020/03/12/P76skMIGWAO3Ntv.jpg">
<meta property="og:image" content="https://i.loli.net/2020/03/19/bUCv5cYonpATdFw.png">
<meta property="og:image" content="https://i.loli.net/2020/03/19/FASYKqlTmbegifL.png">
<meta property="og:image" content="https://i.loli.net/2020/03/19/ELdCNXhp75QSmis.png">
<meta property="og:image" content="https://i.loli.net/2020/03/19/6WRaFfuOPVtTJeE.png">
<meta property="og:image" content="https://i.loli.net/2020/03/19/4AOKQ8fG3ipCJZz.png">
<meta property="og:image" content="https://i.loli.net/2020/03/19/KIRLVOkxsPr58gz.png">
<meta property="article:published_time" content="2020-03-20T04:36:36.000Z">
<meta property="article:modified_time" content="2020-03-22T07:09:11.785Z">
<meta property="article:author" content="Wang Mingsheng">
<meta property="article:tag" content="Interview">
<meta property="article:tag" content="Intergrated">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/03/18/G9r3NBHycJA5Cts.png">

<link rel="canonical" href="http://yoursite.com/2020/03/20/Computer-fundamental-Interview-I/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Computer fundamental Intergrated Interview-I | Hi, This is Bennett</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hi, This is Bennett</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags<span class="badge">22</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories<span class="badge">4</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives<span class="badge">31</span></a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/20/Computer-fundamental-Interview-I/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/faceimage.jpg">
      <meta itemprop="name" content="Wang Mingsheng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hi, This is Bennett">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Computer fundamental Intergrated Interview-I
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-20 12:36:36" itemprop="dateCreated datePublished" datetime="2020-03-20T12:36:36+08:00">2020-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-22 15:09:11" itemprop="dateModified" datetime="2020-03-22T15:09:11+08:00">2020-03-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Interview-Note/" itemprop="url" rel="index">
                    <span itemprop="name">Interview Note</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              
              <span>28k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>知识犹如人体的血液一样宝贵。——高士其</p>
</blockquote>
<a id="more"></a>


<p>其他精彩文章：<a href="https://www.jianshu.com/p/a61f012e84d5" target="_blank" rel="noopener">20+公司面试题总结及补充</a></p>
<h1 id="1-计算机网络"><a href="#1-计算机网络" class="headerlink" title="1.计算机网络"></a>1.计算机网络</h1><h2 id="1-1-HTTPS和HTTP"><a href="#1-1-HTTPS和HTTP" class="headerlink" title="1.1 HTTPS和HTTP"></a>1.1 HTTPS和HTTP</h2><p>HTTP是明文传输，不安全。HTTPS是加密之后的传输方式。</p>
<p>要弄清，先理解对称加密和非对称加密。</p>
<h3 id="对称加密-Symmetric-encryption-和非对称加密-Asymmetric-encryption"><a href="#对称加密-Symmetric-encryption-和非对称加密-Asymmetric-encryption" class="headerlink" title="对称加密(Symmetric encryption)和非对称加密(Asymmetric encryption)"></a>对称加密(Symmetric encryption)和非对称加密(Asymmetric encryption)</h3><h4 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h4><p>对称加密：在每次发送真实数据之前，服务器先生成一把密钥，然后先把密钥传输给客户端。之后服务器给客户端发送真实数据的时候，会用这把密钥对数据进行加密，客户端收到加密数据之后，用刚才收到的密钥进行解密。</p>
<p>如图：</p>
<p><img src="https://i.loli.net/2020/03/18/G9r3NBHycJA5Cts.png" alt="对称加密.png"></p>
<p>这里只画了服务器传送数据给客户端的情况，暂时只考虑这个单向，其实是一样的。</p>
<p>但是这里有一个<strong>致命</strong>的问题，就是秘钥在传输过程中会是以明文方式传输的，在传输过程中可能被拦截。(这也是二战时期图灵能够破解德军军情的原因)</p>
<p>具体来说：假如服务器用明文的方式传输密钥给客户端，然后密钥被中间人给捕获了，那么在之后服务器和客户端的加密传输过程中，中间人也可以用他捕获的密钥进行解密。这样的话，加密的数据在中间人看来和明文没啥两样。</p>
<p>所以对称加密的问题出在<strong>如何把秘钥安全地给客户端</strong>。</p>
<h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><p>让客户端和服务器都拥有两把钥匙，一个用来加密(公钥)，一个用来解密(私钥)。这两把钥匙一般都会用RSA Algorithm来生成。在通信之前不需要先同步秘钥，避免了在同步私钥过程中被黑客盗取信息的风险。</p>
<p>一把钥匙是公开的(全世界知道都没关系)，我们称之为<strong>公钥</strong>；另一把钥匙则是保密的(只有自己本人才知道)，我们称之为<strong>私钥</strong>。</p>
<p>虽然有一点违反常识，但是非对称加密能够做到：用公钥加密的原文，原公钥无法解密，只能用对应的私钥解密。</p>
<p>可以通过私钥计算出公钥，但是无法用公钥推导出私钥。</p>
<p>这且，<strong>用公钥加密的数据，只有<font color=#FF0000>对应的私钥</font>才能解密；用私钥加密的数据，只有<font color=#FF0000>对应的公钥</font>才能解密</strong>。</p>
<p>按照这个思路，服务器在给客户端传输数据的过程中，可以用客户端明文给他的公钥进行加密，然后客户端收到后，再用自己的私钥进行解密。客户端给服务器发送数据的时候也一样采取这样的方式。这样就能保持数据的安全传输了。</p>
<p>图解如下：</p>
<p><img src="https://i.loli.net/2020/03/18/Wspjk3vbEQzdScf.png" alt="非对称加密.png"></p>
<p>但是非对称加密在加密的时候速度比对称加密慢上百倍，所以直接用非对称加密的话效率很低。</p>
<p>因为对称加密不安全的主要原因是密钥无法安全交付给客户端，所以我们可以用非对称加密的方式传输加密过程中的密钥，之后我们就可以采取对称加密的方式来传输数据了。</p>
<p>具体做法：服务器用明文的方式给客户端发送自己的公钥，客户端收到公钥之后，会生成一把密钥(对称加密用的)，然后用服务器的公钥对这把密钥进行加密，之后再把密钥传输给服务器，服务器收到之后进行解密，最后服务器就可以安全着得到这把密钥了，而客户端也有同样一把密钥，他们就可以进行对称加密了。</p>
<p>但是非对称加密也不能保证安全，举个例子：</p>
<p>服务器以明文的方式给客户端传输公钥的时候，中间人截取了这把属于服务器的公钥，并且把<strong>中间人自己的公钥冒充服务器的公钥</strong>传输给了客户端。</p>
<p>之后客户端就会用中间人的公钥来加密自己生成的密钥。然后把被加密的密钥传输给服务器，这个时候中间人又<strong>把密钥给截取了</strong>，中间人用自己的私钥对这把被加密的密钥进行解密，解密后中间人就可以获得这把密钥了。</p>
<p>最后中间人再对这把密钥用刚才服务器的公钥进行加密，再发给服务器。如图：</p>
<p><img src="https://i.loli.net/2020/03/18/uoacZHrNE1MUzmF.png" alt="非对称加密的不安全性.png"></p>
<p>在这个过程中，中间人获取了对称加密中的密钥，在之后服务器和客户端的对称加密传输中，这些加密的数据对中间人来说，和明文没啥区别。</p>
<p>具体说来，非对称加密的不安全的原因主要是客户端不知道这把公钥是不是属于服务器的。</p>
<p>解决方法：数字证书。</p>
<h4 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h4><p>之所以非对称加密会不安全，是因为客户端不知道这把公钥是否是服务器的，因此，我们需要找到一种策略来证明这把公钥就是服务器的，而不是别人冒充的。</p>
<p>解决这个问题的方式就是使用数字证书，具体是这样的：</p>
<p>我们需要找到一个拥有公信力、大家都认可的认证中心(CA)。</p>
<p>服务器在给客户端传输公钥的过程中，会把公钥以及服务器的个人信息通过Hash算法生成信息摘要。</p>
<p>如图：</p>
<p><img src="https://i.loli.net/2020/03/18/sCcTNa9eULfPwpI.png" alt="服务器生成信息摘要.png"></p>
<p>为了防止信息摘要被调换，CA会提供私钥给服务器，服务器会用这个CA给的私钥来加密得到<strong>数字签名</strong>。</p>
<p>如图：</p>
<p><img src="https://i.loli.net/2020/03/18/p96xDFSVn3YXCUj.png" alt="服务器生成数字签名.png"></p>
<p>在生成了数字签名之后，服务端会把所有信息合成在一起，成为<strong>数字证书</strong>。</p>
<p><img src="https://i.loli.net/2020/03/18/tZbqOCITSged1z8.png" alt="合成数字签名等内容为数字证书.png"></p>
<p>客户端拿到证书之后，为了确认发送者确实是服务端，会利用CA给的公钥来对数字证书里面的数字签名进行解密来得到<strong>信息摘要</strong>，然后对数字证书里服务器的公钥以及个人信息进行Hash得到<strong>另外一份信息摘要</strong>，最后比较两者，相同，才能确认这份证书是服务端发送的，否则很可能被人动过手脚。</p>
<p><img src="https://i.loli.net/2020/03/18/xDHKZlhciMgfdNG.png" alt="客户端进行解析对比.png"></p>
<p>由此，可以保证服务器的公钥安全地交给了客户端。</p>
<h4 id="CA的公钥如何拿给客户端？服务器如何获得CA私钥？"><a href="#CA的公钥如何拿给客户端？服务器如何获得CA私钥？" class="headerlink" title="CA的公钥如何拿给客户端？服务器如何获得CA私钥？"></a>CA的公钥如何拿给客户端？服务器如何获得CA私钥？</h4><p>服务器一开始会向CA申请特定私钥。客户端很多浏览器都支持HTTPS方式，也都申请了证书。</p>
<p>更加形象的讲解内容可以参考<a href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&mid=2247485749&idx=1&sn=77f79a358ed59fd45f9b9dab68cfa34c&scene=21#wechat_redirect" target="_blank" rel="noopener">什么是数字签名</a></p>
<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>数字签名详解，参考<a href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&mid=2247485749&idx=1&sn=77f79a358ed59fd45f9b9dab68cfa34c&scene=21#wechat_redirect" target="_blank" rel="noopener">这篇文章</a></p>
<h3 id="SSL-TLS协议"><a href="#SSL-TLS协议" class="headerlink" title="SSL/TLS协议"></a>SSL/TLS协议</h3><p>SSL 即安全套接字层，它在 OSI 七层网络模型中处于第五层(网络层)</p>
<p>TLS 用于两个通信应用程序之间提供保密性和数据完整性。TLS 由记录协议、握手协议、警告协议、变更密码规范协议、扩展协议等几个子协议组成，综合使用了对称加密、非对称加密、身份认证等许多密码学前沿技术。</p>
<p>TLS 在根本上使用对称加密和 非对称加密 两种形式。</p>
<p>HTTPS在使用SSL/TLS传输的过程中，先会用非对称加密，然后用对称加密，也就是所谓的<strong>混合加密</strong>。</p>
<p>实际上混合加密在上面，优化非对称加密传输的过程中已经有详细介绍了。因为非对称加密算法(比如RSA)计算非常慢，而对称加密算法(比如AES)计算相对非对称快上一百倍，所以先用非对称加密算法，先用非对称加密解决<strong>秘钥交换</strong>的问题，然后用随机数产生对称算法使用的<code>会话密钥（session key）</code>，再用<code>公钥加密</code>。对方拿到密文后用<code>私钥解密</code>，取出会话密钥。这样，双方就实现了对称密钥的安全交换。</p>
<h3 id="HTTP状态码？-1开头到5开头的各种典型状态码"><a href="#HTTP状态码？-1开头到5开头的各种典型状态码" class="headerlink" title="HTTP状态码？(1开头到5开头的各种典型状态码)"></a>HTTP状态码？(1开头到5开头的各种典型状态码)</h3><p>客户端的每一次请求，服务器都必须给出回应。回应包括 HTTP 状态码和数据两部分。</p>
<p>HTTP 状态码就是一个三位数，分成五个类别。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>xx：相关信息</span><br><span class="line"><span class="number">2</span>xx：操作成功</span><br><span class="line"><span class="number">3</span>xx：重定向</span><br><span class="line"><span class="number">4</span>xx：客户端错误</span><br><span class="line"><span class="number">5</span>xx：服务器错误</span><br></pre></td></tr></table></figure>

<h3 id="一些可能有用的与HTTP有关的协议"><a href="#一些可能有用的与HTTP有关的协议" class="headerlink" title="一些可能有用的与HTTP有关的协议"></a>一些可能有用的与HTTP有关的协议</h3><p>在互联网中，任何协议都不会单独的完成信息交换，HTTP 也一样。虽然 HTTP 属于应用层的协议，但是它仍然需要其他层次协议的配合完成信息的交换，那么在完成一次 HTTP 请求和响应的过程中，需要哪些协议的配合呢？一起来看一下</p>
<h4 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h4><p>CDN的全称是<code>Content Delivery Network</code>，即<code>内容分发网络</code>，它应用了 HTTP 协议里的缓存和代理技术，代替源站响应客户端的请求。CDN 是构建在现有网络基础之上的网络，它依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有<code>内容存储</code>和<code>分发技术</code>。</p>
<p>打比方说你要去亚马逊上买书，之前你只能通过购物网站购买后从美国发货过海关等重重关卡送到你的家里，现在在中国建立一个亚马逊分基地，你就不用通过美国进行邮寄，从中国就能把书尽快给你送到。</p>
<h4 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h4><p>TCP/IP 我们一般称之为协议簇，什么意思呢？就是 TCP/IP 协议簇中不仅仅只有 TCP 协议和 IP 协议，它是一系列网络通信协议的统称。而其中最核心的两个协议就是 TCP / IP 协议，其他的还有 UDP、ICMP、ARP 等等，共同构成了一个复杂但有层次的协议栈。</p>
<p><font color=#FF0000>HTTP 使用 TCP 作为通信协议</font>，这是因为 TCP 是一种可靠的协议，而可靠能保证数据不丢失。</p>
<h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>计算机网络中的每个端系统都有一个 IP 地址存在，而把 IP 地址转换为便于人类记忆的协议就是 DNS 协议。</p>
<p>DNS 的全称是域名系统<code>（Domain Name System，缩写：DNS）</code>，它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。</p>
<h4 id="URI-URL"><a href="#URI-URL" class="headerlink" title="URI/URL"></a>URI/URL</h4><p>我们上面提到，你可以通过输入 <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> 地址来访问谷歌的官网，那么这个地址有什么规定吗？我怎么输都可以？AAA.BBB.CCC 是不是也行？当然不是的，你输入的地址格式必须要满足 URI 的规范。</p>
<p>URI的全称是（Uniform Resource Identifier），中文名称是统一资源标识符，使用它就能够唯一地标记互联网上资源。</p>
<p>URL的全称是（Uniform Resource Locator），中文名称是统一资源定位符，也就是我们俗称的网址，它实际上是 URI 的一个子集。</p>
<p>URI 不仅包括 URL，还包括 URN（统一资源名称），它们之间的关系如下</p>
<p><img src="https://i.loli.net/2020/03/18/nUXIerAGEjt1Fbo.png" alt="URLURI示意图.png"></p>
<h4 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h4><p>之前讲了很多了，重点是HTTPS和HTTP的区别：</p>
<p>HTTPS 和 HTTP 有很大的不同在于 HTTPS 是以安全为目标的 HTTP 通道，在 HTTP 的基础上通过传输加密和身份认证保证了传输过程的安全性。HTTPS 在 HTTP 的基础上增加了 SSL 层，也就是说 HTTPS = HTTP + SSL</p>
<h3 id="输入一个URL之后，整个请求过程是怎样的？"><a href="#输入一个URL之后，整个请求过程是怎样的？" class="headerlink" title="输入一个URL之后，整个请求过程是怎样的？"></a>输入一个URL之后，整个请求过程是怎样的？</h3><p>举例，访问地址为 <a href="http://www.someSchool.edu/someDepartment/home.index" target="_blank" rel="noopener">http://www.someSchool.edu/someDepartment/home.index</a></p>
<p>一共六步</p>
<ol>
<li>DNS服务器会首先进行域名的映射，找到访问<a href="http://www.someSchool.edu所在的地址，然后HTTP" target="_blank" rel="noopener">www.someSchool.edu所在的地址，然后HTTP</a> 客户端进程在 80 端口发起一个到服务器 <a href="http://www.someSchool.edu" target="_blank" rel="noopener">www.someSchool.edu</a> 的 TCP 连接（80 端口是 HTTP 的默认端口）。在客户和服务器进程中都会有一个套接字与其相连。</li>
<li>HTTP 客户端通过它的套接字向服务器发送一个 HTTP 请求报文。该报文中包含了路径 someDepartment/home.index 的资源，我们后面会详细讨论 HTTP 请求报文。</li>
<li>HTTP 服务器通过它的套接字接受该报文，进行请求的解析工作，并从其存储器(RAM 或磁盘)中检索出对象 <a href="http://www.someSchool.edu/someDepartment/home.index，然后把检索出来的对象进行封装，封装到" target="_blank" rel="noopener">www.someSchool.edu/someDepartment/home.index，然后把检索出来的对象进行封装，封装到</a> HTTP 响应报文中，并通过套接字向客户进行发送。</li>
<li>HTTP 服务器随即通知 TCP 断开 TCP 连接，实际上是需要等到客户接受完响应报文后才会断开 TCP 连接。</li>
<li>HTTP 客户端接受完响应报文后，TCP 连接会关闭。HTTP 客户端从响应中提取出报文中是一个 HTML 响应文件，并检查该 HTML 文件，然后循环检查报文中其他内部对象。</li>
<li>检查完成后，HTTP 客户端会把对应的资源通过显示器呈现给用户。</li>
</ol>
<p>这是个简单的例子，详细的例子可以参考<a href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&mid=2247485074&idx=1&sn=f4e44c4b675adc6e13b4704839c5a19d&scene=21#wechat_redirect" target="_blank" rel="noopener">这篇文章</a></p>
<h3 id="GET和POST报文形式"><a href="#GET和POST报文形式" class="headerlink" title="GET和POST报文形式"></a>GET和POST报文形式</h3><p>实际上HTTP的响应报文结构都是一样的，GET和POST只是会体现在协议版本的地方不同而已。</p>
<p>分为请求行、响应头、响应正文几个部分。每次响应可以没有正文，但是必须有请求头。注意请求头后面会空出来一行，再开始响应正文。</p>
<p>如下图：<br><img src="https://s2.ax1x.com/2020/02/28/30Hs3D.png" alt="HTTP响应报文"></p>
<p>一个例子：</p>
<p><img src="https://i.loli.net/2020/03/19/5B9UPNkcjZohXAv.png" alt="一个实例.png"></p>
<h3 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h3><p>可以从三个层面解释：</p>
<ul>
<li>HTTP报文层面：GET将请求信息放在URL中，POST放在报文体中。</li>
<li>数据库层面：GET符合幂等性 (对数据库的多次操作效果一样，PUT也是幂等的)和安全性 (操作不会改变数据库中的数据)，POST不符合。</li>
<li>其他层面：GET可以被缓存、被存储，而POST不行</li>
</ul>
<h3 id="255-255-255-255和0-0-0-0的作用"><a href="#255-255-255-255和0-0-0-0的作用" class="headerlink" title="255.255.255.255和0.0.0.0的作用"></a>255.255.255.255和0.0.0.0的作用</h3><p>255.255.255.255这个地址一般用来广播的时候使用，而0.0.0.0这个地址可以代表这是一个还没有分配 ip 的主机。</p>
<p>不过0.0.0.0还有其他作用，代表主机还没有分配ip地址只是其中的一个用处。例如：充当默认路由来使用，当一个路由器要发送路由表中无法查询的包时，如果设置了全零网络的路由时，我们就可以把这个包丢给全零网络的路由。</p>
<h3 id="TCP和UDP区别以及各自适用场景"><a href="#TCP和UDP区别以及各自适用场景" class="headerlink" title="TCP和UDP区别以及各自适用场景"></a>TCP和UDP区别以及各自适用场景</h3><p>UDP提供不可靠无连接的数据报传输服务，使用IP实现报文传输，根据协议端口号确定收发双方的应用程序，适用于一个服务器需要对多个客户端频繁的小数据请求进行服务的情况。TCP提供可靠的面向连接的数据流传输服务，TCP偏重于可靠性，而不是实时性，适用于一对一的传输大量数据的场合。</p>
<h3 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h3><p>流量控制与接收方的缓存状态相关。</p>
<p>一般来说，我们都希望数据能传输快一些。但是，<strong>如果发送方把数据发送得过快，接收方就可能来不及接收，这就会造成数据的丢失</strong>。</p>
<p><font color=#FF0000>所谓流量控制(flow control)就是让发送方的发送速率不要太快，要让接收方来得及接收</font>。</p>
<p>解决流量控制的问题的方法很多，比如停止-等待、滑动窗口等。</p>
<p>流量控制不是属于某一层特有的功能，比如数据链路层会要考虑，这里的TCP的也会要考虑(数据链路层的暂时不讨论)</p>
<p>TCP利用<strong>滑动窗口机制</strong>，可以比较好的成功做到流量控制。</p>
<p>详细过程可以参考这个<a href="https://www.bilibili.com/video/av50251501?from=search&seid=2105367062843188825" target="_blank" rel="noopener">教学视频</a></p>
<h3 id="TCP拥塞机制"><a href="#TCP拥塞机制" class="headerlink" title="TCP拥塞机制"></a>TCP拥塞机制</h3><p>拥塞控制与网络拥堵情况相关。</p>
<ul>
<li>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏。这种情况就叫做拥塞(congestion)。<ul>
<li>在计算机网络中的链路容量(即带宽)、交换节点中的缓存和处理机等，都是网络资源。</li>
</ul>
</li>
<li>若<font color=#FF0000>出现拥塞而不进行控制</font>，整个网络的<font color=#FF0000>吞吐量将随输入负荷的增加而下降</font>。</li>
</ul>
<p>就好比平时我们路上如果车流量太大，没有交警的疏导的话就容易造成堵塞。</p>
<p><img src="https://i.loli.net/2020/03/19/7DTeEOArayKsWFn.png" alt="TCP拥塞控制曲线.png"></p>
<p>拥塞控制是很难设计的，因为网络是高度动态的，有时候甚至是因为这个拥塞控制，导致了网络的拥堵。</p>
<p><strong>TCP的拥塞控制机制有四种算法</strong>：</p>
<ul>
<li>慢开始(slow-start)</li>
<li>拥塞避免(congestion avoidance)</li>
<li>快重传(fast retransmit)</li>
<li>快回复(fast recovery)</li>
</ul>
<p>下面介绍这四种拥塞控制算法，但是需要基于以下条件：</p>
<ul>
<li>数据总是单向传送，而另一个方向只传送确认。</li>
<li>接收方总是有足够大的缓存空间(即不考虑流量控制的必要)，因而发送方发送窗口的大小由网络的拥塞程度来决定。</li>
<li>以TCP报文段的个数作为讨论问题的单位，而不是以字节为单位。</li>
</ul>
<p>TCP拥塞控制的示意图如下：</p>
<p><img src="https://i.loli.net/2020/03/19/9tAPyYbSXFT5qJj.png" alt="TCP拥塞控制原理文字图.png"></p>
<p>简而言之，一开始拥塞窗口cwnd的大小会是2的指数级来增加，直到其大小达到了慢开始门限值(ssthresh)，后面就改用<font color=#FF0000>拥塞避免算法</font>，即每次让cwnd加1。整个传输过程曲线的一个详细例子如下图：</p>
<p><img src="https://i.loli.net/2020/03/19/JsDdO4mzlA1BijR.png" alt="拥塞重传超时重新进行.png"></p>
<p>在重新执行一次拥塞控制算法之后，整个的传输曲线是这样的：</p>
<p><img src="https://i.loli.net/2020/03/19/Ixpo25YevyRhL3M.png" alt="慢开始拥塞避免算法例子整个的曲线.png"></p>
<ul>
<li>“慢开始”是指一开始向网络注入的报文段少，不是指拥塞窗口cwnd增长速度慢；</li>
<li>“拥塞避免”不是指能完全避免拥塞，而是指在拥塞避免阶段将拥塞滑动窗口控制为按线性规律增长，使网络比较不容易出现拥塞。</li>
</ul>
<p>上述的慢开始算法和拥塞避免算法是一起的(TCP Tahoe版本)，在1988年被提出的。在1990年又增加了两个新的拥塞控制算法(<font color=#FF0000>改进TCP的性能</font>)，这就是快重传和快恢复(TCP Reno版本)。</p>
<ul>
<li>为什么要有改进的算法？原先的慢开始拥塞避免算法不好么？</li>
</ul>
<p>答：有时候，个别报文段会在网络中丢失，但是实际上网络并未发生拥塞。这会导致发送发认为已经发生拥塞，启动慢开始算法，把拥塞窗口(cwnd)设置为1，但是这会降低传输效率。</p>
<p>所谓快重传，就是使发送方<font color=#FF0000>尽快进行重传</font>，而不是等超时重传计时器超时了再重传。</p>
<p>具体做法：</p>
<ul>
<li>要求接收方不要等待自己发送数据时才进行捎带确认，而是<strong>立即发送确认</strong>。</li>
<li>即使收到了失序报文段也要立即发出对已收到的报文段的<strong>重复确认</strong>。</li>
<li>发送方一旦<font color=#FF0000>收到3个连续的重复确认</font>，就将相应的报文段<strong>立即重传</strong>，而不是等该报文段的重传计时器超时再重传。</li>
</ul>
<p>举一个图的例子，这里包含了TCP处理拥塞控制的四种方法：</p>
<p><img src="https://i.loli.net/2020/03/19/AdSc4CEVvQkrDIa.png" alt="综合四种方法的例子.png"></p>
<p>详细内容可以参考<a href="https://www.bilibili.com/video/av52266048/?spm_id_from=333.788.videocard.0" target="_blank" rel="noopener">这个教学视频</a></p>
<h3 id="选择重传协议-SR-——可靠性传输协议中的一个"><a href="#选择重传协议-SR-——可靠性传输协议中的一个" class="headerlink" title="选择重传协议(SR)——可靠性传输协议中的一个"></a>选择重传协议(SR)——可靠性传输协议中的一个</h3><p>重传协议只重发没有正确接收的帧，而不是重发所有的帧。发送方为每个发送的帧设置一个定时器，收到应答就停止计时，超时未收到应答，说明帧丢失或出错，重发该帧。接收方收到序号正确的帧，就向发送方发送ACK应答信号，如果发现序号不连接，有丢失帧现象，就向发送方发送NAK信号，请求重发制定序号的帧。</p>
<p>提一下其他发送方和接收方的其他两个可靠性传输的实现机制：停止-等待协议(SW)和后退N帧协议(GBN)</p>
<p><img src="https://i.loli.net/2020/03/19/qgGjK9ilPIpLAZo.png" alt="停止等待和后退N帧.png"></p>
<p>选择重传协议也是基于滑动窗口流量控制技术的。它的<strong>接受窗口尺寸和发送窗口尺寸都大于 1</strong>，以便能够一次性接受多个帧。如果采用 n 个比特对帧机型编号，为了避免接受端向前移动窗口后，新接收窗口与旧接收窗口产生重叠，发送窗口的最大尺寸应该不超过序列号范围的一半。</p>
<p>举个例子：</p>
<p><img src="https://i.loli.net/2020/03/20/MsaHLzIjCUAVh9O.png" alt="滑动窗口大小例子.png"></p>
<p>在这个例子中，有四个分组序号 0、1、2、3 且窗口长度为 3。假定发送了分组 0 至 2，并且接收方被正确接收且确认了。此时，接收方窗口落在 4、5、6 个分组上，其序号分别为 3、0、1.现在考虑两种情况。</p>
<p>在第一种情况下，如上图中的 a 图所示，对前 3 个分组的 ACK 丢失，因此发送方重传这些分组。因此，接收方下一步要接收序号为 0 的分组，即第一个发送分组的副本。</p>
<p>在第二种情况下，如上图中的 b 图所示，对前 3 个分组的 ACK 都被正确交付。因此发送方向前移动窗口并发送第 4、5、6 个分组，其序号分别为 3、0、1.序号为 3 的分组丢失，但序号为 0 的分组到达（一个包含新数据的分组）。</p>
<p>显然，接收方并不知道发送方那边出现了什么问题，对于接收方自己来说，上面两种情况是等价的。没有办法区分是第一个分组的重传还是第 5 个分组的初次传输。所以，窗口长度比序号空间小 1 时协议无法正常工作。但窗口应该有多小呢？</p>
<p>答案是：<strong><font color=#FF0000>窗口长度必须小于或等于序号空间大小的一半</font></strong>。</p>
<p>详细内容可以参考<a href="https://www.bilibili.com/video/av50124975?from=search&seid=13909578244053300305" target="_blank" rel="noopener">这个教学视频</a></p>
<p>以及<a href="https://blog.csdn.net/qq_22238021/article/details/80325285" target="_blank" rel="noopener">这篇文章</a></p>
<h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p>回答过程中最好不要只回答SYN、ACK这样，而是把服务端和客户端发送之后的状态也说出来。</p>
<p><img src="https://i.loli.net/2020/03/12/Lja9iFcHx2hubp8.jpg" alt="TCP三次握手"></p>
<p>刚开始两端都处于 closed 的状态，开始传输之后，服务端会被动大开，进入 listen 状态。然后：</p>
<ol>
<li><p>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号seq(x)。发送报文之后，客户端进入 SYN_Send 状态。</p>
</li>
<li><p>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 seq(y)，同时会把客户端的 x + 1 作为 ack 的值(大的ACK表示确认收到，小的ack才表示序列号，ack为当前报文段最后一个字节的编号+1)，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。</p>
</li>
<li><p>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 y + 1 作为 ack 的值，表示已经收到了服务端的 SYN 报文，之后客户端进入 establised 状态。</p>
</li>
</ol>
<p>4、服务器收到 ACK 报文之后，进入 establised 状态，此时，双方以建立起了链接。</p>
<h4 id="TCP三次握手涉及的问题"><a href="#TCP三次握手涉及的问题" class="headerlink" title="TCP三次握手涉及的问题"></a>TCP三次握手涉及的问题</h4><h5 id="1-三次握手的作用"><a href="#1-三次握手的作用" class="headerlink" title="1.三次握手的作用"></a>1.三次握手的作用</h5><p>三次握手的作用也是有好多的，多记住几个，保证不亏。例如：</p>
<ol>
<li><p>确认双方的接受能力、发送能力是否正常。</p>
</li>
<li><p>指定自己的初始化序列号，为后面的可靠传送做准备。</p>
</li>
<li><p>如果是 https 协议的话，三次握手这个过程，还会进行数字证书的验证以及加密密钥的生成到。</p>
</li>
</ol>
<h5 id="2-seq-ISN-是固定的么"><a href="#2-seq-ISN-是固定的么" class="headerlink" title="2.seq(ISN)是固定的么"></a>2.seq(ISN)是固定的么</h5><p>三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。</p>
<p>如果ISN是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。</p>
<h5 id="3-什么是半连接队列"><a href="#3-什么是半连接队列" class="headerlink" title="3.什么是半连接队列"></a>3.什么是半连接队列</h5><p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为<strong>半连接队列</strong>。当然还有一个<strong>全连接队列</strong>，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p>
<blockquote>
<p>这里在补充一点关于SYN-ACK 重传次数的问题：　服务器发送完SYN－ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超 过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s, 2s, 4s, 8s, ….</p>
</blockquote>
<h5 id="4-三次握手过程中可以携带数据吗"><a href="#4-三次握手过程中可以携带数据吗" class="headerlink" title="4.三次握手过程中可以携带数据吗"></a>4.三次握手过程中可以携带数据吗</h5><p>很多人可能会认为三次握手都不能携带数据，其实第三次握手的时候，是可以携带数据的。也就是说，第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。</p>
<p>为什么这样呢？大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。也就是说，第一次握手可以放数据的话，其中一个简单的原因就是会让服务器更加容易受到攻击了。</p>
<p>而对于第三次的话，此时客户端已经处于 established 状态，也就是说，对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据页没啥毛病。</p>
<p>此外，三次握手还会涉及https加密过程。</p>
<h5 id="5-第一次握手时可能会出现SYN超时的问题——针对SYN-Flood的防护措施"><a href="#5-第一次握手时可能会出现SYN超时的问题——针对SYN-Flood的防护措施" class="headerlink" title="5.第一次握手时可能会出现SYN超时的问题——针对SYN Flood的防护措施"></a>5.第一次握手时可能会出现SYN超时的问题——针对SYN Flood的防护措施</h5><p>面试回答建连的问题时，可以提到 SYN 洪水攻击发生的原因，就是 Server 端收到 Client 端的 SYN 请求后，发送了 ACK 和 SYN，但是 Client 端不进行回复，导致 Server 端大量的链接处在 SYN_RCVD 状态，进而影响其他正常请求的建连。可以设置 tcp_synack_retries = 0 加快半链接的回收速度，或者调大 tcp_max_syn_backlog 来应对少量的 SYN 洪水攻击。因为是Server端接收到了Client端的SYN包之后的回复的时候出现的问题，所以可以认为是首次握手时候产生的隐患。</p>
<h3 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h3><p>四次挥手也一样，千万不要对方一个 FIN 报文，我方一个 ACK 报文，再我方一个 FIN 报文，我方一个 ACK 报文。然后结束，最好是说的详细一点，例如想下面这样就差不多了，要把每个阶段的状态记好。</p>
<p><img src="https://i.loli.net/2020/03/12/P76skMIGWAO3Ntv.jpg" alt="四次挥手过程"></p>
<p>刚开始双方都处于 establised 状态，客户端先发起关闭请求，则：</p>
<ol>
<li><p>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号seq。之后客户端进入CLOSED_WAIT1状态。</p>
</li>
<li><p>第二次握手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ack 报文的序列号值，表明已经收到客户端的报文了，然后当然也会附上自己产生的序列号seq=y, 之后服务端进入 CLOSE_WAIT2状态。</p>
</li>
<li><p>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号seq=z。之后服务端进入 LAST_ACK 的状态。</p>
</li>
<li><p>第四次挥手：客户端收到 FIN 之后，一样发送一个 ack 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，之后客户端进入 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态。注意这里客户端不再生成新的序列号，而是使用之前的x+1和z+1</p>
</li>
<li><p>服务端收到 ACK 报文之后，就处于关闭连接了，进入 CLOSED 状态。</p>
</li>
</ol>
<h4 id="TCP四次挥手涉及的问题"><a href="#TCP四次挥手涉及的问题" class="headerlink" title="TCP四次挥手涉及的问题"></a>TCP四次挥手涉及的问题</h4><h5 id="1-为什么客户端在最后要有2MSL的等待时间，即为什么要有TIME-WAIT时间？"><a href="#1-为什么客户端在最后要有2MSL的等待时间，即为什么要有TIME-WAIT时间？" class="headerlink" title="1.为什么客户端在最后要有2MSL的等待时间，即为什么要有TIME_WAIT时间？"></a>1.为什么客户端在最后要有2MSL的等待时间，即为什么要有TIME_WAIT时间？</h5><p>原因有两个：</p>
<ol>
<li>保证TCP协议的全双工连接能够可靠关闭；</li>
<li>保证这次连接的重复数据段从网络中消失，防止端口被重用时可能产生数据混淆。</li>
</ol>
<h5 id="2-四次挥手过程中大量Socket处在TIME-WAIT和CLOSE-WAIT状态，该如何解决？"><a href="#2-四次挥手过程中大量Socket处在TIME-WAIT和CLOSE-WAIT状态，该如何解决？" class="headerlink" title="2.四次挥手过程中大量Socket处在TIME_WAIT和CLOSE_WAIT状态，该如何解决？"></a>2.四次挥手过程中大量Socket处在TIME_WAIT和CLOSE_WAIT状态，该如何解决？</h5><p>需要注意，在四次挥手的过程中，可以提到在实际应用中有可能遇到大量Socket处在TIME_WAIT或者CLOSE_WAIT状态的问题。一般开启 tcp_tw_reuse 和 tcp_tw_recycle 能够加快 TIME-WAIT 的 Sockets 回收；而大量 CLOSE_WAIT 可能是被动关闭的一方存在代码 bug，没有正确关闭链接导致的。</p>
<h3 id="一些状态的含义"><a href="#一些状态的含义" class="headerlink" title="一些状态的含义"></a>一些状态的含义</h3><blockquote>
<p>LISTEN - 侦听来自远方TCP端口的连接请求；</p>
</blockquote>
<blockquote>
<p>SYN-SENT -在发送连接请求后等待匹配的连接请求；</p>
</blockquote>
<blockquote>
<p>SYN-RECEIVED - 在收到和发送一个连接请求后等待对连接请求的确认；</p>
</blockquote>
<blockquote>
<p>ESTABLISHED- 代表一个打开的连接，数据可以传送给用户；</p>
</blockquote>
<blockquote>
<p>FIN-WAIT-1 - 等待远程TCP的连接中断请求，或先前的连接中断请求的确认；</p>
</blockquote>
<blockquote>
<p>FIN-WAIT-2 - 从远程TCP等待连接中断请求；</p>
</blockquote>
<blockquote>
<p>CLOSE-WAIT - 等待从本地用户发来的连接中断请求；</p>
</blockquote>
<blockquote>
<p>CLOSING -等待远程TCP对连接中断的确认；</p>
</blockquote>
<blockquote>
<p>LAST-ACK - 等待原来发向远程TCP的连接中断请求的确认；</p>
</blockquote>
<blockquote>
<p>TIME-WAIT -等待足够的时间以确保远程TCP接收到连接中断请求的确认；</p>
</blockquote>
<blockquote>
<p>CLOSED - 没有任何连接状态；</p>
</blockquote>
<h2 id="1-2-cookie和session的区别"><a href="#1-2-cookie和session的区别" class="headerlink" title="1.2 cookie和session的区别"></a>1.2 cookie和session的区别</h2><p>参考<a href="https://www.jianshu.com/p/2f7031a69f43" target="_blank" rel="noopener">这篇文章</a></p>
<ol>
<li>存储位置不同</li>
</ol>
<blockquote>
<p>cookie的数据信息存放在客户端浏览器上。</p>
</blockquote>
<blockquote>
<p>session的数据信息存放在服务器上。</p>
</blockquote>
<ol start="2">
<li>存储容量不同</li>
</ol>
<blockquote>
<p>单个cookie保存的数据&lt;=4KB，一个站点最多保存20个Cookie。</p>
</blockquote>
<blockquote>
<p>对于session来说并没有上限，但出于对服务器端的性能考虑，session内不要存放过多的东西，并且设置session删除机制。</p>
</blockquote>
<ol start="3">
<li>存储方式不同</li>
</ol>
<blockquote>
<p>cookie中只能保管ASCII字符串，并需要通过编码方式存储为Unicode字符或者二进制数据。</p>
</blockquote>
<blockquote>
<p>session中能够存储任何类型的数据，包括且不限于string，integer，list，map等。</p>
</blockquote>
<ol start="4">
<li>隐私策略不同</li>
</ol>
<blockquote>
<p>cookie对客户端是可见的，别有用心的人可以分析存放在本地的cookie并进行cookie欺骗，所以它是不安全的。</p>
</blockquote>
<blockquote>
<p>session存储在服务器上，对客户端是隐藏，不存在敏感信息泄漏的风险。</p>
</blockquote>
<ol start="5">
<li>有效期上不同</li>
</ol>
<blockquote>
<p>开发可以通过设置cookie的属性，达到使cookie长期有效的效果。</p>
</blockquote>
<blockquote>
<p>session依赖于名为JSESSIONID的cookie，而cookie JSESSIONID的过期时间默认为-1，只需关闭窗口该session就会失效，因而session不能达到长期有效的效果。</p>
</blockquote>
<ol start="6">
<li>服务器压力不同</li>
</ol>
<blockquote>
<p>cookie保管在客户端，不占用服务器资源。对于并发用户十分多的网站，cookie是很好的选择。</p>
</blockquote>
<blockquote>
<p>session是保管在服务器端的，每个用户都会产生一个session。假如并发访问的用户十分多，会产生十分多的session，耗费大量的内存。</p>
</blockquote>
<ol start="7">
<li>浏览器支持不同</li>
</ol>
<p>假如客户端浏览器不支持cookie：</p>
<blockquote>
<p>cookie是需要客户端浏览器支持的，假如客户端禁用了cookie，或者不支持cookie，则会话跟踪会失效。关于WAP上的应用，常规的cookie就派不上用场了。</p>
</blockquote>
<blockquote>
<p>运用session需要使用URL地址重写的方式。一切用到session程序的URL都要进行URL地址重写，否则session会话跟踪还会失效。</p>
</blockquote>
<p>假如客户端支持cookie：</p>
<blockquote>
<p>cookie既能够设为本浏览器窗口以及子窗口内有效，也能够设为一切窗口内有效。</p>
</blockquote>
<blockquote>
<p>session只能在本窗口以及子窗口内有效。</p>
</blockquote>
<ol start="8">
<li>跨域支持上不同</li>
</ol>
<blockquote>
<p>cookie支持跨域名访问。</p>
</blockquote>
<blockquote>
<p>session不支持跨域名访问。</p>
</blockquote>
<p>另外：现在正在淘汰cookie了，谷歌日前就在官方博客上说，将在未来两年淘汰cookie,即chrome逐步淘汰第三方cookie，但是由于市场占比的原因，这件事还有待进一步发展。</p>
<h2 id="HTTP、TCP、UDP、IP、ICMP、DNS、FTP等协议分别处于哪层？"><a href="#HTTP、TCP、UDP、IP、ICMP、DNS、FTP等协议分别处于哪层？" class="headerlink" title="HTTP、TCP、UDP、IP、ICMP、DNS、FTP等协议分别处于哪层？"></a>HTTP、TCP、UDP、IP、ICMP、DNS、FTP等协议分别处于哪层？</h2><p>以OSI七层模型来说：</p>
<ul>
<li>应用层：<strong>HTTP、FTP、DNS、</strong>Telnet、SMTP、</li>
<li>传输层：<strong>TCP、UDP</strong></li>
<li>网络层：<strong>IP、ICMP、</strong>RIP、OSPF、</li>
<li>数据链路层：<strong>ARP</strong>、PPP、RARP、MTU</li>
<li>物理层：ISO2110、IEEEE802、IEEEE802.2</li>
</ul>
<h2 id="Ping指令用的什么协议？在哪一层？"><a href="#Ping指令用的什么协议？在哪一层？" class="headerlink" title="Ping指令用的什么协议？在哪一层？"></a>Ping指令用的什么协议？在哪一层？</h2><p>Ping命令本身处于应用层，相当于一个应用程序，它直接使用网络层的ICMP回应报文来监听返回情况。(所以如果直接问ping在哪一层，答案是应用层)</p>
<h2 id="ARP协议的作用？"><a href="#ARP协议的作用？" class="headerlink" title="ARP协议的作用？"></a>ARP协议的作用？</h2><h3 id="什么是ARP协议？"><a href="#什么是ARP协议？" class="headerlink" title="什么是ARP协议？"></a>什么是ARP协议？</h3><p>ARP (Address Resolution Protocol) 是个地址解析协议。最直白的说法是：在IP以太网中，当一个上层协议要发包时，有了该节点的IP地址，ARP就能提供该节点的MAC地址。</p>
<h3 id="为什么要有ARP协议？"><a href="#为什么要有ARP协议？" class="headerlink" title="为什么要有ARP协议？"></a>为什么要有ARP协议？</h3><p>OSI 模式把网络工作分为七层，彼此不直接打交道，只通过接口(layre interface). IP地址在第三层, MAC地址在第二层。协议在发生数据包时，首先要封装第三层 （IP地址）和第二层 （MAC地址）的报头, 但协议只知道目的节点的IP地址，不知道其物理地址，又不能跨第二、三层，所以得用ARP的服务。</p>
<h2 id="路由器和交换机的区别？"><a href="#路由器和交换机的区别？" class="headerlink" title="路由器和交换机的区别？"></a>路由器和交换机的区别？</h2><p>交换机是一根网线上网，但是大家上网是分别拨号，各自使用自己的宽带，大家上网没有影响。而路由器比交换机多了一个虚拟拨号功能，通过同一台路由器上网的电脑是共用一个宽带账号，大家上网要相互影响。</p>
<p>交换机工作在中继层，交换机根据MAC地址寻址。路由器工作在网络层，根据IP地址寻址，路由器可以处理TCP/IP协议，而交换机不可以。</p>
<p>路由器工作于网络层，用来隔离广播域（子网），连接的设备分属不同子网，工作范围是多个子网之间，负责网络与网络之间通信。</p>
<p><strong>工作层次不同</strong></p>
<p>交换机主要工作在数据链路层（第二层）</p>
<p>路由器工作在网络层（第三层）。</p>
<p><strong>转发依据不同</strong></p>
<p>交换机转发所依据的对象时：MAC地址。（物理地址）</p>
<p>路由转发所依据的对象是：IP地址。（网络地址）</p>
<p><strong>主要功能不同</strong></p>
<p>交换机主要用于组建局域网，而路由主要功能是将由交换机组好的局域网相互连接起来，或者接入Internet。<br>交换机能做的，路由都能做。<br>交换机不能分割广播域，路由可以。<br>路由还可以提供防火墙的功能。<br>路由配置比交换机复杂。</p>
<p>其他有关路由器和交换机的知识：<a href="https://www.cnblogs.com/Lynn-Zhang/articles/5754336.html" target="_blank" rel="noopener">可以参考文章</a></p>
<h1 id="2-操作系统"><a href="#2-操作系统" class="headerlink" title="2.操作系统"></a>2.操作系统</h1><h2 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h2><p>从宏观上来回答：</p>
<p>a.进程是系统资源分配的最小单位，线程是程序执行的最小单位</p>
<p>b.进程使用独立的数据空间，而线程共享进程的数据空间</p>
<p>更深入一点：</p>
<ul>
<li><p>共享内存方面。因为进程间不能共享内存，所以我们会用一些进程间相互交互的方案，比较常见的就是通过TCP/IP的端口来实现。也有其他方案，但是TCP/IP是最通用的，其他方案可能和某个特定操作系统的相关性要更大一些。</p>
</li>
<li><p>进程与线程通信方面。进程通信比较难，线程间通信就很简单了，只要两个线程的指针指向同一块内存，它们之间就可以通信。</p>
</li>
<li><p>In terms of 开销，进程的开销当然比较大，因为我们要给它分配很多内存，而线程我们只是给它分配一个栈，分配一个PC指针(program counter)就可以了。此外，进程之间切换的开销会大于线程之间切换的开销。</p>
</li>
</ul>
<h2 id="进程间通信方式-IPC-Inter-Process-Communication"><a href="#进程间通信方式-IPC-Inter-Process-Communication" class="headerlink" title="进程间通信方式(IPC, Inter Process Communication)"></a>进程间通信方式(IPC, Inter Process Communication)</h2><p>总共七种方法：</p>
<ol>
<li>文件</li>
<li>管道/命名管道</li>
<li>Signal</li>
<li>共享内存</li>
<li>消息队列</li>
<li>同步机制，如信号量(semaphore)</li>
<li>Socket</li>
</ol>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>写一个文件：最简单的方法，一个进程写一个文件，另一个进程去访问这个文件，由此两个进程之间可以交换信息，得以通信。</p>
<h3 id="管道-命名管道"><a href="#管道-命名管道" class="headerlink" title="管道/命名管道"></a>管道/命名管道</h3><p>管道：两个进程之间建立消息通信的通道。不命名的管道一般是单向的，一方可以向另一方从管道里发送数据；命名管道可以单向也可以双向。</p>
<p>管道的通知机制类似于缓存，就像一个进程把数据放在某个缓存区域，然后等着另外一个进程去拿，并且是管道是单向传输的。</p>
<p>这种通信方式有什么缺点呢？显然，这种通信方式效率低下，你看，a 进程给 b 进程传输数据，只能等待 b 进程取了数据之后 a 进程才能返回。</p>
<p>所以管道不适合频繁通信的进程。当然，他也有它的优点，例如比较简单，能够保证我们的数据已经真的被其他进程拿走了。我们平时用 Linux 的时候，也算是经常用。</p>
<h3 id="Signal"><a href="#Signal" class="headerlink" title="Signal"></a>Signal</h3><p>Signal：linux系统中最常用。一个进程给另一个进程发送信号，一般是一串数字，这个数字有自己特定的含义。比如”kill”可以 send a signal to a process,强行”kill”掉。</p>
<p>比如kill -9,可以杀死进程</p>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>系统加载一个进程的时候，分配给进程的内存并不是实际物理内存，而是虚拟内存空间。那么我们可以让两个进程各自拿出一块虚拟地址空间来，然后映射到相同的物理内存中，这样，两个进程虽然有着独立的虚拟内存空间，但有一部分却是映射到相同的物理内存，这就完成了内存共享机制了。</p>
<p>换句话说：虽然进程之间是彼此独立的，但是操作系统可以提供一个机制，两个进程可以约定好，打开一个文件，这个文件映射到内存中，也就是多个进程使用同一块内存。</p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>我们可以用消息队列的通信模式来解决这个问题，例如 a 进程要给 b 进程发送消息，只需要把消息放在对应的消息队列里就行了，b 进程需要的时候再去对应的<br>消息队列里取出来。同理，b 进程要个 a 进程发送消息也是一样。这种通信方式也类似于缓存吧。</p>
<p>这种通信方式有缺点吗？答是有的，如果 a 进程发送的数据占的内存比较大，并且两个进程之间的通信特别频繁的话，消息队列模型就不大适合了。因为 a 发送的数据很大的话，意味发送消息（拷贝）这个过程需要花很多时间来读内存。</p>
<h3 id="同步机制，如信号量-semaphore"><a href="#同步机制，如信号量-semaphore" class="headerlink" title="同步机制，如信号量(semaphore)"></a>同步机制，如信号量(semaphore)</h3><p>信号量的本质就是一个计数器，用来实现进程之间的互斥与同步。例如信号量的初始值是 1，然后 a 进程来访问内存1的时候，我们就把信号量的值设为 0，然后进程b 也要来访问内存1的时候，看到信号量的值为 0 就知道已经有进程在访问内存1了，这个时候进程 b 就会访问不了内存1。所以说，信号量也是进程之间的一种通信方式。</p>
<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>最后一种，而且没回答出来这个其实整个答案都不算好。因为前面6种只能作为同一个机器的进程之间的通信，而Socket可以是不同机器的进程之间的通信。</p>
<p>可以在机器上开一个端口，作为一个服务器，让用户连接。这种通信包含了网络上的服务端和服务器的这种结构。</p>
<p>用浏览器去访问一个网站，这时浏览器的进程和远端服务器的进程要进行通信。</p>
<p>Socket可以作为不同机器之间进程的通信——通过客户端，服务器的方法。这里面走的一般是TCP的协议或者UDP的协议。</p>
<h2 id="经典进程调度算法"><a href="#经典进程调度算法" class="headerlink" title="经典进程调度算法"></a>经典进程调度算法</h2><h3 id="1-批处理时代"><a href="#1-批处理时代" class="headerlink" title="1.批处理时代"></a>1.批处理时代</h3><h4 id="1-FCFS-先来先服务"><a href="#1-FCFS-先来先服务" class="headerlink" title="1.FCFS(先来先服务)"></a>1.FCFS(先来先服务)</h4><p>每个进程按进入内存的时间先后排成一队。每当 CPU 上的进程运行完毕或者阻塞，我就会选择队伍最前面的进程，带着他前往 CPU 执行。</p>
<p>这一算法听起来简单又公平，然而好景不长，我收到了一个短进程的抱怨：”上次我前面排了一个长进程，等了足足 200 秒他才运行完。我只用 1 秒就运行结束了，就因为等他，我多花了这么长时间，太不值得了。”</p>
<p>我仔细一想， FCFS 算法确实有这个缺陷——短进程的响应时间太长了，用户交互体验会变差。</p>
<p>所以我决定，更换调度算法。</p>
<h4 id="2-SPN-段任务优先"><a href="#2-SPN-段任务优先" class="headerlink" title="2.SPN(段任务优先)"></a>2.SPN(段任务优先)</h4><p>这次我设计的算法叫做「短任务优先」（Shortest Process Next，SPN）。每次选择预计处理时间最短的进程。因此，在排队的时候，我会把短进程从队列里提到前面。</p>
<p>这一次，短进程得到了很好的照顾，进程的平均响应时间大大降低，我和操作系统都很满意。</p>
<p>但长进程们不干了：那些短进程天天插队，导致他们经常得不到 CPU 资源，造成了「饥饿」现象。</p>
<p>取消 SPN 算法的呼声越来越高。</p>
<p>这可是个大问题。FCFS 虽然响应时间长，但最后所有进程一定有使用 CPU 资源的机会。但 SPN 算法就不一样了，如果短进程源源不断加入队列，长进程们将永远得不到执行的机会——太可怕了。</p>
<p>因此，短任务优先算法需要得到改进。有什么方法既能照顾短进程，又能照顾长进程呢？</p>
<h4 id="3-HARRN-高响应比优先"><a href="#3-HARRN-高响应比优先" class="headerlink" title="3.HARRN(高响应比优先)"></a>3.HARRN(高响应比优先)</h4><p>经过和操作系统的讨论，我们决定综合考量进程的两个属性：等待时间和要求服务时间——等待时间长，要求服务时间短（就是短进程）的进程更容易被选中。</p>
<p>为了量化，我们制定了一个公式：响应比 = （等待时间+要求服务时间）/ 要求服务时间。响应比高的算法会先执行。我们称之为「高响应比优先」（Highest Response Ratio Next，HRRN）。</p>
<p>这个算法得到了长短进程的一致好评。虽然我的工作量增加了（每次调度前，我都要重新计算所有等待进程的响应比）但为了进程们的公平性，这一切都是值得的。</p>
<h3 id="2-并发时代"><a href="#2-并发时代" class="headerlink" title="2.并发时代"></a>2.并发时代</h3><p>新时代到了。</p>
<p>随着计算机的普及，个人用户大量增长，并发，即一次运行多个程序的需求出现了。这可难倒我了——处理器只有一个，怎么运行多个程序？</p>
<p>所幸 CPU 点醒了我：“我现在的运算速度既然这么快，何不发挥这项长处，弄一个「伪并行」出来？“</p>
<p>“伪并行？什么意思”</p>
<p>“就是看起来像并行，实际上还是串行。每个进程短时间交替使用我的资源，但在人类看来，这些进程就像在「同时」运行。”</p>
<h4 id="1-RR-时间片轮转算法"><a href="#1-RR-时间片轮转算法" class="headerlink" title="1.RR(时间片轮转算法)"></a>1.RR(时间片轮转算法)</h4><p>经过 CPU 的提醒，我很快制定出了新的调度算法——时间片轮转算法（Round Robin，RR）。</p>
<p>在这个算法里，每个进程将轮流使用 CPU 资源，只不过在他们开始运行时，我会为他们打开定时器，如果定时器到时间（或者执行阻塞操作），进程将被迫「下机」，切换至下一个进程。至于下一个进程的选择嘛，直接用 FCFS 就好了。</p>
<p>新的算法必然会面临新的问题，现在我的问题就是，时间片的长度怎么设计？</p>
<p>直观来看，时间片越短，固定时间里可运行的进程就越多，可 CPU 说过，切换进程是要消耗他不少指令周期的，时间片过短会导致大量 CPU 资源浪费在切换上下文上。时间片过长，短交互指令响应会变慢。所以具体怎么取，还得看交互时间大小（感觉像没说一样，但至少给了个标准嘛）。</p>
<p>这一阶段，我的工作量大大提升——以前十几秒都不用切换一次程序，现在倒好，一秒钟就得切换数十次。</p>
<h4 id="2-VRR-虚拟轮转法"><a href="#2-VRR-虚拟轮转法" class="headerlink" title="2.VRR(虚拟轮转法)"></a>2.VRR(虚拟轮转法)</h4><p>时间片轮转算法看起来十分公平——所有的进程时间片都是一样的。但事实真是这样吗？</p>
<p>I/O 密集型进程不这么认为，他对我说：“调度器大哥，时间片轮转没有照顾到我们这类进程啊！我们经常在 CPU 没呆到一半时间片，就遇到了阻塞操作，被你赶下去。而且我们在阻塞队列，往往要停留很长时间。等阻塞操作结束，我们还得在就绪队列排好长时间队。那些处理器密集型进程，使用了大部分的处理器时间，导致我们性能降低，响应时间跟不上”</p>
<p>考虑到这些进程的要求，我决定为他们创建一个新的辅助队列。阻塞解除的进程，将进入这个辅助队列，进行进程调度时，优先选择辅助队列里的进程。</p>
<p>这就是「虚拟轮转法」（Virtual Round Robin，VRR）。</p>
<p>从后来实际性能结果来看，这种方法确实优于轮转法。</p>
<h4 id="3-优先级调度"><a href="#3-优先级调度" class="headerlink" title="3.优先级调度"></a>3.优先级调度</h4><p>这个非常类似于优先队列的思想。</p>
<p>有一天，操作系统忽然找到我，神神秘秘的说：“调度器啊，你是知道的，我要给整个系统提供服务，可最近用户进程太多，导致我的服务进程有时候响应跟不上。我有点担心这会给系统稳定性造成影响。”</p>
<p>我一听，这可是个大事，系统不稳定那还得了？调度算法得换！</p>
<p>既然要让操作系统的服务得到足够的运行资源，那就，干脆让他们具有最高的 CPU 使用优先权吧。</p>
<p><strong>优先级调度算法</strong>就此产生了。</p>
<p>我向大家做出了规定——每个进程将被赋予一个<strong>优先级</strong>，自己根据自己的情况确定优先级数值，但是，用户进程的优先级<strong>不准高于</strong>内核进程的优先级。</p>
<p>切换程序的时候，我会从优先级 1 的队列里选择一个进程，如果优先级 1 队列为空，才会选择优先级 2 中的进程，以此类推。</p>
<p>当然，为了保证低优先级进程不会<strong>饥饿</strong>，我会调高等待时间长的进程的优先级。</p>
<p>使用这个算法，我更忙碌了，不仅需要大量切换进程，还需要动态调节优先级。可能这就是能力越大，责任越大吧。</p>
<p>不过我知道，正是因为我的存在，人类才能在计算机上运行多道程序——这令我感到自豪。</p>
<h2 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h2><p>出现互斥的根本原因就是进程在执行某一个操作(比如购票操作，在操作过程中某个进程买票了，减了一张，如果另外一个进程也访问了买票系统，买了票，又减了1，那导致卖了两张票出去，出错了)</p>
<p>这本质是进程之间冲突造成的，一个进程修改了共享的空间的数据，另一个一个线程再访问的时候自然就会出错。</p>
<p>这个是进程调度器的锅么？——因为貌似进程调度器负责调度进程啊！</p>
<p>但是，并不是。因为进程调度器也只负责做事，它只负责从<strong>就绪队列</strong>中选出来<strong>最应该使用CPU的进程而已</strong>。具体说来，调度器的时机是由<strong>中断</strong>决定的，也就是当进程时间片用完的时候，出现了时钟中断，然后被其他进程抢占了CPU资源。</p>
<p>但是能因此就禁止中断么？当然不行。<strong>中断禁用</strong>虽然可以防止进程在运行代码，但是计算机自己不能控制执行的功能，全部交给程序员，这是不合理的。</p>
<p>解决方法：<strong>加锁</strong>。</p>
<p>加锁是个比喻，其实<strong>「锁」</strong>只是一个共享变量，我们可以让它有 <code>OPEN</code> 和 <code>CLOSE</code> 这两个值。一个进程，比如说 A，进入临界区之前，先检查锁是不是 <code>OPEN</code> 状态，如果是的话，就把锁改为 <code>CLOSE</code> 状态 ，这样其他进程在进入临界区时，会发现锁已经 <code>CLOSE</code> 了，那就让他们<strong>循环等待</strong> ，直到 A 出临界区然后将锁打开。</p>
<p>内存眉头一皱，发现事情并没有这么简单——<strong>如果 A 发现锁是开着的，但在 A 还没有关闭锁之前，切换到了进程 B ，那么 B 也会发现锁是开着的，那么 B 也将能够进入临界区</strong>！</p>
<p>但是CPU说：”这对我来说，不是问题，已经有现成机制可以使用。”</p>
<p>原来计算机里有一条硬件支持的指令——<strong>TSL</strong>（test and set lock，测试并加锁），这条指令可以保证读字和写字的操作「<strong>不可分割</strong>」，也就是说，在这条指令结束前，就连其他处理器也不可能访问该内存字。</p>
<p>但是如果单纯设置这样的锁，一个进程没执行完，另一个不能执行，很可能会浪费CPU资源，所以单纯的TSL方案需要改进。</p>
<p>然而，磁盘想到了解决这个问题的方法。</p>
<p>利用<strong>信号量</strong>。。Dijkstra 提出，<code>P</code>操作是检测信号量是否为正值，如果不是，就阻塞调用它的进程。  <code>V</code>操作能唤醒一个被阻塞的进程，让他恢复执行 。</p>
<p>代码：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// S 为信号量</span></span><br><span class="line"><span class="function"><span class="title">P</span><span class="params">(s)</span></span>:</span><br><span class="line">&#123;</span><br><span class="line">S = S - <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> (S &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        调用该 P 操作的进程阻塞，并插入相应的阻塞队列；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// S 为信号量</span></span><br><span class="line"><span class="function"><span class="title">V</span><span class="params">(s)</span></span>:</span><br><span class="line">&#123;</span><br><span class="line">S = S + <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> (S &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        从等待信号量 S 的阻塞队列里唤醒一个进程；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举个例子，购票操作。这里的 「购票操作」 就是我们要保护的临界区，我们要保证一次只能有一个线程进入。那我们就把 S 的初始值设为 1 。当线程 A 第一个调用 P(S) 后，S 的值就变成了 0 ，A 成功进入临界区。在 A 出临界区之前，线程 B 如果调用 P(S)， S 就变成 -1 ，满足 S &lt; 0 的判断条件，线程 B 就被阻塞了。等 A 调用 V(S) 后，S 的值又变成 0 ，满足 S &lt;= 0，就会把线程 B 唤醒，B 就能进入临界区了。“</p>
<p>而且信号量在这里有了可以增加线程运行速度的作用：<strong>S 的初始值可以控制有多少个线程进入临界区</strong>，太厉害了！</p>
<h2 id="锁-重量级锁、自旋锁、轻量级锁、偏向锁、悲观、乐观锁等"><a href="#锁-重量级锁、自旋锁、轻量级锁、偏向锁、悲观、乐观锁等" class="headerlink" title="锁(重量级锁、自旋锁、轻量级锁、偏向锁、悲观、乐观锁等)"></a>锁(重量级锁、自旋锁、轻量级锁、偏向锁、悲观、乐观锁等)</h2><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>如果你学过多线程，那么你肯定知道<strong>锁</strong>这个东西，至于为什么需要锁，我就不给你普及了，就当做你是已经懂的了。</p>
<p>我们知道，我们要进入一个同步、线程安全的方法时，是需要先获得这个方法的锁的，退出这个方法时，则会释放锁。如果获取不到这个锁的话，意味着有别的线程在执行这个方法，这时我们就会马上进入阻塞的状态，等待那个持有锁的线程释放锁，然后再把我们从阻塞的状态唤醒，我们再去获取这个方法的锁。</p>
<p>这种获取不到锁就马上进入阻塞状态的锁，我们称之为重量级锁。</p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>我们知道，线程从<strong>运行态</strong>进入<strong>阻塞态</strong>这个过程，是非常耗时的，因为不仅需要保存线程此时的执行状态，上下文等数据，还涉及到<strong>用户态</strong>到<strong>内核态</strong>的转换。当然，把线程从阻塞态唤醒也是一样，也是非常消耗时间的。</p>
<p>刚才我说线程拿不到锁，就会<strong>马上</strong>进入阻塞状态，然而现实是，它虽然这一刻拿不到锁，可能在下 0.0001 秒，就有其他线程把这个锁释放了。如果它慢0.0001秒来拿这个锁的话，可能就可以顺利拿到了，不需要经历<strong>阻塞/唤醒</strong>这个花时间的过程了。</p>
<p>然而重量级锁就是这么坑，它就是不肯等待一下，一拿不到就是要马上进入阻塞状态。为了解决这个问题，我们引入了另外一种愿意等待一段时间的锁 — <strong>自旋锁</strong>。</p>
<p>自旋锁就是，如果此时拿不到锁，它不马上进入阻塞状态，而是等待一段时间，看看这段时间有没其他人把这锁给释放了。怎么等呢？这个就类似于线程在那里做<strong>空循环</strong>，如果循环一定的次数还拿不到锁，那么它才会进入阻塞的状态。</p>
<p>至于是循环等待几次，这个是可以人为指定一个数字的。</p>
<h3 id="自适应自旋锁"><a href="#自适应自旋锁" class="headerlink" title="自适应自旋锁"></a>自适应自旋锁</h3><p>上面我们说的自旋锁，每个线程循环等待的次数都是一样的，例如我设置为 100次的话，那么线程在空循环 100 次之后还没拿到锁，就会进入阻塞状态了。</p>
<p>而自适应自旋锁就牛逼了，它不需要我们人为指定循环几次，它自己本身会进行判断要循环几次，而且每个线程可能循环的次数也是不一样的。而之所以这样做，主要是我们觉得，如果一个线程在不久前拿到过这个锁，或者它之前经常拿到过这个锁，那么我们认为<strong>它再次拿到锁的几率非常大</strong>，所以循环的次数会多一些。</p>
<p>而如果有些线程从来就没有拿到过这个锁，或者说，平时很少拿到，那么我们认为，它再次拿到的概率是比较小的，所以我们就让它循环的次数少一些。因为你在那里做空循环是很消耗 CPU 的。</p>
<p>所以这种能够根据线程最近获得锁的状态来调整循环次数的自旋锁，我们称之为<strong>自适应自旋锁</strong>。</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>上面我们介绍的三种锁：重量级、自旋锁和自适应自旋锁，他们都有一个特点，就是进入一个方法的时候，就会加上锁，退出一个方法的时候，也就释放对应的锁。</p>
<p>之所以要加锁，是因为他们害怕自己在这个方法执行的时候，被别人偷偷进来了，所以只能加锁，防止其他线程进来。这就相当于，每次离开自己的房间，都要锁上门，人回来了再把锁解开。</p>
<p>这实在是太麻烦了，如果根本就没有线程来和他们竞争锁，那他们不是白白上锁了？要知道，<strong>加锁</strong>这个过程是需要操作系统这个大佬来帮忙的，是很消耗时间的，。为了解决这种<strong>动不动就加锁</strong>带来的开销，轻量级锁出现了。</p>
<p>轻量级锁认为，当你在方法里面执行的时候，其实是很少刚好有人也来执行这个方法的，所以，当我们进入一个方法的时候根本就不用加锁，我们只需要<strong>做一个标记</strong>就可以了，也就是说，我们可以用一个变量来记录此时该方法是否有人在执行。也就是说，如果这个方法没人在执行，当我们进入这个方法的时候，采用CAS机制，把这个方法的状态标记为已经有人在执行，退出这个方法时，在把这个状态改为了<strong>没有人在执行了</strong>。</p>
<blockquote>
<p>之所以要用CAS机制来改变状态，是因为我们对这个状态的改变，不是一个原子性操作，所以需要CAS机制来保证操作的原子性。</p>
</blockquote>
<p>显然，<strong>比起加锁操作，这个采用CAS来改变状态的操作，花销就小多了</strong>。</p>
<p>然而可能会说，没人来竞争的这种想法，那是你说的而已，那如果万一有人来竞争说呢？也就是说，当一个线程来执行一个方法的时候，方法里面已经有人在执行了。</p>
<p>如果真的遇到了竞争，我们就会认为轻量级锁已经不适合了，我们就会把轻量级锁升级为重量级锁了。</p>
<p>所以轻量级锁适合用在那种，很少出现多个线程竞争一个锁的情况，也就是说，适合那种多个线程总是<strong>错开时间</strong>来获取锁的情况。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁就更加牛逼了，我们已经觉得轻量级锁已经够<strong>轻</strong>，然而偏向锁更加<strong>省事</strong>，偏向锁认为，你轻量级锁每次进入一个方法都需要用CAS来改变状态，退出也需要改变，多麻烦。</p>
<p>偏向锁认为，其实对于一个方法，是很少有两个线程来执行的，搞来搞去，其实也就一个线程在执行这个方法而已，相当于单线程的情况，居然是<strong>单线程</strong>，那就没必要加锁了。</p>
<p>不过毕竟实际情况的多线程，单线程只是自己认为的而已了，所以呢，偏向锁进入一个方法的时候是这样处理的：如果这个方法没有人进来过，那么一个线程首次进入这个方法的时候，会采用CAS机制，把这个方法标记为有人在执行了，和轻量级锁加锁有点类似，并且也会把该线程的 ID 也记录进去，相当于记录了哪个线程在执行。</p>
<p>然后，但这个线程退出这个方法的时候，它不会改变这个方法的状态，而是直接退出来，懒的去改，因为它认为除了自己这个线程之外，其他线程并不会来执行这个方法。</p>
<p>然后当这个线程想要再次进入这个方法的时候，会判断一下这个方法的状态，如果这个方法已经被标记为<strong>有人在执行了</strong>，并且线程的ID是自己，那么它就直接进入这个方法执行，啥也不用做</p>
<p>你看，多方便，第一次进入需要CAS机制来设置，以后进出就啥也不用干了，直接进入退出。</p>
<p>然而，现实总是残酷的，毕竟实际情况还是多线程，所以万一有其他线程来进入这个方法呢？如果真的出现这种情况，其他线程一看这个方法的ID不是自己，这个时候说明，至少有两个线程要来执行这个方法论，这意味着<strong>偏向锁已经不适用了</strong>，这个时候就会从偏向锁升级为轻量级锁。</p>
<p>所以呢，偏向锁适用于那种，始终只有一个线程在执行一个方法的情况。</p>
<h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><p>最开始我们说的三种锁，重量级锁、自旋锁和自适应自旋锁，进入方法之前，就一定要先加一个锁，这种我们为称之为<strong>悲观锁</strong>。悲观锁总认为，如果不事先加锁的话，就会出事，这种想法确实悲观了点，这估计就是悲观锁的来源了。</p>
<p>而<strong>乐观锁</strong>却相反，认为不加锁也没事，我们可以先不加锁，如果出现了冲突，我们在想办法解决，例如 CAS 机制，上面说的轻量级锁，就是乐观锁的。不会马上加锁，而是等待真的出现了冲突，在想办法解决。</p>
<blockquote>
<p>互斥锁(重量级锁)也称为阻塞同步、悲观锁</p>
</blockquote>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>按照对方法加锁的量级，按照synchronized加锁的顺序，从轻到重，依次是：偏向锁-&gt;轻量级锁-&gt;重量级锁</p>
<h1 id="3-计算机组成原理"><a href="#3-计算机组成原理" class="headerlink" title="3.计算机组成原理"></a>3.计算机组成原理</h1><h2 id="为什么寄存器比内存快？"><a href="#为什么寄存器比内存快？" class="headerlink" title="为什么寄存器比内存快？"></a>为什么寄存器比内存快？</h2><p>计算机的存储层次（memory hierarchy）之中，寄存器（register）最快，内存其次，最慢的是硬盘。</p>
<p>同样都是晶体管存储设备，为什么寄存器比内存快呢？</p>
<p><strong>原因一：距离不同</strong></p>
<p>距离不是主要因素，但是最好懂，所以放在最前面说。内存离CPU比较远，所以要耗费更长的时间读取。</p>
<p>以3GHz的CPU为例，电流每秒钟可以振荡30亿次，每次耗时大约为0.33纳秒。光在1纳秒的时间内，可以前进30厘米。也就是说，在CPU的一个时钟周期内，光可以前进10厘米。因此，如果内存距离CPU超过5厘米，就不可能在一个时钟周期内完成数据的读取，这还没有考虑硬件的限制和电流实际上达不到光速。相比之下，寄存器在CPU内部，当然读起来会快一点。</p>
<p>这里说明下：之所以是5厘米而不是10厘米，是因为算的是往返的路程。</p>
<p>距离对于桌面电脑影响很大，对于手机影响就要小得多。手机CPU的时钟频率比较慢（iPhone 5s为1.3GHz），而且手机的内存紧挨着CPU。</p>
<p><strong>原因二：硬件设计不同</strong></p>
<p>苹果公司新推出的iPhone 5s，CPU是A7，寄存器有6000多位（31个64位寄存器，加上32个128位寄存器）。而iPhone 5s的内存是1GB，约为80亿位（bit）。这意味着，高性能、高成本、高耗电的设计可以用在寄存器上，反正只有6000多位，而不能用在内存上。因为每个位的成本和能耗只要增加一点点，就会被放大80亿倍。</p>
<p><strong>原因三：工作方式不同</strong></p>
<p>寄存器的工作方式很简单，只有两步：</p>
<p>（1）找到相关的位</p>
<p>（2）读取这些位</p>
<p>内存的工作方式就要复杂得多：</p>
<p>（1）找到数据的指针。（指针可能存放在寄存器内，所以这一步就已经包括寄存器的全部工作了。）</p>
<p>（2）将指针送往内存管理单元（MMU），由MMU将虚拟的内存地址翻译成实际的物理地址。</p>
<p>（3）将物理地址送往内存控制器（memory controller），由内存控制器找出该地址在哪一根内存插槽（bank）上。</p>
<p>（4）确定数据在哪一个内存块（chunk）上，从该块读取数据。</p>
<p>（5）数据先送回内存控制器，再送回CPU，然后开始使用。</p>
<p>内存的工作流程比寄存器多出许多步。每一步都会产生延迟，累积起来就使得内存比寄存器慢得多。</p>
<p>为了缓解寄存器与内存之间的巨大速度差异，硬件设计师做出了许多努力，包括在CPU内部设置缓存、优化CPU工作方式，尽量一次性从内存读取指令所要用到的全部数据等等。</p>
<h1 id="4-Linux"><a href="#4-Linux" class="headerlink" title="4.Linux"></a>4.Linux</h1><h2 id="线上服务器CPU占用率高如何排查定位问题？"><a href="#线上服务器CPU占用率高如何排查定位问题？" class="headerlink" title="线上服务器CPU占用率高如何排查定位问题？"></a>线上服务器CPU占用率高如何排查定位问题？</h2><p>如果 cpu 很高，但项目的性能却更差了，你会怎么排查？而且还要具体定位到出问题的代码在那里</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&mid=2247485874&idx=1&sn=0edacadb71654e7642832b81d86b6c60&scene=21#wechat_redirect" target="_blank" rel="noopener">参考这篇文章</a></p>
<h1 id="5-数据库"><a href="#5-数据库" class="headerlink" title="5.数据库"></a>5.数据库</h1><h2 id="一条SQL语句执行得很慢的原因有哪些？"><a href="#一条SQL语句执行得很慢的原因有哪些？" class="headerlink" title="一条SQL语句执行得很慢的原因有哪些？"></a>一条SQL语句执行得很慢的原因有哪些？</h2><p>首先说一下总的答案：</p>
<p>一个 SQL 执行的很慢，我们要分两种情况讨论：</p>
<ol>
<li>大多数情况下很正常，偶尔很慢，则有如下原因</li>
</ol>
<p>(1)、数据库在刷新脏页，例如 redo log 写满了需要同步到磁盘。</p>
<p>(2)、执行的时候，遇到锁，如表锁、行锁。</p>
<ol start="2">
<li>这条 SQL 语句一直执行的很慢，则有如下原因。</li>
</ol>
<p>(1)、没有用上索引：例如该字段没有索引；由于对字段进行运算、函数操作导致无法用索引。</p>
<p>(2)、数据库选错了索引(数据库自己预测不使用你的索引能够更快)。主要由于统计失误，导致系统没有走索引，而是走了全表扫描，从而导致某条SQL执行很慢。</p>
<h2 id="什么是数据库的脏读、不可重复读和幻读"><a href="#什么是数据库的脏读、不可重复读和幻读" class="headerlink" title="什么是数据库的脏读、不可重复读和幻读"></a>什么是数据库的脏读、不可重复读和幻读</h2><p>事务的隔离性上，从低到高可能产生的读现象分别是：脏读、不可重复读、幻读。</p>
<p>脏读指读到了未提交的数据。</p>
<p>不可重复读指一次事务内的多次相同查询，读取到了不同的结果。</p>
<p>幻读师不可重复读的特殊场景。一次事务内的多次范围查询得到了不同的结果。</p>
<p>通过在写的时候加锁，可以解决脏读。</p>
<p>通过在读的时候加锁，可以解决不可重复读。</p>
<p>通过串行化，可以解决幻读。</p>
<p>以上这几种解决方案其实是数据库的几种隔离级别。</p>
<h2 id="什么是最左前缀原则？"><a href="#什么是最左前缀原则？" class="headerlink" title="什么是最左前缀原则？"></a>什么是最左前缀原则？</h2><blockquote>
<p>以下回答全部是基于MySQL的InnoDB引擎</p>
</blockquote>
<p>给出一张表作为例子：</p>
<p><img src="https://i.loli.net/2020/03/19/bUCv5cYonpATdFw.png" alt="一个例子.png"></p>
<p>如果我们按照 name 字段来建立索引的话，采用B+树的结构，大概的索引结构如下</p>
<p><img src="https://i.loli.net/2020/03/19/FASYKqlTmbegifL.png" alt="例子索引.png"></p>
<p>如果我们要进行模糊查找，查找name 以“张”开头的所有人的ID，即 sql 语句为</p>
<p><code>select ID from table where name like &#39;张%&#39;</code></p>
<p>由于在B+树结构的索引中，索引项是按照索引定义里面出现的字段顺序排序的，索引在查找的时候，可以快速定位到 ID 为 100的张一，然后直接向右遍历所有张开头的人，直到条件不满足为止。</p>
<p>也就是说，我们找到第一个满足条件的人之后，直接向右遍历就可以了，由于索引是有序的，所有满足条件的人都会聚集在一起。</p>
<p>而这种定位到最左边，然后向右遍历寻找，就是我们所说的<strong>最左前缀原则</strong>。</p>
<h2 id="为什么用-B-树做索引而不用哈希表做索引"><a href="#为什么用-B-树做索引而不用哈希表做索引" class="headerlink" title="为什么用 B+ 树做索引而不用哈希表做索引?"></a>为什么用 B+ 树做索引而不用哈希表做索引?</h2><p>哈希表查找效率是O(1)，二叉树查找效率是O(logn)，那为什么用二叉树不用哈希表呢？</p>
<p>这和业务场景有关。如果只查询一个元素，确实hash表更快，但是数据库经常要选择多条，这时候由于B+树有序，所有value又都保存在叶子节点(操作比B树方便)，而且所有叶子节点都有链表连接，所以效率更高。</p>
<p>1、哈希表是把索引字段映射成对应的哈希码然后再存放在对应的位置，这样的话，如果我们要进行模糊查找的话，显然哈希表这种结构是不支持的，只能遍历这个表。而B+树则可以通过最左前缀原则快速找到对应的数据。</p>
<p>2、如果我们要进行范围查找，例如查找ID为100 ~ 400的人，哈希表同样不支持，只能遍历全表。</p>
<p>3、索引字段通过哈希映射成哈希码，如果很多字段都刚好映射到相同值的哈希码的话，那么形成的索引结构将会是一条很长的链表，这样的话，查找的时间就会大大增加。</p>
<p>4、考虑到磁盘操作，磁盘内存有限，很难保证用哈希表可以一口气全读进去，而B+树支持分批处理，同时树的高度比较低，可以提高查重效率。</p>
<h2 id="主键索引和非主键索引有什么区别？"><a href="#主键索引和非主键索引有什么区别？" class="headerlink" title="主键索引和非主键索引有什么区别？"></a>主键索引和非主键索引有什么区别？</h2><p>例如对于下面这个表(其实就是上面的表中增加了一个k字段),且ID是主键。</p>
<p><img src="https://i.loli.net/2020/03/19/ELdCNXhp75QSmis.png" alt="加了个非主键索引.png"></p>
<p>主键索引和非主键索引的示意图如下：</p>
<p><img src="https://i.loli.net/2020/03/19/6WRaFfuOPVtTJeE.png" alt="主键索引和非主键索引.png"></p>
<p>其中R代表一整行的值。</p>
<p>从图中不难看出，主键索引和非主键索引的区别是：非主键索引的叶子节点存放的是<strong>主键的值</strong>，而主键索引的叶子节点存放的是<strong>整行数据</strong>，其中非主键索引也被称为<strong>二级索引</strong>，而主键索引也被称为<strong>聚簇索引</strong>。</p>
<p>根据这两种结构我们来进行下查询，看看他们在查询上有什么区别。</p>
<ol>
<li><p>如果查询语句是 select * from table where ID = 100,即主键查询的方式，则只需要搜索 ID 这棵 B+树。</p>
</li>
<li><p>如果查询语句是 select * from table where k = 1，即非主键的查询方式，则先搜索k索引树，得到ID=100,再到ID索引树搜索一次，这个过程也被称为回表。</p>
</li>
</ol>
<h2 id="为什么建议使用主键自增的索引？"><a href="#为什么建议使用主键自增的索引？" class="headerlink" title="为什么建议使用主键自增的索引？"></a>为什么建议使用主键自增的索引？</h2><p>对于这颗主键索引的树</p>
<p><img src="https://i.loli.net/2020/03/19/4AOKQ8fG3ipCJZz.png" alt="主键的索引树.png"></p>
<p>如果我们插入 ID = 650 的一行数据，那么直接在最右边插入就可以了</p>
<p><img src="https://i.loli.net/2020/03/19/KIRLVOkxsPr58gz.png" alt="主键的索引树插入数据.png"></p>
<p>但是如果插入的是 ID = 350 的一行数据，由于 B+ 树是有序的，那么需要将下面的叶子节点进行移动，腾出位置来插入 ID = 350 的数据，这样就会比较消耗时间，如果刚好 R4 所在的数据页已经满了，需要进行页分裂操作，这样会更加糟糕。</p>
<p>但是，如果我们的主键是自增的，每次插入的 ID 都会比前面的大，那么我们每次只需要在后面插入就行， 不需要移动位置、分裂等操作，这样可以提高性能。也就是为什么建议使用主键自增的索引。</p>
<h2 id="MyISAM与InnoDB的区别"><a href="#MyISAM与InnoDB的区别" class="headerlink" title="MyISAM与InnoDB的区别"></a>MyISAM与InnoDB的区别</h2><h3 id="1-两者对比"><a href="#1-两者对比" class="headerlink" title="1.两者对比"></a>1.两者对比</h3><ol>
<li><p>count运算上的区别： 因为MyISAM缓存有表meta-data（行数等），因此在做COUNT(*)时对于一个结构很好 的查询是不需要消耗多少资源的。而对于InnoDB来说，则没有这种缓存 </p>
</li>
<li><p>是否支持事务和崩溃后的安全恢复： MyISAM 强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型 更快，但是不提供事务支持。但是InnoDB 提供事务支持事务，外部键等高级数据库功能。 具有事务 (commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。 </p>
</li>
<li><p>是否支持外键： MyISAM不支持，而InnoDB支持。 </p>
</li>
</ol>
<h3 id="2-两者总结"><a href="#2-两者总结" class="headerlink" title="2.两者总结"></a>2.两者总结</h3><p>MyISAM更适合读密集的表，而InnoDB更适合写密集的的表。 在数据库做主从分离的情况下，经常选择MyISAM作 为主库的存储引擎。</p>
<p>一般来说，如果需要事务支持，并且有较高的并发读取频率(MyISAM的表锁的粒度太大，所以当该表写并发量较高 时，要等待的查询就会很多了)，InnoDB是不错的选择。如果你的数据量很大（MyISAM支持压缩特性可以减少磁盘 的空间占用），而且不需要支持事务时，MyISAM是好的选择。 </p>
<h1 id="6-Java相关"><a href="#6-Java相关" class="headerlink" title="6.Java相关"></a>6.Java相关</h1><h2 id="volatile的作用"><a href="#volatile的作用" class="headerlink" title="volatile的作用"></a>volatile的作用</h2><p>两个：保证可见性（这里指主内存与工作内存间的可见性），防止指令重排（指令重排也会导致可见性问题）</p>
<h3 id="什么是可见性？"><a href="#什么是可见性？" class="headerlink" title="什么是可见性？"></a>什么是可见性？</h3><p>意思就是说，在多线程环境下，某个共享变量如果被其中一个线程给修改了，其他线程能够立即知道这个共享变量已经被修改了，当其他线程要读取这个变量的时候，最终会去内存中读取，而不是从自己的工作空间中读取.</p>
<h3 id="如何保证内存可见性？"><a href="#如何保证内存可见性？" class="headerlink" title="如何保证内存可见性？"></a>如何保证内存可见性？</h3><p>答：volatile修饰的变量保证其每个写操作后都更新到主内存，每个读操作都到主内存中更新，具体的话是在JVM层面，在修饰的变量前后加关键字。</p>
<blockquote>
<p>NOTE：Java内存模型规定所有的变量都是存在<strong>(主内存)主存</strong>当中（类似于前面说的物理内存），每个线程都有自己的<strong>工作内存</strong>（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的<strong>工作内存</strong>。</p>
<p>由于java中的每个线程有自己的工作空间，这种工作空间相当于上面所说的高速缓存，因此多个线程在处理一个<strong>共享变量</strong>的时候，就会出现线程安全问题。</p>
<p>所谓共享变量，是能够被多个线程访问到的变量。在java中共享变量包括实例变量，静态变量，数组元素。他们都被存放在堆内存中。</p>
</blockquote>
<h3 id="什么是指令重排？"><a href="#什么是指令重排？" class="headerlink" title="什么是指令重排？"></a>什么是指令重排？</h3><p>当我们把代码写好之后，虚拟机不一定会按照我们写的代码的顺序来执行。例如对于下面的两句代码：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">int</span> b = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>对于这两句代码，你会发现无论是先执行a = 1还是执行b = 2，都不会对a,b最终的值造成影响。所以虚拟机在编译的时候，是有可能把他们进行<strong>重排序</strong>的。</p>
<p>对于这两句代码，你会发现无论是先执行a = 1还是执行b = 2，都不会对a,b最终的值造成影响。所以虚拟机在编译的时候，是有可能把他们进行重排序的。</p>
<p>指令重排是JVM做出的优化，这里Java的双check的单例模式也利用了volatile来保证不重排。</p>
<h3 id="volatile真的能完全保证一个变量的线程安全么？"><a href="#volatile真的能完全保证一个变量的线程安全么？" class="headerlink" title="volatile真的能完全保证一个变量的线程安全么？"></a>volatile真的能完全保证一个变量的线程安全么？</h3><p>volatile好像很有用，不但能够保证变量可见性，还能防止指令重排。</p>
<p>那么，它真的能够保证一个变量在多线程环境下都能被正确的使用吗？</p>
<p>答案是否定的。原因是因为Java里面的运算并非是原子操作，volatile也不能是原子性的。</p>
<h4 id="原子性-原子操作"><a href="#原子性-原子操作" class="headerlink" title="原子性\原子操作"></a>原子性\原子操作</h4><p><strong>原子操作</strong>：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p>
<p>也就是说，处理器要嘛把这组操作全部执行完，中间不允许被其他操作所打断，要嘛这组操作不要执行。</p>
<p>刚才说Java里面的运行并非是原子操作。我举个例子，例如这句代码</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a = b + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>处理器在处理代码的时候，需要处理以下三个操作：</p>
<ol>
<li><p>从内存中读取b的值。</p>
</li>
<li><p>进行a = b + 1这个运算</p>
</li>
<li><p>把a的值写回到内存中</p>
</li>
</ol>
<p>而这三个操作处理器是不一定就会连续执行的，有可能执行了第一个操作之后，处理器就跑去执行别的操作的。</p>
<h3 id="什么情况下volatile可以保证线程安全"><a href="#什么情况下volatile可以保证线程安全" class="headerlink" title="什么情况下volatile可以保证线程安全"></a>什么情况下volatile可以保证线程安全</h3><p>刚才虽然说，volatile关键字不一定能够保证线程安全的问题，其实，在大多数情况下volatile还是可以保证变量的线程安全问题的。所以，在满足以下两个条件的情况下，volatile就能保证变量的线程安全问题：</p>
<ol>
<li><p>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</p>
</li>
<li><p>变量不需要与其他状态变量共同参与不变约束。</p>
</li>
</ol>
<h2 id="搞懂synchronized-从偏量锁到重量级锁"><a href="#搞懂synchronized-从偏量锁到重量级锁" class="headerlink" title="搞懂synchronized(从偏量锁到重量级锁)"></a>搞懂synchronized(从偏量锁到重量级锁)</h2><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&mid=2247485257&idx=1&sn=0ab85e4cd8b575fe5c01b269dda007f5&source=41&scene=21#wechat_redirect" target="_blank" rel="noopener">本部分参考这篇文章</a></p>
<p>接触过线程安全的同学想必都使用过synchronized这个关键字，在java同步代码快中，synchronized的使用方式无非有两个:</p>
<ol>
<li>通过对一个对象进行加锁来实现同步，如下面代码。</li>
</ol>
<p><code>synchronized(lockObject){    //代码}</code></p>
<ol start="2">
<li>对一个方法进行synchronized声明，进而对一个方法进行加锁来实现同步。如下面代码</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> synchornized <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这里需要指出的是，无论是对一个对象进行加锁还是对一个方法进行加锁，实际上，都是对<strong>对象进行加锁</strong>。</p>
<p>也就是说，对于方式2，实际上虚拟机会根据synchronized修饰的是实例方法还是类方法，去取对应的实例对象或者Class对象来进行加锁。</p>
<p>对于synchronized这个关键字，可能之前大家有听过，他是一个重量级锁，开销很大，建议大家少用点。但大家可能也听说过，但到了jdk1.6之后，该关键字被进行了很多的优化，已经不像以前那样不给力了，建议大家多使用。</p>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><h3 id="从synchronized引入"><a href="#从synchronized引入" class="headerlink" title="从synchronized引入"></a>从synchronized引入</h3><p>大家可能都听说说 Java 中的并发包，如果想要读懂 Java 中的并发包，其核心就是要先读懂 CAS 机制，因为 CAS 可以说是并发包的底层实现原理。</p>
<p>CAS能够保证操作的原子性，JDK8也对CAS进行了一些优化。</p>
<p>首先来看synchronized，它很多时候有些大材小用了。</p>
<p>先看几行代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CASTest</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如有100个线程同时调用 increment() 方法对 i 进行自增操作，i 的结果会是 100 吗？</p>
<p>学会多线程的同学应该都知道，这个方法是线程不安全的，由于 i++ 不是<strong>一个原子操作</strong>，所以是很难得到 100 的。</p>
<blockquote>
<p>这里稍微解释下为啥会得不到 100(知道的可直接跳过)， i++ 这个操作，计算机需要分成三步来执行。</p>
<p>1、读取 i 的值。</p>
<p>2、把 i 加 1.</p>
<p>3、把 最终 i 的结果写入内存之中。</p>
<p>所以，（1）、假如线程 A 读取了 i 的值为 i = 0，（2）、这个时候线程 B 也读取了 i 的值 i = 0。（3）、接着 A把 i 加 1，然后写入内存，此时 i = 1。（4）、紧接着，B也把 i 加 1，此时线程B中的 i = 1，然后线程 B 把 i 写入内存，此时内存中的 i = 1。也就是说，线程 A, B 都对 i 进行了自增，但最终的结果却是 1，不是 2.</p>
</blockquote>
<p>解决方法：加锁。比如可以加synchronized锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CASTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加了 synchronized 之后，就最多只能有一个线程能够进入这个 increment() 方法了，保证了线程安全。</p>
<p>然而，一个简简单单的自增操作，就加了 synchronized 进行同步，好像有点大材小用的感觉，加了 synchronized 关键词之后，当有很多线程去竞争 increment 这个方法的时候，拿不到锁的方法是会被阻塞在方法外面的，最后再来唤醒他们，而阻塞/唤醒这些操作，是非常消耗时间的。</p>
<p>更合适的解决方法：CAS</p>
<h3 id="CAS介绍"><a href="#CAS介绍" class="headerlink" title="CAS介绍"></a>CAS介绍</h3><p>大家看一下，如果我采用下面这种方式，能否保证 increment 是线程安全的呢？步骤如下：</p>
<p>1、线程从内存中读取 i 的值，假如此时 i 的值为 0，我们把这个值称为 k 吧，即此时 k = 0。</p>
<p>2、令 j = k + 1。</p>
<p>3、用 k 的值与内存中i的值相比，如果相等，这意味着没有其他线程修改过 i 的值，我们就把 j（此时为1） 的值写入内存；如果不相等（意味着i的值被其他线程修改过），我们就不把j的值写入内存，而是重新跳回步骤 1，继续这三个操作。</p>
<p>翻译成代码的话就是这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = i;</span><br><span class="line">        <span class="keyword">int</span> j = k + <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">while</span> (compareAndSet(i, k, j))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你去模拟一下，就会发现，这样写是线程安全的。</p>
<p>这里可能有人会说，第三步的 compareAndSet 这个操作不仅要读取内存，还干了比较、写入内存等操作，，，这一步本身就是线程不安全的啊？</p>
<p>如果你能想到这个，说明你是真的有去思考、模拟这个过程，不过我想要告诉你的是，这个 compareAndSet 操作，他其实只对应操作系统的一条硬件操作指令，尽管看似有很多操作在里面，但操作系统能够保证他是原子执行的。</p>
<p>对于一条英文单词很长的指令，我们都喜欢用它的简称来称呼他，所以，我们就把 compareAndSet 称为 CAS 吧。</p>
<p><strong>所以，采用 CAS 这种机制的写法也是线程安全的</strong>，通过这种方式，可以说是不存在锁的竞争，也不存在阻塞等事情的发生，可以让程序执行的更好。</p>
<p>在 Java 中，也是提供了这种 CAS 的原子类，例如：</p>
<p>AtomicBoolean</p>
<p>AtomicInteger</p>
<p>AtomicLong</p>
<p>AtomicReference</p>
<p>具体如何使用呢？我就以上面那个例子进行改版吧，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CASTest</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> AtomicInteger i = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 自增 1并返回之后的结果</span></span><br><span class="line">        i.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是又会有一个问题，就是如果函数的操作返回的就是和原来传入的值相同的值，那线程A可能认为B还没执行完。</p>
<p>举个例子：当线程A即将要执行第三步的时候，线程 B 把 i 的值加1，之后又马上把 i 的值减 1，然后，线程 A 执行第三步，这个时候线程 A 是认为并没有人修改过 i 的值，因为 i 的值并没有发生改变。而这，就是我们平常说的<strong>ABA问题</strong>。</p>
<p>对于基本类型的值来说，这种把数字改变了在改回原来的值是没有太大影响的，但如果是对于<strong>引用类型</strong>的话，就会产生很大的影响了。</p>
<p>解决方法：版本控制。</p>
<p>例如，每次有线程修改了引用的值，就会进行版本的更新，虽然两个线程持有相同的引用，但他们的版本不同，这样，我们就可以预防 ABA 问题了。Java 中提供了 AtomicStampedReference 这个类，就可以进行版本控制了。</p>
<h3 id="JDK8对CAS的优化"><a href="#JDK8对CAS的优化" class="headerlink" title="JDK8对CAS的优化"></a>JDK8对CAS的优化</h3><p>由于采用这种 CAS 机制是没有对方法进行加锁的，所以，所有的线程都可以进入 increment() 这个方法，假如进入这个方法的线程太多，就会出现一个问题：每次有线程要执行第三个步骤的时候，i 的值老是被修改了，所以线程又到回到第一步继续重头再来。</p>
<p>而这就会导致一个问题：由于线程太密集了，太多人想要修改 i 的值了，进而大部分人都会修改不成功，白白着在那里循环消耗资源。</p>
<p>为了解决这个问题，Java8 引入了一个 cell[] 数组，它的工作机制是这样的：假如有 5 个线程要对 i  进行自增操作，由于 5 个线程的话，不是很多，起冲突的几率较小，那就让他们按照以往正常的那样，采用 CAS 来自增吧。</p>
<p>但是，如果有 100 个线程要对 i 进行自增操作的话，这个时候，冲突就会大大增加，系统就会把这些线程分配到不同的 cell 数组元素去，假如 cell[10] 有 10 个元素吧，且元素的初始化值为 0，那么系统就会把 100 个线程分成 10 组，每一组对 cell 数组其中的一个元素做自增操作，这样到最后，cell 数组 10 个元素的值都为 10，系统在把这 10 个元素的值进行汇总，进而得到 100，二这，就等价于 100 个线程对 i 进行了 100 次自增操作。</p>
<h2 id="Java垃圾回收机制"><a href="#Java垃圾回收机制" class="headerlink" title="Java垃圾回收机制"></a>Java垃圾回收机制</h2>
    </div>


    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Interview/" rel="tag"><i class="fa fa-tag"></i># Interview</a>
              <a href="/tags/Intergrated/" rel="tag"><i class="fa fa-tag"></i># Intergrated</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/03/20/List-Map-Analysis/" rel="prev" title="List-Map-Analysis">
      <i class="fa fa-chevron-left"></i> List-Map-Analysis
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC80ODAxMC8yNDUwNw=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-计算机网络"><span class="nav-text">1.计算机网络</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-HTTPS和HTTP"><span class="nav-text">1.1 HTTPS和HTTP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#对称加密-Symmetric-encryption-和非对称加密-Asymmetric-encryption"><span class="nav-text">对称加密(Symmetric encryption)和非对称加密(Asymmetric encryption)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#对称加密"><span class="nav-text">对称加密</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#非对称加密"><span class="nav-text">非对称加密</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数字证书"><span class="nav-text">数字证书</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CA的公钥如何拿给客户端？服务器如何获得CA私钥？"><span class="nav-text">CA的公钥如何拿给客户端？服务器如何获得CA私钥？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数字签名"><span class="nav-text">数字签名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SSL-TLS协议"><span class="nav-text">SSL&#x2F;TLS协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP状态码？-1开头到5开头的各种典型状态码"><span class="nav-text">HTTP状态码？(1开头到5开头的各种典型状态码)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一些可能有用的与HTTP有关的协议"><span class="nav-text">一些可能有用的与HTTP有关的协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CDN"><span class="nav-text">CDN</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-IP"><span class="nav-text">TCP&#x2F;IP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DNS"><span class="nav-text">DNS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#URI-URL"><span class="nav-text">URI&#x2F;URL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTPS"><span class="nav-text">HTTPS</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#输入一个URL之后，整个请求过程是怎样的？"><span class="nav-text">输入一个URL之后，整个请求过程是怎样的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GET和POST报文形式"><span class="nav-text">GET和POST报文形式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GET和POST的区别"><span class="nav-text">GET和POST的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#255-255-255-255和0-0-0-0的作用"><span class="nav-text">255.255.255.255和0.0.0.0的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP和UDP区别以及各自适用场景"><span class="nav-text">TCP和UDP区别以及各自适用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP流量控制"><span class="nav-text">TCP流量控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP拥塞机制"><span class="nav-text">TCP拥塞机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#选择重传协议-SR-——可靠性传输协议中的一个"><span class="nav-text">选择重传协议(SR)——可靠性传输协议中的一个</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP三次握手"><span class="nav-text">TCP三次握手</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP三次握手涉及的问题"><span class="nav-text">TCP三次握手涉及的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-三次握手的作用"><span class="nav-text">1.三次握手的作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-seq-ISN-是固定的么"><span class="nav-text">2.seq(ISN)是固定的么</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-什么是半连接队列"><span class="nav-text">3.什么是半连接队列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-三次握手过程中可以携带数据吗"><span class="nav-text">4.三次握手过程中可以携带数据吗</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-第一次握手时可能会出现SYN超时的问题——针对SYN-Flood的防护措施"><span class="nav-text">5.第一次握手时可能会出现SYN超时的问题——针对SYN Flood的防护措施</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP四次挥手"><span class="nav-text">TCP四次挥手</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP四次挥手涉及的问题"><span class="nav-text">TCP四次挥手涉及的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-为什么客户端在最后要有2MSL的等待时间，即为什么要有TIME-WAIT时间？"><span class="nav-text">1.为什么客户端在最后要有2MSL的等待时间，即为什么要有TIME_WAIT时间？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-四次挥手过程中大量Socket处在TIME-WAIT和CLOSE-WAIT状态，该如何解决？"><span class="nav-text">2.四次挥手过程中大量Socket处在TIME_WAIT和CLOSE_WAIT状态，该如何解决？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一些状态的含义"><span class="nav-text">一些状态的含义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-cookie和session的区别"><span class="nav-text">1.2 cookie和session的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP、TCP、UDP、IP、ICMP、DNS、FTP等协议分别处于哪层？"><span class="nav-text">HTTP、TCP、UDP、IP、ICMP、DNS、FTP等协议分别处于哪层？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ping指令用的什么协议？在哪一层？"><span class="nav-text">Ping指令用的什么协议？在哪一层？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ARP协议的作用？"><span class="nav-text">ARP协议的作用？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是ARP协议？"><span class="nav-text">什么是ARP协议？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么要有ARP协议？"><span class="nav-text">为什么要有ARP协议？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#路由器和交换机的区别？"><span class="nav-text">路由器和交换机的区别？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-操作系统"><span class="nav-text">2.操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#进程与线程的区别"><span class="nav-text">进程与线程的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程间通信方式-IPC-Inter-Process-Communication"><span class="nav-text">进程间通信方式(IPC, Inter Process Communication)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文件"><span class="nav-text">文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#管道-命名管道"><span class="nav-text">管道&#x2F;命名管道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Signal"><span class="nav-text">Signal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#共享内存"><span class="nav-text">共享内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息队列"><span class="nav-text">消息队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#同步机制，如信号量-semaphore"><span class="nav-text">同步机制，如信号量(semaphore)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Socket"><span class="nav-text">Socket</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#经典进程调度算法"><span class="nav-text">经典进程调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-批处理时代"><span class="nav-text">1.批处理时代</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-FCFS-先来先服务"><span class="nav-text">1.FCFS(先来先服务)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-SPN-段任务优先"><span class="nav-text">2.SPN(段任务优先)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-HARRN-高响应比优先"><span class="nav-text">3.HARRN(高响应比优先)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-并发时代"><span class="nav-text">2.并发时代</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-RR-时间片轮转算法"><span class="nav-text">1.RR(时间片轮转算法)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-VRR-虚拟轮转法"><span class="nav-text">2.VRR(虚拟轮转法)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-优先级调度"><span class="nav-text">3.优先级调度</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#互斥"><span class="nav-text">互斥</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#锁-重量级锁、自旋锁、轻量级锁、偏向锁、悲观、乐观锁等"><span class="nav-text">锁(重量级锁、自旋锁、轻量级锁、偏向锁、悲观、乐观锁等)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#重量级锁"><span class="nav-text">重量级锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自旋锁"><span class="nav-text">自旋锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自适应自旋锁"><span class="nav-text">自适应自旋锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#轻量级锁"><span class="nav-text">轻量级锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#偏向锁"><span class="nav-text">偏向锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#乐观锁和悲观锁"><span class="nav-text">乐观锁和悲观锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结"><span class="nav-text">小结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-计算机组成原理"><span class="nav-text">3.计算机组成原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么寄存器比内存快？"><span class="nav-text">为什么寄存器比内存快？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-Linux"><span class="nav-text">4.Linux</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#线上服务器CPU占用率高如何排查定位问题？"><span class="nav-text">线上服务器CPU占用率高如何排查定位问题？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-数据库"><span class="nav-text">5.数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一条SQL语句执行得很慢的原因有哪些？"><span class="nav-text">一条SQL语句执行得很慢的原因有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是数据库的脏读、不可重复读和幻读"><span class="nav-text">什么是数据库的脏读、不可重复读和幻读</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是最左前缀原则？"><span class="nav-text">什么是最左前缀原则？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么用-B-树做索引而不用哈希表做索引"><span class="nav-text">为什么用 B+ 树做索引而不用哈希表做索引?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#主键索引和非主键索引有什么区别？"><span class="nav-text">主键索引和非主键索引有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么建议使用主键自增的索引？"><span class="nav-text">为什么建议使用主键自增的索引？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MyISAM与InnoDB的区别"><span class="nav-text">MyISAM与InnoDB的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-两者对比"><span class="nav-text">1.两者对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-两者总结"><span class="nav-text">2.两者总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-Java相关"><span class="nav-text">6.Java相关</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile的作用"><span class="nav-text">volatile的作用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是可见性？"><span class="nav-text">什么是可见性？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何保证内存可见性？"><span class="nav-text">如何保证内存可见性？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是指令重排？"><span class="nav-text">什么是指令重排？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile真的能完全保证一个变量的线程安全么？"><span class="nav-text">volatile真的能完全保证一个变量的线程安全么？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#原子性-原子操作"><span class="nav-text">原子性\原子操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么情况下volatile可以保证线程安全"><span class="nav-text">什么情况下volatile可以保证线程安全</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#搞懂synchronized-从偏量锁到重量级锁"><span class="nav-text">搞懂synchronized(从偏量锁到重量级锁)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CAS"><span class="nav-text">CAS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#从synchronized引入"><span class="nav-text">从synchronized引入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CAS介绍"><span class="nav-text">CAS介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK8对CAS的优化"><span class="nav-text">JDK8对CAS的优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java垃圾回收机制"><span class="nav-text">Java垃圾回收机制</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Wang Mingsheng"
      src="/images/faceimage.jpg">
  <p class="site-author-name" itemprop="name">Wang Mingsheng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wmsheng" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wmsheng" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:wangmingshenghku@163.com" title="E-Mail → mailto:wangmingshenghku@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://music.163.com/#/my/m/music/playlist?id=372605964" title="Music → https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;my&#x2F;m&#x2F;music&#x2F;playlist?id&#x3D;372605964" rel="noopener" target="_blank"><i class="fa fa-fw fa-youtube"></i>Music</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>


    </div>
    
    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=3314336&auto=1&height=66">
    </iframe>

  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wang Mingsheng</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">320k</span>
</div>


<div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_uv">
    本站访客数:<span id="busuanzi_value_site_uv"></span>
  </span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_pv">
    本站访问量<span id="busuanzi_value_site_pv"></span>
  </span>
</div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共159.6k字</span>
</div>

        
<div class="busuanzi-count">
  <script pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.getAttribute('pjax') !== null) {
      element.setAttribute('pjax', '');
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

    </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/clicklove.js"></script>
