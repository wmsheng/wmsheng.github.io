<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/siyecao.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/siyecao.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","padding":18,"offset":12,"onmobile":false,"b2t":true,"scrollpercent":true},
    copycode: {"enable":true,"show_result":true,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="知识犹如人体的血液一样宝贵。——高士其">
<meta property="og:type" content="article">
<meta property="og:title" content="Computer fundamental Intergrated Interview-I">
<meta property="og:url" content="http://yoursite.com/2020/03/20/Computer-fundamental-Interview-I/index.html">
<meta property="og:site_name" content="Hi, This is Bennett">
<meta property="og:description" content="知识犹如人体的血液一样宝贵。——高士其">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2020/03/18/G9r3NBHycJA5Cts.png">
<meta property="og:image" content="https://i.loli.net/2020/03/18/Wspjk3vbEQzdScf.png">
<meta property="og:image" content="https://i.loli.net/2020/03/18/uoacZHrNE1MUzmF.png">
<meta property="og:image" content="https://i.loli.net/2020/03/18/sCcTNa9eULfPwpI.png">
<meta property="og:image" content="https://i.loli.net/2020/03/18/p96xDFSVn3YXCUj.png">
<meta property="og:image" content="https://i.loli.net/2020/03/18/tZbqOCITSged1z8.png">
<meta property="og:image" content="https://i.loli.net/2020/03/18/xDHKZlhciMgfdNG.png">
<meta property="og:image" content="https://i.loli.net/2020/03/18/nUXIerAGEjt1Fbo.png">
<meta property="og:image" content="https://s2.ax1x.com/2020/02/28/30Hs3D.png">
<meta property="og:image" content="https://i.loli.net/2020/03/19/5B9UPNkcjZohXAv.png">
<meta property="og:image" content="https://i.loli.net/2020/03/19/7DTeEOArayKsWFn.png">
<meta property="og:image" content="https://i.loli.net/2020/03/19/9tAPyYbSXFT5qJj.png">
<meta property="og:image" content="https://i.loli.net/2020/03/19/JsDdO4mzlA1BijR.png">
<meta property="og:image" content="https://i.loli.net/2020/03/19/Ixpo25YevyRhL3M.png">
<meta property="og:image" content="https://i.loli.net/2020/03/19/AdSc4CEVvQkrDIa.png">
<meta property="og:image" content="https://i.loli.net/2020/03/19/qgGjK9ilPIpLAZo.png">
<meta property="og:image" content="https://i.loli.net/2020/03/20/MsaHLzIjCUAVh9O.png">
<meta property="og:image" content="https://i.loli.net/2020/03/12/Lja9iFcHx2hubp8.jpg">
<meta property="og:image" content="https://i.loli.net/2020/03/12/P76skMIGWAO3Ntv.jpg">
<meta property="og:image" content="https://i.loli.net/2020/03/19/bUCv5cYonpATdFw.png">
<meta property="og:image" content="https://i.loli.net/2020/03/19/FASYKqlTmbegifL.png">
<meta property="og:image" content="https://i.loli.net/2020/03/19/ELdCNXhp75QSmis.png">
<meta property="og:image" content="https://i.loli.net/2020/03/19/6WRaFfuOPVtTJeE.png">
<meta property="og:image" content="https://i.loli.net/2020/03/19/4AOKQ8fG3ipCJZz.png">
<meta property="og:image" content="https://i.loli.net/2020/03/19/KIRLVOkxsPr58gz.png">
<meta property="og:image" content="https://i.loli.net/2020/03/26/a7vAHYK6h23Xf5L.png">
<meta property="og:image" content="https://i.loli.net/2020/03/27/z48VkDrqOcN9Yug.png">
<meta property="og:image" content="https://i.loli.net/2020/03/29/uXlKdG83SJTmHCp.png">
<meta property="og:image" content="https://i.loli.net/2020/03/28/RkuhOC931cYBSsw.png">
<meta property="og:image" content="https://i.loli.net/2020/03/28/MhosgzRn3EPIxtp.png">
<meta property="og:image" content="https://i.loli.net/2020/03/28/kWu9vcZ5AILjNQm.png">
<meta property="og:image" content="https://i.loli.net/2020/03/28/fUSMYGbVAux1LH7.png">
<meta property="og:image" content="https://i.loli.net/2020/03/29/lX7uBNwA6s2gUeQ.png">
<meta property="og:image" content="https://i.loli.net/2020/03/28/WQbFa9Iy8kgzjDi.png">
<meta property="og:image" content="https://i.loli.net/2020/03/29/FdK93NT78n5U2lb.png">
<meta property="og:image" content="https://i.loli.net/2020/03/30/PnzieOJcNX8mB24.png">
<meta property="og:image" content="https://i.loli.net/2020/03/30/LeThwqHWSBGvtzX.png">
<meta property="article:published_time" content="2020-03-20T04:36:36.000Z">
<meta property="article:modified_time" content="2020-04-02T00:41:33.040Z">
<meta property="article:author" content="Wang Mingsheng">
<meta property="article:tag" content="Interview">
<meta property="article:tag" content="Intergrated">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/03/18/G9r3NBHycJA5Cts.png">

<link rel="canonical" href="http://yoursite.com/2020/03/20/Computer-fundamental-Interview-I/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Computer fundamental Intergrated Interview-I | Hi, This is Bennett</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hi, This is Bennett</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags<span class="badge">28</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories<span class="badge">4</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives<span class="badge">34</span></a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/20/Computer-fundamental-Interview-I/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/faceimage.jpg">
      <meta itemprop="name" content="Wang Mingsheng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hi, This is Bennett">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Computer fundamental Intergrated Interview-I
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-20 12:36:36" itemprop="dateCreated datePublished" datetime="2020-03-20T12:36:36+08:00">2020-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-02 08:41:33" itemprop="dateModified" datetime="2020-04-02T08:41:33+08:00">2020-04-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Interview-Note/" itemprop="url" rel="index">
                    <span itemprop="name">Interview Note</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              
              <span>53k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>知识犹如人体的血液一样宝贵。——高士其</p>
</blockquote>
<a id="more"></a>


<p>其他精彩文章：<a href="https://www.jianshu.com/p/a61f012e84d5" target="_blank" rel="noopener">20+公司面试题总结及补充</a></p>
<h1 id="1-计算机网络"><a href="#1-计算机网络" class="headerlink" title="1.计算机网络"></a>1.计算机网络</h1><h2 id="1-1-HTTPS和HTTP"><a href="#1-1-HTTPS和HTTP" class="headerlink" title="1.1 HTTPS和HTTP"></a>1.1 HTTPS和HTTP</h2><p>HTTP是明文传输，不安全。HTTPS是加密之后的传输方式。</p>
<p>要弄清，先理解对称加密和非对称加密。</p>
<h3 id="对称加密-Symmetric-encryption-和非对称加密-Asymmetric-encryption"><a href="#对称加密-Symmetric-encryption-和非对称加密-Asymmetric-encryption" class="headerlink" title="对称加密(Symmetric encryption)和非对称加密(Asymmetric encryption)"></a>对称加密(Symmetric encryption)和非对称加密(Asymmetric encryption)</h3><h4 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h4><p>对称加密：在每次发送真实数据之前，服务器先生成一把密钥，然后先把密钥传输给客户端。之后服务器给客户端发送真实数据的时候，会用这把密钥对数据进行加密，客户端收到加密数据之后，用刚才收到的密钥进行解密。</p>
<p>如图：</p>
<p><img src="https://i.loli.net/2020/03/18/G9r3NBHycJA5Cts.png" alt="对称加密.png"></p>
<p>这里只画了服务器传送数据给客户端的情况，暂时只考虑这个单向，其实是一样的。</p>
<p>但是这里有一个<strong>致命</strong>的问题，就是秘钥在传输过程中会是以明文方式传输的，在传输过程中可能被拦截。(这也是二战时期图灵能够破解德军军情的原因)</p>
<p>具体来说：假如服务器用明文的方式传输密钥给客户端，然后密钥被中间人给捕获了，那么在之后服务器和客户端的加密传输过程中，中间人也可以用他捕获的密钥进行解密。这样的话，加密的数据在中间人看来和明文没啥两样。</p>
<p>所以对称加密的问题出在<strong>如何把秘钥安全地给客户端</strong>。</p>
<h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><p>让客户端和服务器都拥有两把钥匙，一个用来加密(公钥)，一个用来解密(私钥)。这两把钥匙一般都会用RSA Algorithm来生成。在通信之前不需要先同步秘钥，避免了在同步私钥过程中被黑客盗取信息的风险。</p>
<p>一把钥匙是公开的(全世界知道都没关系)，我们称之为<strong>公钥</strong>；另一把钥匙则是保密的(只有自己本人才知道)，我们称之为<strong>私钥</strong>。</p>
<p>虽然有一点违反常识，但是非对称加密能够做到：用公钥加密的原文，原公钥无法解密，只能用对应的私钥解密。</p>
<p>可以通过私钥计算出公钥，但是无法用公钥推导出私钥。</p>
<p>这且，<strong>用公钥加密的数据，只有<font color=#FF0000>对应的私钥</font>才能解密；用私钥加密的数据，只有<font color=#FF0000>对应的公钥</font>才能解密</strong>。</p>
<p>按照这个思路，服务器在给客户端传输数据的过程中，可以用客户端明文给他的公钥进行加密，然后客户端收到后，再用自己的私钥进行解密。客户端给服务器发送数据的时候也一样采取这样的方式。这样就能保持数据的安全传输了。</p>
<p>图解如下：</p>
<p><img src="https://i.loli.net/2020/03/18/Wspjk3vbEQzdScf.png" alt="非对称加密.png"></p>
<p>但是非对称加密在加密的时候速度比对称加密慢上百倍，所以直接用非对称加密的话效率很低。</p>
<p>因为对称加密不安全的主要原因是密钥无法安全交付给客户端，所以我们可以用非对称加密的方式传输加密过程中的密钥，之后我们就可以采取对称加密的方式来传输数据了。</p>
<p>具体做法：服务器用明文的方式给客户端发送自己的公钥，客户端收到公钥之后，会生成一把密钥(对称加密用的)，然后用服务器的公钥对这把密钥进行加密，之后再把密钥传输给服务器，服务器收到之后进行解密，最后服务器就可以安全着得到这把密钥了，而客户端也有同样一把密钥，他们就可以进行对称加密了。</p>
<p>但是非对称加密也不能保证安全，举个例子：</p>
<p>服务器以明文的方式给客户端传输公钥的时候，中间人截取了这把属于服务器的公钥，并且把<strong>中间人自己的公钥冒充服务器的公钥</strong>传输给了客户端。</p>
<p>之后客户端就会用中间人的公钥来加密自己生成的密钥。然后把被加密的密钥传输给服务器，这个时候中间人又<strong>把密钥给截取了</strong>，中间人用自己的私钥对这把被加密的密钥进行解密，解密后中间人就可以获得这把密钥了。</p>
<p>最后中间人再对这把密钥用刚才服务器的公钥进行加密，再发给服务器。如图：</p>
<p><img src="https://i.loli.net/2020/03/18/uoacZHrNE1MUzmF.png" alt="非对称加密的不安全性.png"></p>
<p>在这个过程中，中间人获取了对称加密中的密钥，在之后服务器和客户端的对称加密传输中，这些加密的数据对中间人来说，和明文没啥区别。</p>
<p>具体说来，非对称加密的不安全的原因主要是客户端不知道这把公钥是不是属于服务器的。</p>
<p>解决方法：数字证书。</p>
<h4 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h4><p>之所以非对称加密会不安全，是因为客户端不知道这把公钥是否是服务器的，因此，我们需要找到一种策略来证明这把公钥就是服务器的，而不是别人冒充的。</p>
<p>解决这个问题的方式就是使用数字证书，具体是这样的：</p>
<p>我们需要找到一个拥有公信力、大家都认可的认证中心(CA)。</p>
<p>服务器在给客户端传输公钥的过程中，会把公钥以及服务器的个人信息通过Hash算法生成信息摘要。</p>
<p>如图：</p>
<p><img src="https://i.loli.net/2020/03/18/sCcTNa9eULfPwpI.png" alt="服务器生成信息摘要.png"></p>
<p>为了防止信息摘要被调换，CA会提供私钥给服务器，服务器会用这个CA给的私钥来加密得到<strong>数字签名</strong>。</p>
<p>如图：</p>
<p><img src="https://i.loli.net/2020/03/18/p96xDFSVn3YXCUj.png" alt="服务器生成数字签名.png"></p>
<p>在生成了数字签名之后，服务端会把所有信息合成在一起，成为<strong>数字证书</strong>。</p>
<p><img src="https://i.loli.net/2020/03/18/tZbqOCITSged1z8.png" alt="合成数字签名等内容为数字证书.png"></p>
<p>客户端拿到证书之后，为了确认发送者确实是服务端，会利用CA给的公钥来对数字证书里面的数字签名进行解密来得到<strong>信息摘要</strong>，然后对数字证书里服务器的公钥以及个人信息进行Hash得到<strong>另外一份信息摘要</strong>，最后比较两者，相同，才能确认这份证书是服务端发送的，否则很可能被人动过手脚。</p>
<p><img src="https://i.loli.net/2020/03/18/xDHKZlhciMgfdNG.png" alt="客户端进行解析对比.png"></p>
<p>由此，可以保证服务器的公钥安全地交给了客户端。</p>
<h4 id="CA的公钥如何拿给客户端？服务器如何获得CA私钥？"><a href="#CA的公钥如何拿给客户端？服务器如何获得CA私钥？" class="headerlink" title="CA的公钥如何拿给客户端？服务器如何获得CA私钥？"></a>CA的公钥如何拿给客户端？服务器如何获得CA私钥？</h4><p>服务器一开始会向CA申请特定私钥。客户端很多浏览器都支持HTTPS方式，也都申请了证书。</p>
<p>更加形象的讲解内容可以参考<a href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&mid=2247485749&idx=1&sn=77f79a358ed59fd45f9b9dab68cfa34c&scene=21#wechat_redirect" target="_blank" rel="noopener">什么是数字签名</a></p>
<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>数字签名详解，参考<a href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&mid=2247485749&idx=1&sn=77f79a358ed59fd45f9b9dab68cfa34c&scene=21#wechat_redirect" target="_blank" rel="noopener">这篇文章</a></p>
<h3 id="SSL-TLS协议"><a href="#SSL-TLS协议" class="headerlink" title="SSL/TLS协议"></a>SSL/TLS协议</h3><p>SSL 即安全套接字层，它在 OSI 七层网络模型中处于第五层(网络层)</p>
<p>TLS 用于两个通信应用程序之间提供保密性和数据完整性。TLS 由记录协议、握手协议、警告协议、变更密码规范协议、扩展协议等几个子协议组成，综合使用了对称加密、非对称加密、身份认证等许多密码学前沿技术。</p>
<p>TLS 在根本上使用对称加密和 非对称加密 两种形式。</p>
<p>HTTPS在使用SSL/TLS传输的过程中，先会用非对称加密，然后用对称加密，也就是所谓的<strong>混合加密</strong>。</p>
<p>实际上混合加密在上面，优化非对称加密传输的过程中已经有详细介绍了。因为非对称加密算法(比如RSA)计算非常慢，而对称加密算法(比如AES)计算相对非对称快上一百倍，所以先用非对称加密算法，先用非对称加密解决<strong>秘钥交换</strong>的问题，然后用随机数产生对称算法使用的<code>会话密钥（session key）</code>，再用<code>公钥加密</code>。对方拿到密文后用<code>私钥解密</code>，取出会话密钥。这样，双方就实现了对称密钥的安全交换。</p>
<h3 id="HTTP状态码？-1开头到5开头的各种典型状态码"><a href="#HTTP状态码？-1开头到5开头的各种典型状态码" class="headerlink" title="HTTP状态码？(1开头到5开头的各种典型状态码)"></a>HTTP状态码？(1开头到5开头的各种典型状态码)</h3><p>客户端的每一次请求，服务器都必须给出回应。回应包括 HTTP 状态码和数据两部分。</p>
<p>HTTP 状态码就是一个三位数，一共有五种取值可能：</p>
<ul>
<li>1xx：指示信息——表示请求已经接收，继续处理，<font color=#FF0000>但是整个请求还没成功</font></li>
<li>2xx：成功——表示请求已被成功接收、理解、接受，已经成功处理了请求的状态代码</li>
<li>3xx：重定向——要完成请求，但是需要进一步操作(往往要再跳转一步)</li>
<li>4xx：客户端错误——请求有语法错误或请求无法实现</li>
<li>5xx：服务器错误——服务器未能实现合法的请求，表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求的错误。</li>
</ul>
<p>常见HTTP状态码及其作用：</p>
<p>200 OK：正常返回信息</p>
<p>400 Bad Request：客户端请求有语法错误，不能被服务器所理解</p>
<p>401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用</p>
<p>403 Forbidden：服务器收到请求，但拒绝提供服务(比如IP被禁了)</p>
<p>404 Note Found：请求资源不存在，eg.输入了错误的URL</p>
<p>500 Internal Server Error：服务器发生不可预期的错误</p>
<p>503 Server Unabaliable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常</p>
<h3 id="一些可能有用的与HTTP有关的协议"><a href="#一些可能有用的与HTTP有关的协议" class="headerlink" title="一些可能有用的与HTTP有关的协议"></a>一些可能有用的与HTTP有关的协议</h3><p>在互联网中，任何协议都不会单独的完成信息交换，HTTP 也一样。虽然 HTTP 属于应用层的协议，但是它仍然需要其他层次协议的配合完成信息的交换，那么在完成一次 HTTP 请求和响应的过程中，需要哪些协议的配合呢？一起来看一下</p>
<h4 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h4><p>CDN的全称是<code>Content Delivery Network</code>，即<code>内容分发网络</code>，它应用了 HTTP 协议里的缓存和代理技术，代替源站响应客户端的请求。CDN 是构建在现有网络基础之上的网络，它依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有<code>内容存储</code>和<code>分发技术</code>。</p>
<p>打比方说你要去亚马逊上买书，之前你只能通过购物网站购买后从美国发货过海关等重重关卡送到你的家里，现在在中国建立一个亚马逊分基地，你就不用通过美国进行邮寄，从中国就能把书尽快给你送到。</p>
<h4 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h4><p>TCP/IP 我们一般称之为协议簇，什么意思呢？就是 TCP/IP 协议簇中不仅仅只有 TCP 协议和 IP 协议，它是一系列网络通信协议的统称。而其中最核心的两个协议就是 TCP / IP 协议，其他的还有 UDP、ICMP、ARP 等等，共同构成了一个复杂但有层次的协议栈。</p>
<p><font color=#FF0000>HTTP 使用 TCP 作为通信协议</font>，这是因为 TCP 是一种可靠的协议，而可靠能保证数据不丢失。</p>
<h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>计算机网络中的每个端系统都有一个 IP 地址存在，而把 IP 地址转换为便于人类记忆的协议就是 DNS 协议。</p>
<p>DNS 的全称是域名系统<code>（Domain Name System，缩写：DNS）</code>，它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。</p>
<h4 id="URI-URL"><a href="#URI-URL" class="headerlink" title="URI/URL"></a>URI/URL</h4><p>我们上面提到，你可以通过输入 <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> 地址来访问谷歌的官网，那么这个地址有什么规定吗？我怎么输都可以？AAA.BBB.CCC 是不是也行？当然不是的，你输入的地址格式必须要满足 URI 的规范。</p>
<p>URI的全称是（Uniform Resource Identifier），中文名称是统一资源标识符，使用它就能够唯一地标记互联网上资源。</p>
<p>URL的全称是（Uniform Resource Locator），中文名称是统一资源定位符，也就是我们俗称的网址，它实际上是 URI 的一个子集。</p>
<p>URI 不仅包括 URL，还包括 URN（统一资源名称），它们之间的关系如下</p>
<p><img src="https://i.loli.net/2020/03/18/nUXIerAGEjt1Fbo.png" alt="URLURI示意图.png"></p>
<h4 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h4><p>之前讲了很多了，重点是HTTPS和HTTP的区别：</p>
<p>HTTPS 和 HTTP 有很大的不同在于 HTTPS 是以安全为目标的 HTTP 通道，在 HTTP 的基础上通过传输加密和身份认证保证了传输过程的安全性。HTTPS 在 HTTP 的基础上增加了 SSL 层，也就是说 HTTPS = HTTP + SSL</p>
<h3 id="输入一个URL之后，整个请求过程是怎样的？"><a href="#输入一个URL之后，整个请求过程是怎样的？" class="headerlink" title="输入一个URL之后，整个请求过程是怎样的？"></a>输入一个URL之后，整个请求过程是怎样的？</h3><p>举例，访问地址为 <a href="http://www.someSchool.edu/someDepartment/home.index" target="_blank" rel="noopener">http://www.someSchool.edu/someDepartment/home.index</a></p>
<p>一共六步</p>
<ol>
<li>DNS服务器会首先进行域名的映射，找到访问<a href="http://www.someSchool.edu所在的地址，然后HTTP" target="_blank" rel="noopener">www.someSchool.edu所在的地址，然后HTTP</a> 客户端进程在 80 端口发起一个到服务器 <a href="http://www.someSchool.edu" target="_blank" rel="noopener">www.someSchool.edu</a> 的 TCP 连接（80 端口是 HTTP 的默认端口）。在客户和服务器进程中都会有一个套接字与其相连。</li>
<li>HTTP 客户端通过它的套接字向服务器发送一个 HTTP 请求报文。该报文中包含了路径 someDepartment/home.index 的资源，我们后面会详细讨论 HTTP 请求报文。</li>
<li>HTTP 服务器通过它的套接字接受该报文，进行请求的解析工作，并从其存储器(RAM 或磁盘)中检索出对象 <a href="http://www.someSchool.edu/someDepartment/home.index，然后把检索出来的对象进行封装，封装到" target="_blank" rel="noopener">www.someSchool.edu/someDepartment/home.index，然后把检索出来的对象进行封装，封装到</a> HTTP 响应报文中，并通过套接字向客户进行发送。</li>
<li>HTTP 服务器随即通知 TCP 断开 TCP 连接，实际上是需要等到客户接受完响应报文后才会断开 TCP 连接。</li>
<li>HTTP 客户端接受完响应报文后，TCP 连接会关闭。HTTP 客户端从响应中提取出报文中是一个 HTML 响应文件，并检查该 HTML 文件，然后循环检查报文中其他内部对象。</li>
<li>检查完成后，HTTP 客户端会把对应的资源通过显示器呈现给用户。</li>
</ol>
<p>这是个简单的例子，详细的例子可以参考<a href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&mid=2247485074&idx=1&sn=f4e44c4b675adc6e13b4704839c5a19d&scene=21#wechat_redirect" target="_blank" rel="noopener">这篇文章</a></p>
<h3 id="GET和POST报文形式"><a href="#GET和POST报文形式" class="headerlink" title="GET和POST报文形式"></a>GET和POST报文形式</h3><p>实际上HTTP的响应报文结构都是一样的，GET和POST只是会体现在协议版本的地方不同而已。</p>
<p>分为请求行、响应头、响应正文几个部分。每次响应可以没有正文，但是必须有请求头。注意请求头后面会空出来一行，再开始响应正文。</p>
<p>如下图：<br><img src="https://s2.ax1x.com/2020/02/28/30Hs3D.png" alt="HTTP响应报文"></p>
<p>一个例子：</p>
<p><img src="https://i.loli.net/2020/03/19/5B9UPNkcjZohXAv.png" alt="一个实例.png"></p>
<h3 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h3><p>可以从三个层面解释：</p>
<ul>
<li>HTTP报文层面：GET将请求信息放在URL中，POST放在报文体中。</li>
<li>数据库层面：GET符合幂等性 (对数据库的多次操作效果一样，PUT也是幂等的)和安全性 (操作不会改变数据库中的数据)，POST不符合。</li>
<li>其他层面：GET可以被缓存、被存储，而POST不行</li>
</ul>
<h3 id="255-255-255-255和0-0-0-0的作用"><a href="#255-255-255-255和0-0-0-0的作用" class="headerlink" title="255.255.255.255和0.0.0.0的作用"></a>255.255.255.255和0.0.0.0的作用</h3><p>255.255.255.255这个地址一般用来广播的时候使用，而0.0.0.0这个地址可以代表这是一个还没有分配 ip 的主机。</p>
<p>不过0.0.0.0还有其他作用，代表主机还没有分配ip地址只是其中的一个用处。例如：充当默认路由来使用，当一个路由器要发送路由表中无法查询的包时，如果设置了全零网络的路由时，我们就可以把这个包丢给全零网络的路由。</p>
<h3 id="TCP和UDP区别以及各自适用场景"><a href="#TCP和UDP区别以及各自适用场景" class="headerlink" title="TCP和UDP区别以及各自适用场景"></a>TCP和UDP区别以及各自适用场景</h3><p>UDP提供不可靠无连接的数据报传输服务，使用IP实现报文传输，根据协议端口号确定收发双方的应用程序，适用于一个服务器需要对多个客户端频繁的小数据请求进行服务的情况。TCP提供可靠的面向连接的数据流传输服务，TCP偏重于可靠性，而不是实时性，适用于一对一的传输大量数据的场合。</p>
<h3 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h3><p>流量控制与接收方的缓存状态相关。</p>
<p>一般来说，我们都希望数据能传输快一些。但是，<strong>如果发送方把数据发送得过快，接收方就可能来不及接收，这就会造成数据的丢失</strong>。</p>
<p><font color=#FF0000>所谓流量控制(flow control)就是让发送方的发送速率不要太快，要让接收方来得及接收</font>。</p>
<p>解决流量控制的问题的方法很多，比如停止-等待、滑动窗口等。</p>
<p>流量控制不是属于某一层特有的功能，比如数据链路层会要考虑，这里的TCP的也会要考虑(数据链路层的暂时不讨论)</p>
<p>TCP利用<strong>滑动窗口机制</strong>，可以比较好的成功做到流量控制。</p>
<p>详细过程可以参考这个<a href="https://www.bilibili.com/video/av50251501?from=search&seid=2105367062843188825" target="_blank" rel="noopener">教学视频</a></p>
<h3 id="TCP拥塞机制"><a href="#TCP拥塞机制" class="headerlink" title="TCP拥塞机制"></a>TCP拥塞机制</h3><p>拥塞控制与网络拥堵情况相关。</p>
<ul>
<li>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏。这种情况就叫做拥塞(congestion)。<ul>
<li>在计算机网络中的链路容量(即带宽)、交换节点中的缓存和处理机等，都是网络资源。</li>
</ul>
</li>
<li>若<font color=#FF0000>出现拥塞而不进行控制</font>，整个网络的<font color=#FF0000>吞吐量将随输入负荷的增加而下降</font>。</li>
</ul>
<p>就好比平时我们路上如果车流量太大，没有交警的疏导的话就容易造成堵塞。</p>
<p><img src="https://i.loli.net/2020/03/19/7DTeEOArayKsWFn.png" alt="TCP拥塞控制曲线.png"></p>
<p>拥塞控制是很难设计的，因为网络是高度动态的，有时候甚至是因为这个拥塞控制，导致了网络的拥堵。</p>
<p><strong>TCP的拥塞控制机制有四种算法</strong>：</p>
<ul>
<li>慢开始(slow-start)</li>
<li>拥塞避免(congestion avoidance)</li>
<li>快重传(fast retransmit)</li>
<li>快回复(fast recovery)</li>
</ul>
<p>下面介绍这四种拥塞控制算法，但是需要基于以下条件：</p>
<ul>
<li>数据总是单向传送，而另一个方向只传送确认。</li>
<li>接收方总是有足够大的缓存空间(即不考虑流量控制的必要)，因而发送方发送窗口的大小由网络的拥塞程度来决定。</li>
<li>以TCP报文段的个数作为讨论问题的单位，而不是以字节为单位。</li>
</ul>
<p>TCP拥塞控制的示意图如下：</p>
<p><img src="https://i.loli.net/2020/03/19/9tAPyYbSXFT5qJj.png" alt="TCP拥塞控制原理文字图.png"></p>
<p>简而言之，一开始拥塞窗口cwnd的大小会是2的指数级来增加，直到其大小达到了慢开始门限值(ssthresh)，后面就改用<font color=#FF0000>拥塞避免算法</font>，即每次让cwnd加1。整个传输过程曲线的一个详细例子如下图：</p>
<p><img src="https://i.loli.net/2020/03/19/JsDdO4mzlA1BijR.png" alt="拥塞重传超时重新进行.png"></p>
<p>在重新执行一次拥塞控制算法之后，整个的传输曲线是这样的：</p>
<p><img src="https://i.loli.net/2020/03/19/Ixpo25YevyRhL3M.png" alt="慢开始拥塞避免算法例子整个的曲线.png"></p>
<ul>
<li>“慢开始”是指一开始向网络注入的报文段少，不是指拥塞窗口cwnd增长速度慢；</li>
<li>“拥塞避免”不是指能完全避免拥塞，而是指在拥塞避免阶段将拥塞滑动窗口控制为按线性规律增长，使网络比较不容易出现拥塞。</li>
</ul>
<p>上述的慢开始算法和拥塞避免算法是一起的(TCP Tahoe版本)，在1988年被提出的。在1990年又增加了两个新的拥塞控制算法(<font color=#FF0000>改进TCP的性能</font>)，这就是快重传和快恢复(TCP Reno版本)。</p>
<ul>
<li>为什么要有改进的算法？原先的慢开始拥塞避免算法不好么？</li>
</ul>
<p>答：有时候，个别报文段会在网络中丢失，但是实际上网络并未发生拥塞。这会导致发送发认为已经发生拥塞，启动慢开始算法，把拥塞窗口(cwnd)设置为1，但是这会降低传输效率。</p>
<p>所谓快重传，就是使发送方<font color=#FF0000>尽快进行重传</font>，而不是等超时重传计时器超时了再重传。</p>
<p>具体做法：</p>
<ul>
<li>要求接收方不要等待自己发送数据时才进行捎带确认，而是<strong>立即发送确认</strong>。</li>
<li>即使收到了失序报文段也要立即发出对已收到的报文段的<strong>重复确认</strong>。</li>
<li>发送方一旦<font color=#FF0000>收到3个连续的重复确认</font>，就将相应的报文段<strong>立即重传</strong>，而不是等该报文段的重传计时器超时再重传。</li>
</ul>
<p>举一个图的例子，这里包含了TCP处理拥塞控制的四种方法：</p>
<p><img src="https://i.loli.net/2020/03/19/AdSc4CEVvQkrDIa.png" alt="综合四种方法的例子.png"></p>
<p>详细内容可以参考<a href="https://www.bilibili.com/video/av52266048/?spm_id_from=333.788.videocard.0" target="_blank" rel="noopener">这个教学视频</a></p>
<h3 id="选择重传协议-SR-——可靠性传输协议中的一个"><a href="#选择重传协议-SR-——可靠性传输协议中的一个" class="headerlink" title="选择重传协议(SR)——可靠性传输协议中的一个"></a>选择重传协议(SR)——可靠性传输协议中的一个</h3><p>重传协议只重发没有正确接收的帧，而不是重发所有的帧。发送方为每个发送的帧设置一个定时器，收到应答就停止计时，超时未收到应答，说明帧丢失或出错，重发该帧。接收方收到序号正确的帧，就向发送方发送ACK应答信号，如果发现序号不连接，有丢失帧现象，就向发送方发送NAK信号，请求重发制定序号的帧。</p>
<p>提一下其他发送方和接收方的其他两个可靠性传输的实现机制：停止-等待协议(SW)和后退N帧协议(GBN)</p>
<p><img src="https://i.loli.net/2020/03/19/qgGjK9ilPIpLAZo.png" alt="停止等待和后退N帧.png"></p>
<p>选择重传协议也是基于滑动窗口流量控制技术的。它的<strong>接受窗口尺寸和发送窗口尺寸都大于 1</strong>，以便能够一次性接受多个帧。如果采用 n 个比特对帧机型编号，为了避免接受端向前移动窗口后，新接收窗口与旧接收窗口产生重叠，发送窗口的最大尺寸应该不超过序列号范围的一半。</p>
<p>举个例子：</p>
<p><img src="https://i.loli.net/2020/03/20/MsaHLzIjCUAVh9O.png" alt="滑动窗口大小例子.png"></p>
<p>在这个例子中，有四个分组序号 0、1、2、3 且窗口长度为 3。假定发送了分组 0 至 2，并且接收方被正确接收且确认了。此时，接收方窗口落在 4、5、6 个分组上，其序号分别为 3、0、1.现在考虑两种情况。</p>
<p>在第一种情况下，如上图中的 a 图所示，对前 3 个分组的 ACK 丢失，因此发送方重传这些分组。因此，接收方下一步要接收序号为 0 的分组，即第一个发送分组的副本。</p>
<p>在第二种情况下，如上图中的 b 图所示，对前 3 个分组的 ACK 都被正确交付。因此发送方向前移动窗口并发送第 4、5、6 个分组，其序号分别为 3、0、1.序号为 3 的分组丢失，但序号为 0 的分组到达（一个包含新数据的分组）。</p>
<p>显然，接收方并不知道发送方那边出现了什么问题，对于接收方自己来说，上面两种情况是等价的。没有办法区分是第一个分组的重传还是第 5 个分组的初次传输。所以，窗口长度比序号空间小 1 时协议无法正常工作。但窗口应该有多小呢？</p>
<p>答案是：<strong><font color=#FF0000>窗口长度必须小于或等于序号空间大小的一半</font></strong>。</p>
<p>详细内容可以参考<a href="https://www.bilibili.com/video/av50124975?from=search&seid=13909578244053300305" target="_blank" rel="noopener">这个教学视频</a></p>
<p>以及<a href="https://blog.csdn.net/qq_22238021/article/details/80325285" target="_blank" rel="noopener">这篇文章</a></p>
<h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p>回答过程中最好不要只回答SYN、ACK这样，而是把服务端和客户端发送之后的状态也说出来。</p>
<p><img src="https://i.loli.net/2020/03/12/Lja9iFcHx2hubp8.jpg" alt="TCP三次握手"></p>
<p>刚开始两端都处于 closed 的状态，开始传输之后，服务端会被动大开，进入 listen 状态。然后：</p>
<ol>
<li><p>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号seq(x)。发送报文之后，客户端进入 SYN_Send 状态。</p>
</li>
<li><p>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 seq(y)，同时会把客户端的 x + 1 作为 ack 的值(大的ACK表示确认收到，小的ack才表示序列号，ack为当前报文段最后一个字节的编号+1)，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。</p>
</li>
<li><p>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 y + 1 作为 ack 的值，表示已经收到了服务端的 SYN 报文，之后客户端进入 establised 状态。</p>
</li>
</ol>
<p>4、服务器收到 ACK 报文之后，进入 establised 状态，此时，双方以建立起了链接。</p>
<h4 id="TCP三次握手涉及的问题"><a href="#TCP三次握手涉及的问题" class="headerlink" title="TCP三次握手涉及的问题"></a>TCP三次握手涉及的问题</h4><h5 id="1-三次握手的作用"><a href="#1-三次握手的作用" class="headerlink" title="1.三次握手的作用"></a>1.三次握手的作用</h5><p>三次握手的作用也是有好多的，多记住几个，保证不亏。例如：</p>
<ol>
<li><p>确认双方的接受能力、发送能力是否正常。</p>
</li>
<li><p>指定自己的初始化序列号，为后面的可靠传送做准备。</p>
</li>
<li><p>如果是 https 协议的话，三次握手这个过程，还会进行数字证书的验证以及加密密钥的生成到。</p>
</li>
</ol>
<h5 id="2-seq-ISN-是固定的么"><a href="#2-seq-ISN-是固定的么" class="headerlink" title="2.seq(ISN)是固定的么"></a>2.seq(ISN)是固定的么</h5><p>三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。</p>
<p>如果ISN是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。</p>
<h5 id="3-什么是半连接队列"><a href="#3-什么是半连接队列" class="headerlink" title="3.什么是半连接队列"></a>3.什么是半连接队列</h5><p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为<strong>半连接队列</strong>。当然还有一个<strong>全连接队列</strong>，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p>
<blockquote>
<p>这里在补充一点关于SYN-ACK 重传次数的问题：　服务器发送完SYN－ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超 过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s, 2s, 4s, 8s, ….</p>
</blockquote>
<h5 id="4-三次握手过程中可以携带数据吗"><a href="#4-三次握手过程中可以携带数据吗" class="headerlink" title="4.三次握手过程中可以携带数据吗"></a>4.三次握手过程中可以携带数据吗</h5><p>很多人可能会认为三次握手都不能携带数据，其实第三次握手的时候，是可以携带数据的。也就是说，第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。</p>
<p>为什么这样呢？大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。也就是说，第一次握手可以放数据的话，其中一个简单的原因就是会让服务器更加容易受到攻击了。</p>
<p>而对于第三次的话，此时客户端已经处于 established 状态，也就是说，对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据页没啥毛病。</p>
<p>此外，三次握手还会涉及https加密过程。</p>
<h5 id="5-第一次握手时可能会出现SYN超时的问题——针对SYN-Flood的防护措施"><a href="#5-第一次握手时可能会出现SYN超时的问题——针对SYN-Flood的防护措施" class="headerlink" title="5.第一次握手时可能会出现SYN超时的问题——针对SYN Flood的防护措施"></a>5.第一次握手时可能会出现SYN超时的问题——针对SYN Flood的防护措施</h5><p>面试回答建连的问题时，可以提到 SYN 洪水攻击发生的原因，就是 Server 端收到 Client 端的 SYN 请求后，发送了 ACK 和 SYN，但是 Client 端不进行回复，导致 Server 端大量的链接处在 SYN_RCVD 状态，进而影响其他正常请求的建连。可以设置 tcp_synack_retries = 0 加快半链接的回收速度，或者调大 tcp_max_syn_backlog 来应对少量的 SYN 洪水攻击。因为是Server端接收到了Client端的SYN包之后的回复的时候出现的问题，所以可以认为是首次握手时候产生的隐患。</p>
<h3 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h3><p>四次挥手也一样，千万不要对方一个 FIN 报文，我方一个 ACK 报文，再我方一个 FIN 报文，我方一个 ACK 报文。然后结束，最好是说的详细一点，例如想下面这样就差不多了，要把每个阶段的状态记好。</p>
<p><img src="https://i.loli.net/2020/03/12/P76skMIGWAO3Ntv.jpg" alt="四次挥手过程"></p>
<p>刚开始双方都处于 establised 状态，客户端先发起关闭请求，则：</p>
<ol>
<li><p>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号seq。之后客户端进入CLOSED_WAIT1状态。</p>
</li>
<li><p>第二次握手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ack 报文的序列号值，表明已经收到客户端的报文了，然后当然也会附上自己产生的序列号seq=y, 之后服务端进入 CLOSE_WAIT2状态。</p>
</li>
<li><p>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号seq=z。之后服务端进入 LAST_ACK 的状态。</p>
</li>
<li><p>第四次挥手：客户端收到 FIN 之后，一样发送一个 ack 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，之后客户端进入 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态。注意这里客户端不再生成新的序列号，而是使用之前的x+1和z+1</p>
</li>
<li><p>服务端收到 ACK 报文之后，就处于关闭连接了，进入 CLOSED 状态。</p>
</li>
</ol>
<h4 id="TCP四次挥手涉及的问题"><a href="#TCP四次挥手涉及的问题" class="headerlink" title="TCP四次挥手涉及的问题"></a>TCP四次挥手涉及的问题</h4><h5 id="1-为什么客户端在最后要有2MSL的等待时间，即为什么要有TIME-WAIT时间？"><a href="#1-为什么客户端在最后要有2MSL的等待时间，即为什么要有TIME-WAIT时间？" class="headerlink" title="1.为什么客户端在最后要有2MSL的等待时间，即为什么要有TIME_WAIT时间？"></a>1.为什么客户端在最后要有2MSL的等待时间，即为什么要有TIME_WAIT时间？</h5><p>原因有两个：</p>
<ol>
<li>保证TCP协议的全双工连接能够可靠关闭；</li>
<li>保证这次连接的重复数据段从网络中消失，防止端口被重用时可能产生数据混淆。</li>
</ol>
<h5 id="2-四次挥手过程中大量Socket处在TIME-WAIT和CLOSE-WAIT状态，该如何解决？"><a href="#2-四次挥手过程中大量Socket处在TIME-WAIT和CLOSE-WAIT状态，该如何解决？" class="headerlink" title="2.四次挥手过程中大量Socket处在TIME_WAIT和CLOSE_WAIT状态，该如何解决？"></a>2.四次挥手过程中大量Socket处在TIME_WAIT和CLOSE_WAIT状态，该如何解决？</h5><p>需要注意，在四次挥手的过程中，可以提到在实际应用中有可能遇到大量Socket处在TIME_WAIT或者CLOSE_WAIT状态的问题。一般开启 tcp_tw_reuse 和 tcp_tw_recycle 能够加快 TIME-WAIT 的 Sockets 回收；而大量 CLOSE_WAIT 可能是被动关闭的一方存在代码 bug，没有正确关闭链接导致的。</p>
<h3 id="一些状态的含义"><a href="#一些状态的含义" class="headerlink" title="一些状态的含义"></a>一些状态的含义</h3><blockquote>
<p>LISTEN - 侦听来自远方TCP端口的连接请求；</p>
</blockquote>
<blockquote>
<p>SYN-SENT -在发送连接请求后等待匹配的连接请求；</p>
</blockquote>
<blockquote>
<p>SYN-RECEIVED - 在收到和发送一个连接请求后等待对连接请求的确认；</p>
</blockquote>
<blockquote>
<p>ESTABLISHED- 代表一个打开的连接，数据可以传送给用户；</p>
</blockquote>
<blockquote>
<p>FIN-WAIT-1 - 等待远程TCP的连接中断请求，或先前的连接中断请求的确认；</p>
</blockquote>
<blockquote>
<p>FIN-WAIT-2 - 从远程TCP等待连接中断请求；</p>
</blockquote>
<blockquote>
<p>CLOSE-WAIT - 等待从本地用户发来的连接中断请求；</p>
</blockquote>
<blockquote>
<p>CLOSING -等待远程TCP对连接中断的确认；</p>
</blockquote>
<blockquote>
<p>LAST-ACK - 等待原来发向远程TCP的连接中断请求的确认；</p>
</blockquote>
<blockquote>
<p>TIME-WAIT -等待足够的时间以确保远程TCP接收到连接中断请求的确认；</p>
</blockquote>
<blockquote>
<p>CLOSED - 没有任何连接状态；</p>
</blockquote>
<h2 id="1-2-cookie和session的区别"><a href="#1-2-cookie和session的区别" class="headerlink" title="1.2 cookie和session的区别"></a>1.2 cookie和session的区别</h2><p>参考<a href="https://www.jianshu.com/p/2f7031a69f43" target="_blank" rel="noopener">这篇文章</a></p>
<ol>
<li>存储位置不同</li>
</ol>
<blockquote>
<p>cookie的数据信息存放在客户端浏览器上。</p>
</blockquote>
<blockquote>
<p>session的数据信息存放在服务器上。</p>
</blockquote>
<ol start="2">
<li>存储容量不同</li>
</ol>
<blockquote>
<p>单个cookie保存的数据&lt;=4KB，一个站点最多保存20个Cookie。</p>
</blockquote>
<blockquote>
<p>对于session来说并没有上限，但出于对服务器端的性能考虑，session内不要存放过多的东西，并且设置session删除机制。</p>
</blockquote>
<ol start="3">
<li>存储方式不同</li>
</ol>
<blockquote>
<p>cookie中只能保管ASCII字符串，并需要通过编码方式存储为Unicode字符或者二进制数据。</p>
</blockquote>
<blockquote>
<p>session中能够存储任何类型的数据，包括且不限于string，integer，list，map等。</p>
</blockquote>
<ol start="4">
<li>隐私策略不同</li>
</ol>
<blockquote>
<p>cookie对客户端是可见的，别有用心的人可以分析存放在本地的cookie并进行cookie欺骗，所以它是不安全的。</p>
</blockquote>
<blockquote>
<p>session存储在服务器上，对客户端是隐藏，不存在敏感信息泄漏的风险。</p>
</blockquote>
<ol start="5">
<li>有效期上不同</li>
</ol>
<blockquote>
<p>开发可以通过设置cookie的属性，达到使cookie长期有效的效果。</p>
</blockquote>
<blockquote>
<p>session依赖于名为JSESSIONID的cookie，而cookie JSESSIONID的过期时间默认为-1，只需关闭窗口该session就会失效，因而session不能达到长期有效的效果。</p>
</blockquote>
<ol start="6">
<li>服务器压力不同</li>
</ol>
<blockquote>
<p>cookie保管在客户端，不占用服务器资源。对于并发用户十分多的网站，cookie是很好的选择。</p>
</blockquote>
<blockquote>
<p>session是保管在服务器端的，每个用户都会产生一个session。假如并发访问的用户十分多，会产生十分多的session，耗费大量的内存。</p>
</blockquote>
<ol start="7">
<li>浏览器支持不同</li>
</ol>
<p>假如客户端浏览器不支持cookie：</p>
<blockquote>
<p>cookie是需要客户端浏览器支持的，假如客户端禁用了cookie，或者不支持cookie，则会话跟踪会失效。关于WAP上的应用，常规的cookie就派不上用场了。</p>
</blockquote>
<blockquote>
<p>运用session需要使用URL地址重写的方式。一切用到session程序的URL都要进行URL地址重写，否则session会话跟踪还会失效。</p>
</blockquote>
<p>假如客户端支持cookie：</p>
<blockquote>
<p>cookie既能够设为本浏览器窗口以及子窗口内有效，也能够设为一切窗口内有效。</p>
</blockquote>
<blockquote>
<p>session只能在本窗口以及子窗口内有效。</p>
</blockquote>
<ol start="8">
<li>跨域支持上不同</li>
</ol>
<blockquote>
<p>cookie支持跨域名访问。</p>
</blockquote>
<blockquote>
<p>session不支持跨域名访问。</p>
</blockquote>
<p>另外：现在正在淘汰cookie了，谷歌日前就在官方博客上说，将在未来两年淘汰cookie,即chrome逐步淘汰第三方cookie，但是由于市场占比的原因，这件事还有待进一步发展。</p>
<h2 id="HTTP、TCP、UDP、IP、ICMP、DNS、FTP等协议分别处于哪层？"><a href="#HTTP、TCP、UDP、IP、ICMP、DNS、FTP等协议分别处于哪层？" class="headerlink" title="HTTP、TCP、UDP、IP、ICMP、DNS、FTP等协议分别处于哪层？"></a>HTTP、TCP、UDP、IP、ICMP、DNS、FTP等协议分别处于哪层？</h2><p>以OSI七层模型来说：</p>
<ul>
<li>应用层：<strong>HTTP、FTP、DNS、</strong>Telnet、SMTP、</li>
<li>传输层：<strong>TCP、UDP</strong></li>
<li>网络层：<strong>IP、ICMP、</strong>RIP、OSPF、</li>
<li>数据链路层：<strong>ARP</strong>、PPP、RARP、MTU</li>
<li>物理层：ISO2110、IEEEE802、IEEEE802.2</li>
</ul>
<h2 id="Ping指令用的什么协议？在哪一层？"><a href="#Ping指令用的什么协议？在哪一层？" class="headerlink" title="Ping指令用的什么协议？在哪一层？"></a>Ping指令用的什么协议？在哪一层？</h2><p>Ping命令本身处于应用层，相当于一个应用程序，它直接使用网络层的ICMP回应报文来监听返回情况。(所以如果直接问ping在哪一层，答案是应用层)</p>
<h2 id="ARP协议的作用？"><a href="#ARP协议的作用？" class="headerlink" title="ARP协议的作用？"></a>ARP协议的作用？</h2><h3 id="什么是ARP协议？"><a href="#什么是ARP协议？" class="headerlink" title="什么是ARP协议？"></a>什么是ARP协议？</h3><p>ARP (Address Resolution Protocol) 是个地址解析协议。最直白的说法是：在IP以太网中，当一个上层协议要发包时，有了该节点的IP地址，ARP就能提供该节点的MAC地址。</p>
<h3 id="为什么要有ARP协议？"><a href="#为什么要有ARP协议？" class="headerlink" title="为什么要有ARP协议？"></a>为什么要有ARP协议？</h3><p>OSI 模式把网络工作分为七层，彼此不直接打交道，只通过接口(layre interface). IP地址在第三层, MAC地址在第二层。协议在发生数据包时，首先要封装第三层 （IP地址）和第二层 （MAC地址）的报头, 但协议只知道目的节点的IP地址，不知道其物理地址，又不能跨第二、三层，所以得用ARP的服务。</p>
<h2 id="路由器和交换机的区别？"><a href="#路由器和交换机的区别？" class="headerlink" title="路由器和交换机的区别？"></a>路由器和交换机的区别？</h2><p>交换机是一根网线上网，但是大家上网是分别拨号，各自使用自己的宽带，大家上网没有影响。而路由器比交换机多了一个虚拟拨号功能，通过同一台路由器上网的电脑是共用一个宽带账号，大家上网要相互影响。</p>
<p>交换机工作在中继层，交换机根据MAC地址寻址。路由器工作在网络层，根据IP地址寻址，路由器可以处理TCP/IP协议，而交换机不可以。</p>
<p>路由器工作于网络层，用来隔离广播域（子网），连接的设备分属不同子网，工作范围是多个子网之间，负责网络与网络之间通信。</p>
<p><strong>工作层次不同</strong></p>
<p>交换机主要工作在数据链路层（第二层）</p>
<p>路由器工作在网络层（第三层）。</p>
<p><strong>转发依据不同</strong></p>
<p>交换机转发所依据的对象时：MAC地址。（物理地址）</p>
<p>路由转发所依据的对象是：IP地址。（网络地址）</p>
<p><strong>主要功能不同</strong></p>
<p>交换机主要用于组建局域网，而路由主要功能是将由交换机组好的局域网相互连接起来，或者接入Internet。<br>交换机能做的，路由都能做。<br>交换机不能分割广播域，路由可以。<br>路由还可以提供防火墙的功能。<br>路由配置比交换机复杂。</p>
<h2 id="TCP粘包为什么会发生？怎么处理？"><a href="#TCP粘包为什么会发生？怎么处理？" class="headerlink" title="TCP粘包为什么会发生？怎么处理？"></a>TCP粘包为什么会发生？怎么处理？</h2><p>只有TCP会产生粘包问题，因为TCP是基于数据流的协议，而UDP是基于数据报的协议。也就是说，TCP认为消息不是一条一条的，而是”流”式的，是没有消息边界的。而UDP则是有消息边界的，接收方一次只接收一条独立的信息，所以不存在粘包问题。</p>
<p>TCP粘包指的是发送方发送的若干包数据到达接收方时粘成了一个很大的包，从接收方来看，是一个数据包的头紧接着另一个数据包的尾。</p>
<h3 id="发生TCP粘包主要是两个原因："><a href="#发生TCP粘包主要是两个原因：" class="headerlink" title="发生TCP粘包主要是两个原因："></a>发生TCP粘包主要是两个原因：</h3><ul>
<li><strong>发送方的原因</strong>：发送方默认开启Nagle算法(主要作用是减少网络中报文段的数量)，而Nagle算法主要做两件事：1.只在上一个分组得到确认之后才发送下一个分组；2.收集多个小分组，在一个确认到来之后一起发送。Nagle这两个功能造成了发送方可能会产生粘包问题。</li>
<li><strong>接收方原因</strong>：接收方接收到TCP包之后不会马上处理，而是会先放在缓存中，然后应用程序会从缓存里面读取到数据分组。但是这样一来如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。</li>
</ul>
<h3 id="解决粘包问题的两个方法："><a href="#解决粘包问题的两个方法：" class="headerlink" title="解决粘包问题的两个方法："></a>解决粘包问题的两个方法：</h3><p>经过上面原因的分析我们可以知道，可以在发送方和应用层两个层面解决TCP粘包问题，但是接收方没办法解决，从接受方的角度来看只能交给应用层处理。</p>
<ul>
<li>发送方可以选择关闭Nagle算法，使用TCP_NODELAY选项关闭</li>
<li>从应用层来解决可以有两种方法，主要目的都是从缓存中循环地一条一条地读数据，直到所有数据被处理完成。这里重点是如何判断每条数据的长度，重点解决方法有两个：</li>
</ul>
<ol>
<li><strong>格式化数据</strong>：给每条数据设置固有的格式(开始符、结束符，比叡设置每条数据的结尾都统一是”/0”)，</li>
<li><strong>统一发送长度</strong>：每次发送数据时都统一长度，然后将数据按照统一的长度发送。比如规定数据的前4位是数据的长度，之后应用层在处理时可以根据长度来判断每个分组的开始和结束位置。</li>
</ol>
<hr>
<p>其他有关路由器和交换机的知识：<a href="https://www.cnblogs.com/Lynn-Zhang/articles/5754336.html" target="_blank" rel="noopener">可以参考文章</a></p>
<h1 id="2-操作系统"><a href="#2-操作系统" class="headerlink" title="2.操作系统"></a>2.操作系统</h1><h2 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h2><p>从宏观上来回答：</p>
<p>a.进程是系统资源分配的最小单位，线程是程序执行的最小单位</p>
<p>b.进程使用独立的数据空间，而线程共享进程的数据空间</p>
<p>更深入一点：</p>
<ul>
<li><p>共享内存方面。因为进程间不能共享内存，所以我们会用一些进程间相互交互的方案，比较常见的就是通过TCP/IP的端口来实现。也有其他方案，但是TCP/IP是最通用的，其他方案可能和某个特定操作系统的相关性要更大一些。</p>
</li>
<li><p>进程与线程通信方面。进程通信比较难，线程间通信就很简单了，只要两个线程的指针指向同一块内存，它们之间就可以通信。</p>
</li>
<li><p>In terms of 开销，进程的开销当然比较大，因为我们要给它分配很多内存，而线程我们只是给它分配一个栈，分配一个PC指针(program counter)就可以了。此外，进程之间切换的开销会大于线程之间切换的开销。</p>
</li>
</ul>
<h2 id="进程间通信方式-IPC-Inter-Process-Communication"><a href="#进程间通信方式-IPC-Inter-Process-Communication" class="headerlink" title="进程间通信方式(IPC, Inter Process Communication)"></a>进程间通信方式(IPC, Inter Process Communication)</h2><p>总共七种方法：</p>
<ol>
<li>文件</li>
<li>管道/命名管道</li>
<li>Signal</li>
<li>共享内存</li>
<li>消息队列</li>
<li>同步机制，如信号量(semaphore)</li>
<li>Socket</li>
</ol>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>写一个文件：最简单的方法，一个进程写一个文件，另一个进程去访问这个文件，由此两个进程之间可以交换信息，得以通信。</p>
<h3 id="管道-命名管道"><a href="#管道-命名管道" class="headerlink" title="管道/命名管道"></a>管道/命名管道</h3><p>管道：两个进程之间建立消息通信的通道。不命名的管道一般是单向的，一方可以向另一方从管道里发送数据；命名管道可以单向也可以双向。</p>
<p>管道的通知机制类似于缓存，就像一个进程把数据放在某个缓存区域，然后等着另外一个进程去拿，并且是管道是单向传输的。</p>
<p>这种通信方式有什么缺点呢？显然，这种通信方式效率低下，你看，a 进程给 b 进程传输数据，只能等待 b 进程取了数据之后 a 进程才能返回。</p>
<p>所以管道不适合频繁通信的进程。当然，他也有它的优点，例如比较简单，能够保证我们的数据已经真的被其他进程拿走了。我们平时用 Linux 的时候，也算是经常用。</p>
<h3 id="Signal"><a href="#Signal" class="headerlink" title="Signal"></a>Signal</h3><p>Signal：linux系统中最常用。一个进程给另一个进程发送信号，一般是一串数字，这个数字有自己特定的含义。比如”kill”可以 send a signal to a process,强行”kill”掉。</p>
<p>比如kill -9,可以杀死进程</p>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>系统加载一个进程的时候，分配给进程的内存并不是实际物理内存，而是虚拟内存空间。那么我们可以让两个进程各自拿出一块虚拟地址空间来，然后映射到相同的物理内存中，这样，两个进程虽然有着独立的虚拟内存空间，但有一部分却是映射到相同的物理内存，这就完成了内存共享机制了。</p>
<p>换句话说：虽然进程之间是彼此独立的，但是操作系统可以提供一个机制，两个进程可以约定好，打开一个文件，这个文件映射到内存中，也就是多个进程使用同一块内存。</p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>我们可以用消息队列的通信模式来解决这个问题，例如 a 进程要给 b 进程发送消息，只需要把消息放在对应的消息队列里就行了，b 进程需要的时候再去对应的<br>消息队列里取出来。同理，b 进程要个 a 进程发送消息也是一样。这种通信方式也类似于缓存吧。</p>
<p>这种通信方式有缺点吗？答是有的，如果 a 进程发送的数据占的内存比较大，并且两个进程之间的通信特别频繁的话，消息队列模型就不大适合了。因为 a 发送的数据很大的话，意味发送消息（拷贝）这个过程需要花很多时间来读内存。</p>
<h3 id="同步机制，如信号量-semaphore"><a href="#同步机制，如信号量-semaphore" class="headerlink" title="同步机制，如信号量(semaphore)"></a>同步机制，如信号量(semaphore)</h3><p>信号量的本质就是一个计数器，用来实现进程之间的互斥与同步。例如信号量的初始值是 1，然后 a 进程来访问内存1的时候，我们就把信号量的值设为 0，然后进程b 也要来访问内存1的时候，看到信号量的值为 0 就知道已经有进程在访问内存1了，这个时候进程 b 就会访问不了内存1。所以说，信号量也是进程之间的一种通信方式。</p>
<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>最后一种，而且没回答出来这个其实整个答案都不算好。因为前面6种只能作为同一个机器的进程之间的通信，而Socket可以是不同机器的进程之间的通信。</p>
<p>可以在机器上开一个端口，作为一个服务器，让用户连接。这种通信包含了网络上的服务端和服务器的这种结构。</p>
<p>用浏览器去访问一个网站，这时浏览器的进程和远端服务器的进程要进行通信。</p>
<p>Socket可以作为不同机器之间进程的通信——通过客户端，服务器的方法。这里面走的一般是TCP的协议或者UDP的协议。</p>
<h2 id="经典进程调度算法"><a href="#经典进程调度算法" class="headerlink" title="经典进程调度算法"></a>经典进程调度算法</h2><h3 id="1-批处理时代"><a href="#1-批处理时代" class="headerlink" title="1.批处理时代"></a>1.批处理时代</h3><h4 id="1-FCFS-先来先服务"><a href="#1-FCFS-先来先服务" class="headerlink" title="1.FCFS(先来先服务)"></a>1.FCFS(先来先服务)</h4><p>每个进程按进入内存的时间先后排成一队。每当 CPU 上的进程运行完毕或者阻塞，我就会选择队伍最前面的进程，带着他前往 CPU 执行。</p>
<p>这一算法听起来简单又公平，然而好景不长，我收到了一个短进程的抱怨：”上次我前面排了一个长进程，等了足足 200 秒他才运行完。我只用 1 秒就运行结束了，就因为等他，我多花了这么长时间，太不值得了。”</p>
<p>我仔细一想， FCFS 算法确实有这个缺陷——短进程的响应时间太长了，用户交互体验会变差。</p>
<p>所以我决定，更换调度算法。</p>
<h4 id="2-SPN-段任务优先"><a href="#2-SPN-段任务优先" class="headerlink" title="2.SPN(段任务优先)"></a>2.SPN(段任务优先)</h4><p>这次我设计的算法叫做「短任务优先」（Shortest Process Next，SPN）。每次选择预计处理时间最短的进程。因此，在排队的时候，我会把短进程从队列里提到前面。</p>
<p>这一次，短进程得到了很好的照顾，进程的平均响应时间大大降低，我和操作系统都很满意。</p>
<p>但长进程们不干了：那些短进程天天插队，导致他们经常得不到 CPU 资源，造成了「饥饿」现象。</p>
<p>取消 SPN 算法的呼声越来越高。</p>
<p>这可是个大问题。FCFS 虽然响应时间长，但最后所有进程一定有使用 CPU 资源的机会。但 SPN 算法就不一样了，如果短进程源源不断加入队列，长进程们将永远得不到执行的机会——太可怕了。</p>
<p>因此，短任务优先算法需要得到改进。有什么方法既能照顾短进程，又能照顾长进程呢？</p>
<h4 id="3-HARRN-高响应比优先"><a href="#3-HARRN-高响应比优先" class="headerlink" title="3.HARRN(高响应比优先)"></a>3.HARRN(高响应比优先)</h4><p>经过和操作系统的讨论，我们决定综合考量进程的两个属性：等待时间和要求服务时间——等待时间长，要求服务时间短（就是短进程）的进程更容易被选中。</p>
<p>为了量化，我们制定了一个公式：响应比 = （等待时间+要求服务时间）/ 要求服务时间。响应比高的算法会先执行。我们称之为「高响应比优先」（Highest Response Ratio Next，HRRN）。</p>
<p>这个算法得到了长短进程的一致好评。虽然我的工作量增加了（每次调度前，我都要重新计算所有等待进程的响应比）但为了进程们的公平性，这一切都是值得的。</p>
<h3 id="2-并发时代"><a href="#2-并发时代" class="headerlink" title="2.并发时代"></a>2.并发时代</h3><p>新时代到了。</p>
<p>随着计算机的普及，个人用户大量增长，并发，即一次运行多个程序的需求出现了。这可难倒我了——处理器只有一个，怎么运行多个程序？</p>
<p>所幸 CPU 点醒了我：“我现在的运算速度既然这么快，何不发挥这项长处，弄一个「伪并行」出来？“</p>
<p>“伪并行？什么意思”</p>
<p>“就是看起来像并行，实际上还是串行。每个进程短时间交替使用我的资源，但在人类看来，这些进程就像在「同时」运行。”</p>
<h4 id="1-RR-时间片轮转算法"><a href="#1-RR-时间片轮转算法" class="headerlink" title="1.RR(时间片轮转算法)"></a>1.RR(时间片轮转算法)</h4><p>经过 CPU 的提醒，我很快制定出了新的调度算法——时间片轮转算法（Round Robin，RR）。</p>
<p>在这个算法里，每个进程将轮流使用 CPU 资源，只不过在他们开始运行时，我会为他们打开定时器，如果定时器到时间（或者执行阻塞操作），进程将被迫「下机」，切换至下一个进程。至于下一个进程的选择嘛，直接用 FCFS 就好了。</p>
<p>新的算法必然会面临新的问题，现在我的问题就是，时间片的长度怎么设计？</p>
<p>直观来看，时间片越短，固定时间里可运行的进程就越多，可 CPU 说过，切换进程是要消耗他不少指令周期的，时间片过短会导致大量 CPU 资源浪费在切换上下文上。时间片过长，短交互指令响应会变慢。所以具体怎么取，还得看交互时间大小（感觉像没说一样，但至少给了个标准嘛）。</p>
<p>这一阶段，我的工作量大大提升——以前十几秒都不用切换一次程序，现在倒好，一秒钟就得切换数十次。</p>
<h4 id="2-VRR-虚拟轮转法"><a href="#2-VRR-虚拟轮转法" class="headerlink" title="2.VRR(虚拟轮转法)"></a>2.VRR(虚拟轮转法)</h4><p>时间片轮转算法看起来十分公平——所有的进程时间片都是一样的。但事实真是这样吗？</p>
<p>I/O 密集型进程不这么认为，他对我说：“调度器大哥，时间片轮转没有照顾到我们这类进程啊！我们经常在 CPU 没呆到一半时间片，就遇到了阻塞操作，被你赶下去。而且我们在阻塞队列，往往要停留很长时间。等阻塞操作结束，我们还得在就绪队列排好长时间队。那些处理器密集型进程，使用了大部分的处理器时间，导致我们性能降低，响应时间跟不上”</p>
<p>考虑到这些进程的要求，我决定为他们创建一个新的辅助队列。阻塞解除的进程，将进入这个辅助队列，进行进程调度时，优先选择辅助队列里的进程。</p>
<p>这就是「虚拟轮转法」（Virtual Round Robin，VRR）。</p>
<p>从后来实际性能结果来看，这种方法确实优于轮转法。</p>
<h4 id="3-优先级调度"><a href="#3-优先级调度" class="headerlink" title="3.优先级调度"></a>3.优先级调度</h4><p>这个非常类似于优先队列的思想。</p>
<p>有一天，操作系统忽然找到我，神神秘秘的说：“调度器啊，你是知道的，我要给整个系统提供服务，可最近用户进程太多，导致我的服务进程有时候响应跟不上。我有点担心这会给系统稳定性造成影响。”</p>
<p>我一听，这可是个大事，系统不稳定那还得了？调度算法得换！</p>
<p>既然要让操作系统的服务得到足够的运行资源，那就，干脆让他们具有最高的 CPU 使用优先权吧。</p>
<p><strong>优先级调度算法</strong>就此产生了。</p>
<p>我向大家做出了规定——每个进程将被赋予一个<strong>优先级</strong>，自己根据自己的情况确定优先级数值，但是，用户进程的优先级<strong>不准高于</strong>内核进程的优先级。</p>
<p>切换程序的时候，我会从优先级 1 的队列里选择一个进程，如果优先级 1 队列为空，才会选择优先级 2 中的进程，以此类推。</p>
<p>当然，为了保证低优先级进程不会<strong>饥饿</strong>，我会调高等待时间长的进程的优先级。</p>
<p>使用这个算法，我更忙碌了，不仅需要大量切换进程，还需要动态调节优先级。可能这就是能力越大，责任越大吧。</p>
<p>不过我知道，正是因为我的存在，人类才能在计算机上运行多道程序——这令我感到自豪。</p>
<h2 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h2><p>出现互斥的根本原因就是进程在执行某一个操作(比如购票操作，在操作过程中某个进程买票了，减了一张，如果另外一个进程也访问了买票系统，买了票，又减了1，那导致卖了两张票出去，出错了)</p>
<p>这本质是进程之间冲突造成的，一个进程修改了共享的空间的数据，另一个一个线程再访问的时候自然就会出错。</p>
<p>这个是进程调度器的锅么？——因为貌似进程调度器负责调度进程啊！</p>
<p>但是，并不是。因为进程调度器也只负责做事，它只负责从<strong>就绪队列</strong>中选出来<strong>最应该使用CPU的进程而已</strong>。具体说来，调度器的时机是由<strong>中断</strong>决定的，也就是当进程时间片用完的时候，出现了时钟中断，然后被其他进程抢占了CPU资源。</p>
<p>但是能因此就禁止中断么？当然不行。<strong>中断禁用</strong>虽然可以防止进程在运行代码，但是计算机自己不能控制执行的功能，全部交给程序员，这是不合理的。</p>
<p>解决方法：<strong>加锁</strong>。</p>
<p>加锁是个比喻，其实<strong>「锁」</strong>只是一个共享变量，我们可以让它有 <code>OPEN</code> 和 <code>CLOSE</code> 这两个值。一个进程，比如说 A，进入临界区之前，先检查锁是不是 <code>OPEN</code> 状态，如果是的话，就把锁改为 <code>CLOSE</code> 状态 ，这样其他进程在进入临界区时，会发现锁已经 <code>CLOSE</code> 了，那就让他们<strong>循环等待</strong> ，直到 A 出临界区然后将锁打开。</p>
<p>内存眉头一皱，发现事情并没有这么简单——<strong>如果 A 发现锁是开着的，但在 A 还没有关闭锁之前，切换到了进程 B ，那么 B 也会发现锁是开着的，那么 B 也将能够进入临界区</strong>！</p>
<p>但是CPU说：”这对我来说，不是问题，已经有现成机制可以使用。”</p>
<p>原来计算机里有一条硬件支持的指令——<strong>TSL</strong>（test and set lock，测试并加锁），这条指令可以保证读字和写字的操作「<strong>不可分割</strong>」，也就是说，在这条指令结束前，就连其他处理器也不可能访问该内存字。</p>
<p>但是如果单纯设置这样的锁，一个进程没执行完，另一个不能执行，很可能会浪费CPU资源，所以单纯的TSL方案需要改进。</p>
<p>然而，磁盘想到了解决这个问题的方法。</p>
<p>利用<strong>信号量</strong>。。Dijkstra 提出，<code>P</code>操作是检测信号量是否为正值，如果不是，就阻塞调用它的进程。  <code>V</code>操作能唤醒一个被阻塞的进程，让他恢复执行 。</p>
<p>代码：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// S 为信号量</span></span><br><span class="line"><span class="function"><span class="title">P</span><span class="params">(s)</span></span>:</span><br><span class="line">&#123;</span><br><span class="line">S = S - <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> (S &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        调用该 P 操作的进程阻塞，并插入相应的阻塞队列；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// S 为信号量</span></span><br><span class="line"><span class="function"><span class="title">V</span><span class="params">(s)</span></span>:</span><br><span class="line">&#123;</span><br><span class="line">S = S + <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> (S &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        从等待信号量 S 的阻塞队列里唤醒一个进程；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举个例子，购票操作。这里的 「购票操作」 就是我们要保护的临界区，我们要保证一次只能有一个线程进入。那我们就把 S 的初始值设为 1 。当线程 A 第一个调用 P(S) 后，S 的值就变成了 0 ，A 成功进入临界区。在 A 出临界区之前，线程 B 如果调用 P(S)， S 就变成 -1 ，满足 S &lt; 0 的判断条件，线程 B 就被阻塞了。等 A 调用 V(S) 后，S 的值又变成 0 ，满足 S &lt;= 0，就会把线程 B 唤醒，B 就能进入临界区了。“</p>
<p>而且信号量在这里有了可以增加线程运行速度的作用：<strong>S 的初始值可以控制有多少个线程进入临界区</strong>，太厉害了！</p>
<h2 id="锁-重量级锁、自旋锁、轻量级锁、偏向锁、悲观、乐观锁等"><a href="#锁-重量级锁、自旋锁、轻量级锁、偏向锁、悲观、乐观锁等" class="headerlink" title="锁(重量级锁、自旋锁、轻量级锁、偏向锁、悲观、乐观锁等)"></a>锁(重量级锁、自旋锁、轻量级锁、偏向锁、悲观、乐观锁等)</h2><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>如果你学过多线程，那么你肯定知道<strong>锁</strong>这个东西，至于为什么需要锁，我就不给你普及了，就当做你是已经懂的了。</p>
<p>我们知道，我们要进入一个同步、线程安全的方法时，是需要先获得这个方法的锁的，退出这个方法时，则会释放锁。如果获取不到这个锁的话，意味着有别的线程在执行这个方法，这时我们就会马上进入阻塞的状态，等待那个持有锁的线程释放锁，然后再把我们从阻塞的状态唤醒，我们再去获取这个方法的锁。</p>
<p>这种获取不到锁就马上进入阻塞状态的锁，我们称之为重量级锁。</p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>我们知道，线程从<strong>运行态</strong>进入<strong>阻塞态</strong>这个过程，是非常耗时的，因为不仅需要保存线程此时的执行状态，上下文等数据，还涉及到<strong>用户态</strong>到<strong>内核态</strong>的转换。当然，把线程从阻塞态唤醒也是一样，也是非常消耗时间的。</p>
<p>刚才我说线程拿不到锁，就会<strong>马上</strong>进入阻塞状态，然而现实是，它虽然这一刻拿不到锁，可能在下 0.0001 秒，就有其他线程把这个锁释放了。如果它慢0.0001秒来拿这个锁的话，可能就可以顺利拿到了，不需要经历<strong>阻塞/唤醒</strong>这个花时间的过程了。</p>
<p>然而重量级锁就是这么坑，它就是不肯等待一下，一拿不到就是要马上进入阻塞状态。为了解决这个问题，我们引入了另外一种愿意等待一段时间的锁 — <strong>自旋锁</strong>。</p>
<p>自旋锁就是，如果此时拿不到锁，它不马上进入阻塞状态，而是等待一段时间，看看这段时间有没其他人把这锁给释放了。怎么等呢？这个就类似于线程在那里做<strong>空循环</strong>，如果循环一定的次数还拿不到锁，那么它才会进入阻塞的状态。</p>
<p>至于是循环等待几次，这个是可以人为指定一个数字的。</p>
<h3 id="自适应自旋锁"><a href="#自适应自旋锁" class="headerlink" title="自适应自旋锁"></a>自适应自旋锁</h3><p>上面我们说的自旋锁，每个线程循环等待的次数都是一样的，例如我设置为 100次的话，那么线程在空循环 100 次之后还没拿到锁，就会进入阻塞状态了。</p>
<p>而自适应自旋锁就牛逼了，它不需要我们人为指定循环几次，它自己本身会进行判断要循环几次，而且每个线程可能循环的次数也是不一样的。而之所以这样做，主要是我们觉得，如果一个线程在不久前拿到过这个锁，或者它之前经常拿到过这个锁，那么我们认为<strong>它再次拿到锁的几率非常大</strong>，所以循环的次数会多一些。</p>
<p>而如果有些线程从来就没有拿到过这个锁，或者说，平时很少拿到，那么我们认为，它再次拿到的概率是比较小的，所以我们就让它循环的次数少一些。因为你在那里做空循环是很消耗 CPU 的。</p>
<p>所以这种能够根据线程最近获得锁的状态来调整循环次数的自旋锁，我们称之为<strong>自适应自旋锁</strong>。</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>上面我们介绍的三种锁：重量级、自旋锁和自适应自旋锁，他们都有一个特点，就是进入一个方法的时候，就会加上锁，退出一个方法的时候，也就释放对应的锁。</p>
<p>之所以要加锁，是因为他们害怕自己在这个方法执行的时候，被别人偷偷进来了，所以只能加锁，防止其他线程进来。这就相当于，每次离开自己的房间，都要锁上门，人回来了再把锁解开。</p>
<p>这实在是太麻烦了，如果根本就没有线程来和他们竞争锁，那他们不是白白上锁了？要知道，<strong>加锁</strong>这个过程是需要操作系统这个大佬来帮忙的，是很消耗时间的，。为了解决这种<strong>动不动就加锁</strong>带来的开销，轻量级锁出现了。</p>
<p>轻量级锁认为，当你在方法里面执行的时候，其实是很少刚好有人也来执行这个方法的，所以，当我们进入一个方法的时候根本就不用加锁，我们只需要<strong>做一个标记</strong>就可以了，也就是说，我们可以用一个变量来记录此时该方法是否有人在执行。也就是说，如果这个方法没人在执行，当我们进入这个方法的时候，采用CAS机制，把这个方法的状态标记为已经有人在执行，退出这个方法时，在把这个状态改为了<strong>没有人在执行了</strong>。</p>
<blockquote>
<p>之所以要用CAS机制来改变状态，是因为我们对这个状态的改变，不是一个原子性操作，所以需要CAS机制来保证操作的原子性。</p>
</blockquote>
<p>显然，<strong>比起加锁操作，这个采用CAS来改变状态的操作，花销就小多了</strong>。</p>
<p>然而可能会说，没人来竞争的这种想法，那是你说的而已，那如果万一有人来竞争说呢？也就是说，当一个线程来执行一个方法的时候，方法里面已经有人在执行了。</p>
<p>如果真的遇到了竞争，我们就会认为轻量级锁已经不适合了，我们就会把轻量级锁升级为重量级锁了。</p>
<p>所以轻量级锁适合用在那种，很少出现多个线程竞争一个锁的情况，也就是说，适合那种多个线程总是<strong>错开时间</strong>来获取锁的情况。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁就更加牛逼了，我们已经觉得轻量级锁已经够<strong>轻</strong>，然而偏向锁更加<strong>省事</strong>，偏向锁认为，你轻量级锁每次进入一个方法都需要用CAS来改变状态，退出也需要改变，多麻烦。</p>
<p>偏向锁认为，其实对于一个方法，是很少有两个线程来执行的，搞来搞去，其实也就一个线程在执行这个方法而已，相当于单线程的情况，居然是<strong>单线程</strong>，那就没必要加锁了。</p>
<p>不过毕竟实际情况的多线程，单线程只是自己认为的而已了，所以呢，偏向锁进入一个方法的时候是这样处理的：如果这个方法没有人进来过，那么一个线程首次进入这个方法的时候，会采用CAS机制，把这个方法标记为有人在执行了，和轻量级锁加锁有点类似，并且也会把该线程的 ID 也记录进去，相当于记录了哪个线程在执行。</p>
<p>然后，但这个线程退出这个方法的时候，它不会改变这个方法的状态，而是直接退出来，懒的去改，因为它认为除了自己这个线程之外，其他线程并不会来执行这个方法。</p>
<p>然后当这个线程想要再次进入这个方法的时候，会判断一下这个方法的状态，如果这个方法已经被标记为<strong>有人在执行了</strong>，并且线程的ID是自己，那么它就直接进入这个方法执行，啥也不用做</p>
<p>你看，多方便，第一次进入需要CAS机制来设置，以后进出就啥也不用干了，直接进入退出。</p>
<p>然而，现实总是残酷的，毕竟实际情况还是多线程，所以万一有其他线程来进入这个方法呢？如果真的出现这种情况，其他线程一看这个方法的ID不是自己，这个时候说明，至少有两个线程要来执行这个方法论，这意味着<strong>偏向锁已经不适用了</strong>，这个时候就会从偏向锁升级为轻量级锁。</p>
<p>所以呢，偏向锁适用于那种，始终只有一个线程在执行一个方法的情况。</p>
<h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><p>最开始我们说的三种锁，重量级锁、自旋锁和自适应自旋锁，进入方法之前，就一定要先加一个锁，这种我们为称之为<strong>悲观锁</strong>。悲观锁总认为，如果不事先加锁的话，就会出事，这种想法确实悲观了点。</p>
<p>而<strong>乐观锁</strong>却相反，认为不加锁也没事，我们可以先不加锁，如果出现了冲突，我们在想办法解决，例如 CAS 机制，上面说的轻量级锁，就是乐观锁的。不会马上加锁，而是等待真的出现了冲突，在想办法解决。</p>
<blockquote>
<p>互斥锁(重量级锁)也称为阻塞同步、悲观锁</p>
</blockquote>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>按照对方法加锁的量级，按照synchronized加锁的顺序，从轻到重，依次是：偏向锁-&gt;轻量级锁-&gt;重量级锁</p>
<h1 id="3-计算机组成原理"><a href="#3-计算机组成原理" class="headerlink" title="3.计算机组成原理"></a>3.计算机组成原理</h1><h2 id="为什么寄存器比内存快？"><a href="#为什么寄存器比内存快？" class="headerlink" title="为什么寄存器比内存快？"></a>为什么寄存器比内存快？</h2><p>计算机的存储层次（memory hierarchy）之中，寄存器（register）最快，内存其次，最慢的是硬盘。</p>
<p>同样都是晶体管存储设备，为什么寄存器比内存快呢？</p>
<p><strong>原因一：距离不同</strong></p>
<p>距离不是主要因素，但是最好懂，所以放在最前面说。内存离CPU比较远，所以要耗费更长的时间读取。</p>
<p>以3GHz的CPU为例，电流每秒钟可以振荡30亿次，每次耗时大约为0.33纳秒。光在1纳秒的时间内，可以前进30厘米。也就是说，在CPU的一个时钟周期内，光可以前进10厘米。因此，如果内存距离CPU超过5厘米，就不可能在一个时钟周期内完成数据的读取，这还没有考虑硬件的限制和电流实际上达不到光速。相比之下，寄存器在CPU内部，当然读起来会快一点。</p>
<p>这里说明下：之所以是5厘米而不是10厘米，是因为算的是往返的路程。</p>
<p>距离对于桌面电脑影响很大，对于手机影响就要小得多。手机CPU的时钟频率比较慢（iPhone 5s为1.3GHz），而且手机的内存紧挨着CPU。</p>
<p><strong>原因二：硬件设计不同</strong></p>
<p>苹果公司新推出的iPhone 5s，CPU是A7，寄存器有6000多位（31个64位寄存器，加上32个128位寄存器）。而iPhone 5s的内存是1GB，约为80亿位（bit）。这意味着，高性能、高成本、高耗电的设计可以用在寄存器上，反正只有6000多位，而不能用在内存上。因为每个位的成本和能耗只要增加一点点，就会被放大80亿倍。</p>
<p><strong>原因三：工作方式不同</strong></p>
<p>寄存器的工作方式很简单，只有两步：</p>
<p>（1）找到相关的位</p>
<p>（2）读取这些位</p>
<p>内存的工作方式就要复杂得多：</p>
<p>（1）找到数据的指针。（指针可能存放在寄存器内，所以这一步就已经包括寄存器的全部工作了。）</p>
<p>（2）将指针送往内存管理单元（MMU），由MMU将虚拟的内存地址翻译成实际的物理地址。</p>
<p>（3）将物理地址送往内存控制器（memory controller），由内存控制器找出该地址在哪一根内存插槽（bank）上。</p>
<p>（4）确定数据在哪一个内存块（chunk）上，从该块读取数据。</p>
<p>（5）数据先送回内存控制器，再送回CPU，然后开始使用。</p>
<p>内存的工作流程比寄存器多出许多步。每一步都会产生延迟，累积起来就使得内存比寄存器慢得多。</p>
<p>为了缓解寄存器与内存之间的巨大速度差异，硬件设计师做出了许多努力，包括在CPU内部设置缓存、优化CPU工作方式，尽量一次性从内存读取指令所要用到的全部数据等等。</p>
<h1 id="4-Linux"><a href="#4-Linux" class="headerlink" title="4.Linux"></a>4.Linux</h1><h2 id="线上服务器CPU占用率高如何排查定位问题？"><a href="#线上服务器CPU占用率高如何排查定位问题？" class="headerlink" title="线上服务器CPU占用率高如何排查定位问题？"></a>线上服务器CPU占用率高如何排查定位问题？</h2><p>如果 cpu 很高，但项目的性能却更差了，你会怎么排查？而且还要具体定位到出问题的代码在那里</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&mid=2247485874&idx=1&sn=0edacadb71654e7642832b81d86b6c60&scene=21#wechat_redirect" target="_blank" rel="noopener">参考这篇文章</a></p>
<h1 id="5-数据库"><a href="#5-数据库" class="headerlink" title="5.数据库"></a>5.数据库</h1><h2 id="一条SQL语句执行得很慢的原因有哪些？"><a href="#一条SQL语句执行得很慢的原因有哪些？" class="headerlink" title="一条SQL语句执行得很慢的原因有哪些？"></a>一条SQL语句执行得很慢的原因有哪些？</h2><p>首先说一下总的答案：</p>
<p>一个 SQL 执行的很慢，我们要分两种情况讨论：</p>
<ol>
<li>大多数情况下很正常，偶尔很慢，则有如下原因</li>
</ol>
<p>(1)、数据库在刷新脏页，例如 redo log 写满了需要同步到磁盘。</p>
<p>(2)、执行的时候，遇到锁，如表锁、行锁。</p>
<ol start="2">
<li>这条 SQL 语句一直执行的很慢，则有如下原因。</li>
</ol>
<p>(1)、没有用上索引：例如该字段没有索引；由于对字段进行运算、函数操作导致无法用索引。</p>
<p>(2)、数据库选错了索引(数据库自己预测不使用你的索引能够更快)。主要由于统计失误，导致系统没有走索引，而是走了全表扫描，从而导致某条SQL执行很慢。</p>
<h2 id="什么是数据库的脏读、不可重复读和幻读"><a href="#什么是数据库的脏读、不可重复读和幻读" class="headerlink" title="什么是数据库的脏读、不可重复读和幻读"></a>什么是数据库的脏读、不可重复读和幻读</h2><p>事务的隔离性上，从低到高可能产生的读现象分别是：脏读、不可重复读、幻读。</p>
<p>脏读指读到了未提交的数据。</p>
<p>不可重复读指一次事务内的多次相同查询，读取到了不同的结果。</p>
<p>幻读是不可重复读的特殊场景。一次事务内的多次范围查询得到了不同的结果。</p>
<p>通过在写的时候加锁，可以解决脏读。</p>
<p>通过在读的时候加锁，可以解决不可重复读。</p>
<p>通过串行化，可以解决幻读。</p>
<p>以上这几种解决方案其实是数据库的几种隔离级别。</p>
<h2 id="什么是最左前缀原则？"><a href="#什么是最左前缀原则？" class="headerlink" title="什么是最左前缀原则？"></a>什么是最左前缀原则？</h2><blockquote>
<p>以下回答全部是基于MySQL的InnoDB引擎</p>
</blockquote>
<p>给出一张表作为例子：</p>
<p><img src="https://i.loli.net/2020/03/19/bUCv5cYonpATdFw.png" alt="一个例子.png"></p>
<p>如果我们按照 name 字段来建立索引的话，采用B+树的结构，大概的索引结构如下</p>
<p><img src="https://i.loli.net/2020/03/19/FASYKqlTmbegifL.png" alt="例子索引.png"></p>
<p>如果我们要进行模糊查找，查找name 以“张”开头的所有人的ID，即 sql 语句为</p>
<p><code>select ID from table where name like &#39;张%&#39;</code></p>
<p>由于在B+树结构的索引中，索引项是按照索引定义里面出现的字段顺序排序的，索引在查找的时候，可以快速定位到 ID 为 100的张一，然后直接向右遍历所有张开头的人，直到条件不满足为止。</p>
<p>也就是说，我们找到第一个满足条件的人之后，直接向右遍历就可以了，由于索引是有序的，所有满足条件的人都会聚集在一起。</p>
<p>而这种定位到最左边，然后向右遍历寻找，就是我们所说的<strong>最左前缀原则</strong>。</p>
<h2 id="为什么用-B-树做索引而不用哈希表做索引"><a href="#为什么用-B-树做索引而不用哈希表做索引" class="headerlink" title="为什么用 B+ 树做索引而不用哈希表做索引?"></a>为什么用 B+ 树做索引而不用哈希表做索引?</h2><p>哈希表查找效率是O(1)，二叉树查找效率是O(logn)，那为什么用二叉树不用哈希表呢？</p>
<p>这和业务场景有关。如果只查询一个元素，确实hash表更快，但是数据库经常要选择多条，这时候由于B+树有序，所有value又都保存在叶子节点(操作比B树方便)，而且所有叶子节点都有链表连接，所以效率更高。</p>
<p>1、哈希表是把索引字段映射成对应的哈希码然后再存放在对应的位置，这样的话，如果我们要进行模糊查找的话，显然哈希表这种结构是不支持的，只能遍历这个表。而B+树则可以通过最左前缀原则快速找到对应的数据。</p>
<p>2、如果我们要进行范围查找，例如查找ID为100 ~ 400的人，哈希表同样不支持，只能遍历全表。</p>
<p>3、索引字段通过哈希映射成哈希码，如果很多字段都刚好映射到相同值的哈希码的话，那么形成的索引结构将会是一条很长的链表，这样的话，查找的时间就会大大增加。</p>
<p>4、考虑到磁盘操作，磁盘内存有限，很难保证用哈希表可以一口气全读进去，而B+树支持分批处理，同时树的高度比较低，可以提高查重效率。</p>
<h2 id="主键索引和非主键索引有什么区别？"><a href="#主键索引和非主键索引有什么区别？" class="headerlink" title="主键索引和非主键索引有什么区别？"></a>主键索引和非主键索引有什么区别？</h2><p>例如对于下面这个表(其实就是上面的表中增加了一个k字段),且ID是主键。</p>
<p><img src="https://i.loli.net/2020/03/19/ELdCNXhp75QSmis.png" alt="加了个非主键索引.png"></p>
<p>主键索引和非主键索引的示意图如下：</p>
<p><img src="https://i.loli.net/2020/03/19/6WRaFfuOPVtTJeE.png" alt="主键索引和非主键索引.png"></p>
<p>其中R代表一整行的值。</p>
<p>从图中不难看出，主键索引和非主键索引的区别是：非主键索引的叶子节点存放的是<strong>主键的值</strong>，而主键索引的叶子节点存放的是<strong>整行数据</strong>，其中非主键索引也被称为<strong>二级索引</strong>，而主键索引也被称为<strong>聚簇索引</strong>。</p>
<p>根据这两种结构我们来进行下查询，看看他们在查询上有什么区别。</p>
<ol>
<li><p>如果查询语句是 select * from table where ID = 100,即主键查询的方式，则只需要搜索 ID 这棵 B+树。</p>
</li>
<li><p>如果查询语句是 select * from table where k = 1，即非主键的查询方式，则先搜索k索引树，得到ID=100,再到ID索引树搜索一次，这个过程也被称为回表。</p>
</li>
</ol>
<h2 id="为什么建议使用主键自增的索引？"><a href="#为什么建议使用主键自增的索引？" class="headerlink" title="为什么建议使用主键自增的索引？"></a>为什么建议使用主键自增的索引？</h2><p>对于这颗主键索引的树</p>
<p><img src="https://i.loli.net/2020/03/19/4AOKQ8fG3ipCJZz.png" alt="主键的索引树.png"></p>
<p>如果我们插入 ID = 650 的一行数据，那么直接在最右边插入就可以了</p>
<p><img src="https://i.loli.net/2020/03/19/KIRLVOkxsPr58gz.png" alt="主键的索引树插入数据.png"></p>
<p>但是如果插入的是 ID = 350 的一行数据，由于 B+ 树是有序的，那么需要将下面的叶子节点进行移动，腾出位置来插入 ID = 350 的数据，这样就会比较消耗时间，如果刚好 R4 所在的数据页已经满了，需要进行页分裂操作，这样会更加糟糕。</p>
<p>但是，如果我们的主键是自增的，每次插入的 ID 都会比前面的大，那么我们每次只需要在后面插入就行， 不需要移动位置、分裂等操作，这样可以提高性能。也就是为什么建议使用主键自增的索引。</p>
<h2 id="MyISAM与InnoDB的区别"><a href="#MyISAM与InnoDB的区别" class="headerlink" title="MyISAM与InnoDB的区别"></a>MyISAM与InnoDB的区别</h2><h3 id="1-两者对比"><a href="#1-两者对比" class="headerlink" title="1.两者对比"></a>1.两者对比</h3><ol>
<li><p><strong>count运算上的区别</strong>： 因为MyISAM缓存有表meta-data（行数等），因此在做COUNT(*)时对于一个结构很好 的查询是不需要消耗多少资源的。而对于InnoDB来说，则没有这种缓存 </p>
</li>
<li><p><strong>是否支持事务和崩溃后的安全恢复</strong>： MyISAM 强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型 更快，但是不提供事务支持。但是InnoDB 提供事务支持事务，外部键等高级数据库功能。 具有事务 (commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。 </p>
</li>
<li><p><strong>是否支持外键</strong>： MyISAM不支持，而InnoDB支持。 </p>
</li>
</ol>
<h3 id="2-两者总结"><a href="#2-两者总结" class="headerlink" title="2.两者总结"></a>2.两者总结</h3><p>MyISAM更适合读密集的表，而InnoDB更适合写密集的的表。 在数据库做主从分离的情况下，经常选择MyISAM作 为主库的存储引擎。</p>
<p>一般来说，如果需要事务支持，并且有较高的并发读取频率(MyISAM的表锁的粒度太大，所以当该表写并发量较高 时，要等待的查询就会很多了)，InnoDB是不错的选择。如果你的数据量很大（MyISAM支持压缩特性可以减少磁盘 的空间占用），而且不需要支持事务时，MyISAM是好的选择。 </p>
<h1 id="6-Java相关"><a href="#6-Java相关" class="headerlink" title="6.Java相关"></a>6.Java相关</h1><h2 id="Java的线程状态有哪些？它是如何工作的？-重要"><a href="#Java的线程状态有哪些？它是如何工作的？-重要" class="headerlink" title="Java的线程状态有哪些？它是如何工作的？(重要**)"></a>Java的线程状态有哪些？它是如何工作的？(重要**)</h2><p>线程(Thread)是并发编程的基础，它是程序执行的最小单元。一个进程可以包含多个线程，多线程可以共享一块内存空间和一组系统资源，因此线程之间的切换更节省资源，也因为如此，线程常被成为轻量级的进程。</p>
<p>对线程的掌握，可以有效地提高程序整体运行效率。</p>
<h3 id="Java线程状态在JDK1-5后一共有六个"><a href="#Java线程状态在JDK1-5后一共有六个" class="headerlink" title="Java线程状态在JDK1.5后一共有六个"></a>Java线程状态在JDK1.5后一共有六个</h3><p>Java线程状态在JDK1.5后以枚举的方式定义在Thread的源码中，一共有六个状态</p>
<ul>
<li>NEW新建状态，线程被创建出来，但尚未启动时的线程状态；</li>
<li>RUNNABLE,就绪状态，表示可以运行的线程状态，它可能正在运行，或者是在排队等待操作系统给它分配 CPU 资源；</li>
<li>BLOCKED，阻塞等待锁的线程状态，表示处于阻塞状态的线程正在等待监视器锁，比如等待执行 synchronized 代码块或者使用 synchronized 标记的方法； </li>
<li>WAITING，等待状态，一个处于等待状态的线程正在等待另一个线程执行某个特定的动作，比如，一个线程调用了Object.wait()方法，那它就在等待另一个线程调用Object.notify()或Objec.botifyAll()方法;</li>
<li>TIMED_WAITING,计时等待状态，和等待状态(WAITING)类似，它只是多了超时时间，比如调用了有超时时间设置的方法 Object.wait(long timeout) 和 Thread.join(long timeout) 等这些方法时，它才会进入此状态；</li>
<li>TERMINATED,终止状态，表示线程已经执行完成</li>
</ul>
<h4 id="线程如何工作的？——线程工作模式"><a href="#线程如何工作的？——线程工作模式" class="headerlink" title="线程如何工作的？——线程工作模式"></a>线程如何工作的？——线程工作模式</h4><p>线程的工作模式是，首先先要创建线程并指定线程需要执行的业务方法，然后再调用线程的start()方法，此时线程就从NEW（新建）状态变成了RUNNABLE（就绪）状态，此时线程会判断要执行的方法中有没有 synchronized 同步代码块，如果有并且其他线程也在使用此锁，那么线程就会变为 BLOCKED（阻塞等待）状态，当其他线程使用完此锁之后，线程会继续执行剩余的方法。</p>
<p>当遇到Object.wait()或Thread.join()方法时，线程会变为WAITING（等待状态）状态，如果是带了超时时间的等待方法，那么线程会进入TIMED_WAITING（计时等待）状态，当有其他线程执行了 notify() 或 notifyAll() 方法之后，线程被唤醒继续执行剩余的业务方法，直到方法执行完成为止，此时整个线程的流程就执行完了，执行流程如下图所示：</p>
<p><img src="https://i.loli.net/2020/03/26/a7vAHYK6h23Xf5L.png" alt="Java多线程工作流程.png"></p>
<h2 id="Java创建新线程有几种方式？"><a href="#Java创建新线程有几种方式？" class="headerlink" title="Java创建新线程有几种方式？"></a>Java创建新线程有几种方式？</h2><p>一般来说有四种方式：</p>
<ol>
<li>继承Thread类(真正意义上的线程类)，这个类是Runnable接口的实现，继承之后重写run()方法，在这个方法里写出来该线程具体要完成的任务。</li>
<li>自己实现Runnable接口，重写里面的run方法，创建线程类</li>
<li>使用Executor框架创建线程池(<strong>需要注意，阿里巴巴的《Java开发手册》不允许用Executors区创建线程池，而要用ThreadPoolExecutor的方式，这样可以更加明确线程池的运行规则，规避资源耗尽的风险</strong>)。Executor框架是JUC里提供的线程池实现的。</li>
<li>通过Callable和Future创建线程</li>
</ol>
<p>虽然最常用的是四种，但是继承Thread类和实现Runnable接口是最常用的。而且更加提倡的是使用实现Runnable接口的方式。实现Runnable接口的优势：</p>
<p>①避免点继承的局限，一个类可以继承多个接口。</p>
<p>②适合于资源的共享</p>
<h2 id="BLOCKED-阻塞等待-和WAITING-等待-有什么区别？"><a href="#BLOCKED-阻塞等待-和WAITING-等待-有什么区别？" class="headerlink" title="BLOCKED(阻塞等待)和WAITING(等待)有什么区别？"></a>BLOCKED(阻塞等待)和WAITING(等待)有什么区别？</h2><p>虽然BLOCKED和WAITING都有等待的含义，但二者有着本质的区别，首先它们状态形成的调用方法不同，其次BLOCKED可以理解为当前线程还处于活跃状态，只是在阻塞等待其他线程使用完某个锁资源；而WAITING则是因为自身调用了Object.wait()或着是Thread.join()又或者是LockSupport.park()而进入等待状态，只能等待其他线程执行某个特定的动作才能被继续唤醒，比如当线程因为调用了 Object.wait() 而进入 WAITING 状态之后，则需要等待另一个线程执行Object.notify() 或 Object.notifyAll() 才能被唤醒。</p>
<h2 id="start-方法和run-方法有什么区别？"><a href="#start-方法和run-方法有什么区别？" class="headerlink" title="start()方法和run()方法有什么区别？"></a>start()方法和run()方法有什么区别？</h2><p>首先从 Thread 源码来看，start() 方法属于 Thread 自身的方法，并且使用了 synchronized 来保证线程安全。</p>
<p>run() 方法为 Runnable 的抽象方法，必须由调用类重写此方法，重写的 run() 方法其实就是此线程要执行的业务方法，源码如下：</p>
<p>从执行的效果来说，start() 方法可以开启多线程，让线程从 NEW 状态转换成 RUNNABLE 状态，而 run() 方法只是一个普通的方法。</p>
<p>其次，它们可调用的次数不同，start()方法不能被多次调用，否则会抛出java.lang.IllegalStateException；而run()方法可以进行多次调用，因为它只是一个普通的方法而已。</p>
<h2 id="线程的优先级有什么用？如何设置优先级？"><a href="#线程的优先级有什么用？如何设置优先级？" class="headerlink" title="线程的优先级有什么用？如何设置优先级？"></a>线程的优先级有什么用？如何设置优先级？</h2><p>Thread源码中与线程优先级相关的属性有3个：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程可以拥有的最小优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> static <span class="built_in">int</span> MIN_PRIORITY =<span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程默认优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> static <span class="built_in">int</span> NORM_PNORM_PRIORITY = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程可以拥有的最大优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> static <span class="built_in">int</span> MAX_PRIORITY = <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>线程的优先级可以理解为线程抢占 CPU 时间片的概率，优先级越高的线程优先执行的概率就越大，但并不能保证优先级高的线程一定先执行。</p>
<p>在程序中我们可以通过Thread.setPriority()来设置优先级。</p>
<h2 id="线程常用方法有哪些？"><a href="#线程常用方法有哪些？" class="headerlink" title="线程常用方法有哪些？"></a>线程常用方法有哪些？</h2><h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><p>在一个线程中调用join()，会让当前线程交出执行权给other线程，直到other线程执行完或者过了超时时间之后再继续执行当前线程。</p>
<p>在源码中可以看到，join()方法底层是通过wait()方法实现的。</p>
<p>举个例子：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">    public static <span class="literal">void</span> main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread<span class="function"><span class="params">(() -&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">try</span> &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                   Thread.sleep(<span class="number">1000</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                   e.printStackTrace();</span></span></span><br><span class="line"><span class="function"><span class="params">               &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">               System.out.println(<span class="string">"子线程睡眠："</span> + i + <span class="string">"秒"</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">           &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">        &#125;)</span>;</span></span><br><span class="line"><span class="function">        <span class="title">thread</span>.<span class="title">start</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">        <span class="title">for</span> <span class="params">(int i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++)</span> &#123;</span></span><br><span class="line"><span class="function">            <span class="title">Thread</span>.<span class="title">sleep</span><span class="params">(<span class="number">1000</span>)</span>;</span></span><br><span class="line"><span class="function">            <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(<span class="string">"主线程睡眠："</span> + i + <span class="string">"秒"</span>)</span>;</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这段代码的执行结果：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">主线程睡眠：<span class="number">1</span>秒</span><br><span class="line">子线程睡眠：<span class="number">1</span>秒</span><br><span class="line">主线程睡眠：<span class="number">2</span>秒</span><br><span class="line">子线程睡眠：<span class="number">2</span>秒</span><br><span class="line">主线程睡眠：<span class="number">3</span>秒</span><br><span class="line">子线程睡眠：<span class="number">3</span>秒</span><br><span class="line">子线程睡眠：<span class="number">4</span>秒</span><br><span class="line">子线程睡眠：<span class="number">5</span>秒</span><br><span class="line">子线程睡眠：<span class="number">6</span>秒</span><br></pre></td></tr></table></figure>

<p>可以看到，不使用join()的时候，主线程和子线程会交替执行。</p>
<p>然后加入join()方法：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">    public static <span class="literal">void</span> main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread<span class="function"><span class="params">(() -&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">try</span> &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                   Thread.sleep(<span class="number">1000</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                   e.printStackTrace();</span></span></span><br><span class="line"><span class="function"><span class="params">               &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">               System.out.println(<span class="string">"子线程睡眠："</span> + i + <span class="string">"秒"</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">           &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">        &#125;)</span>;</span></span><br><span class="line"><span class="function">        <span class="title">thread</span>.<span class="title">start</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">        <span class="title">thread</span>.<span class="title">join</span><span class="params">(<span class="number">4000</span>)</span>;</span></span><br><span class="line"><span class="function">        <span class="title">for</span> <span class="params">(int i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++)</span> &#123;</span></span><br><span class="line"><span class="function">            <span class="title">Thread</span>.<span class="title">sleep</span><span class="params">(<span class="number">1000</span>)</span>;</span></span><br><span class="line"><span class="function">            <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(<span class="string">"主线程睡眠："</span> + i + <span class="string">"秒"</span>)</span>;</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">子线程睡眠：<span class="number">1</span>秒</span><br><span class="line">子线程睡眠：<span class="number">2</span>秒</span><br><span class="line">子线程睡眠：<span class="number">3</span>秒</span><br><span class="line">子线程睡眠：<span class="number">4</span>秒</span><br><span class="line">主线程睡眠：<span class="number">1</span>秒</span><br><span class="line">子线程睡眠：<span class="number">5</span>秒</span><br><span class="line">主线程睡眠：<span class="number">2</span>秒</span><br><span class="line">子线程睡眠：<span class="number">6</span>秒</span><br><span class="line">主线程睡眠：<span class="number">3</span>秒</span><br></pre></td></tr></table></figure>

<p>可以看到用了join()方法之后，子线程会先<code>join</code>进来执行4秒，之后才会执行主线程。</p>
<h3 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h3><p>通过Thread()源码可以知道yield()为本地方法，也就是说yield()是由C/C++实现的。</p>
<p>yield() 方法表示给线程调度器一个当前线程愿意出让 CPU 使用权的暗示，但是线程调度器可能会忽略这个暗示。</p>
<p>执行一段包含yield()方法的代码之后会发现，每次执行的结果都不相同，这是因为yield()执行非常不稳定，线程调度器不一定会采纳yield()出让CPU使用权的建议，从而导致了这样的结果。</p>
<h2 id="volatile的作用"><a href="#volatile的作用" class="headerlink" title="volatile的作用"></a>volatile的作用</h2><p>两个：保证可见性（这里指主内存与工作内存间的可见性），防止指令重排（指令重排也会导致可见性问题）</p>
<h3 id="什么是可见性？"><a href="#什么是可见性？" class="headerlink" title="什么是可见性？"></a>什么是可见性？</h3><p>意思就是说，在多线程环境下，某个共享变量如果被其中一个线程给修改了，其他线程能够立即知道这个共享变量已经被修改了，当其他线程要读取这个变量的时候，最终会去内存中读取，而不是从自己的工作空间中读取.</p>
<h3 id="如何保证内存可见性？"><a href="#如何保证内存可见性？" class="headerlink" title="如何保证内存可见性？"></a>如何保证内存可见性？</h3><p>答：volatile修饰的变量保证其每个写操作后都更新到主内存，每个读操作都到主内存中更新，具体的话是在JVM层面，在修饰的变量前后加关键字。</p>
<blockquote>
<p>NOTE：Java内存模型规定所有的变量都是存在<strong>(主内存)主存</strong>当中（类似于前面说的物理内存），每个线程都有自己的<strong>工作内存</strong>（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的<strong>工作内存</strong>。</p>
<p>由于java中的每个线程有自己的工作空间，这种工作空间相当于上面所说的高速缓存，因此多个线程在处理一个<strong>共享变量</strong>的时候，就会出现线程安全问题。</p>
<p>所谓共享变量，是能够被多个线程访问到的变量。在java中共享变量包括实例变量，静态变量，数组元素。他们都被存放在堆内存中。</p>
</blockquote>
<h3 id="什么是指令重排？"><a href="#什么是指令重排？" class="headerlink" title="什么是指令重排？"></a>什么是指令重排？</h3><p>当我们把代码写好之后，虚拟机不一定会按照我们写的代码的顺序来执行。例如对于下面的两句代码：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">int</span> b = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>对于这两句代码，你会发现无论是先执行a = 1还是执行b = 2，都不会对a,b最终的值造成影响。所以虚拟机在编译的时候，是有可能把他们进行<strong>重排序</strong>的。</p>
<p>对于这两句代码，你会发现无论是先执行a = 1还是执行b = 2，都不会对a,b最终的值造成影响。所以虚拟机在编译的时候，是有可能把他们进行重排序的。</p>
<p>指令重排是JVM做出的优化，这里Java的双check的单例模式也利用了volatile来保证不重排。</p>
<h3 id="volatile真的能完全保证一个变量的线程安全么？"><a href="#volatile真的能完全保证一个变量的线程安全么？" class="headerlink" title="volatile真的能完全保证一个变量的线程安全么？"></a>volatile真的能完全保证一个变量的线程安全么？</h3><p>volatile好像很有用，不但能够保证变量可见性，还能防止指令重排。</p>
<p>那么，它真的能够保证一个变量在多线程环境下都能被正确的使用吗？</p>
<p>答案是否定的。原因是因为Java里面的运算并非是原子操作，volatile也不能是原子性的。</p>
<h4 id="原子性-原子操作"><a href="#原子性-原子操作" class="headerlink" title="原子性\原子操作"></a>原子性\原子操作</h4><p><strong>原子操作</strong>：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p>
<p>也就是说，处理器要嘛把这组操作全部执行完，中间不允许被其他操作所打断，要嘛这组操作不要执行。</p>
<p>刚才说Java里面的运行并非是原子操作。我举个例子，例如这句代码</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a = b + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>处理器在处理代码的时候，需要处理以下三个操作：</p>
<ol>
<li><p>从内存中读取b的值。</p>
</li>
<li><p>进行a = b + 1这个运算</p>
</li>
<li><p>把a的值写回到内存中</p>
</li>
</ol>
<p>而这三个操作处理器是不一定就会连续执行的，有可能执行了第一个操作之后，处理器就跑去执行别的操作的。</p>
<h3 id="什么情况下volatile可以保证线程安全"><a href="#什么情况下volatile可以保证线程安全" class="headerlink" title="什么情况下volatile可以保证线程安全"></a>什么情况下volatile可以保证线程安全</h3><p>刚才虽然说，volatile关键字不一定能够保证线程安全的问题，其实，在大多数情况下volatile还是可以保证变量的线程安全问题的。所以，在满足以下两个条件的情况下，volatile就能保证变量的线程安全问题：</p>
<ol>
<li><p>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</p>
</li>
<li><p>变量不需要与其他状态变量共同参与不变约束。</p>
</li>
</ol>
<h2 id="ThreadPoolExecutor介绍"><a href="#ThreadPoolExecutor介绍" class="headerlink" title="ThreadPoolExecutor介绍"></a>ThreadPoolExecutor介绍</h2><p>线程池的使用必须要通过ThreadPoolExecutor的方式来创建，这样才可以更加明确线程池的运行规则，规避资源耗尽的风险。</p>
<p>ThreadPoolExecutor有七大核心参数,包括核心线程数和最大线程数之间的区别，当线程池的任务队列没有可用空间且线程池的线程数量已经达到了最大线程数时，则会执行拒绝策略，Java 自动的拒绝策略有 4 种，用户也可以通过重写rejectedExecution()来自定义拒绝策略，我们还可以通过重写beforeExecute()和afterExecute()来实现ThreadPoolExecutor的扩展功能。</p>
<h2 id="线程池——ThreadPoolExecutor参数含义及源码执行流程？"><a href="#线程池——ThreadPoolExecutor参数含义及源码执行流程？" class="headerlink" title="线程池——ThreadPoolExecutor参数含义及源码执行流程？"></a>线程池——ThreadPoolExecutor参数含义及源码执行流程？</h2><p>线程池是为了避免线程频繁的创建和销毁带来的性能消耗，而建立的一种池化技术，它是把已创建的线程放入“池”中，当有任务来临时就可以重用已有的线程，无需等待创建的过程，这样就可以有效提高程序的响应速度。</p>
<p>而说到线程池，现在一定离不开<code>ThreadPoolExecutor</code>，现在不推荐用<code>Executors</code>去创建线程池了。阿里巴巴的《Java开发手册》中这样规定创建线程池的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的读者更加明确线程池的运行规则，规避资源耗尽的风险。</span><br></pre></td></tr></table></figure>

<h3 id="ThreadPoolExecutor一共有七个核心参数"><a href="#ThreadPoolExecutor一共有七个核心参数" class="headerlink" title="ThreadPoolExecutor一共有七个核心参数"></a>ThreadPoolExecutor一共有七个核心参数</h3><p>第1个参数：corePoolSize表示线程池的常驻核心线程数。如果设置为0，则表示在没有任何任务时，销毁线程池；如果大于0，即使没有任务时也会保证线程池的线程数量等于此值。但需要注意，此值如果设置的比较小，则会频繁的创建和销毁线程；如果设置的比较大，则会浪费系统资源，所以开发者需要根据自己的实际业务来调整此值。</p>
<p>第2个参数：maximumPoolSize表示线程池在任务最多时，最大可以创建的线程数。官方规定此值必须大于0，也必须大于等于corePoolSize，此值只有在任务比较多，且不能存放在任务队列时，才会用到。</p>
<p>第3个参数：keepAliveTime表示线程的存活时间，当线程池空闲时并且超过了此时间，多余的线程就会销毁，直到线程池中的线程数量销毁的等于corePoolSize为止，如果 maximumPoolSize 等于 corePoolSize，那么线程池在空闲的时候也不会销毁任何线程。</p>
<p>第 4 个参数：unit 表示存活时间的单位，它是配合 keepAliveTime 参数共同使用的。</p>
<p>第 5 个参数：workQueue 表示线程池执行的任务队列，当线程池的所有线程都在处理任务时，如果来了新任务就会缓存到此任务队列中排队等待执行。</p>
<p>第 6 个参数：threadFactory 表示线程的创建工厂，此参数一般用的比较少，我们通常在创建线程池时不指定此参数，它会使用默认的线程创建工厂的方法来创建线程。</p>
<p>第7个参数：RejectedExecutionHandler表示指定线程池的拒绝策略，当线程池的任务已经在缓存队列workQueue中存储满了之后，并且不能创建新的线程来执行此任务时，就会用到此拒绝策略，它属于一种限流保护的机制。</p>
<h3 id="线程池-ThreadPoolExecutor-执行流程"><a href="#线程池-ThreadPoolExecutor-执行流程" class="headerlink" title="线程池(ThreadPoolExecutor)执行流程"></a>线程池(ThreadPoolExecutor)执行流程</h3><p>通过<code>executor()</code>方法开始执行，如果当前工作线程数(workerCount)小于核心线程数，会创建新的线程执行这个任务。</p>
<p>然后检查线程池是否处于运行状态，是的话把任务添加到队列。如果线程池处于非运行状态，而且处于爆满，并且尝试新启动一个线程失败了，那么执行拒绝策略。</p>
<p>重点方法：<code>addWorker(Runnable firstTask, boolean core)</code>两个方法参数如下：</p>
<ul>
<li><p>firstTask，线程应首先运行的任务，如果没有则可以设置为 null；</p>
</li>
<li><p>core，判断是否可以创建线程的阀值（最大值），如果等于 true 则表示使用 corePoolSize 作为阀值，false 则表示使用 maximumPoolSize 作为阀值。</p>
</li>
</ul>
<p>具体流程可以参考这张图：</p>
<p><img src="https://i.loli.net/2020/03/27/z48VkDrqOcN9Yug.png" alt="ThreadPoolExecutor执行流程.png"></p>
<h3 id="使用Executors返回线程池对象的弊端"><a href="#使用Executors返回线程池对象的弊端" class="headerlink" title="使用Executors返回线程池对象的弊端"></a>使用Executors返回线程池对象的弊端</h3><p>主要两点：</p>
<ol>
<li><p>FixedThreadPool 和 SingleThreadPool：允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。</p>
</li>
<li><p>CachedThreadPool 和 ScheduledThreadPool：允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</p>
</li>
</ol>
<h2 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h2><p>当线程池中的任务队列已经被存满，再有任务添加时会先判断当前线程池中的线程数是否大于等于线程池的最大值，如果是，则会触发线程池的拒绝策略。</p>
<p>Java 自带的拒绝策略有 4 种：</p>
<ul>
<li>AbortPolicy，终止策略，线程池会抛出异常并终止执行，它是默认的拒绝策略；</li>
<li>CallerRunsPolicy，把任务交给当前线程来执行</li>
<li>DiscardPolicy，忽略此任务（最新的任务）；</li>
<li>DiscardOldestPolicy，忽略最早的任务（最先加入队列的任务）。</li>
</ul>
<h3 id="自定义拒绝策略"><a href="#自定义拒绝策略" class="headerlink" title="自定义拒绝策略"></a>自定义拒绝策略</h3><p>自定义拒绝策略只需要新建一个 <strong>RejectedExecutionHandler</strong> 对象，然后重写它的 <strong>rejectedExecution()</strong> 方法即可。</p>
<h3 id="ThreadPoolExecutor扩展"><a href="#ThreadPoolExecutor扩展" class="headerlink" title="ThreadPoolExecutor扩展"></a>ThreadPoolExecutor扩展</h3><p>ThreadPoolExecutor的扩展主要是通过重写它的<strong>beforeExecute()</strong>和<strong>afterExecute()</strong>方法实现的，我们可以在扩展方法中添加日志或者实现数据统计，比如统计线程的执行时间。</p>
<p>展示代码暂时略。</p>
<h2 id="搞懂synchronized-从偏量锁到重量级锁"><a href="#搞懂synchronized-从偏量锁到重量级锁" class="headerlink" title="搞懂synchronized(从偏量锁到重量级锁)"></a>搞懂synchronized(从偏量锁到重量级锁)</h2><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&mid=2247485257&idx=1&sn=0ab85e4cd8b575fe5c01b269dda007f5&source=41&scene=21#wechat_redirect" target="_blank" rel="noopener">本部分参考这篇文章</a></p>
<p>接触过线程安全的同学想必都使用过synchronized这个关键字，在java同步代码快中，synchronized的使用方式无非有两个:</p>
<ol>
<li>通过对一个对象进行加锁来实现同步，如下面代码。</li>
</ol>
<p><code>synchronized(lockObject){    //代码}</code></p>
<ol start="2">
<li>对一个方法进行synchronized声明，进而对一个方法进行加锁来实现同步。如下面代码</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> synchornized <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这里需要指出的是，无论是对一个对象进行加锁还是对一个方法进行加锁，实际上，都是对<strong>对象进行加锁</strong>。</p>
<p>也就是说，对于方式2，实际上虚拟机会根据synchronized修饰的是实例方法还是类方法，去取对应的实例对象或者Class对象来进行加锁。</p>
<blockquote>
<p>synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者 代码块在任意时刻只能有一个线程执行。</p>
</blockquote>
<p>另外，在 Java 早期版本(JDK1.6之前)中，synchronized属于重量级锁，效率低下，因为监视器锁（<strong>monitor,在Java中每个对象都隐式包含一个monitor（监视器）对象，加锁的过程其实就是竞争monitor的过程，当线程进入字节码monitorenter指令之后，线程将持有monitor对象，执行 monitorexit 时释放 monitor 对象，当其他线程没有拿到 monitor 对象时，则需要阻塞等待获取该对象。</strong> ）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程， 都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要 相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对 锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的 开销。</p>
<h2 id="synchronized和ReentrantLock-两者的实现原理？两者的区别？"><a href="#synchronized和ReentrantLock-两者的实现原理？两者的区别？" class="headerlink" title="synchronized和ReentrantLock,两者的实现原理？两者的区别？"></a>synchronized和ReentrantLock,两者的实现原理？两者的区别？</h2><p>在JDK1.5之前共享对象的协调机制只有synchronized和volatile，在JDK1.5中增加了新的机制ReentrantLock，该机制的诞生并不是为了替代synchronized而是在 synchronized 不适用的情况下，提供一种可以选择的高级功能。</p>
<p>注意synchronized：synchronized关键字加到非 static 静态 方法上是给对象实例上锁。另外需要注意的是：尽量不要使用 synchronized(String a) 因为JVM中，字符串常量 池具有缓冲功能！</p>
<h3 id="synchronized和ReentrantLock原理"><a href="#synchronized和ReentrantLock原理" class="headerlink" title="synchronized和ReentrantLock原理"></a>synchronized和ReentrantLock原理</h3><p>synchronized 属于独占式悲观锁，是通过 JVM 隐式实现的.</p>
<p>synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者 代码块在任意时刻只能有一个线程执行。</p>
<p>synchronized的一个例子就是单例模式的双检查模式中对类加锁的操作。</p>
<p>ReentrantLock是Lock的默认实现方式之一，它是基于AQS（AbstractQueuedSynchronizer，队列同步器）实现的，它默认是通过非公平锁实现的，在它的内部有一个 state 的状态字段用于表示锁是否被占用，如果是 0 则表示锁未被占用，此时线程就可以把 state 改为 1，并成功获得锁，而其他未获得锁的线程只能去排队等待获取锁资源。</p>
<h3 id="synchronized和ReentrantLock共同点与区别"><a href="#synchronized和ReentrantLock共同点与区别" class="headerlink" title="synchronized和ReentrantLock共同点与区别"></a>synchronized和ReentrantLock共同点与区别</h3><h4 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h4><p><strong>两者都是可重入锁</strong></p>
<p>两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时 这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p>
<h4 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h4><p>① synchronized 依赖于 JVM 而 ReenTrantLock 依赖于 API</p>
<p>synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多 优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReenTrantLock 是 JDK 层面实现的（也就 是 API 层面，需要 lock() 和 unlock 方法配合 try/ﬁnally 语句块来完成），所以我们可以通过查看它的源代码，来看 它是如何实现的。</p>
<p>②  ReenTrantLock 比 synchronized 增加了一些高级功能 </p>
<p>相比synchronized，ReenTrantLock增加了一些高级功能。主要来说主要有三点：</p>
<ol>
<li>等待可中断；</li>
<li>可实现公平锁； </li>
<li>可实现选择性通知（锁可以绑定多个条件）</li>
</ol>
<ul>
<li><p><strong>ReenTrantLock提供了一种能够中断等待锁的线程的机制</strong>，通过lock.lockInterruptibly()来实现这个机制。也 就是说正在等待的线程可以选择放弃等待，改为处理其他事情。 </p>
</li>
<li><p><strong>ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁</strong>。所谓的公平锁就是先等 待的线程先获得锁。 ReenTrantLock默认情况是非公平的，可以通过 ReenTrantLock类的 <code>ReentrantLock(boolean fair)</code> 构造方法来制定是否是公平的。 </p>
</li>
<li><p>synchronized关键字与wait()和notify/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也 可以实现，但是需要借助于Condition接口与newCondition() 方法。Condition是JDK1.5之后才有的，它具有很 好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视 器），<strong>线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合 Condition实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是Condition接口默认提供的。而 synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的 signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。 </p>
</li>
</ul>
<h2 id="“synchronized和ReentrantLock共同点与区别”的典型回答-重要"><a href="#“synchronized和ReentrantLock共同点与区别”的典型回答-重要" class="headerlink" title="“synchronized和ReentrantLock共同点与区别”的典型回答(重要)"></a>“synchronized和ReentrantLock共同点与区别”的典型回答(重要)</h2><p>synchronized 属于独占式悲观锁，是通过 JVM 隐式实现的，synchronized 只允许同一时刻只有一个线程操作资源。</p>
<p>在Java中每个对象都隐式包含一个monitor（监视器）对象，加锁的过程其实就是竞争monitor的过程，当线程进入字节码monitorenter指令之后，线程将持有monitor对象，执行 monitorexit 时释放 monitor 对象，当其他线程没有拿到 monitor 对象时，则需要阻塞等待获取该对象。  </p>
<p>ReentrantLock 是 Lock 的默认实现方式之一，它是基于 AQS（Abstract Queued Synchronizer，队列同步器）实现的，它默认是通过非公平锁实现的，在它的内部有一个 state 的状态字段用于表示锁是否被占用，如果是 0 则表示锁未被占用，此时线程就可以把 state 改为 1，并成功获得锁，而其他未获得锁的线程只能去排队等待获取锁资源。</p>
<p>synchronized和ReentrantLock都提供了锁的功能，具备互斥性和不可见性。在JDK1.5中synchronized的性能远远低于ReentrantLock，但在 JDK 1.6 之后  synchronized 的性能略低于  ReentrantLock，它的区别如下(四点)：</p>
<ul>
<li>synchronized是JVM隐式实现的，而ReentrantLock是Java语言提供的API；ReentrantLock可设置为公平锁，而synchronized却不行；</li>
<li>ReentrantLock只能修饰代码块，而synchronized可以用于修饰方法、修饰代码块等；</li>
<li>ReentrantLock需要手动加锁和释放锁，如果忘记释放锁，则会造成资源被永久占用，而 synchronized 无需手动释放锁；</li>
<li>ReentrantLock 可以知道是否成功获得了锁，而 synchronized  却不行。</li>
</ul>
<h2 id="公平锁-VS-非公平锁"><a href="#公平锁-VS-非公平锁" class="headerlink" title="公平锁 VS 非公平锁"></a>公平锁 VS 非公平锁</h2><p>先介绍一下什么是公平锁和非公平锁。</p>
<p>公平锁的含义是线程需要按照请求的顺序来获得锁；而非公平锁则允许“插队”的情况存在，所谓的“插队”指的是，线程在发送请求的同时该锁的状态恰好变成了可用，那么此线程就可以跳过队列中所有排队的线程直接拥有该锁。</p>
<p>而公平锁由于有挂起和恢复所以存在一定的开销，因此性能不如非公平锁，所以 <strong>ReentrantLock 和 synchronized 默认都是非公平锁的实现方式</strong>。</p>
<h2 id="ReentrantLock详细介绍-源码分析，主要针对加锁和解锁的流程"><a href="#ReentrantLock详细介绍-源码分析，主要针对加锁和解锁的流程" class="headerlink" title="ReentrantLock详细介绍(源码分析，主要针对加锁和解锁的流程)"></a>ReentrantLock详细介绍(源码分析，主要针对加锁和解锁的流程)</h2><p>本课时从源码出发来解密 ReentrantLock 的具体实现细节，首先来看 ReentrantLock 的两个构造函数：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public <span class="constructor">ReentrantLock()</span> &#123;</span><br><span class="line">	sync = <span class="keyword">new</span> <span class="constructor">NonfairSync()</span>; <span class="comment">// 非公平锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="constructor">ReentrantLock()</span> &#123;</span><br><span class="line">	sync = fair ? <span class="keyword">new</span> <span class="constructor">FairSync()</span> : <span class="keyword">new</span> <span class="constructor">NonfairSync()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无参的构造函数创建了一个<em>非公平锁</em>，用户也可以根据第二个构造函数，设置一个 boolean 类型的值，来决定是否使用公平锁来实现线程的调度。</p>
<p>ReentrantLock默认使用lock()来获取锁的，并通过unlock()释放锁，样例代码如下：</p>
<figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Lock</span> <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock()<span class="comment">;</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">// 加锁</span></span><br><span class="line">	<span class="keyword">lock</span>.<span class="keyword">lock</span>()<span class="comment">;</span></span><br><span class="line">	<span class="comment">// .....业务处理</span></span><br><span class="line">&#125; finally &#123;</span><br><span class="line">	<span class="comment">// 释放锁，这里别忘了，否则会造成资源被永久占用</span></span><br><span class="line">	<span class="keyword">lock</span>.unlock()<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color=#FF0000>先来重点看一下lock()的过程</font>：</p>
<p>ReentrantLock中的lock()是通过sync.lock()实现的，但Sync类中的lock()是一个抽象方法，需要子类NonfairSync或FairSync去实现，NonfairSync中的lock()源码如下：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="built_in">void</span> lock() &#123;</span><br><span class="line">	<span class="keyword">if</span>(compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">		<span class="comment">// 将当前线程设置为此锁的持有者</span></span><br><span class="line">		setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FairSync中的lock()源码如下：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="built_in">void</span> lock() &#123;</span><br><span class="line">	acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出非公平锁比公平锁只是多了一行 compareAndSetState 方法，该方法是尝试将 state 值由 0 置换为 1，如果设置成功的话，则说明当前没有其他线程持有该锁，不用再去排队了，可直接占用该锁，否则，则需要通过 acquire() 方法去排队。</p>
<p><code>acquire()</code>源码如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(<span class="built_in">int</span> arg) &#123;</span><br><span class="line">	<span class="keyword">if</span>(!<span class="keyword">try</span><span class="constructor">Acquire(<span class="params">arg</span>)</span> &amp;&amp;</span><br><span class="line">		acquire<span class="constructor">Queued(<span class="params">addWaiter</span>(Node.EXCLUSIVE)</span>, arg))</span><br><span class="line">		self<span class="constructor">Interrupt()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tryAcquire 方法尝试获取锁，如果获取锁失败，则把它加入到阻塞队列中，来看 tryAcquire 的源码：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean <span class="keyword">try</span><span class="constructor">Acquire(<span class="params">int</span> <span class="params">acquires</span>)</span> &#123;</span><br><span class="line">	final Thread current = <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>;</span><br><span class="line">	<span class="built_in">int</span> c = get<span class="constructor">State()</span>;</span><br><span class="line">	<span class="keyword">if</span>(c<span class="operator"> == </span><span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// 公平锁比非公平锁多了一行代码： !hasQueuedPredecessors()</span></span><br><span class="line">		<span class="keyword">if</span>(!has<span class="constructor">QueuePredecessors()</span> &amp;&amp;</span><br><span class="line">			compare<span class="constructor">AndSetState(0, <span class="params">acquires</span>)</span>) &#123; <span class="comment">//尝试获取锁</span></span><br><span class="line">			set<span class="constructor">ExclusiveOwnerThread(<span class="params">current</span>)</span>; <span class="comment">//获取成功，标记被抢占</span></span><br><span class="line">			return <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(current<span class="operator"> == </span>get<span class="constructor">ExclusiveOwnerThread()</span>) &#123;</span><br><span class="line">		<span class="built_in">int</span> nextc = c + acquires;</span><br><span class="line">		<span class="keyword">if</span>(nextc &lt; <span class="number">0</span>)</span><br><span class="line">			throw <span class="keyword">new</span> <span class="constructor">Error(<span class="string">"Maximum lock count exceeded"</span>)</span>;</span><br><span class="line">		set<span class="constructor">State(<span class="params">nextc</span>)</span>; <span class="comment">// set state = state + 1</span></span><br><span class="line">		return <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里公平锁比非公平锁多了一行代码<code>!hasQueuePredecessors()</code>，它的作用是查看队列中是否有比它等待时间更长的线程，如果没有，尝试一下是否能获取到锁。如果能获取成功，则把当前锁标记为已经被占用。</p>
<p>如果获取失败，则调用addWaiter方法(在<code>acquire()</code>方法中，见更上面的<code>acquire()</code>源码)把线程包装成Node对象，同时放入到队列中，但addWaiter方法并不会尝试获取锁，<code>acquireQueued()</code>方法才会尝试获取锁，如果获取失败，则此节点会被挂起。</p>
<p><code>acquireQueued()</code>的源码如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 队列中的线程尝试获取锁，失败则会被挂起</span></span><br><span class="line">final boolean acquire<span class="constructor">Queued(<span class="params">final</span> Node <span class="params">node</span>, <span class="params">int</span> <span class="params">arg</span>)</span> &#123;</span><br><span class="line">	boolean faild = <span class="literal">true</span>; <span class="comment">// 获取锁是否成功的状态标识</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		boolean interrrupted = <span class="literal">false</span>; <span class="comment">// 线程是否被中断</span></span><br><span class="line">		for(;;) &#123;</span><br><span class="line">			<span class="comment">// 获取当前一个节点(前驱节点)</span></span><br><span class="line">			final Node p = node.predecessor<span class="literal">()</span>;</span><br><span class="line">			<span class="comment">// 当前节点为头结点的下一个节点时，有权尝试获取锁</span></span><br><span class="line">			<span class="keyword">if</span>(p<span class="operator"> == </span>head<span class="operator"> &amp;&amp; </span><span class="keyword">try</span><span class="constructor">Acquire(<span class="params">arg</span>)</span>) &#123;</span><br><span class="line">				set<span class="constructor">Head(<span class="params">node</span>)</span>; <span class="comment">//获取成功，将当前节点设置为head节点</span></span><br><span class="line">				p.next = null; <span class="comment">//原head节点出队，等待被GC</span></span><br><span class="line">				faild = <span class="literal">false</span>; <span class="comment">// 获取成功</span></span><br><span class="line">				return interrupted;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 判断获取锁失败后是否可以将其挂起</span></span><br><span class="line">			<span class="keyword">if</span>(should<span class="constructor">ParkAfterFailedAcquire(<span class="params">p</span>, <span class="params">node</span>)</span> &amp;&amp;</span><br><span class="line">				park<span class="constructor">AndCheckInterrupt()</span>)</span><br><span class="line">				<span class="comment">// 如果线程被中断，则返回true</span></span><br><span class="line">				interrupted = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; finally &#123;</span><br><span class="line">		<span class="keyword">if</span>(faild)</span><br><span class="line">			cance<span class="constructor">Acquire(<span class="params">node</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法有个很有意思的地方，就是用了<code>for(;;)</code>这个死循环来尝试获取锁，如果获取失败了，会调用<code>shouldParkAfterFailedAcquire()</code>来尝试挂起当前线程。<code>shouldParkAfterFailedAcquire()</code>方法的源码如下：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 判断是否可以被挂起</span><br><span class="line">private static boolean shouldParkAfterFailedAcquire(<span class="keyword">Node</span> <span class="title">pred</span>, <span class="keyword">Node</span> <span class="title">node</span>) &#123;</span><br><span class="line">	// 获得当前节点的前驱节点的状态</span><br><span class="line">	int ws = pred.waitStatus;</span><br><span class="line">	// 只在前驱节点状态为<span class="keyword">Node</span>.<span class="title">SIGNAL</span>的时候，当前线程可以被挂起(阻塞)</span><br><span class="line">	if(ws == <span class="keyword">Node</span>.<span class="title">SIGNAL</span>)</span><br><span class="line">		return <span class="literal">true</span>;</span><br><span class="line">	if(ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		do &#123;</span><br><span class="line">			// 若前驱节点状态为CANCELLED,那就一直往前找，直到找到一个正常等待的状态</span><br><span class="line">				<span class="keyword">node</span>.<span class="title">prev</span> = pred = pred.prev;</span><br><span class="line">		&#125; while(pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">		// 并将当前节点排在它后边</span><br><span class="line">		pred.next = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">	&#125; else</span> &#123;</span><br><span class="line">		// 把前驱节点的状态修改为 SIGNAL</span><br><span class="line">		compareAndSetWaitStatus(pred, ws, <span class="keyword">Node</span>.<span class="title">SIGNAL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前驱节点状态为SIGNAL(SIGNAL状态的含义是后继节点处于等待状态，当前节点释放锁后将会唤醒后继节点),线程才会在入队列的时候被挂起。</p>
<p>在上述代码中，先获取前驱节点pred.waitStatus(即ws)，然后判断这个节点的状态是否为SIGNAL，如果是SIGNAL，则当前线程可以被挂起并返回true；如果前驱节点状态&gt;0,则表示前驱节点已经被干掉了，它已经失效了，所以要继续往前找更前面的节点，直到找到最近一个正常等待的前驱节点，然后把它当前的前驱节点，然后将其状态设置为SIGNAL.</p>
<p>整个加锁过程到这里就完成了，最后需要注意，没有拿到锁的线程会在队列中被挂起，直到拥有锁的线程释放掉锁之后，才会去唤醒其他的线程去获取锁资源，整个运行流程如下图所示：</p>
<p><img src="https://i.loli.net/2020/03/29/uXlKdG83SJTmHCp.png" alt="整个加锁流程.png"></p>
<p><font color=#FF0000>再来看一下unlock()的过程</font>：</p>
<p>这个过程相比加锁简单很多。unlock()只涉及到release()和tryRelease()方法。</p>
<p>unlock源码如下：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	sync.<span class="built_in">release</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简单，我们再深入进去看一下release()方法：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="built_in">bool</span>ean release(<span class="built_in">int</span> arg) &#123;</span><br><span class="line">	<span class="comment">// 尝试释放锁</span></span><br><span class="line">	<span class="keyword">if</span>(tryRelease(arg)) &#123;</span><br><span class="line">		<span class="comment">// 释放成功</span></span><br><span class="line">		Node h = head;</span><br><span class="line">		<span class="keyword">if</span>(h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">			unparkSuccessor(h);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，锁释放的流程为，先调用tryRelease()方法尝试释放锁，如果释放成功，则查看头结点的状态是否为SIGNAL，是则唤醒头结点的下一个关联的线程；如果释放失败，则直接返回false</p>
<p>tryRelease()源码如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放当前线程占有的锁</span></span><br><span class="line">protected final boolean <span class="keyword">try</span><span class="constructor">Release(<span class="params">int</span> <span class="params">releases</span>)</span> &#123;</span><br><span class="line">	<span class="built_in">int</span> c = get<span class="constructor">State()</span> - releases; <span class="comment">// 释放锁后的状态，0表示释放成功</span></span><br><span class="line">	<span class="comment">// 如果拥有锁的线程不是当前线程的话抛出异常</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span> != get<span class="constructor">ExclusiveOwnerThread()</span>)</span><br><span class="line">		throw <span class="keyword">new</span> <span class="constructor">IllegalMonitorStateException()</span>;</span><br><span class="line">	boolean free = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span>(c<span class="operator"> == </span><span class="number">0</span>) &#123; <span class="comment">//锁被成功释放</span></span><br><span class="line">		free = <span class="literal">true</span>;</span><br><span class="line">		set<span class="constructor">ExclusiveOwnerThread(<span class="params">null</span>)</span>; <span class="comment">//清空独占线程</span></span><br><span class="line">	&#125;</span><br><span class="line">	set<span class="constructor">State(<span class="params">c</span>)</span>; <span class="comment">//更新state的值，0表示释放锁成功</span></span><br><span class="line">	return free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在tryRelease()方法中，会先判断当前的线程是不是占用锁的线程，如果不是的话，会抛出异常；如果是的话，会先计算锁的状态值:<code>getState()-releases</code>是否为0，如果是0，则表示可以正常地释放锁，然后清空独占线程，最后会更新锁的状态并返回执行结果。</p>
<h2 id="JDK1-6之后synchronized关键字底层做了哪些优化？详细介绍一下这些优化？"><a href="#JDK1-6之后synchronized关键字底层做了哪些优化？详细介绍一下这些优化？" class="headerlink" title="JDK1.6之后synchronized关键字底层做了哪些优化？详细介绍一下这些优化？"></a>JDK1.6之后synchronized关键字底层做了哪些优化？详细介绍一下这些优化？</h2><p>JDK 1.5 在升级为 JDK 1.6 时，HotSpot 虚拟机团队在锁的优化上下了很大功夫，比如实现了自适应式自旋锁、锁升级等。</p>
<p>JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减 少锁操作的开销。</p>
<p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐 渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p>
<p>下面详细讲一下<strong>自适应自旋锁</strong>和<strong>锁升级</strong>两个部分。</p>
<h3 id="自适应自旋锁-1"><a href="#自适应自旋锁-1" class="headerlink" title="自适应自旋锁"></a>自适应自旋锁</h3><p>JDK1.6引入了自适应式自旋锁意味着自旋的时间不再是固定的时间了，比如在同一个锁对象上，如果通过自旋等待成功获取了锁，那么虚拟机就会认为，它下一次很有可能也会成功(通过自旋获取到锁)，因此允许自旋等待的时间会相对的比较长，而当某个锁通过自旋很少成功获得过锁，那么以后在获取该锁时，可能会直接忽略掉自旋的过程，以避免浪费 CPU 的资源，这就是<strong>自适应自旋锁</strong>的功能。</p>
<h3 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h3><p>锁升级其实就是从偏向锁到轻量级锁再到重量级锁升级的过程，这是 JDK 1.6 提供的优化功能，也称之为<strong>锁膨胀</strong>。</p>
<ul>
<li><p><strong>偏向锁</strong>是指在无竞争的情况下设置的一种锁状态。偏向锁的意思是它会偏向于第一个获取它的线程，当锁对象第一次被获取到之后，会在此对象头中设置标示为“01”，表示偏向锁的模式，并且在对象头中记录此线程的ID，这种情况下，如果是持有偏向锁的线程每次在进入的话，不再进行任何同步操作，如Locking、Unlocking等，直到另一个线程尝试获取此锁的时候，偏向锁模式才会结束，偏向锁可以提高带有同步但无竞争的程序性能。但如果在多数锁总会被不同的线程访问时，偏向锁模式就比较多余了，此时可以通过 -XX:-UseBiasedLocking 来禁用偏向锁以提高性能。</p>
</li>
<li><p><strong>重量锁</strong>：在JDK1.6之前，synchronized是通过操作系统的互斥量（mutexlock）来实现的，这种实现方式需要在用户态和核心态之间做转换，有很大的性能消耗，这种传统实现锁的方式被称之为<strong>重量锁</strong>。</p>
</li>
<li><p><strong>轻量锁</strong>：轻量锁是相对于重量锁而言的，轻量锁是通过比较并交换（CAS，CompareandSwap）来实现的，它对比的是线程和对象的MarkWord（对象头中的一个区域），如果更新成功则表示当前线程成功拥有此锁；如果失败，虚拟机会先检查对象的MarkWord是否指向当前线程的栈帧，如果是，则说明当前线程已经拥有此锁，否则，则说明此锁已经被其他线程占用了。当两个以上的线程争抢此锁时，轻量级锁就膨胀为重量级锁，这就是锁升级的过程，也是JDK1.6锁优化的内容。</p>
</li>
</ul>
<h2 id="synchronized关键字底层原理详解"><a href="#synchronized关键字底层原理详解" class="headerlink" title="synchronized关键字底层原理详解"></a>synchronized关键字底层原理详解</h2><p>synchronized 关键字底层原理属于 JVM 层面，我们一般不会直接接触其源代码。与之对比的是ReenTrantLock， ReenTrantLock是 JDK 层面实现的（也就 是 API 层面，需要 lock() 和 unlock 方法配合 try/ﬁnally 语句块来完成），所以我们可以通过查看它的源代码，来看 它是如何实现的。</p>
<p>对于synchronized我们主要看两种情况：</p>
<h3 id="synchronized-同步语句块的情况"><a href="#synchronized-同步语句块的情况" class="headerlink" title="synchronized 同步语句块的情况"></a>synchronized 同步语句块的情况</h3><p>这里我们自己做实验，首先写一段简单的代码，用synchronized关键字使得代码块上锁：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"synchronized Code block"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后想要看synchronized的工作原理，我们可以看它执行的过程，比如可以看相关字节码文件。我们可以用JDK自带的javap命令查看SynchronizedDemo类的相关字节码信息。先用javac生成其编译后的.class文件，然后执行<code>javap -c -s -v -l SynchronizedDemo.class</code></p>
<p>结果如下图：</p>
<p><img src="https://i.loli.net/2020/03/28/RkuhOC931cYBSsw.png" alt="synchronized修饰代码块.png"></p>
<p>从上图可以看出：</p>
<p><strong>synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同 步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。</strong> 当执行 monitorenter 指令时，线程试图 获取锁也就是获取 monitor(monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取 锁的，也是为什么Java中任意对象可以作为锁的原因) 的持有权.当计数器为0则可以成功获取，获取后将锁计数器设 为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当 前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p>
<h3 id="synchronized修饰方法"><a href="#synchronized修饰方法" class="headerlink" title="synchronized修饰方法"></a>synchronized修饰方法</h3><p>代码如下：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo2</span> &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> synchronized <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"synchronized method"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码用javap查看字节码文件：</p>
<p><img src="https://i.loli.net/2020/03/28/MhosgzRn3EPIxtp.png" alt="synchronized修饰方法.png"></p>
<p>synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来 辨别一个方法是否声明为同步方法，从而执行相应的同步调用。 </p>
<h2 id="Java内存模型与synchronized和volatile的面试二连击"><a href="#Java内存模型与synchronized和volatile的面试二连击" class="headerlink" title="Java内存模型与synchronized和volatile的面试二连击"></a>Java内存模型与synchronized和volatile的面试二连击</h2><h3 id="1-Java内存模型-JMM"><a href="#1-Java内存模型-JMM" class="headerlink" title="1.Java内存模型(JMM)"></a>1.Java内存模型(JMM)</h3><p>Java内存模型JMM和JVM是两回事，JMM是为了定义程序中变量的访问规则，而JVM是Java虚拟机。</p>
<p>在 JDK1.2 之前，Java的内存模型(JMM)实现总是从<font color=#FF0000><strong>主存</strong>（即共享内存）读取变量</font>，是不需要进行特别的注意的。而在当前 的 Java 内存模型下，线程可以把变量保存<font color=#FF0000><strong>本地内存</strong></font>（比如机器的寄存器）中，而不是直接在主存中进行读写。这就 可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成<font color=#FF0000><strong>数据的不一致</strong></font>。</p>
<p>新的Java内存模型如下图：</p>
<p><img src="https://i.loli.net/2020/03/28/kWu9vcZ5AILjNQm.png" alt="现代版Java内存模型.png"></p>
<p>要解决这个问题，就需要把变量声明为 <font color=#FF0000><strong>volatile</strong></font>，这就指示 JVM，这个变量是不稳定的，每次使用它都到主存中进行 读取。</p>
<p>说白了， volatile 关键字的主要作用就是保证变量的可见性然后还有一个作用是防止指令重排序。</p>
<p><img src="https://i.loli.net/2020/03/28/fUSMYGbVAux1LH7.png" alt="volatile作用.png"></p>
<h3 id="2-synchronized关键字和volatile关键字的区别"><a href="#2-synchronized关键字和volatile关键字的区别" class="headerlink" title="2.synchronized关键字和volatile关键字的区别"></a>2.synchronized关键字和volatile关键字的区别</h3><p>synchronized关键字和volatile关键字比较 </p>
<ul>
<li><p><strong>volatile关键字</strong>是线程同步的<strong>轻量级实现</strong>，所以<strong>volatile性能肯定比synchronized关键字要好</strong>。但是<strong>volatile关键字只能用于变量</strong>而<strong>synchronized关键字可以修饰方法以及代码块</strong>。synchronized关键字在JavaSE1.6之后进 行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行 效率有了显著提升，<strong>实际开发中使用 synchronized 关键字的场景还是更多一些</strong>。 </p>
</li>
<li><p><strong>多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞</strong></p>
</li>
<li><p><strong>volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。</strong> </p>
</li>
<li><p><strong>volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访 问资源的同步性。</strong> </p>
</li>
</ul>
<h2 id="Java线程池的面试四连击"><a href="#Java线程池的面试四连击" class="headerlink" title="Java线程池的面试四连击"></a>Java线程池的面试四连击</h2><h3 id="1-为什么要用线程池？"><a href="#1-为什么要用线程池？" class="headerlink" title="1.为什么要用线程池？"></a>1.为什么要用线程池？</h3><p>线程池是为了避免线程频繁的创建和销毁带来的性能消耗，而建立的一种池化技术，它是把已创建的线程放入“池”中，当有任务来临时就可以重用已有的线程，无需等待创建的过程，这样就可以有效提高程序的响应速度。</p>
<p>这里借用《Java并发编程的艺术》提到的来说一下使用线程池的好处： </p>
<ul>
<li><strong>降低资源消耗</strong>。 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 </li>
<li><strong>提高响应速度</strong>。 当任务到达时，任务可以不需要的等到线程创建就能立即执行。 </li>
<li><strong>提高线程的可管理性</strong>。 线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性， 使用线程池可以进行统一的分配，调优和监控。 </li>
</ul>
<h3 id="2-实现Runnable接口和Callable接口的区别？"><a href="#2-实现Runnable接口和Callable接口的区别？" class="headerlink" title="2.实现Runnable接口和Callable接口的区别？"></a>2.实现Runnable接口和Callable接口的区别？</h3><p>如果想让线程池执行任务的话需要实现的Runnable接口或Callable接口。 Runnable接口或Callable接口实现类都可 以被ThreadPoolExecutor或ScheduledThreadPoolExecutor执行。两者的区别在于 Runnable 接口不会返回结果但 是 Callable 接口可以返回结果。</p>
<p><strong>备注</strong>：工具类 <code>Executors</code> 可以实现 <code>Runnable</code> 对象和 <code>Callable</code> 对象之间的相互转换。 （ <code>Executors.callable（Runnable task）</code>或 <code>Executors.callable（Runnable task，Object resule）</code>）。 </p>
<h3 id="3-执行execute-方法和submit-方法的区别是什么呢？"><a href="#3-执行execute-方法和submit-方法的区别是什么呢？" class="headerlink" title="3.执行execute()方法和submit()方法的区别是什么呢？"></a>3.执行execute()方法和submit()方法的区别是什么呢？</h3><ol>
<li><strong>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否。</strong>；</li>
<li><strong>submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断 任务是否执行成功</strong>，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用 get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行 完。 </li>
</ol>
<p>此外它们俩之间另一个区别是，execute()方法属于Executor接口的方法，而submit()方法则是属于ExecutorService接口的方法，它们之间的继承关系如下图所示：</p>
<p><img src="https://i.loli.net/2020/03/29/lX7uBNwA6s2gUeQ.png" alt="execute__方法和submit__方法另一个区别.png"></p>
<h3 id="4-如何创建线程池"><a href="#4-如何创建线程池" class="headerlink" title="4.如何创建线程池"></a>4.如何创建线程池</h3><p>《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这 样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p>
<blockquote>
<p>Executors 返回线程池对象的弊端如下：</p>
<ul>
<li>FixedThreadPool 和 SingleThreadExecutor ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积 大量的请求，从而导致OOM。 </li>
<li>CachedThreadPool 和 ScheduledThreadPool ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能 会创建大量线程，从而导致OOM。</li>
</ul>
</blockquote>
<p>而且参考之前写过的《ThreadPoolExecutor的核心参数》，那部分已经度过了源代码(能把参数和其作用都具体说出来，效果已经不错了)。其实当我们去看Executors的源码会发现，Executors.newFixedThreadPool()、Executors.newSingleThreadExecutor()和Executors.newCachedThreadPool() 等方法的底层都是通过 ThreadPoolExecutor 实现的。</p>
<p><img src="https://i.loli.net/2020/03/28/WQbFa9Iy8kgzjDi.png" alt="线程池创建方法_THreadPoolExecutor_.png"></p>
<p>顺带提一下上面三种基于Executor框架的工具类Executors实现的三种类型的ThreadPoolExecutor：</p>
<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>AQS的全称为（AbstractQueuedSynchronizer），这个类在java.util.concurrent.locks包下面。</p>
<h3 id="从synchronized引入"><a href="#从synchronized引入" class="headerlink" title="从synchronized引入"></a>从synchronized引入</h3><p>大家可能都听说说 Java 中的并发包，如果想要读懂 Java 中的并发包，其核心就是要先读懂 CAS 机制，因为 CAS 可以说是并发包的底层实现原理。</p>
<p>CAS能够保证操作的原子性，JDK8也对CAS进行了一些优化。</p>
<p>首先来看synchronized，它很多时候有些大材小用了。</p>
<p>先看几行代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CASTest</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如有100个线程同时调用 increment() 方法对 i 进行自增操作，i 的结果会是 100 吗？</p>
<p>学会多线程的同学应该都知道，这个方法是线程不安全的，由于 i++ 不是<strong>一个原子操作</strong>，所以是很难得到 100 的。</p>
<blockquote>
<p>这里稍微解释下为啥会得不到 100(知道的可直接跳过)， i++ 这个操作，计算机需要分成三步来执行。</p>
<p>1、读取 i 的值。</p>
<p>2、把 i 加 1.</p>
<p>3、把 最终 i 的结果写入内存之中。</p>
<p>所以，（1）、假如线程 A 读取了 i 的值为 i = 0，（2）、这个时候线程 B 也读取了 i 的值 i = 0。（3）、接着 A把 i 加 1，然后写入内存，此时 i = 1。（4）、紧接着，B也把 i 加 1，此时线程B中的 i = 1，然后线程 B 把 i 写入内存，此时内存中的 i = 1。也就是说，线程 A, B 都对 i 进行了自增，但最终的结果却是 1，不是 2.</p>
</blockquote>
<p>解决方法：加锁。比如可以加synchronized锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CASTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加了 synchronized 之后，就最多只能有一个线程能够进入这个 increment() 方法了，保证了线程安全。</p>
<p>然而，一个简简单单的自增操作，就加了 synchronized 进行同步，好像有点大材小用的感觉，加了 synchronized 关键词之后，当有很多线程去竞争 increment 这个方法的时候，拿不到锁的方法是会被阻塞在方法外面的，最后再来唤醒他们，而阻塞/唤醒这些操作，是非常消耗时间的。</p>
<p>更合适的解决方法：CAS</p>
<h3 id="CAS介绍"><a href="#CAS介绍" class="headerlink" title="CAS介绍"></a>CAS介绍</h3><p>大家看一下，如果我采用下面这种方式，能否保证 increment 是线程安全的呢？步骤如下：</p>
<p>1、线程从内存中读取 i 的值，假如此时 i 的值为 0，我们把这个值称为 k 吧，即此时 k = 0。</p>
<p>2、令 j = k + 1。</p>
<p>3、用 k 的值与内存中i的值相比，如果相等，这意味着没有其他线程修改过 i 的值，我们就把 j（此时为1） 的值写入内存；如果不相等（意味着i的值被其他线程修改过），我们就不把j的值写入内存，而是重新跳回步骤 1，继续这三个操作。</p>
<p>翻译成代码的话就是这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = i;</span><br><span class="line">        <span class="keyword">int</span> j = k + <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">while</span> (compareAndSet(i, k, j))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你去模拟一下，就会发现，这样写是线程安全的。</p>
<p>这里可能有人会说，第三步的 compareAndSet 这个操作不仅要读取内存，还干了比较、写入内存等操作，，，这一步本身就是线程不安全的啊？</p>
<p>如果你能想到这个，说明你是真的有去思考、模拟这个过程，不过我想要告诉你的是，这个 compareAndSet 操作，他其实只对应操作系统的一条硬件操作指令，尽管看似有很多操作在里面，但操作系统能够保证他是原子执行的。</p>
<p>对于一条英文单词很长的指令，我们都喜欢用它的简称来称呼他，所以，我们就把 compareAndSet 称为 CAS 吧。</p>
<p><strong>所以，采用 CAS 这种机制的写法也是线程安全的</strong>，通过这种方式，可以说是不存在锁的竞争，也不存在阻塞等事情的发生，可以让程序执行的更好。</p>
<p>在 Java 中，也是提供了这种 CAS 的原子类，例如：</p>
<p>AtomicBoolean</p>
<p>AtomicInteger</p>
<p>AtomicLong</p>
<p>AtomicReference</p>
<p>具体如何使用呢？我就以上面那个例子进行改版吧，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CASTest</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> AtomicInteger i = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 自增 1并返回之后的结果</span></span><br><span class="line">        i.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是又会有一个问题，就是如果函数的操作返回的就是和原来传入的值相同的值，那线程A可能认为B还没执行完。</p>
<p>举个例子：当线程A即将要执行第三步的时候，线程 B 把 i 的值加1，之后又马上把 i 的值减 1，然后，线程 A 执行第三步，这个时候线程 A 是认为并没有人修改过 i 的值，因为 i 的值并没有发生改变。而这，就是我们平常说的<strong>ABA问题</strong>。</p>
<p>CAS只能保障一个变量的原子性，但不能保证整个代码块的原子性。</p>
<p>CAS可能会造成ABA问题，即：<strong>线程一拿到了某个变量最初的预期原值A，在将要进行CAS的时候被其他线程抢占了执行权，把值从A变成了B，然后其他线程又把这个值从B变回了A。虽然这个时候此变量实际上已经不是原先的A了，但线程一并不知道这个情况，它在执行CAS的时候，对比了A的值没有改变，就按照这个预期工作了，这就造成了ABA问题。</strong></p>
<p>以警匪剧为例，假如某人把装了100W现金的箱子放在了家里，几分钟之后要拿它去赎人，然而在趁他不注意的时候，进来了一个小偷，用空箱子换走了装满钱的箱子，当某人进来之后看到箱子还是一模一样的，他会以为这就是原来的箱子，就拿着它去赎人了，这种情况肯定有问题，因为箱子已经是空的了，这就是 ABA 的问题。</p>
<p>对于基本类型的值来说，这种把数字改变了在改回原来的值是没有太大影响的，但如果是对于<strong>引用类型</strong>的话，就会产生很大的影响了。</p>
<p>解决方法：版本控制，或者说<strong>添加版本号</strong>。每次修改之后都更新版本号，拿上面的例子来说，假如每次移动箱子之后，箱子的位置就会发生变化，而这个变化的位置就相当于“版本号”，当某人进来之后发现箱子的位置发生了变化就知道有人动了手脚，就会放弃原有的计划，这样就解决了ABA问题。</p>
<p>相似的，每次有线程修改了引用的值，就会进行版本的更新，虽然两个线程持有相同的引用，但他们的版本不同，这样，我们就可以预防 ABA 问题了。</p>
<p>JDK在1.5时提供了 <code>AtomicStampedReference</code> 这个类，维护了”版本号” <code>Stamp</code>,每次，值和版本号，都会比较，这样就解决了ABA的问题。</p>
<h3 id="JDK8对CAS的优化"><a href="#JDK8对CAS的优化" class="headerlink" title="JDK8对CAS的优化"></a>JDK8对CAS的优化</h3><p>由于采用这种 CAS 机制是没有对方法进行加锁的，所以，所有的线程都可以进入 increment() 这个方法，假如进入这个方法的线程太多，就会出现一个问题：每次有线程要执行第三个步骤的时候，i 的值老是被修改了，所以线程又到回到第一步继续重头再来。</p>
<p>而这就会导致一个问题：由于线程太密集了，太多人想要修改 i 的值了，进而大部分人都会修改不成功，白白着在那里循环消耗资源。</p>
<p>为了解决这个问题，Java8 引入了一个 cell[] 数组，它的工作机制是这样的：假如有 5 个线程要对 i  进行自增操作，由于 5 个线程的话，不是很多，起冲突的几率较小，那就让他们按照以往正常的那样，采用 CAS 来自增吧。</p>
<p>但是，如果有 100 个线程要对 i 进行自增操作的话，这个时候，冲突就会大大增加，系统就会把这些线程分配到不同的 cell 数组元素去，假如 cell[10] 有 10 个元素吧，且元素的初始化值为 0，那么系统就会把 100 个线程分成 10 组，每一组对 cell 数组其中的一个元素做自增操作，这样到最后，cell 数组 10 个元素的值都为 10，系统在把这 10 个元素的值进行汇总，进而得到 100，二这，就等价于 100 个线程对 i 进行了 100 次自增操作。</p>
<h3 id="正式介绍AQS"><a href="#正式介绍AQS" class="headerlink" title="正式介绍AQS"></a>正式介绍AQS</h3><p><a href="https://www.cnblogs.com/yszzu/p/10198904.html" target="_blank" rel="noopener">CAS、AQS和lock之间的关系</a></p>
<p><a href="https://www.jianshu.com/p/2a48778871a9" target="_blank" rel="noopener">CAS和AQS</a></p>
<p>AQS的全称为（AbstractQueuedSynchronizer），这个类在java.util.concurrent.locks包下面。</p>
<p><font color=#FF0000><strong>AQS是基于CAS的锁同步框架</strong></font>，是一个抽象类，其中有一个状态统计变量stateOffset是使用CAS来操作的。</p>
<p><img src="https://i.loli.net/2020/03/29/FdK93NT78n5U2lb.png" alt="AQS的位置.png"></p>
<p>AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask(一些具体作用见下段)等等皆是 基于AQS的。当然，我们自己也能利用AQS非常轻松容易地构造出符合我们自己需求的同步器。</p>
<p>参考《Java并发编程实战》的内容：</p>
<blockquote>
<p>AQS管理一个关于状态信息的单一整数，状态信息可以通过protected类型的getState()、setState()和compareAndSetState()等方法操作，这可以用于表现任何状态。</p>
<p>例如，ReentrantLock用它来表现<strong>拥有它的线程已经请求了多少次锁</strong>；Semaphore用它来表现<strong>剩余的许可次数</strong>；FutureTask用它来表现<strong>任务的状态(尚未开始、运行、完成和取消)</strong>。</p>
</blockquote>
<h3 id="AQS核心思想"><a href="#AQS核心思想" class="headerlink" title="AQS核心思想"></a>AQS核心思想</h3><p>AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设 置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</p>
<blockquote>
<p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结 点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）来实现锁的分配。</p>
</blockquote>
<p>AQS原理图如下：</p>
<p><img src="https://i.loli.net/2020/03/30/PnzieOJcNX8mB24.png" alt="CLH队列.png"></p>
<p>AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该 同步状态进行原子操作实现对其值的修改。</p>
<h3 id="AQS两种资源共享方式"><a href="#AQS两种资源共享方式" class="headerlink" title="AQS两种资源共享方式"></a>AQS两种资源共享方式</h3><ul>
<li><strong>Exclusive</strong>(独占)：只有一个线程能执行，比如ReentrantLock。又可以分为公平锁和非公平锁。<ul>
<li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li>
<li>非公平锁：当线程要获取锁的时候，无视队列顺序直接去抢锁，谁先抢到就是谁的。</li>
</ul>
</li>
<li><strong>Share</strong>(共享)：：多个线程可同时执行，如Semaphore/CountDownLatch。</li>
</ul>
<p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方 式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。</p>
<h3 id="AQS组件总结"><a href="#AQS组件总结" class="headerlink" title="AQS组件总结"></a>AQS组件总结</h3><ul>
<li><strong>Semaphore(信号量)-允许多个线程同时访问</strong>： synchronized 和 ReentrantLock 都是一次只允许一个线程访问 某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。 </li>
<li><strong>CountDownLatch （倒计时器）</strong>： CountDownLatch是一个同步工具类，用来协调多个线程之间的同步。这 个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。 </li>
<li><strong>CyclicBarrier(循环栅栏)</strong>： CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待， 但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫 同步点）时被阻塞，直到后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。 CyclicBarrier默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用 await方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</li>
</ul>
<h2 id="谈谈对多线程的锁的理解？如何手动模拟一个死锁？"><a href="#谈谈对多线程的锁的理解？如何手动模拟一个死锁？" class="headerlink" title="谈谈对多线程的锁的理解？如何手动模拟一个死锁？"></a>谈谈对多线程的锁的理解？如何手动模拟一个死锁？</h2><p>多线程并发编程有两个重要概念：<strong>线程和锁</strong>。虽然多线程可以提高程序性能，但是带来了编码的复杂性，尤其是要解决多线程操作同一组资源的时候保证数据的一致性的问题。引入了锁之后，我们会给某个资源上锁，只有拥有这个资源的锁的线程才能操作此资源，而其他线程只能排队等待使用锁，也就是要等待这个锁被释放才行。</p>
<p>在并发编程中，当有多个线程同时操作一个资源时，为了保证数据操作的正确性，需要让多线程排队，一个一个地操作资源，而这个过程就是给资源加锁和释放锁的过程，就好像去公共厕所一样，一次只能有一个人占用，剩下的必须排队，而且一个人用的时候为了防止后面人进来，要给门上锁一样。</p>
<h3 id="什么是死锁？如何手动模拟一个死锁？"><a href="#什么是死锁？如何手动模拟一个死锁？" class="headerlink" title="什么是死锁？如何手动模拟一个死锁？"></a>什么是死锁？如何手动模拟一个死锁？</h3><p>首先，死锁是指两个线程都各自拥有一个资源的锁，但是又都在等待对方释放对方锁拥有的资源的锁。如下图所示：</p>
<p><img src="https://i.loli.net/2020/03/30/LeThwqHWSBGvtzX.png" alt="死锁.png"></p>
<p>代码例子如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">class</span> LockExample &#123;</span><br><span class="line">	public static void main(String<span class="literal">[]</span> arg) &#123;</span><br><span class="line">		dead<span class="constructor">Lock()</span>; <span class="comment">// 死锁</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 死锁</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">private</span> static void dead<span class="constructor">Lock()</span> &#123;</span><br><span class="line">		Object lock1 = <span class="keyword">new</span> <span class="constructor">Object()</span>;</span><br><span class="line">		Object lock2 = <span class="keyword">new</span> <span class="constructor">Object()</span>;</span><br><span class="line">		<span class="comment">// 线程1拥有 lock1 试图获取lock2</span></span><br><span class="line">		<span class="keyword">new</span> <span class="constructor">Thread(()</span> -&gt; &#123;</span><br><span class="line">			synchronized(lock1) &#123;</span><br><span class="line">				<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"获取lock1成功"</span>);</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="module-access"><span class="module"><span class="identifier">TimeUnit</span>.</span><span class="module"><span class="identifier">SECONDS</span>.</span></span>sleep(<span class="number">3</span>);</span><br><span class="line">				&#125; catch (InterruptedException e) &#123;</span><br><span class="line">					e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 试图获取lock2</span></span><br><span class="line">				synchronized(lock2) &#123;</span><br><span class="line">					<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start<span class="literal">()</span>;</span><br><span class="line">		<span class="comment">// 线程二拥有 lock2 试图获取lock1</span></span><br><span class="line">		<span class="keyword">new</span> <span class="constructor">Thread(()</span> -&gt; &#123;</span><br><span class="line">			synchronized(lock2) &#123;</span><br><span class="line">				<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"获取lock2成功"</span>);</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="module-access"><span class="module"><span class="identifier">TimeUnit</span>.</span><span class="module"><span class="identifier">SECONDS</span>.</span></span>sleep(<span class="number">3</span>);</span><br><span class="line">				&#125; catch (InterruptedException e) &#123;</span><br><span class="line">					e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 试图获取lock2</span></span><br><span class="line">				synchronized(lock1) &#123;</span><br><span class="line">					<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start<span class="literal">()</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">获取lock1成功</span><br><span class="line">获取lock2成功</span><br></pre></td></tr></table></figure>

<p>在分别获得lock1和lock2成功之后，这两个线程还会试图获得对方的锁，也就是线程一拥有锁lock1之后试图获取lock2，而线程二在拥有lock2之后试图获取lock1,这样就造成了彼此都在等待对方释放资源，于是造成了<strong>死锁</strong>。</p>
<h2 id="Java的悲观锁和乐观锁、共享锁和独占锁"><a href="#Java的悲观锁和乐观锁、共享锁和独占锁" class="headerlink" title="Java的悲观锁和乐观锁、共享锁和独占锁"></a>Java的悲观锁和乐观锁、共享锁和独占锁</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>悲观锁是指<strong>数据对外界的修改采取保守策略，它认为线程很容易会把数据修改掉，因此在整个数据被修改的过程中都会采取锁定状态，直到一个线程使用完，其他线程才可以继续使用。</strong>通俗理解，就是在用数据之前要先加上锁，用完之后才能释放锁。</p>
<p>拿synchronized来说，每次执行被synchronized修饰的代码块在执行之前会先用<code>monitorenter</code>指令加上锁，在执行结束之后再使用<code>monitorexit</code>指令释放锁资源，在整个执行期间这个代码都是锁定的状态，这就是<strong>典型悲观锁的实现流程</strong>。</p>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁肯定与悲观锁相反啦，<strong>乐观锁认为数据之间一般不会发生冲突，所以在数据访问之前不会加锁，只有在提交的时候，才会对数据进行检测和上锁。</strong></p>
<p>乐观锁大部分都是通过<strong>CAS(Compare And Swap，比较并交换)</strong>操作实现的。CAS之前有过介绍，它是一个多线程同步的原子指令。CAS操作包含三个重要信息：内存位置、预期原值和新值。如果内存位置的值和预期原值相等的话，可以把该位置的值更新为新值，否则不做任何修改。之前讲过的ReentrantLock就是通过CAS实现的，Lock就是乐观锁的典型例子。</p>
<p>然而，CAS可能造成ABA问题(前面有介绍过，解决方法是用版本号)。</p>
<h3 id="共享锁和独占锁"><a href="#共享锁和独占锁" class="headerlink" title="共享锁和独占锁"></a>共享锁和独占锁</h3><ul>
<li><p>可以被多线程持有的称作<strong>共享锁</strong></p>
</li>
<li><p>只能被单线程持有的锁称作<strong>独占锁</strong>。独占锁指的是在任何时候最多只能有一个线程持有该锁，比如 ReentrantLock 就是独占锁，而 ReadWriteLock 读写锁允许同一时间内有多个线程进行读操作，它就属于共享锁。</p>
</li>
</ul>
<p><strong>独占锁可以理解为悲观锁</strong>，当每次访问资源时都要加上互斥锁，<strong>而共享锁可以理解为乐观锁</strong>，它放宽了加锁的条件，允许多线程同时访问该资源。</p>
<h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>可重入锁也叫<strong>递归锁</strong>，指的是同一个线程，如果外层的函数拥有这个锁，内层的函数可以继续获取该锁。</p>
<p>在Java语言中，ReentrantLock和synchronized都是可重入锁。</p>
<p>用代码举一个可重入锁的例子，用synchronized来演示：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockExample</span> &#123;</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] arg)</span> </span>&#123;</span><br><span class="line">		reentrantA(); <span class="comment">// 可重入锁</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	*	可重入锁A方法</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> synchronized <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reentrantA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.<span class="built_in">println</span>(Thread.currentThread.getName() + <span class="string">":执行 reentrantA"</span>);</span><br><span class="line">		reentrantB();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	*	可重入锁B方法</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> synchronized <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reentrantB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.<span class="built_in">println</span>(Thread.currentThread.getName() + <span class="string">":执行 reentrantB"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main：执行 reentrantA</span><br><span class="line">main：执行 reentrantB</span><br></pre></td></tr></table></figure>

<p>从结果可以看出reentrantA方法和reentrantB方法的执行线程都是“main”，我们调用了reentrantA方法，它的方法中嵌套了reentrantB，如果synchronized是不可重入的话，那么线程会一直堵塞。</p>
<p>可重入锁的实现原理，是在锁内部存储了一个线程标识，用于判断当前的锁属于哪个线程，并且锁的内部维护了一个计数器，当锁空闲时此计数器的值为0，当被线程占用和重入时分别加1，当锁被释放时计数器减1，直到减到 0 时表示此锁为空闲状态。</p>
<h2 id="Java垃圾回收机制"><a href="#Java垃圾回收机制" class="headerlink" title="Java垃圾回收机制"></a>Java垃圾回收机制</h2>
    </div>


    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Interview/" rel="tag"><i class="fa fa-tag"></i># Interview</a>
              <a href="/tags/Intergrated/" rel="tag"><i class="fa fa-tag"></i># Intergrated</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/03/20/List-Map-Analysis/" rel="prev" title="List-Map-Analysis">
      <i class="fa fa-chevron-left"></i> List-Map-Analysis
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/03/25/Spring/" rel="next" title="Spring">
      Spring <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC80ODAxMC8yNDUwNw=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-计算机网络"><span class="nav-text">1.计算机网络</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-HTTPS和HTTP"><span class="nav-text">1.1 HTTPS和HTTP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#对称加密-Symmetric-encryption-和非对称加密-Asymmetric-encryption"><span class="nav-text">对称加密(Symmetric encryption)和非对称加密(Asymmetric encryption)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#对称加密"><span class="nav-text">对称加密</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#非对称加密"><span class="nav-text">非对称加密</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数字证书"><span class="nav-text">数字证书</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CA的公钥如何拿给客户端？服务器如何获得CA私钥？"><span class="nav-text">CA的公钥如何拿给客户端？服务器如何获得CA私钥？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数字签名"><span class="nav-text">数字签名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SSL-TLS协议"><span class="nav-text">SSL&#x2F;TLS协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP状态码？-1开头到5开头的各种典型状态码"><span class="nav-text">HTTP状态码？(1开头到5开头的各种典型状态码)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一些可能有用的与HTTP有关的协议"><span class="nav-text">一些可能有用的与HTTP有关的协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CDN"><span class="nav-text">CDN</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-IP"><span class="nav-text">TCP&#x2F;IP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DNS"><span class="nav-text">DNS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#URI-URL"><span class="nav-text">URI&#x2F;URL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTPS"><span class="nav-text">HTTPS</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#输入一个URL之后，整个请求过程是怎样的？"><span class="nav-text">输入一个URL之后，整个请求过程是怎样的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GET和POST报文形式"><span class="nav-text">GET和POST报文形式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GET和POST的区别"><span class="nav-text">GET和POST的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#255-255-255-255和0-0-0-0的作用"><span class="nav-text">255.255.255.255和0.0.0.0的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP和UDP区别以及各自适用场景"><span class="nav-text">TCP和UDP区别以及各自适用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP流量控制"><span class="nav-text">TCP流量控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP拥塞机制"><span class="nav-text">TCP拥塞机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#选择重传协议-SR-——可靠性传输协议中的一个"><span class="nav-text">选择重传协议(SR)——可靠性传输协议中的一个</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP三次握手"><span class="nav-text">TCP三次握手</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP三次握手涉及的问题"><span class="nav-text">TCP三次握手涉及的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-三次握手的作用"><span class="nav-text">1.三次握手的作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-seq-ISN-是固定的么"><span class="nav-text">2.seq(ISN)是固定的么</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-什么是半连接队列"><span class="nav-text">3.什么是半连接队列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-三次握手过程中可以携带数据吗"><span class="nav-text">4.三次握手过程中可以携带数据吗</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-第一次握手时可能会出现SYN超时的问题——针对SYN-Flood的防护措施"><span class="nav-text">5.第一次握手时可能会出现SYN超时的问题——针对SYN Flood的防护措施</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP四次挥手"><span class="nav-text">TCP四次挥手</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP四次挥手涉及的问题"><span class="nav-text">TCP四次挥手涉及的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-为什么客户端在最后要有2MSL的等待时间，即为什么要有TIME-WAIT时间？"><span class="nav-text">1.为什么客户端在最后要有2MSL的等待时间，即为什么要有TIME_WAIT时间？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-四次挥手过程中大量Socket处在TIME-WAIT和CLOSE-WAIT状态，该如何解决？"><span class="nav-text">2.四次挥手过程中大量Socket处在TIME_WAIT和CLOSE_WAIT状态，该如何解决？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一些状态的含义"><span class="nav-text">一些状态的含义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-cookie和session的区别"><span class="nav-text">1.2 cookie和session的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP、TCP、UDP、IP、ICMP、DNS、FTP等协议分别处于哪层？"><span class="nav-text">HTTP、TCP、UDP、IP、ICMP、DNS、FTP等协议分别处于哪层？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ping指令用的什么协议？在哪一层？"><span class="nav-text">Ping指令用的什么协议？在哪一层？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ARP协议的作用？"><span class="nav-text">ARP协议的作用？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是ARP协议？"><span class="nav-text">什么是ARP协议？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么要有ARP协议？"><span class="nav-text">为什么要有ARP协议？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#路由器和交换机的区别？"><span class="nav-text">路由器和交换机的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP粘包为什么会发生？怎么处理？"><span class="nav-text">TCP粘包为什么会发生？怎么处理？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#发生TCP粘包主要是两个原因："><span class="nav-text">发生TCP粘包主要是两个原因：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解决粘包问题的两个方法："><span class="nav-text">解决粘包问题的两个方法：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-操作系统"><span class="nav-text">2.操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#进程与线程的区别"><span class="nav-text">进程与线程的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程间通信方式-IPC-Inter-Process-Communication"><span class="nav-text">进程间通信方式(IPC, Inter Process Communication)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文件"><span class="nav-text">文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#管道-命名管道"><span class="nav-text">管道&#x2F;命名管道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Signal"><span class="nav-text">Signal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#共享内存"><span class="nav-text">共享内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息队列"><span class="nav-text">消息队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#同步机制，如信号量-semaphore"><span class="nav-text">同步机制，如信号量(semaphore)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Socket"><span class="nav-text">Socket</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#经典进程调度算法"><span class="nav-text">经典进程调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-批处理时代"><span class="nav-text">1.批处理时代</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-FCFS-先来先服务"><span class="nav-text">1.FCFS(先来先服务)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-SPN-段任务优先"><span class="nav-text">2.SPN(段任务优先)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-HARRN-高响应比优先"><span class="nav-text">3.HARRN(高响应比优先)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-并发时代"><span class="nav-text">2.并发时代</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-RR-时间片轮转算法"><span class="nav-text">1.RR(时间片轮转算法)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-VRR-虚拟轮转法"><span class="nav-text">2.VRR(虚拟轮转法)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-优先级调度"><span class="nav-text">3.优先级调度</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#互斥"><span class="nav-text">互斥</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#锁-重量级锁、自旋锁、轻量级锁、偏向锁、悲观、乐观锁等"><span class="nav-text">锁(重量级锁、自旋锁、轻量级锁、偏向锁、悲观、乐观锁等)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#重量级锁"><span class="nav-text">重量级锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自旋锁"><span class="nav-text">自旋锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自适应自旋锁"><span class="nav-text">自适应自旋锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#轻量级锁"><span class="nav-text">轻量级锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#偏向锁"><span class="nav-text">偏向锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#乐观锁和悲观锁"><span class="nav-text">乐观锁和悲观锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结"><span class="nav-text">小结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-计算机组成原理"><span class="nav-text">3.计算机组成原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么寄存器比内存快？"><span class="nav-text">为什么寄存器比内存快？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-Linux"><span class="nav-text">4.Linux</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#线上服务器CPU占用率高如何排查定位问题？"><span class="nav-text">线上服务器CPU占用率高如何排查定位问题？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-数据库"><span class="nav-text">5.数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一条SQL语句执行得很慢的原因有哪些？"><span class="nav-text">一条SQL语句执行得很慢的原因有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是数据库的脏读、不可重复读和幻读"><span class="nav-text">什么是数据库的脏读、不可重复读和幻读</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是最左前缀原则？"><span class="nav-text">什么是最左前缀原则？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么用-B-树做索引而不用哈希表做索引"><span class="nav-text">为什么用 B+ 树做索引而不用哈希表做索引?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#主键索引和非主键索引有什么区别？"><span class="nav-text">主键索引和非主键索引有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么建议使用主键自增的索引？"><span class="nav-text">为什么建议使用主键自增的索引？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MyISAM与InnoDB的区别"><span class="nav-text">MyISAM与InnoDB的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-两者对比"><span class="nav-text">1.两者对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-两者总结"><span class="nav-text">2.两者总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-Java相关"><span class="nav-text">6.Java相关</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java的线程状态有哪些？它是如何工作的？-重要"><span class="nav-text">Java的线程状态有哪些？它是如何工作的？(重要**)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java线程状态在JDK1-5后一共有六个"><span class="nav-text">Java线程状态在JDK1.5后一共有六个</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#线程如何工作的？——线程工作模式"><span class="nav-text">线程如何工作的？——线程工作模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java创建新线程有几种方式？"><span class="nav-text">Java创建新线程有几种方式？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BLOCKED-阻塞等待-和WAITING-等待-有什么区别？"><span class="nav-text">BLOCKED(阻塞等待)和WAITING(等待)有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#start-方法和run-方法有什么区别？"><span class="nav-text">start()方法和run()方法有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程的优先级有什么用？如何设置优先级？"><span class="nav-text">线程的优先级有什么用？如何设置优先级？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程常用方法有哪些？"><span class="nav-text">线程常用方法有哪些？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#join"><span class="nav-text">join()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#yield"><span class="nav-text">yield()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile的作用"><span class="nav-text">volatile的作用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是可见性？"><span class="nav-text">什么是可见性？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何保证内存可见性？"><span class="nav-text">如何保证内存可见性？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是指令重排？"><span class="nav-text">什么是指令重排？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile真的能完全保证一个变量的线程安全么？"><span class="nav-text">volatile真的能完全保证一个变量的线程安全么？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#原子性-原子操作"><span class="nav-text">原子性\原子操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么情况下volatile可以保证线程安全"><span class="nav-text">什么情况下volatile可以保证线程安全</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadPoolExecutor介绍"><span class="nav-text">ThreadPoolExecutor介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程池——ThreadPoolExecutor参数含义及源码执行流程？"><span class="nav-text">线程池——ThreadPoolExecutor参数含义及源码执行流程？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadPoolExecutor一共有七个核心参数"><span class="nav-text">ThreadPoolExecutor一共有七个核心参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池-ThreadPoolExecutor-执行流程"><span class="nav-text">线程池(ThreadPoolExecutor)执行流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用Executors返回线程池对象的弊端"><span class="nav-text">使用Executors返回线程池对象的弊端</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程池的拒绝策略"><span class="nav-text">线程池的拒绝策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义拒绝策略"><span class="nav-text">自定义拒绝策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadPoolExecutor扩展"><span class="nav-text">ThreadPoolExecutor扩展</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#搞懂synchronized-从偏量锁到重量级锁"><span class="nav-text">搞懂synchronized(从偏量锁到重量级锁)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized和ReentrantLock-两者的实现原理？两者的区别？"><span class="nav-text">synchronized和ReentrantLock,两者的实现原理？两者的区别？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized和ReentrantLock原理"><span class="nav-text">synchronized和ReentrantLock原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized和ReentrantLock共同点与区别"><span class="nav-text">synchronized和ReentrantLock共同点与区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#相同点："><span class="nav-text">相同点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不同点："><span class="nav-text">不同点：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#“synchronized和ReentrantLock共同点与区别”的典型回答-重要"><span class="nav-text">“synchronized和ReentrantLock共同点与区别”的典型回答(重要)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#公平锁-VS-非公平锁"><span class="nav-text">公平锁 VS 非公平锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ReentrantLock详细介绍-源码分析，主要针对加锁和解锁的流程"><span class="nav-text">ReentrantLock详细介绍(源码分析，主要针对加锁和解锁的流程)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK1-6之后synchronized关键字底层做了哪些优化？详细介绍一下这些优化？"><span class="nav-text">JDK1.6之后synchronized关键字底层做了哪些优化？详细介绍一下这些优化？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#自适应自旋锁-1"><span class="nav-text">自适应自旋锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#锁升级"><span class="nav-text">锁升级</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized关键字底层原理详解"><span class="nav-text">synchronized关键字底层原理详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized-同步语句块的情况"><span class="nav-text">synchronized 同步语句块的情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized修饰方法"><span class="nav-text">synchronized修饰方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java内存模型与synchronized和volatile的面试二连击"><span class="nav-text">Java内存模型与synchronized和volatile的面试二连击</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Java内存模型-JMM"><span class="nav-text">1.Java内存模型(JMM)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-synchronized关键字和volatile关键字的区别"><span class="nav-text">2.synchronized关键字和volatile关键字的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java线程池的面试四连击"><span class="nav-text">Java线程池的面试四连击</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-为什么要用线程池？"><span class="nav-text">1.为什么要用线程池？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-实现Runnable接口和Callable接口的区别？"><span class="nav-text">2.实现Runnable接口和Callable接口的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-执行execute-方法和submit-方法的区别是什么呢？"><span class="nav-text">3.执行execute()方法和submit()方法的区别是什么呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-如何创建线程池"><span class="nav-text">4.如何创建线程池</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AQS"><span class="nav-text">AQS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#从synchronized引入"><span class="nav-text">从synchronized引入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CAS介绍"><span class="nav-text">CAS介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK8对CAS的优化"><span class="nav-text">JDK8对CAS的优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#正式介绍AQS"><span class="nav-text">正式介绍AQS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AQS核心思想"><span class="nav-text">AQS核心思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AQS两种资源共享方式"><span class="nav-text">AQS两种资源共享方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AQS组件总结"><span class="nav-text">AQS组件总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#谈谈对多线程的锁的理解？如何手动模拟一个死锁？"><span class="nav-text">谈谈对多线程的锁的理解？如何手动模拟一个死锁？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是死锁？如何手动模拟一个死锁？"><span class="nav-text">什么是死锁？如何手动模拟一个死锁？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java的悲观锁和乐观锁、共享锁和独占锁"><span class="nav-text">Java的悲观锁和乐观锁、共享锁和独占锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#悲观锁"><span class="nav-text">悲观锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#乐观锁"><span class="nav-text">乐观锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#共享锁和独占锁"><span class="nav-text">共享锁和独占锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可重入锁"><span class="nav-text">可重入锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java垃圾回收机制"><span class="nav-text">Java垃圾回收机制</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Wang Mingsheng"
      src="/images/faceimage.jpg">
  <p class="site-author-name" itemprop="name">Wang Mingsheng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wmsheng" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wmsheng" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:wangmingshenghku@163.com" title="E-Mail → mailto:wangmingshenghku@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://music.163.com/#/my/m/music/playlist?id=372605964" title="Music → https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;my&#x2F;m&#x2F;music&#x2F;playlist?id&#x3D;372605964" rel="noopener" target="_blank"><i class="fa fa-fw fa-youtube"></i>Music</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>


    </div>
    
    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=3314336&auto=1&height=66">
    </iframe>

  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wang Mingsheng</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">389k</span>
</div>


<div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_uv">
    本站访客数:<span id="busuanzi_value_site_uv"></span>
  </span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_pv">
    本站访问量<span id="busuanzi_value_site_pv"></span>
  </span>
</div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共200.4k字</span>
</div>

        
<div class="busuanzi-count">
  <script pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.getAttribute('pjax') !== null) {
      element.setAttribute('pjax', '');
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

    </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/clicklove.js"></script>
